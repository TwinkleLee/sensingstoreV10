/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.3.0 (NJsonSchema v10.3.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BIGDATA_URL = new InjectionToken<string>('API_BIGDATA_URL');

@Injectable()
export class DeviceBehaviorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取特定设备下的人脸信息，支持分页
     * @param body (optional) 
     * @return Success
     */
    getFaceRecords(body: GetFaceRecordsInput | undefined): Observable<FaceRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceBehavior/GetFaceRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceRecords(<any>response_);
                } catch (e) {
                    return <Observable<FaceRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FaceRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFaceRecords(response: HttpResponseBase): Observable<FaceRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FaceRecordDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取特定设备下的一段时间内的热力图矩阵数据
     * @param deviceID (optional) 
     * @param dtStart (optional) 
     * @param dtEnd (optional) 
     * @return Success
     */
    getDeviceHeatmapData(deviceID: number | undefined, dtStart: moment.Moment | undefined, dtEnd: moment.Moment | undefined): Observable<DeviceHeatMapDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceBehavior/GetDeviceHeatmapData?";
        if (deviceID === null)
            throw new Error("The parameter 'deviceID' cannot be null.");
        else if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&";
        if (dtStart === null)
            throw new Error("The parameter 'dtStart' cannot be null.");
        else if (dtStart !== undefined)
            url_ += "dtStart=" + encodeURIComponent(dtStart ? "" + dtStart.toJSON() : "") + "&";
        if (dtEnd === null)
            throw new Error("The parameter 'dtEnd' cannot be null.");
        else if (dtEnd !== undefined)
            url_ += "dtEnd=" + encodeURIComponent(dtEnd ? "" + dtEnd.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceHeatmapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceHeatmapData(<any>response_);
                } catch (e) {
                    return <Observable<DeviceHeatMapDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceHeatMapDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceHeatmapData(response: HttpResponseBase): Observable<DeviceHeatMapDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHeatMapDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceHeatMapDto[]>(<any>null);
    }
}

@Injectable()
export class DeviceOperationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 管理者添加设备的运维记录
     * @param body (optional) 
     * @return Success
     */
    addOperationRecords(body: AddDeviceOptRecordInput[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/AddOperationRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOperationRecords(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 更新设备的维护记录
     * @param body (optional) 
     * @return Success
     */
    updateOperationRecord(body: UpdateDeviceOptRecordInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/UpdateOperationRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOperationRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOperationRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOperationRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 删除某个运维记录
     * @param id (optional) 
     * @return Success
     */
    deleteOperationRecord(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/DeleteOperationRecord?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOperationRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 批量删除运维记录
     * @param ids (optional) 
     * @return Success
     */
    deleteOperationRecords(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/DeleteOperationRecords?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOperationRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备的维护历史纪录,支持分页，目前仅限于Host用户,后期会完善
     * @param body (optional) 
     * @return Success
     */
    getOperationRecords(body: GetDeviceOptInput | undefined): Observable<DeviceOptDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/GetOperationRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOptDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOptDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationRecords(response: HttpResponseBase): Observable<DeviceOptDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceOptDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOptDtoPagedResultDto>(<any>null);
    }

    /**
     * 导出设备的维护记录到Excel
     * @param deviceId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param optStatus (optional) 
     * @param tenantId (optional) 
     * @param categoryId (optional) 
     * @param optKnowledgeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOperationRecordsToExcel(deviceId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, optStatus: EnumOptStatus[] | undefined, tenantId: number | undefined, categoryId: number | undefined, optKnowledgeId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceOptExcelDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOperations/GetOperationRecordsToExcel?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (optStatus === null)
            throw new Error("The parameter 'optStatus' cannot be null.");
        else if (optStatus !== undefined)
            optStatus && optStatus.forEach(item => { url_ += "OptStatus=" + encodeURIComponent("" + item) + "&"; });
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (optKnowledgeId === null)
            throw new Error("The parameter 'optKnowledgeId' cannot be null.");
        else if (optKnowledgeId !== undefined)
            url_ += "OptKnowledgeId=" + encodeURIComponent("" + optKnowledgeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationRecordsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationRecordsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOptExcelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOptExcelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationRecordsToExcel(response: HttpResponseBase): Observable<DeviceOptExcelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceOptExcelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOptExcelDto>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class OperationKnowledgeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 新增维护的知识库记录
     * @param body (optional) 
     * @return Success
     */
    createOptKnowledge(body: CreateKnowledgeCategoryInput | undefined): Observable<KnowledgeCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/CreateOptKnowledge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOptKnowledge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOptKnowledge(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOptKnowledge(response: HttpResponseBase): Observable<KnowledgeCategoriesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeCategoriesDto>(<any>null);
    }

    /**
     * 获取维护知识库的信息，支持分页
     * @param tenantId (optional) 
     * @param categoryId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOptKnowledges(tenantId: number | undefined, categoryId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<KnowledgeCategoriesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/GetOptKnowledges?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOptKnowledges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptKnowledges(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeCategoriesDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeCategoriesDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptKnowledges(response: HttpResponseBase): Observable<KnowledgeCategoriesDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeCategoriesDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeCategoriesDtoPagedResultDto>(<any>null);
    }

    /**
     * 更新维护知识库的信息
     * @param body (optional) 
     * @return Success
     */
    updateOptKnowledge(body: UpdateKnowledgeCategoryInput | undefined): Observable<KnowledgeCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/UpdateOptKnowledge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptKnowledge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptKnowledge(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOptKnowledge(response: HttpResponseBase): Observable<KnowledgeCategoriesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeCategoriesDto>(<any>null);
    }

    /**
     * 删除特定的维护知识库的信息
     * @param id (optional) 
     * @return Success
     */
    deleteOptKnowledge(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/DeleteOptKnowledge?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOptKnowledge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOptKnowledge(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOptKnowledge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除特定的维护知识库的信息
     * @param ids (optional) 
     * @return Success
     */
    deleteOptKnowledges(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/DeleteOptKnowledges?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOptKnowledges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOptKnowledges(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOptKnowledges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新增问题分类
     * @param body (optional) 
     * @return Success
     */
    createQuestionCategory(body: CreateQuestionCategoryInput | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/CreateQuestionCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }

    /**
     * 获取所有的问题分类
     * @param tenantId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionCategories(tenantId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<QuestionsCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/GetQuestionCategories?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionCategories(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionCategories(response: HttpResponseBase): Observable<QuestionsCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * 更新设备的问题分类
     * @param body (optional) 
     * @return Success
     */
    updateQuestionCategory(body: UpdateQuestionCategoryInput | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/UpdateQuestionCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }

    /**
     * 删除特定的问题分类
     * @param id (optional) 
     * @return Success
     */
    deleteQuestionCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/DeleteQuestionCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestionCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取问题分类的树形列表
     * @param tenantId (optional) 
     * @return Success
     */
    getCategoryTrees(tenantId: number | undefined): Observable<Int64TreeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/GetCategoryTrees?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<Int64TreeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64TreeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTrees(response: HttpResponseBase): Observable<Int64TreeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64TreeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64TreeDto[]>(<any>null);
    }

    /**
     * 获取单个的问题分类信息
     * @param id (optional) 
     * @return Success
     */
    getSingleQuestionCategory(id: number | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationKnowledge/GetSingleQuestionCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 动作排行，比如点击前10的项目
     * @param body (optional) 
     * @return Success
     */
    topItems(body: RankInput | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/TopItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopItems(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTopItems(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取拿起/RFID/Order相关的数据
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPickAndRfidAndOrderReport(startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PickAndRfidAndOrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPickAndRfidAndOrderReport?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickAndRfidAndOrderReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickAndRfidAndOrderReport(<any>response_);
                } catch (e) {
                    return <Observable<PickAndRfidAndOrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PickAndRfidAndOrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickAndRfidAndOrderReport(response: HttpResponseBase): Observable<PickAndRfidAndOrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PickAndRfidAndOrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PickAndRfidAndOrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPickAndRfidAndOrderReportToExcel(startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPickAndRfidAndOrderReportToExcel?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickAndRfidAndOrderReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickAndRfidAndOrderReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickAndRfidAndOrderReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取 商品点击数（按，设备Id，日期区间） 广告播放的时长 用户停留状态统计（按时间区间）
     * @param body (optional) 
     * @return Success
     */
    getBehaviorChartReport(body: ChartReportInput | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBehaviorChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBehaviorChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBehaviorChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBehaviorChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取设备在线时长图表
     * @param body (optional) 
     * @return Success
     */
    getDeviceRuntimeChartReportGet(body: DevieStatusChartReportInput | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRuntimeChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRuntimeChartReportGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRuntimeChartReportGet(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRuntimeChartReportGet(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取设备在线时长图表
     * @param body (optional) 
     * @return Success
     */
    getDeviceRuntimeChartReportPost(body: DevieStatusChartReportInput | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRuntimeChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRuntimeChartReportPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRuntimeChartReportPost(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRuntimeChartReportPost(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取设备行为数据的图表
     * @param body (optional) 
     * @return Success
     */
    getDeviceActionsChartReport(body: GetDeviceActionsChartReportInput | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceActionsChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActionsChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActionsChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActionsChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取设备运行时间
     * @param deviceId (optional) 
     * @param ouOrStoreList (optional) 
     * @return Success
     */
    getDeviceRunTime(deviceId: number | undefined, startTime: moment.Moment, endTime: moment.Moment, ouOrStoreList: IdTypeDto[] | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRunTime?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (ouOrStoreList === null)
            throw new Error("The parameter 'ouOrStoreList' cannot be null.");
        else if (ouOrStoreList !== undefined)
            ouOrStoreList && ouOrStoreList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OuOrStoreList[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRunTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRunTime(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRunTime(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 设备是否开机的历史数据
     * @param deviceId (optional) 
     * @param ouOrStoreList (optional) 
     * @return Success
     */
    getDeviceStatusChartReport(deviceId: number | undefined, startTime: moment.Moment, endTime: moment.Moment, ouOrStoreList: IdTypeDto[] | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceStatusChartReport?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (ouOrStoreList === null)
            throw new Error("The parameter 'ouOrStoreList' cannot be null.");
        else if (ouOrStoreList !== undefined)
            ouOrStoreList && ouOrStoreList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OuOrStoreList[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceStatusChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceStatusChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceStatusChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * 获取设备在线的Excel数据文件
     * @param body (optional) 
     * @return Success
     */
    getBigDataToExcel(body: DevieOnlineReportInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBigDataToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigDataToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigDataToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigDataToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取设备在线的Excel数据文件，以任务的形式提供
     * @param body (optional) 
     * @return Success
     */
    getBigDataToExcelByTask(body: DevieOnlineReportInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBigDataToExcelByTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigDataToExcelByTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigDataToExcelByTask(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigDataToExcelByTask(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取设备在线的Csv的数据文件
     * @param organizationUnitIds (optional) 
     * @return Success
     */
    getDeviceOnlineCsv(startTime: moment.Moment, endTime: moment.Moment, organizationUnitIds: number[] | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceOnlineCsv?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (organizationUnitIds === null)
            throw new Error("The parameter 'organizationUnitIds' cannot be null.");
        else if (organizationUnitIds !== undefined)
            organizationUnitIds && organizationUnitIds.forEach(item => { url_ += "OrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceOnlineCsv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceOnlineCsv(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceOnlineCsv(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 上传设备的截图图片
     * @param body (optional) 
     * @return Success
     */
    postSnapShotImage(body: PostCameraImageInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostSnapShotImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSnapShotImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSnapShotImage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostSnapShotImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 上传设备的热力图数据信息
     * @param body (optional) 
     * @return Success
     */
    postHeatmapData(body: PostHeatmapDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostHeatmapData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostHeatmapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostHeatmapData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostHeatmapData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 回传用户行为数据，不记录用户的个人信息
     * @param subKey (optional) 设备的Subkey
     * @param body (optional) 回传的记录
     * @return Success
     */
    postBehaviorRecords(subKey: string | undefined, body: BehaviorViewInput[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostBehaviorRecords?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostBehaviorRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostBehaviorRecords(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostBehaviorRecords(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 记录机器的在线状态，以及在线时间段内CPU和Memory的情况
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    postDeviceStatusRecords(subKey: string | undefined, body: DeviceStatusInput[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostDeviceStatusRecords?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDeviceStatusRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDeviceStatusRecords(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostDeviceStatusRecords(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 记录机器的网络状态, 用于监视设备的网络状态
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    postDeviceNetworkStatusRecords(subKey: string | undefined, body: DeviceNetworkStatusInput[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostDeviceNetworkStatusRecords?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDeviceNetworkStatusRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDeviceNetworkStatusRecords(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostDeviceNetworkStatusRecords(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 回传设备的人机交互数据，同时带有客户的人脸信息，用户后面大数据的分析
     * @param body (optional) 
     * @return Success
     */
    postFaceRecord(subKey: string, body: FaceBehaviorInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostFaceRecord?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFaceRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFaceRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostFaceRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 更新设备的心跳时间
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    deviceHeartBeat(subKey: string | undefined, body: DeviceHeartBeatInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DeviceHeartBeat?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeviceHeartBeat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeviceHeartBeat(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeviceHeartBeat(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 根据特定的查询条件，获取符合条件的设备用户行为数据
     * @param subKey (optional) 
     * @param thingId (optional) 
     * @param category (optional) 
     * @param name (optional) 
     * @param softwareName (optional) 
     * @param comments (optional) 
     * @param productId (optional) 
     * @param recordAction (optional) 
     * @param collectionTime (optional) 
     * @return Success
     */
    getBehaviorRecords(subKey: string | undefined, thingId: string | undefined, category: string | undefined, name: string | undefined, softwareName: string | undefined, comments: string | undefined, productId: number | undefined, recordAction: string | undefined, collectionTime: moment.Moment | undefined): Observable<BehaviorRecordDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBehaviorRecords?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (thingId === null)
            throw new Error("The parameter 'thingId' cannot be null.");
        else if (thingId !== undefined)
            url_ += "thingId=" + encodeURIComponent("" + thingId) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (softwareName === null)
            throw new Error("The parameter 'softwareName' cannot be null.");
        else if (softwareName !== undefined)
            url_ += "softwareName=" + encodeURIComponent("" + softwareName) + "&";
        if (comments === null)
            throw new Error("The parameter 'comments' cannot be null.");
        else if (comments !== undefined)
            url_ += "comments=" + encodeURIComponent("" + comments) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (recordAction === null)
            throw new Error("The parameter 'recordAction' cannot be null.");
        else if (recordAction !== undefined)
            url_ += "recordAction=" + encodeURIComponent("" + recordAction) + "&";
        if (collectionTime === null)
            throw new Error("The parameter 'collectionTime' cannot be null.");
        else if (collectionTime !== undefined)
            url_ += "collectionTime=" + encodeURIComponent(collectionTime ? "" + collectionTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBehaviorRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBehaviorRecords(<any>response_);
                } catch (e) {
                    return <Observable<BehaviorRecordDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BehaviorRecordDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBehaviorRecords(response: HttpResponseBase): Observable<BehaviorRecordDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BehaviorRecordDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BehaviorRecordDto[]>(<any>null);
    }
}

export class AddDeviceOptRecordInput implements IAddDeviceOptRecordInput {
    deviceId!: number;
    deviceName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    action!: string | undefined;
    question!: string;
    totalMinutes!: number;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    optStatus!: EnumOptStatus;
    operator!: string;

    constructor(data?: IAddDeviceOptRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.action = _data["action"];
            this.question = _data["question"];
            this.totalMinutes = _data["totalMinutes"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.optStatus = _data["optStatus"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): AddDeviceOptRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddDeviceOptRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["question"] = this.question;
        data["totalMinutes"] = this.totalMinutes;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        return data; 
    }
}

export interface IAddDeviceOptRecordInput {
    deviceId: number;
    deviceName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    action: string | undefined;
    question: string;
    totalMinutes: number;
    tenantId: number;
    organizationUnitId: number | undefined;
    optStatus: EnumOptStatus;
    operator: string;
}

export class BehaviorRecordDto implements IBehaviorRecordDto {
    tenantId!: number;
    thingId!: string | undefined;
    category!: string | undefined;
    name!: string | undefined;
    increment!: number;
    action!: string | undefined;
    collectionTime!: moment.Moment;
    collectEndTime!: moment.Moment;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    comments!: string | undefined;
    organizationUnitId!: number | undefined;
    storeId!: number | undefined;
    productId!: number | undefined;

    constructor(data?: IBehaviorRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.thingId = _data["thingId"];
            this.category = _data["category"];
            this.name = _data["name"];
            this.increment = _data["increment"];
            this.action = _data["action"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
            this.softwareId = _data["softwareId"];
            this.softwareName = _data["softwareName"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.comments = _data["comments"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): BehaviorRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["thingId"] = this.thingId;
        data["category"] = this.category;
        data["name"] = this.name;
        data["increment"] = this.increment;
        data["action"] = this.action;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["comments"] = this.comments;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface IBehaviorRecordDto {
    tenantId: number;
    thingId: string | undefined;
    category: string | undefined;
    name: string | undefined;
    increment: number;
    action: string | undefined;
    collectionTime: moment.Moment;
    collectEndTime: moment.Moment;
    softwareId: number | undefined;
    softwareName: string | undefined;
    deviceId: number;
    deviceName: string | undefined;
    comments: string | undefined;
    organizationUnitId: number | undefined;
    storeId: number | undefined;
    productId: number | undefined;
}

export class BehaviorViewInput implements IBehaviorViewInput {
    thingId!: string | undefined;
    productId!: number | undefined;
    name!: string | undefined;
    category!: string | undefined;
    increment!: number;
    action!: string | undefined;
    collectionTime!: moment.Moment;
    collectEndTime!: moment.Moment;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    comments!: string | undefined;
    pageName!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;
    pSource!: string | undefined;

    constructor(data?: IBehaviorViewInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.increment = _data["increment"];
            this.action = _data["action"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
            this.softwareId = _data["softwareId"];
            this.softwareName = _data["softwareName"];
            this.comments = _data["comments"];
            this.pageName = _data["pageName"];
            this.previousPageName = _data["previousPageName"];
            this.previousPageArea = _data["previousPageArea"];
            this.pSource = _data["pSource"];
        }
    }

    static fromJS(data: any): BehaviorViewInput {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorViewInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["category"] = this.category;
        data["increment"] = this.increment;
        data["action"] = this.action;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["comments"] = this.comments;
        data["pageName"] = this.pageName;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        data["pSource"] = this.pSource;
        return data; 
    }
}

export interface IBehaviorViewInput {
    thingId: string | undefined;
    productId: number | undefined;
    name: string | undefined;
    category: string | undefined;
    increment: number;
    action: string | undefined;
    collectionTime: moment.Moment;
    collectEndTime: moment.Moment;
    softwareId: number | undefined;
    softwareName: string | undefined;
    comments: string | undefined;
    pageName: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
    pSource: string | undefined;
}

export class ChartItem implements IChartItem {
    date!: string | undefined;
    value!: number;
    picUrl!: string | undefined;
    category!: string | undefined;
    thingId!: number;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.value = _data["value"];
            this.picUrl = _data["picUrl"];
            this.category = _data["category"];
            this.thingId = _data["thingId"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        data["picUrl"] = this.picUrl;
        data["category"] = this.category;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IChartItem {
    date: string | undefined;
    value: number;
    picUrl: string | undefined;
    category: string | undefined;
    thingId: number;
}

export class ChartReportDto implements IChartReportDto {
    title!: string | undefined;
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IChartReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of _data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartReportDto {
    title: string | undefined;
    chartItems: ChartItem[] | undefined;
}

export class ChartReportInput implements IChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    type!: string | undefined;
    actions!: string | undefined;
    categories!: string | undefined;
    storeIds!: number[] | undefined;

    constructor(data?: IChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.actions = _data["actions"];
            this.categories = _data["categories"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["actions"] = this.actions;
        data["categories"] = this.categories;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        return data; 
    }
}

export interface IChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    type: string | undefined;
    actions: string | undefined;
    categories: string | undefined;
    storeIds: number[] | undefined;
}

export class CreateKnowledgeCategoryInput implements ICreateKnowledgeCategoryInput {
    tenantId!: number | undefined;
    name!: string;
    operations!: string;
    categoryId!: number | undefined;

    constructor(data?: ICreateKnowledgeCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.operations = _data["operations"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateKnowledgeCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKnowledgeCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface ICreateKnowledgeCategoryInput {
    tenantId: number | undefined;
    name: string;
    operations: string;
    categoryId: number | undefined;
}

export class CreateQuestionCategoryInput implements ICreateQuestionCategoryInput {
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;

    constructor(data?: ICreateQuestionCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateQuestionCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        return data; 
    }
}

export interface ICreateQuestionCategoryInput {
    tenantId: number | undefined;
    code: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
}

export class DeviceHeartBeatInput implements IDeviceHeartBeatInput {
    cpuUsaged!: number | undefined;
    memoryUsaged!: number | undefined;

    constructor(data?: IDeviceHeartBeatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cpuUsaged = _data["cpuUsaged"];
            this.memoryUsaged = _data["memoryUsaged"];
        }
    }

    static fromJS(data: any): DeviceHeartBeatInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeartBeatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpuUsaged"] = this.cpuUsaged;
        data["memoryUsaged"] = this.memoryUsaged;
        return data; 
    }
}

export interface IDeviceHeartBeatInput {
    cpuUsaged: number | undefined;
    memoryUsaged: number | undefined;
}

export class DeviceHeatMapDto implements IDeviceHeatMapDto {
    collectionTime!: moment.Moment;
    snapShotUrl!: string | undefined;
    width!: number | undefined;
    height!: number | undefined;
    heatMapValues!: string[][] | undefined;

    constructor(data?: IDeviceHeatMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.snapShotUrl = _data["snapShotUrl"];
            this.width = _data["width"];
            this.height = _data["height"];
            if (Array.isArray(_data["heatMapValues"])) {
                this.heatMapValues = [] as any;
                for (let item of _data["heatMapValues"])
                    this.heatMapValues!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceHeatMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeatMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["snapShotUrl"] = this.snapShotUrl;
        data["width"] = this.width;
        data["height"] = this.height;
        if (Array.isArray(this.heatMapValues)) {
            data["heatMapValues"] = [];
            for (let item of this.heatMapValues)
                data["heatMapValues"].push(item);
        }
        return data; 
    }
}

export interface IDeviceHeatMapDto {
    collectionTime: moment.Moment;
    snapShotUrl: string | undefined;
    width: number | undefined;
    height: number | undefined;
    heatMapValues: string[][] | undefined;
}

export class DeviceNetworkStatusInput implements IDeviceNetworkStatusInput {
    collectionTime!: moment.Moment;
    collectionEndTime!: moment.Moment;
    pingSeed!: number;

    constructor(data?: IDeviceNetworkStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectionEndTime = _data["collectionEndTime"] ? moment(_data["collectionEndTime"].toString()) : <any>undefined;
            this.pingSeed = _data["pingSeed"];
        }
    }

    static fromJS(data: any): DeviceNetworkStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceNetworkStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectionEndTime"] = this.collectionEndTime ? this.collectionEndTime.toISOString() : <any>undefined;
        data["pingSeed"] = this.pingSeed;
        return data; 
    }
}

export interface IDeviceNetworkStatusInput {
    collectionTime: moment.Moment;
    collectionEndTime: moment.Moment;
    pingSeed: number;
}

export class DeviceOptDto implements IDeviceOptDto {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    tenantName!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number;
    organizationUnitName!: string | undefined;
    categoryId!: number | undefined;
    category!: KnowledgeCategoriesDto;
    optKnowledgeId!: number | undefined;
    optKnowledge!: QuestionsCategoryDto;
    question!: string | undefined;
    action!: string | undefined;
    totalMinutes!: number;
    optStatus!: EnumOptStatus;
    operator!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceOptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? KnowledgeCategoriesDto.fromJS(_data["category"]) : <any>undefined;
            this.optKnowledgeId = _data["optKnowledgeId"];
            this.optKnowledge = _data["optKnowledge"] ? QuestionsCategoryDto.fromJS(_data["optKnowledge"]) : <any>undefined;
            this.question = _data["question"];
            this.action = _data["action"];
            this.totalMinutes = _data["totalMinutes"];
            this.optStatus = _data["optStatus"];
            this.operator = _data["operator"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceOptDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["optKnowledgeId"] = this.optKnowledgeId;
        data["optKnowledge"] = this.optKnowledge ? this.optKnowledge.toJSON() : <any>undefined;
        data["question"] = this.question;
        data["action"] = this.action;
        data["totalMinutes"] = this.totalMinutes;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceOptDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    deviceId: number;
    deviceName: string | undefined;
    tenantName: string | undefined;
    tenantId: number;
    organizationUnitId: number;
    organizationUnitName: string | undefined;
    categoryId: number | undefined;
    category: KnowledgeCategoriesDto;
    optKnowledgeId: number | undefined;
    optKnowledge: QuestionsCategoryDto;
    question: string | undefined;
    action: string | undefined;
    totalMinutes: number;
    optStatus: EnumOptStatus;
    operator: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DeviceOptDtoPagedResultDto implements IDeviceOptDtoPagedResultDto {
    totalCount!: number;
    items!: DeviceOptDto[] | undefined;

    constructor(data?: IDeviceOptDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceOptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceOptDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOptDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceOptDtoPagedResultDto {
    totalCount: number;
    items: DeviceOptDto[] | undefined;
}

export class DeviceOptExcelDto implements IDeviceOptExcelDto {
    totalCount!: number;
    count!: number;
    excelDataUrl!: string | undefined;

    constructor(data?: IDeviceOptExcelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.count = _data["count"];
            this.excelDataUrl = _data["excelDataUrl"];
        }
    }

    static fromJS(data: any): DeviceOptExcelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOptExcelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["count"] = this.count;
        data["excelDataUrl"] = this.excelDataUrl;
        return data; 
    }
}

export interface IDeviceOptExcelDto {
    totalCount: number;
    count: number;
    excelDataUrl: string | undefined;
}

export class DeviceStatusInput implements IDeviceStatusInput {
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    cpu!: number;
    memory!: number;

    constructor(data?: IDeviceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.cpu = _data["cpu"];
            this.memory = _data["memory"];
        }
    }

    static fromJS(data: any): DeviceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["cpu"] = this.cpu;
        data["memory"] = this.memory;
        return data; 
    }
}

export interface IDeviceStatusInput {
    startTime: moment.Moment;
    endTime: moment.Moment;
    cpu: number;
    memory: number;
}

export class DevieOnlineReportInput implements IDevieOnlineReportInput {
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    organizationUnitIds!: number[] | undefined;

    constructor(data?: IDevieOnlineReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DevieOnlineReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new DevieOnlineReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        return data; 
    }
}

export interface IDevieOnlineReportInput {
    startTime: moment.Moment;
    endTime: moment.Moment;
    organizationUnitIds: number[] | undefined;
}

export class DevieStatusChartReportInput implements IDevieStatusChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    ouOrStoreList!: IdTypeDto[] | undefined;

    constructor(data?: IDevieStatusChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DevieStatusChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new DevieStatusChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDevieStatusChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    ouOrStoreList: IdTypeDto[] | undefined;
}

export enum EnumOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class FaceBehaviorInput implements IFaceBehaviorInput {
    face!: string | undefined;
    collectionTime!: moment.Moment;
    collectEndTime!: moment.Moment;
    softwareName!: string | undefined;
    softwareId!: number | undefined;
    comments!: string | undefined;
    pageName!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;

    constructor(data?: IFaceBehaviorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.face = _data["face"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
            this.softwareName = _data["softwareName"];
            this.softwareId = _data["softwareId"];
            this.comments = _data["comments"];
            this.pageName = _data["pageName"];
            this.previousPageName = _data["previousPageName"];
            this.previousPageArea = _data["previousPageArea"];
        }
    }

    static fromJS(data: any): FaceBehaviorInput {
        data = typeof data === 'object' ? data : {};
        let result = new FaceBehaviorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["face"] = this.face;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareName"] = this.softwareName;
        data["softwareId"] = this.softwareId;
        data["comments"] = this.comments;
        data["pageName"] = this.pageName;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        return data; 
    }
}

export interface IFaceBehaviorInput {
    face: string | undefined;
    collectionTime: moment.Moment;
    collectEndTime: moment.Moment;
    softwareName: string | undefined;
    softwareId: number | undefined;
    comments: string | undefined;
    pageName: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
}

export class FaceRecordDto implements IFaceRecordDto {
    id!: number;
    action!: string | undefined;
    pageName!: string | undefined;
    faceUrl!: string | undefined;
    collectionTime!: moment.Moment;
    gender!: string | undefined;
    age!: string | undefined;
    happpiness!: string | undefined;
    emotion!: string | undefined;
    score!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;

    constructor(data?: IFaceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
            this.pageName = _data["pageName"];
            this.faceUrl = _data["faceUrl"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.happpiness = _data["happpiness"];
            this.emotion = _data["emotion"];
            this.score = _data["score"];
            this.previousPageName = _data["previousPageName"];
            this.previousPageArea = _data["previousPageArea"];
        }
    }

    static fromJS(data: any): FaceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["pageName"] = this.pageName;
        data["faceUrl"] = this.faceUrl;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["happpiness"] = this.happpiness;
        data["emotion"] = this.emotion;
        data["score"] = this.score;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        return data; 
    }
}

export interface IFaceRecordDto {
    id: number;
    action: string | undefined;
    pageName: string | undefined;
    faceUrl: string | undefined;
    collectionTime: moment.Moment;
    gender: string | undefined;
    age: string | undefined;
    happpiness: string | undefined;
    emotion: string | undefined;
    score: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
}

export class FaceRecordDtoPagedResultDto implements IFaceRecordDtoPagedResultDto {
    totalCount!: number;
    items!: FaceRecordDto[] | undefined;

    constructor(data?: IFaceRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FaceRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FaceRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaceRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFaceRecordDtoPagedResultDto {
    totalCount: number;
    items: FaceRecordDto[] | undefined;
}

export class GetDeviceActionsChartReportInput implements IGetDeviceActionsChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    ouOrStoreList!: IdTypeDto[] | undefined;

    constructor(data?: IGetDeviceActionsChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceActionsChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceActionsChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDeviceActionsChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    ouOrStoreList: IdTypeDto[] | undefined;
}

export class GetDeviceOptInput implements IGetDeviceOptInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    optStatus!: EnumOptStatus[] | undefined;
    tenantId!: number | undefined;
    categoryId!: number | undefined;
    optKnowledgeId!: number | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetDeviceOptInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["optStatus"])) {
                this.optStatus = [] as any;
                for (let item of _data["optStatus"])
                    this.optStatus!.push(item);
            }
            this.tenantId = _data["tenantId"];
            this.categoryId = _data["categoryId"];
            this.optKnowledgeId = _data["optKnowledgeId"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetDeviceOptInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceOptInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.optStatus)) {
            data["optStatus"] = [];
            for (let item of this.optStatus)
                data["optStatus"].push(item);
        }
        data["tenantId"] = this.tenantId;
        data["categoryId"] = this.categoryId;
        data["optKnowledgeId"] = this.optKnowledgeId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetDeviceOptInput {
    deviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    optStatus: EnumOptStatus[] | undefined;
    tenantId: number | undefined;
    categoryId: number | undefined;
    optKnowledgeId: number | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetFaceRecordsInput implements IGetFaceRecordsInput {
    deviceId!: number;
    gender!: string | undefined;
    collectionStartTime!: moment.Moment | undefined;
    collectionEndTime!: moment.Moment | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetFaceRecordsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.gender = _data["gender"];
            this.collectionStartTime = _data["collectionStartTime"] ? moment(_data["collectionStartTime"].toString()) : <any>undefined;
            this.collectionEndTime = _data["collectionEndTime"] ? moment(_data["collectionEndTime"].toString()) : <any>undefined;
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetFaceRecordsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFaceRecordsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["gender"] = this.gender;
        data["collectionStartTime"] = this.collectionStartTime ? this.collectionStartTime.toISOString() : <any>undefined;
        data["collectionEndTime"] = this.collectionEndTime ? this.collectionEndTime.toISOString() : <any>undefined;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetFaceRecordsInput {
    deviceId: number;
    gender: string | undefined;
    collectionStartTime: moment.Moment | undefined;
    collectionEndTime: moment.Moment | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class Int64TreeDto implements IInt64TreeDto {
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    children!: Int64TreeDto[] | undefined;
    outerId!: string | undefined;

    constructor(data?: IInt64TreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Int64TreeDto.fromJS(item));
            }
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): Int64TreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64TreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface IInt64TreeDto {
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    children: Int64TreeDto[] | undefined;
    outerId: string | undefined;
}

export class KnowledgeCategoriesDto implements IKnowledgeCategoriesDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    operations!: string | undefined;
    categoryId!: number | undefined;
    categoryName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IKnowledgeCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.operations = _data["operations"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): KnowledgeCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKnowledgeCategoriesDto {
    tenantId: number | undefined;
    name: string | undefined;
    operations: string | undefined;
    categoryId: number | undefined;
    categoryName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class KnowledgeCategoriesDtoPagedResultDto implements IKnowledgeCategoriesDtoPagedResultDto {
    totalCount!: number;
    items!: KnowledgeCategoriesDto[] | undefined;

    constructor(data?: IKnowledgeCategoriesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KnowledgeCategoriesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KnowledgeCategoriesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeCategoriesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IKnowledgeCategoriesDtoPagedResultDto {
    totalCount: number;
    items: KnowledgeCategoriesDto[] | undefined;
}

export class PickAndRfidAndOrderDto implements IPickAndRfidAndOrderDto {
    skuId!: string | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    totalPickup!: number;
    totalRfid!: number;
    totalSaleNumber!: number;
    totalSaleAmount!: number;

    constructor(data?: IPickAndRfidAndOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.totalPickup = _data["totalPickup"];
            this.totalRfid = _data["totalRfid"];
            this.totalSaleNumber = _data["totalSaleNumber"];
            this.totalSaleAmount = _data["totalSaleAmount"];
        }
    }

    static fromJS(data: any): PickAndRfidAndOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PickAndRfidAndOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["totalPickup"] = this.totalPickup;
        data["totalRfid"] = this.totalRfid;
        data["totalSaleNumber"] = this.totalSaleNumber;
        data["totalSaleAmount"] = this.totalSaleAmount;
        return data; 
    }
}

export interface IPickAndRfidAndOrderDto {
    skuId: string | undefined;
    outerId: string | undefined;
    name: string | undefined;
    totalPickup: number;
    totalRfid: number;
    totalSaleNumber: number;
    totalSaleAmount: number;
}

export class PickAndRfidAndOrderDtoPagedResultDto implements IPickAndRfidAndOrderDtoPagedResultDto {
    totalCount!: number;
    items!: PickAndRfidAndOrderDto[] | undefined;

    constructor(data?: IPickAndRfidAndOrderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PickAndRfidAndOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PickAndRfidAndOrderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PickAndRfidAndOrderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPickAndRfidAndOrderDtoPagedResultDto {
    totalCount: number;
    items: PickAndRfidAndOrderDto[] | undefined;
}

export class PostCameraImageInput implements IPostCameraImageInput {
    subKey!: string | undefined;
    mac!: string | undefined;
    cameraImage!: string | undefined;

    constructor(data?: IPostCameraImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.mac = _data["mac"];
            this.cameraImage = _data["cameraImage"];
        }
    }

    static fromJS(data: any): PostCameraImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostCameraImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["mac"] = this.mac;
        data["cameraImage"] = this.cameraImage;
        return data; 
    }
}

export interface IPostCameraImageInput {
    subKey: string | undefined;
    mac: string | undefined;
    cameraImage: string | undefined;
}

export class PostHeatmapDataInput implements IPostHeatmapDataInput {
    subKey!: string | undefined;
    collectionTime!: moment.Moment;
    mac!: string | undefined;
    heatmapData!: string | undefined;

    constructor(data?: IPostHeatmapDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.mac = _data["mac"];
            this.heatmapData = _data["heatmapData"];
        }
    }

    static fromJS(data: any): PostHeatmapDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostHeatmapDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["mac"] = this.mac;
        data["heatmapData"] = this.heatmapData;
        return data; 
    }
}

export interface IPostHeatmapDataInput {
    subKey: string | undefined;
    collectionTime: moment.Moment;
    mac: string | undefined;
    heatmapData: string | undefined;
}

export class QuestionsCategoryDto implements IQuestionsCategoryDto {
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    categoryDepth!: number;
    parentCategoryId!: number | undefined;
    parentCategoryName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IQuestionsCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.categoryDepth = _data["categoryDepth"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): QuestionsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["categoryDepth"] = this.categoryDepth;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IQuestionsCategoryDto {
    tenantId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    categoryDepth: number;
    parentCategoryId: number | undefined;
    parentCategoryName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class QuestionsCategoryDtoPagedResultDto implements IQuestionsCategoryDtoPagedResultDto {
    totalCount!: number;
    items!: QuestionsCategoryDto[] | undefined;

    constructor(data?: IQuestionsCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionsCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionsCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionsCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionsCategoryDtoPagedResultDto {
    totalCount: number;
    items: QuestionsCategoryDto[] | undefined;
}

export class RankInput implements IRankInput {
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    top!: number;
    action!: string | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    category!: string[] | undefined;
    brandId!: number | undefined;

    constructor(data?: IRankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.top = _data["top"];
            this.action = _data["action"];
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
            this.brandId = _data["brandId"];
        }
    }

    static fromJS(data: any): RankInput {
        data = typeof data === 'object' ? data : {};
        let result = new RankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["action"] = this.action;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface IRankInput {
    startTime: moment.Moment;
    endTime: moment.Moment;
    top: number;
    action: string | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    category: string[] | undefined;
    brandId: number | undefined;
}

export class UpdateDeviceOptRecordInput implements IUpdateDeviceOptRecordInput {
    id!: number;
    deviceId!: number;
    deviceName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    action!: string | undefined;
    question!: string;
    totalMinutes!: number;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    optStatus!: EnumOptStatus;
    operator!: string;

    constructor(data?: IUpdateDeviceOptRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.action = _data["action"];
            this.question = _data["question"];
            this.totalMinutes = _data["totalMinutes"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.optStatus = _data["optStatus"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): UpdateDeviceOptRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceOptRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["question"] = this.question;
        data["totalMinutes"] = this.totalMinutes;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        return data; 
    }
}

export interface IUpdateDeviceOptRecordInput {
    id: number;
    deviceId: number;
    deviceName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    action: string | undefined;
    question: string;
    totalMinutes: number;
    tenantId: number;
    organizationUnitId: number | undefined;
    optStatus: EnumOptStatus;
    operator: string;
}

export class UpdateKnowledgeCategoryInput implements IUpdateKnowledgeCategoryInput {
    id!: number;
    tenantId!: number | undefined;
    name!: string;
    operations!: string;
    categoryId!: number | undefined;

    constructor(data?: IUpdateKnowledgeCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.operations = _data["operations"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): UpdateKnowledgeCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKnowledgeCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface IUpdateKnowledgeCategoryInput {
    id: number;
    tenantId: number | undefined;
    name: string;
    operations: string;
    categoryId: number | undefined;
}

export class UpdateQuestionCategoryInput implements IUpdateQuestionCategoryInput {
    id!: number;
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;

    constructor(data?: IUpdateQuestionCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): UpdateQuestionCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        return data; 
    }
}

export interface IUpdateQuestionCategoryInput {
    id: number;
    tenantId: number | undefined;
    code: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}