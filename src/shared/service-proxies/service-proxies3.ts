/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BIGDATA_URL = new InjectionToken<string>('API_BIGDATA_URL');

@Injectable()
export class BehaviorRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param records (optional) 
     * @return Success
     */
    postRecord(subKey: string | null | undefined, records: BehaviorViewInput[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/PostRecord?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(records);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param records (optional) 
     * @return Success
     */
    postDeviceStatusRecord(subKey: string | null | undefined, records: DeviceStatusInput[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/PostDeviceStatusRecord?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(records);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDeviceStatusRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDeviceStatusRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostDeviceStatusRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param records (optional) 
     * @return Success
     */
    postDeviceNetworkStatusRecords(subKey: string | null | undefined, records: DeviceNetworkStatusInput[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/PostDeviceNetworkStatusRecords?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(records);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDeviceNetworkStatusRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDeviceNetworkStatusRecords(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostDeviceNetworkStatusRecords(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    postFaceRecord(subKey: string, record: FaceBehaviorInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/PostFaceRecord?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFaceRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFaceRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostFaceRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param heartBeatInput (optional) 
     * @return Success
     */
    deviceHeartBeat(subKey: string | null | undefined, heartBeatInput: DeviceHeartBeatInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/DeviceHeartBeat?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(heartBeatInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeviceHeartBeat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeviceHeartBeat(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeviceHeartBeat(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getOnlineDeviceCount(tenantId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/GetOnlineDeviceCount?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnlineDeviceCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnlineDeviceCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnlineDeviceCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getOnlineDevices(tenantId: number | null | undefined): Observable<DeviceHeartBeat[]> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/GetOnlineDevices?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnlineDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnlineDevices(<any>response_);
                } catch (e) {
                    return <Observable<DeviceHeartBeat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceHeartBeat[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnlineDevices(response: HttpResponseBase): Observable<DeviceHeartBeat[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHeartBeat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceHeartBeat[]>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param gender (optional) 
     * @param collectionStartTime (optional) 
     * @param collectionEndTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFaceRecords(subKey: string | null | undefined, deviceId: number, gender: string | null | undefined, collectionStartTime: moment.Moment | null | undefined, collectionEndTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfFaceRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecord/GetFaceRecords?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        if (collectionStartTime !== undefined)
            url_ += "CollectionStartTime=" + encodeURIComponent(collectionStartTime ? "" + collectionStartTime.toJSON() : "") + "&"; 
        if (collectionEndTime !== undefined)
            url_ += "CollectionEndTime=" + encodeURIComponent(collectionEndTime ? "" + collectionEndTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFaceRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFaceRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFaceRecords(response: HttpResponseBase): Observable<PagedResultDtoOfFaceRecordDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfFaceRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFaceRecordDto>(<any>null);
    }
}

@Injectable()
export class DeviceHeatmapDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dtStart (optional) 
     * @param dtEnd (optional) 
     * @param deviceID (optional) 
     * @return Success
     */
    getDeviceHeatmapData(dtStart: moment.Moment | null | undefined, dtEnd: moment.Moment | null | undefined, deviceID: number | null | undefined): Observable<DeviceHeatMapViewModel[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceHeatmapData/GetDeviceHeatmapData?";
        if (dtStart !== undefined)
            url_ += "dtStart=" + encodeURIComponent(dtStart ? "" + dtStart.toJSON() : "") + "&"; 
        if (dtEnd !== undefined)
            url_ += "dtEnd=" + encodeURIComponent(dtEnd ? "" + dtEnd.toJSON() : "") + "&"; 
        if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceHeatmapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceHeatmapData(<any>response_);
                } catch (e) {
                    return <Observable<DeviceHeatMapViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceHeatMapViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceHeatmapData(response: HttpResponseBase): Observable<DeviceHeatMapViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHeatMapViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceHeatMapViewModel[]>(<any>null);
    }
}

@Injectable()
export class DeviceOptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param records (optional) 
     * @return Success
     */
    addDeviceOptRecord(records: AddDeviceOptRecordInput[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOpt/AddDeviceOptRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(records);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeviceOptRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeviceOptRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddDeviceOptRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    updateDeviceOptRecord(record: UpdateDeviceOptRecordInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOpt/UpdateDeviceOptRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceOptRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceOptRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceOptRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOptRecord(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOpt/DeleteOptRecord?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOptRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOptRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOptRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param optStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceOpt(deviceId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, optStatus: OptStatus | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDeviceOptDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceOpt/GetDeviceOpt?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (optStatus !== undefined)
            url_ += "OptStatus=" + encodeURIComponent("" + optStatus) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceOpt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceOpt(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceOptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceOptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceOpt(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceOptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceOptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceOptDto>(<any>null);
    }
}

@Injectable()
export class FaceRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param gender (optional) 
     * @param collectionStartTime (optional) 
     * @param collectionEndTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFaceRecords(deviceId: number, gender: string | null | undefined, collectionStartTime: moment.Moment | null | undefined, collectionEndTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfFaceRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/FaceRecord/GetFaceRecords?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        if (collectionStartTime !== undefined)
            url_ += "CollectionStartTime=" + encodeURIComponent(collectionStartTime ? "" + collectionStartTime.toJSON() : "") + "&"; 
        if (collectionEndTime !== undefined)
            url_ += "CollectionEndTime=" + encodeURIComponent(collectionEndTime ? "" + collectionEndTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFaceRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFaceRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFaceRecords(response: HttpResponseBase): Observable<PagedResultDtoOfFaceRecordDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfFaceRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFaceRecordDto>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class KnowledgeCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createKnowledgeCategory(input: CreateKnowledgeCategoryInput | null | undefined): Observable<KnowledgeCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/app/KnowledgeCategory/CreateKnowledgeCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateKnowledgeCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateKnowledgeCategory(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateKnowledgeCategory(response: HttpResponseBase): Observable<KnowledgeCategoriesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeCategoriesDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param categoryId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getKnowledgeCategories(tenantId: number | null | undefined, categoryId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfKnowledgeCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/app/KnowledgeCategory/GetKnowledgeCategories?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKnowledgeCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKnowledgeCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfKnowledgeCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfKnowledgeCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKnowledgeCategories(response: HttpResponseBase): Observable<PagedResultDtoOfKnowledgeCategoriesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfKnowledgeCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfKnowledgeCategoriesDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateKnowledgeCategory(input: UpdateKnowledgeCategoryInput | null | undefined): Observable<KnowledgeCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/app/KnowledgeCategory/UpdateKnowledgeCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateKnowledgeCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateKnowledgeCategory(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateKnowledgeCategory(response: HttpResponseBase): Observable<KnowledgeCategoriesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeCategoriesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeCategoriesDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteKnowledgeCategory(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KnowledgeCategory/DeleteKnowledgeCategory?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteKnowledgeCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteKnowledgeCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteKnowledgeCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteKnowledgeCategories(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KnowledgeCategory/DeleteKnowledgeCategories?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteKnowledgeCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteKnowledgeCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteKnowledgeCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OperationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param records (optional) 
     * @return Success
     */
    addOperationRecord(records: AddOperationInput[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Operations/AddOperationRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(records);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOperationRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOperationRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOperationRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    updateOperationRecord(record: UpdateOperationRecordInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Operations/UpdateOperationRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOperationRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOperationRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOperationRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOperationRecord(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Operations/DeleteOperationRecord?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOperationRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteOperationRecords(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Operations/DeleteOperationRecords?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOperationRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param tenantId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param optStatus (optional) 
     * @param categoryId (optional) 
     * @param optKnowledgeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOperationRecords(deviceId: number | null | undefined, tenantId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, optStatus: OptStatus2 | null | undefined, categoryId: number | null | undefined, optKnowledgeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOperationOptDto> {
        let url_ = this.baseUrl + "/api/services/app/Operations/GetOperationRecords?";
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (optStatus !== undefined)
            url_ += "OptStatus=" + encodeURIComponent("" + optStatus) + "&"; 
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (optKnowledgeId !== undefined)
            url_ += "OptKnowledgeId=" + encodeURIComponent("" + optKnowledgeId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOperationOptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOperationOptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationRecords(response: HttpResponseBase): Observable<PagedResultDtoOfOperationOptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOperationOptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOperationOptDto>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param tenantId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param optStatus (optional) 
     * @param categoryId (optional) 
     * @param optKnowledgeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOperationRecordsToExcel(deviceId: number | null | undefined, tenantId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, optStatus: OptStatus3 | null | undefined, categoryId: number | null | undefined, optKnowledgeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Operations/GetOperationRecordsToExcel?";
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (optStatus !== undefined)
            url_ += "OptStatus=" + encodeURIComponent("" + optStatus) + "&"; 
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (optKnowledgeId !== undefined)
            url_ += "OptKnowledgeId=" + encodeURIComponent("" + optKnowledgeId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationRecordsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationRecordsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationRecordsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param tenantId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param optStatuses (optional) 
     * @param categoryId (optional) 
     * @param optKnowledgeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getNeedRepairOperationRecords(deviceId: number | null | undefined, tenantId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, optStatuses: OptStatuses[] | null | undefined, categoryId: number | null | undefined, optKnowledgeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOperationOptDto> {
        let url_ = this.baseUrl + "/api/services/app/Operations/GetNeedRepairOperationRecords?";
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (optStatuses !== undefined)
            optStatuses && optStatuses.forEach(item => { url_ += "OptStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (optKnowledgeId !== undefined)
            url_ += "OptKnowledgeId=" + encodeURIComponent("" + optKnowledgeId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNeedRepairOperationRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNeedRepairOperationRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOperationOptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOperationOptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNeedRepairOperationRecords(response: HttpResponseBase): Observable<PagedResultDtoOfOperationOptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOperationOptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOperationOptDto>(<any>null);
    }
}

@Injectable()
export class QuestionCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createQuestionCategory(input: CreateQuestionCategoryInput | null | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/CreateQuestionCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionCategories(tenantId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfQuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/GetQuestionCategories?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionCategories(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionsCategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionsCategoryDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateQuestionCategory(input: UpdateQuestionCategoryInput | null | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/UpdateQuestionCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteQuestionCategory(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/DeleteQuestionCategory?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestionCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getCategoryTrees(tenantId: number | null | undefined): Observable<QuestionCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/GetCategoryTrees?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTrees(response: HttpResponseBase): Observable<QuestionCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleQuestionCategory(id: number | null | undefined): Observable<QuestionsCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategory/GetSingleQuestionCategory?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionsCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionsCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleQuestionCategory(response: HttpResponseBase): Observable<QuestionsCategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionsCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionsCategoryDto>(<any>null);
    }
}

@Injectable()
export class QuestionCategoryMangerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTopLevelCategoreIds(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategoryManger/GetTopLevelCategoreIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopLevelCategoreIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopLevelCategoreIds(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopLevelCategoreIds(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param parentCategoryId (optional) 
     * @return Success
     */
    getTrees(parentCategoryId: number | null | undefined): Observable<QuestionCategoryTreeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategoryManger/GetTrees?";
        if (parentCategoryId !== undefined)
            url_ += "parentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrees(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoryTreeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoryTreeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrees(response: HttpResponseBase): Observable<QuestionCategoryTreeItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionCategoryTreeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoryTreeItemDto>(<any>null);
    }

    /**
     * @param current (optional) 
     * @return Success
     */
    f(current: QuestionCategoryTreeItemDto | null | undefined): Observable<QuestionCategoryTreeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionCategoryManger/F";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(current);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processF(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoryTreeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoryTreeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processF(response: HttpResponseBase): Observable<QuestionCategoryTreeItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionCategoryTreeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoryTreeItemDto>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    topItems(input: RankInput | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/TopItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopItems(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTopItems(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPickAndRfidAndOrderReport(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPickAndRfidAndOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPickAndRfidAndOrderReport?";
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickAndRfidAndOrderReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickAndRfidAndOrderReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPickAndRfidAndOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPickAndRfidAndOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickAndRfidAndOrderReport(response: HttpResponseBase): Observable<PagedResultDtoOfPickAndRfidAndOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPickAndRfidAndOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPickAndRfidAndOrderDto>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPickAndRfidAndOrderReportToExcel(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPickAndRfidAndOrderReportToExcel?";
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickAndRfidAndOrderReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickAndRfidAndOrderReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickAndRfidAndOrderReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBehaviorChartReport(input: ChartReportInput | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBehaviorChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBehaviorChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBehaviorChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBehaviorChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDeviceRuntimeChartReportGet(input: DevieStatusChartReportInput | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRuntimeChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRuntimeChartReportGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRuntimeChartReportGet(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRuntimeChartReportGet(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDeviceRuntimeChartReportPost(input: DevieStatusChartReportInput | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRuntimeChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRuntimeChartReportPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRuntimeChartReportPost(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRuntimeChartReportPost(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDeviceActionsChartReport(input: GetDeviceActionsChartReportInput | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceActionsChartReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActionsChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActionsChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActionsChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param ouOrStoreList (optional) 
     * @return Success
     */
    getDeviceRunTime(deviceId: number | null | undefined, startTime: moment.Moment, endTime: moment.Moment, ouOrStoreList: any[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceRunTime?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (ouOrStoreList !== undefined)
            ouOrStoreList && ouOrStoreList.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OuOrStoreList[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceRunTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceRunTime(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceRunTime(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param ouOrStoreList (optional) 
     * @return Success
     */
    getDeviceStatusChartReport(deviceId: number | null | undefined, startTime: moment.Moment, endTime: moment.Moment, ouOrStoreList: any[] | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceStatusChartReport?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (ouOrStoreList !== undefined)
            ouOrStoreList && ouOrStoreList.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OuOrStoreList[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceStatusChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceStatusChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceStatusChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBigDataToExcel(input: DevieOnlineReportInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBigDataToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigDataToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigDataToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigDataToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBigDataToExcelByTask(input: DevieOnlineReportInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetBigDataToExcelByTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigDataToExcelByTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigDataToExcelByTask(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigDataToExcelByTask(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param organizationUnitIds (optional) 
     * @return Success
     */
    getDeviceOnlineCsv(startTime: moment.Moment, endTime: moment.Moment, organizationUnitIds: number[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDeviceOnlineCsv?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (organizationUnitIds !== undefined)
            organizationUnitIds && organizationUnitIds.forEach(item => { url_ += "OrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceOnlineCsv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceOnlineCsv(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceOnlineCsv(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BIGDATA_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param mac (optional) 
     * @param cameraImage (optional) 
     * @return Success
     */
    postSnapShotByDevice(subKey: string | null | undefined, mac: string | null | undefined, cameraImage: FileParameter | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostSnapShotByDevice?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (mac !== undefined)
            url_ += "Mac=" + encodeURIComponent("" + mac) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (cameraImage !== null && cameraImage !== undefined)
            content_.append("CameraImage", cameraImage.data, cameraImage.fileName ? cameraImage.fileName : "CameraImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSnapShotByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSnapShotByDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostSnapShotByDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param collectionTime (optional) 
     * @param subKey (optional) 
     * @param mac (optional) 
     * @param heatmapData (optional) 
     * @return Success
     */
    postHeatmapByDevice(collectionTime: moment.Moment | null | undefined, subKey: string | null | undefined, mac: string | null | undefined, heatmapData: FileParameter | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostHeatmapByDevice?";
        if (collectionTime !== undefined)
            url_ += "CollectionTime=" + encodeURIComponent(collectionTime ? "" + collectionTime.toJSON() : "") + "&"; 
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (mac !== undefined)
            url_ += "Mac=" + encodeURIComponent("" + mac) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (heatmapData !== null && heatmapData !== undefined)
            content_.append("HeatmapData", heatmapData.data, heatmapData.fileName ? heatmapData.fileName : "HeatmapData");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostHeatmapByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostHeatmapByDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostHeatmapByDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param thingId (optional) 
     * @param category (optional) 
     * @param name (optional) 
     * @param softwareName (optional) 
     * @param comments (optional) 
     * @param productId (optional) 
     * @param recordAction (optional) 
     * @param collectionTime (optional) 
     * @return Success
     */
    getBehaviorRecords(subKey: string | null | undefined, thingId: string | null | undefined, category: string | null | undefined, name: string | null | undefined, softwareName: string | null | undefined, comments: string | null | undefined, productId: number | null | undefined, recordAction: string | null | undefined, collectionTime: moment.Moment | null | undefined): Observable<BehaviorRecordDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBehaviorRecords?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (thingId !== undefined)
            url_ += "thingId=" + encodeURIComponent("" + thingId) + "&"; 
        if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (softwareName !== undefined)
            url_ += "softwareName=" + encodeURIComponent("" + softwareName) + "&"; 
        if (comments !== undefined)
            url_ += "comments=" + encodeURIComponent("" + comments) + "&"; 
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (recordAction !== undefined)
            url_ += "recordAction=" + encodeURIComponent("" + recordAction) + "&"; 
        if (collectionTime !== undefined)
            url_ += "collectionTime=" + encodeURIComponent(collectionTime ? "" + collectionTime.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBehaviorRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBehaviorRecords(<any>response_);
                } catch (e) {
                    return <Observable<BehaviorRecordDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BehaviorRecordDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBehaviorRecords(response: HttpResponseBase): Observable<BehaviorRecordDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BehaviorRecordDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BehaviorRecordDto[]>(<any>null);
    }
}

export class BehaviorViewInput implements IBehaviorViewInput {
    thingId!: string | undefined;
    productId!: number | undefined;
    name!: string | undefined;
    category!: string | undefined;
    increment!: number | undefined;
    action!: string | undefined;
    collectionTime!: moment.Moment | undefined;
    collectEndTime!: moment.Moment | undefined;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    comments!: string | undefined;
    pageName!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;
    pSource!: string | undefined;

    constructor(data?: IBehaviorViewInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thingId = data["thingId"];
            this.productId = data["productId"];
            this.name = data["name"];
            this.category = data["category"];
            this.increment = data["increment"];
            this.action = data["action"];
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = data["collectEndTime"] ? moment(data["collectEndTime"].toString()) : <any>undefined;
            this.softwareId = data["softwareId"];
            this.softwareName = data["softwareName"];
            this.comments = data["comments"];
            this.pageName = data["pageName"];
            this.previousPageName = data["previousPageName"];
            this.previousPageArea = data["previousPageArea"];
            this.pSource = data["pSource"];
        }
    }

    static fromJS(data: any): BehaviorViewInput {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorViewInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["category"] = this.category;
        data["increment"] = this.increment;
        data["action"] = this.action;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["comments"] = this.comments;
        data["pageName"] = this.pageName;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        data["pSource"] = this.pSource;
        return data; 
    }
}

export interface IBehaviorViewInput {
    thingId: string | undefined;
    productId: number | undefined;
    name: string | undefined;
    category: string | undefined;
    increment: number | undefined;
    action: string | undefined;
    collectionTime: moment.Moment | undefined;
    collectEndTime: moment.Moment | undefined;
    softwareId: number | undefined;
    softwareName: string | undefined;
    comments: string | undefined;
    pageName: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
    pSource: string | undefined;
}

export class DeviceStatusInput implements IDeviceStatusInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    cpu!: number | undefined;
    memory!: number | undefined;

    constructor(data?: IDeviceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.cpu = data["cpu"];
            this.memory = data["memory"];
        }
    }

    static fromJS(data: any): DeviceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["cpu"] = this.cpu;
        data["memory"] = this.memory;
        return data; 
    }
}

export interface IDeviceStatusInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    cpu: number | undefined;
    memory: number | undefined;
}

export class DeviceNetworkStatusInput implements IDeviceNetworkStatusInput {
    collectionTime!: moment.Moment | undefined;
    collectionEndTime!: moment.Moment | undefined;
    pingSeed!: number | undefined;

    constructor(data?: IDeviceNetworkStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.collectionEndTime = data["collectionEndTime"] ? moment(data["collectionEndTime"].toString()) : <any>undefined;
            this.pingSeed = data["pingSeed"];
        }
    }

    static fromJS(data: any): DeviceNetworkStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceNetworkStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectionEndTime"] = this.collectionEndTime ? this.collectionEndTime.toISOString() : <any>undefined;
        data["pingSeed"] = this.pingSeed;
        return data; 
    }
}

export interface IDeviceNetworkStatusInput {
    collectionTime: moment.Moment | undefined;
    collectionEndTime: moment.Moment | undefined;
    pingSeed: number | undefined;
}

export class FaceBehaviorInput implements IFaceBehaviorInput {
    face!: string | undefined;
    collectionTime!: moment.Moment | undefined;
    collectEndTime!: moment.Moment | undefined;
    softwareName!: string | undefined;
    softwareId!: number | undefined;
    comments!: string | undefined;
    pageName!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;

    constructor(data?: IFaceBehaviorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.face = data["face"];
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = data["collectEndTime"] ? moment(data["collectEndTime"].toString()) : <any>undefined;
            this.softwareName = data["softwareName"];
            this.softwareId = data["softwareId"];
            this.comments = data["comments"];
            this.pageName = data["pageName"];
            this.previousPageName = data["previousPageName"];
            this.previousPageArea = data["previousPageArea"];
        }
    }

    static fromJS(data: any): FaceBehaviorInput {
        data = typeof data === 'object' ? data : {};
        let result = new FaceBehaviorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["face"] = this.face;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareName"] = this.softwareName;
        data["softwareId"] = this.softwareId;
        data["comments"] = this.comments;
        data["pageName"] = this.pageName;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        return data; 
    }
}

export interface IFaceBehaviorInput {
    face: string | undefined;
    collectionTime: moment.Moment | undefined;
    collectEndTime: moment.Moment | undefined;
    softwareName: string | undefined;
    softwareId: number | undefined;
    comments: string | undefined;
    pageName: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
}

export class DeviceHeartBeatInput implements IDeviceHeartBeatInput {
    cpuUsaged!: number | undefined;
    memoryUsaged!: number | undefined;

    constructor(data?: IDeviceHeartBeatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cpuUsaged = data["cpuUsaged"];
            this.memoryUsaged = data["memoryUsaged"];
        }
    }

    static fromJS(data: any): DeviceHeartBeatInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeartBeatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpuUsaged"] = this.cpuUsaged;
        data["memoryUsaged"] = this.memoryUsaged;
        return data; 
    }
}

export interface IDeviceHeartBeatInput {
    cpuUsaged: number | undefined;
    memoryUsaged: number | undefined;
}

export class DeviceHeartBeat implements IDeviceHeartBeat {
    id!: number | undefined;
    tenantId!: number | undefined;
    heartBeatTime!: moment.Moment | undefined;

    constructor(data?: IDeviceHeartBeat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.heartBeatTime = data["heartBeatTime"] ? moment(data["heartBeatTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceHeartBeat {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeartBeat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["heartBeatTime"] = this.heartBeatTime ? this.heartBeatTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDeviceHeartBeat {
    id: number | undefined;
    tenantId: number | undefined;
    heartBeatTime: moment.Moment | undefined;
}

export class PagedResultDtoOfFaceRecordDto implements IPagedResultDtoOfFaceRecordDto {
    totalCount!: number | undefined;
    items!: FaceRecordDto[] | undefined;

    constructor(data?: IPagedResultDtoOfFaceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FaceRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFaceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFaceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfFaceRecordDto {
    totalCount: number | undefined;
    items: FaceRecordDto[] | undefined;
}

export class FaceRecordDto implements IFaceRecordDto {
    id!: number | undefined;
    action!: string | undefined;
    pageName!: string | undefined;
    faceUrl!: string | undefined;
    collectionTime!: moment.Moment | undefined;
    gender!: string | undefined;
    age!: string | undefined;
    happpiness!: string | undefined;
    emotion!: string | undefined;
    score!: string | undefined;
    previousPageName!: string | undefined;
    previousPageArea!: string | undefined;

    constructor(data?: IFaceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.action = data["action"];
            this.pageName = data["pageName"];
            this.faceUrl = data["faceUrl"];
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.age = data["age"];
            this.happpiness = data["happpiness"];
            this.emotion = data["emotion"];
            this.score = data["score"];
            this.previousPageName = data["previousPageName"];
            this.previousPageArea = data["previousPageArea"];
        }
    }

    static fromJS(data: any): FaceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["pageName"] = this.pageName;
        data["faceUrl"] = this.faceUrl;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["happpiness"] = this.happpiness;
        data["emotion"] = this.emotion;
        data["score"] = this.score;
        data["previousPageName"] = this.previousPageName;
        data["previousPageArea"] = this.previousPageArea;
        return data; 
    }
}

export interface IFaceRecordDto {
    id: number | undefined;
    action: string | undefined;
    pageName: string | undefined;
    faceUrl: string | undefined;
    collectionTime: moment.Moment | undefined;
    gender: string | undefined;
    age: string | undefined;
    happpiness: string | undefined;
    emotion: string | undefined;
    score: string | undefined;
    previousPageName: string | undefined;
    previousPageArea: string | undefined;
}

export class DeviceHeatMapViewModel implements IDeviceHeatMapViewModel {
    collectionTime!: moment.Moment | undefined;
    snapShotUrl!: string | undefined;
    width!: number | undefined;
    height!: number | undefined;
    heatMapValues!: string[][] | undefined;

    constructor(data?: IDeviceHeatMapViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.snapShotUrl = data["snapShotUrl"];
            this.width = data["width"];
            this.height = data["height"];
            if (Array.isArray(data["heatMapValues"])) {
                this.heatMapValues = [] as any;
                for (let item of data["heatMapValues"])
                    this.heatMapValues!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceHeatMapViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeatMapViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["snapShotUrl"] = this.snapShotUrl;
        data["width"] = this.width;
        data["height"] = this.height;
        if (Array.isArray(this.heatMapValues)) {
            data["heatMapValues"] = [];
            for (let item of this.heatMapValues)
                data["heatMapValues"].push(item);
        }
        return data; 
    }
}

export interface IDeviceHeatMapViewModel {
    collectionTime: moment.Moment | undefined;
    snapShotUrl: string | undefined;
    width: number | undefined;
    height: number | undefined;
    heatMapValues: string[][] | undefined;
}

export class AddDeviceOptRecordInput implements IAddDeviceOptRecordInput {
    deviceId!: number;
    deviceName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    action!: string | undefined;
    question!: string;
    totalMinutes!: number | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    optStatus!: AddDeviceOptRecordInputOptStatus | undefined;
    operator!: string;

    constructor(data?: IAddDeviceOptRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.action = data["action"];
            this.question = data["question"];
            this.totalMinutes = data["totalMinutes"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.optStatus = data["optStatus"];
            this.operator = data["operator"];
        }
    }

    static fromJS(data: any): AddDeviceOptRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddDeviceOptRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["question"] = this.question;
        data["totalMinutes"] = this.totalMinutes;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        return data; 
    }
}

export interface IAddDeviceOptRecordInput {
    deviceId: number;
    deviceName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    action: string | undefined;
    question: string;
    totalMinutes: number | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    optStatus: AddDeviceOptRecordInputOptStatus | undefined;
    operator: string;
}

export class UpdateDeviceOptRecordInput implements IUpdateDeviceOptRecordInput {
    id!: number | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    action!: string | undefined;
    question!: string;
    totalMinutes!: number | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    optStatus!: UpdateDeviceOptRecordInputOptStatus | undefined;
    operator!: string;

    constructor(data?: IUpdateDeviceOptRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.action = data["action"];
            this.question = data["question"];
            this.totalMinutes = data["totalMinutes"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.optStatus = data["optStatus"];
            this.operator = data["operator"];
        }
    }

    static fromJS(data: any): UpdateDeviceOptRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceOptRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["question"] = this.question;
        data["totalMinutes"] = this.totalMinutes;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        return data; 
    }
}

export interface IUpdateDeviceOptRecordInput {
    id: number | undefined;
    deviceId: number;
    deviceName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    action: string | undefined;
    question: string;
    totalMinutes: number | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    optStatus: UpdateDeviceOptRecordInputOptStatus | undefined;
    operator: string;
}

export class PagedResultDtoOfDeviceOptDto implements IPagedResultDtoOfDeviceOptDto {
    totalCount!: number | undefined;
    items!: DeviceOptDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceOptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DeviceOptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceOptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceOptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceOptDto {
    totalCount: number | undefined;
    items: DeviceOptDto[] | undefined;
}

export class DeviceOptDto implements IDeviceOptDto {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    question!: string | undefined;
    action!: string | undefined;
    totalMinutes!: number | undefined;
    optStatus!: DeviceOptDtoOptStatus | undefined;
    operator!: string | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceOptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.question = data["question"];
            this.action = data["action"];
            this.totalMinutes = data["totalMinutes"];
            this.optStatus = data["optStatus"];
            this.operator = data["operator"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceOptDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["question"] = this.question;
        data["action"] = this.action;
        data["totalMinutes"] = this.totalMinutes;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceOptDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    question: string | undefined;
    action: string | undefined;
    totalMinutes: number | undefined;
    optStatus: DeviceOptDtoOptStatus | undefined;
    operator: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateKnowledgeCategoryInput implements ICreateKnowledgeCategoryInput {
    tenantId!: number | undefined;
    name!: string;
    operations!: string;
    categoryId!: number | undefined;

    constructor(data?: ICreateKnowledgeCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.operations = data["operations"];
            this.categoryId = data["categoryId"];
        }
    }

    static fromJS(data: any): CreateKnowledgeCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKnowledgeCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface ICreateKnowledgeCategoryInput {
    tenantId: number | undefined;
    name: string;
    operations: string;
    categoryId: number | undefined;
}

export class KnowledgeCategoriesDto implements IKnowledgeCategoriesDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    operations!: string | undefined;
    categoryId!: number | undefined;
    categoryName!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IKnowledgeCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.operations = data["operations"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KnowledgeCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IKnowledgeCategoriesDto {
    tenantId: number | undefined;
    name: string | undefined;
    operations: string | undefined;
    categoryId: number | undefined;
    categoryName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfKnowledgeCategoriesDto implements IPagedResultDtoOfKnowledgeCategoriesDto {
    totalCount!: number | undefined;
    items!: KnowledgeCategoriesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfKnowledgeCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(KnowledgeCategoriesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfKnowledgeCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfKnowledgeCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfKnowledgeCategoriesDto {
    totalCount: number | undefined;
    items: KnowledgeCategoriesDto[] | undefined;
}

export class UpdateKnowledgeCategoryInput implements IUpdateKnowledgeCategoryInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    name!: string;
    operations!: string;
    categoryId!: number | undefined;

    constructor(data?: IUpdateKnowledgeCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.operations = data["operations"];
            this.categoryId = data["categoryId"];
        }
    }

    static fromJS(data: any): UpdateKnowledgeCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKnowledgeCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface IUpdateKnowledgeCategoryInput {
    id: number | undefined;
    tenantId: number | undefined;
    name: string;
    operations: string;
    categoryId: number | undefined;
}

export class AddOperationInput implements IAddOperationInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    categoryId!: number | undefined;
    optKnowledgeId!: number | undefined;
    question!: string | undefined;
    action!: string | undefined;
    deviceName!: string | undefined;
    tenantName!: string | undefined;
    totalMinutes!: number | undefined;
    operator!: string | undefined;
    optStatus!: AddOperationInputOptStatus | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IAddOperationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.categoryId = data["categoryId"];
            this.optKnowledgeId = data["optKnowledgeId"];
            this.question = data["question"];
            this.action = data["action"];
            this.deviceName = data["deviceName"];
            this.tenantName = data["tenantName"];
            this.totalMinutes = data["totalMinutes"];
            this.operator = data["operator"];
            this.optStatus = data["optStatus"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AddOperationInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOperationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["optKnowledgeId"] = this.optKnowledgeId;
        data["question"] = this.question;
        data["action"] = this.action;
        data["deviceName"] = this.deviceName;
        data["tenantName"] = this.tenantName;
        data["totalMinutes"] = this.totalMinutes;
        data["operator"] = this.operator;
        data["optStatus"] = this.optStatus;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IAddOperationInput {
    deviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    categoryId: number | undefined;
    optKnowledgeId: number | undefined;
    question: string | undefined;
    action: string | undefined;
    deviceName: string | undefined;
    tenantName: string | undefined;
    totalMinutes: number | undefined;
    operator: string | undefined;
    optStatus: AddOperationInputOptStatus | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
}

export class UpdateOperationRecordInput implements IUpdateOperationRecordInput {
    id!: number | undefined;
    deviceId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    categoryId!: number | undefined;
    optKnowledgeId!: number | undefined;
    question!: string | undefined;
    action!: string | undefined;
    deviceName!: string | undefined;
    tenantName!: string | undefined;
    totalMinutes!: number | undefined;
    operator!: string | undefined;
    optStatus!: UpdateOperationRecordInputOptStatus | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUpdateOperationRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.categoryId = data["categoryId"];
            this.optKnowledgeId = data["optKnowledgeId"];
            this.question = data["question"];
            this.action = data["action"];
            this.deviceName = data["deviceName"];
            this.tenantName = data["tenantName"];
            this.totalMinutes = data["totalMinutes"];
            this.operator = data["operator"];
            this.optStatus = data["optStatus"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateOperationRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOperationRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["optKnowledgeId"] = this.optKnowledgeId;
        data["question"] = this.question;
        data["action"] = this.action;
        data["deviceName"] = this.deviceName;
        data["tenantName"] = this.tenantName;
        data["totalMinutes"] = this.totalMinutes;
        data["operator"] = this.operator;
        data["optStatus"] = this.optStatus;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateOperationRecordInput {
    id: number | undefined;
    deviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    categoryId: number | undefined;
    optKnowledgeId: number | undefined;
    question: string | undefined;
    action: string | undefined;
    deviceName: string | undefined;
    tenantName: string | undefined;
    totalMinutes: number | undefined;
    operator: string | undefined;
    optStatus: UpdateOperationRecordInputOptStatus | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
}

export class PagedResultDtoOfOperationOptDto implements IPagedResultDtoOfOperationOptDto {
    totalCount!: number | undefined;
    items!: OperationOptDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOperationOptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OperationOptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOperationOptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOperationOptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOperationOptDto {
    totalCount: number | undefined;
    items: OperationOptDto[] | undefined;
}

export class OperationOptDto implements IOperationOptDto {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    tenantName!: string | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    organizationUnitName!: string | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    categoryId!: number | undefined;
    category!: OptCategory | undefined;
    optKnowledgeId!: number | undefined;
    optKnowledge!: OptKnowledge | undefined;
    question!: string | undefined;
    action!: string | undefined;
    totalMinutes!: number | undefined;
    optStatus!: OperationOptDtoOptStatus | undefined;
    operator!: string | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOperationOptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.tenantName = data["tenantName"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationUnitName = data["organizationUnitName"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.categoryId = data["categoryId"];
            this.category = data["category"] ? OptCategory.fromJS(data["category"]) : <any>undefined;
            this.optKnowledgeId = data["optKnowledgeId"];
            this.optKnowledge = data["optKnowledge"] ? OptKnowledge.fromJS(data["optKnowledge"]) : <any>undefined;
            this.question = data["question"];
            this.action = data["action"];
            this.totalMinutes = data["totalMinutes"];
            this.optStatus = data["optStatus"];
            this.operator = data["operator"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OperationOptDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationOptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["optKnowledgeId"] = this.optKnowledgeId;
        data["optKnowledge"] = this.optKnowledge ? this.optKnowledge.toJSON() : <any>undefined;
        data["question"] = this.question;
        data["action"] = this.action;
        data["totalMinutes"] = this.totalMinutes;
        data["optStatus"] = this.optStatus;
        data["operator"] = this.operator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOperationOptDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    tenantName: string | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    categoryId: number | undefined;
    category: OptCategory | undefined;
    optKnowledgeId: number | undefined;
    optKnowledge: OptKnowledge | undefined;
    question: string | undefined;
    action: string | undefined;
    totalMinutes: number | undefined;
    optStatus: OperationOptDtoOptStatus | undefined;
    operator: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OptCategory implements IOptCategory {
    code!: string | undefined;
    parentId!: number | undefined;
    parent!: OptCategory | undefined;
    tenantId!: number | undefined;
    children!: OptCategory[] | undefined;
    displayName!: string;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOptCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? OptCategory.fromJS(data["parent"]) : <any>undefined;
            this.tenantId = data["tenantId"];
            if (Array.isArray(data["children"])) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children!.push(OptCategory.fromJS(item));
            }
            this.displayName = data["displayName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OptCategory {
        data = typeof data === 'object' ? data : {};
        let result = new OptCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOptCategory {
    code: string | undefined;
    parentId: number | undefined;
    parent: OptCategory | undefined;
    tenantId: number | undefined;
    children: OptCategory[] | undefined;
    displayName: string;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OptKnowledge implements IOptKnowledge {
    tenantId!: number | undefined;
    categoryId!: number | undefined;
    category!: OptCategory | undefined;
    name!: string;
    operations!: string;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOptKnowledge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.categoryId = data["categoryId"];
            this.category = data["category"] ? OptCategory.fromJS(data["category"]) : <any>undefined;
            this.name = data["name"];
            this.operations = data["operations"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OptKnowledge {
        data = typeof data === 'object' ? data : {};
        let result = new OptKnowledge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["operations"] = this.operations;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOptKnowledge {
    tenantId: number | undefined;
    categoryId: number | undefined;
    category: OptCategory | undefined;
    name: string;
    operations: string;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateQuestionCategoryInput implements ICreateQuestionCategoryInput {
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;

    constructor(data?: ICreateQuestionCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.code = data["code"];
            this.name = data["name"];
            this.parentCategoryId = data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateQuestionCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        return data; 
    }
}

export interface ICreateQuestionCategoryInput {
    tenantId: number | undefined;
    code: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
}

export class QuestionsCategoryDto implements IQuestionsCategoryDto {
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    categoryDepth!: number | undefined;
    parentCategoryId!: number | undefined;
    parentCategoryName!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IQuestionsCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.code = data["code"];
            this.name = data["name"];
            this.categoryDepth = data["categoryDepth"];
            this.parentCategoryId = data["parentCategoryId"];
            this.parentCategoryName = data["parentCategoryName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["categoryDepth"] = this.categoryDepth;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IQuestionsCategoryDto {
    tenantId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    categoryDepth: number | undefined;
    parentCategoryId: number | undefined;
    parentCategoryName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfQuestionsCategoryDto implements IPagedResultDtoOfQuestionsCategoryDto {
    totalCount!: number | undefined;
    items!: QuestionsCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuestionsCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuestionsCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuestionsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuestionsCategoryDto {
    totalCount: number | undefined;
    items: QuestionsCategoryDto[] | undefined;
}

export class UpdateQuestionCategoryInput implements IUpdateQuestionCategoryInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    code!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;

    constructor(data?: IUpdateQuestionCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.code = data["code"];
            this.name = data["name"];
            this.parentCategoryId = data["parentCategoryId"];
        }
    }

    static fromJS(data: any): UpdateQuestionCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        return data; 
    }
}

export interface IUpdateQuestionCategoryInput {
    id: number | undefined;
    tenantId: number | undefined;
    code: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
}

export class QuestionCategoryTreeItemDto implements IQuestionCategoryTreeItemDto {
    text!: string | undefined;
    id!: number | undefined;
    isSelected!: boolean | undefined;
    children!: QuestionCategoryTreeItemDto[] | undefined;

    constructor(data?: IQuestionCategoryTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.id = data["id"];
            this.isSelected = data["isSelected"];
            if (Array.isArray(data["children"])) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children!.push(QuestionCategoryTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionCategoryTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionCategoryTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["id"] = this.id;
        data["isSelected"] = this.isSelected;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionCategoryTreeItemDto {
    text: string | undefined;
    id: number | undefined;
    isSelected: boolean | undefined;
    children: QuestionCategoryTreeItemDto[] | undefined;
}

export class RankInput implements IRankInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    top!: number | undefined;
    action!: string | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    category!: string[] | undefined;
    brandId!: number | undefined;

    constructor(data?: IRankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.top = data["top"];
            this.action = data["action"];
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            if (Array.isArray(data["category"])) {
                this.category = [] as any;
                for (let item of data["category"])
                    this.category!.push(item);
            }
            this.brandId = data["brandId"];
        }
    }

    static fromJS(data: any): RankInput {
        data = typeof data === 'object' ? data : {};
        let result = new RankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["action"] = this.action;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface IRankInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    top: number | undefined;
    action: string | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    category: string[] | undefined;
    brandId: number | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number | undefined;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number | undefined;
    type: string | undefined;
}

export class ChartReportDto implements IChartReportDto {
    title!: string | undefined;
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IChartReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            if (Array.isArray(data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartReportDto {
    title: string | undefined;
    chartItems: ChartItem[] | undefined;
}

export class ChartItem implements IChartItem {
    date!: string | undefined;
    value!: number | undefined;
    picUrl!: string | undefined;
    category!: string | undefined;
    thingId!: number | undefined;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.value = data["value"];
            this.picUrl = data["picUrl"];
            this.category = data["category"];
            this.thingId = data["thingId"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        data["picUrl"] = this.picUrl;
        data["category"] = this.category;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IChartItem {
    date: string | undefined;
    value: number | undefined;
    picUrl: string | undefined;
    category: string | undefined;
    thingId: number | undefined;
}

export class PagedResultDtoOfPickAndRfidAndOrderDto implements IPagedResultDtoOfPickAndRfidAndOrderDto {
    totalCount!: number | undefined;
    items!: PickAndRfidAndOrderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPickAndRfidAndOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PickAndRfidAndOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPickAndRfidAndOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPickAndRfidAndOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPickAndRfidAndOrderDto {
    totalCount: number | undefined;
    items: PickAndRfidAndOrderDto[] | undefined;
}

export class PickAndRfidAndOrderDto implements IPickAndRfidAndOrderDto {
    skuId!: string | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    totalPickup!: number | undefined;
    totalRfid!: number | undefined;
    totalSaleNumber!: number | undefined;
    totalSaleAmount!: number | undefined;

    constructor(data?: IPickAndRfidAndOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.outerId = data["outerId"];
            this.name = data["name"];
            this.totalPickup = data["totalPickup"];
            this.totalRfid = data["totalRfid"];
            this.totalSaleNumber = data["totalSaleNumber"];
            this.totalSaleAmount = data["totalSaleAmount"];
        }
    }

    static fromJS(data: any): PickAndRfidAndOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PickAndRfidAndOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["totalPickup"] = this.totalPickup;
        data["totalRfid"] = this.totalRfid;
        data["totalSaleNumber"] = this.totalSaleNumber;
        data["totalSaleAmount"] = this.totalSaleAmount;
        return data; 
    }
}

export interface IPickAndRfidAndOrderDto {
    skuId: string | undefined;
    outerId: string | undefined;
    name: string | undefined;
    totalPickup: number | undefined;
    totalRfid: number | undefined;
    totalSaleNumber: number | undefined;
    totalSaleAmount: number | undefined;
}

export class ChartReportInput implements IChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    type!: string | undefined;
    actions!: string | undefined;
    categories!: string | undefined;
    storeIds!: number[] | undefined;

    constructor(data?: IChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.type = data["type"];
            this.actions = data["actions"];
            this.categories = data["categories"];
            if (Array.isArray(data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of data["storeIds"])
                    this.storeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["actions"] = this.actions;
        data["categories"] = this.categories;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        return data; 
    }
}

export interface IChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    type: string | undefined;
    actions: string | undefined;
    categories: string | undefined;
    storeIds: number[] | undefined;
}

export class DevieStatusChartReportInput implements IDevieStatusChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    ouOrStoreList!: IdTypeDto[] | undefined;

    constructor(data?: IDevieStatusChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DevieStatusChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new DevieStatusChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDevieStatusChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    ouOrStoreList: IdTypeDto[] | undefined;
}

export class GetDeviceActionsChartReportInput implements IGetDeviceActionsChartReportInput {
    deviceId!: number | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    ouOrStoreList!: IdTypeDto[] | undefined;

    constructor(data?: IGetDeviceActionsChartReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceActionsChartReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceActionsChartReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDeviceActionsChartReportInput {
    deviceId: number | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    ouOrStoreList: IdTypeDto[] | undefined;
}

export class DevieOnlineReportInput implements IDevieOnlineReportInput {
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    organizationUnitIds!: number[] | undefined;

    constructor(data?: IDevieOnlineReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DevieOnlineReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new DevieOnlineReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        return data; 
    }
}

export interface IDevieOnlineReportInput {
    startTime: moment.Moment;
    endTime: moment.Moment;
    organizationUnitIds: number[] | undefined;
}

export class BehaviorRecordDto implements IBehaviorRecordDto {
    tenantId!: number | undefined;
    thingId!: string | undefined;
    category!: string | undefined;
    name!: string | undefined;
    increment!: number | undefined;
    action!: string | undefined;
    collectionTime!: moment.Moment | undefined;
    collectEndTime!: moment.Moment | undefined;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    comments!: string | undefined;
    organizationUnitId!: number | undefined;
    storeId!: number | undefined;
    productId!: number | undefined;

    constructor(data?: IBehaviorRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.thingId = data["thingId"];
            this.category = data["category"];
            this.name = data["name"];
            this.increment = data["increment"];
            this.action = data["action"];
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = data["collectEndTime"] ? moment(data["collectEndTime"].toString()) : <any>undefined;
            this.softwareId = data["softwareId"];
            this.softwareName = data["softwareName"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.comments = data["comments"];
            this.organizationUnitId = data["organizationUnitId"];
            this.storeId = data["storeId"];
            this.productId = data["productId"];
        }
    }

    static fromJS(data: any): BehaviorRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["thingId"] = this.thingId;
        data["category"] = this.category;
        data["name"] = this.name;
        data["increment"] = this.increment;
        data["action"] = this.action;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["comments"] = this.comments;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface IBehaviorRecordDto {
    tenantId: number | undefined;
    thingId: string | undefined;
    category: string | undefined;
    name: string | undefined;
    increment: number | undefined;
    action: string | undefined;
    collectionTime: moment.Moment | undefined;
    collectEndTime: moment.Moment | undefined;
    softwareId: number | undefined;
    softwareName: string | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    comments: string | undefined;
    organizationUnitId: number | undefined;
    storeId: number | undefined;
    productId: number | undefined;
}

export enum OptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum OptStatus2 {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum OptStatus3 {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum OptStatuses {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum AddDeviceOptRecordInputOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum UpdateDeviceOptRecordInputOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum DeviceOptDtoOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum AddOperationInputOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum UpdateOperationRecordInputOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum OperationOptDtoOptStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}