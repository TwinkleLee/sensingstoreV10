/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.3.0 (NJsonSchema v10.3.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_ADS_URL = new InjectionToken<string>('API_ADS_URL');

@Injectable()
export class AdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 获取广告信息列表
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagId (optional) 标签 Id
     * @param isCustom (optional) 是否自定义广告
     * @param organizationUnitId (optional) 所属组织ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAds(auditStatus: AuditStatus | undefined, tagId: number | undefined, isCustom: boolean | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAds?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (isCustom === null)
            throw new Error("The parameter 'isCustom' cannot be null.");
        else if (isCustom !== undefined)
            url_ += "IsCustom=" + encodeURIComponent("" + isCustom) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAds(<any>response_);
                } catch (e) {
                    return <Observable<AdListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAds(response: HttpResponseBase): Observable<AdListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdListDtoPagedResultDto>(<any>null);
    }

    /**
     * 导出广告数据到Excel
     * @param status (optional) 上下线查询 offline,online
     * @param tagId (optional) 标签 Id
     * @param isCustom (optional) 是否自定义广告
     * @param organizationUnitId (optional) 所属组织ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsToExcel(status: AuditStatus | undefined, tagId: number | undefined, isCustom: boolean | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAdsToExcel?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (isCustom === null)
            throw new Error("The parameter 'isCustom' cannot be null.");
        else if (isCustom !== undefined)
            url_ += "IsCustom=" + encodeURIComponent("" + isCustom) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 通过广告ID获取单个广告详情
     * @param id (optional) 广告ID
     * @return Success
     */
    getSingleAd(id: number | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSingleAd?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * 创建广告
     * @param body (optional) 
     * @return Success
     */
    createAd(body: CreateAdInput | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/CreateAd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * 获取某个广告下所有的资源
     * @param adId (optional) 广告ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdResources(adId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdResourcesFileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAdResources?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdResources(<any>response_);
                } catch (e) {
                    return <Observable<AdResourcesFileDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdResourcesFileDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdResources(response: HttpResponseBase): Observable<AdResourcesFileDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdResourcesFileDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdResourcesFileDtoPagedResultDto>(<any>null);
    }

    /**
     * 为某个广告添加或更新资源
     * @param body (optional) 
     * @return Success
     */
    addorUpdateAdResource(body: AddAdResourceFileInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddorUpdateAdResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddorUpdateAdResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddorUpdateAdResource(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddorUpdateAdResource(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除广告下某一个资源
     * @param ids (optional) 广告资源的id
     * @return Success
     */
    deleteAdResources(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAdResources?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAdResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新广告信息
     * @param body (optional) 
     * @return Success
     */
    updateAd(body: UpdateAdInput | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateAd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * 删除广告
     * @param id (optional) 
     * @return Success
     */
    deleteAd(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAd?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除广告
     * @param ids (optional) 广告ID数组
     * @return Success
     */
    deleteAdByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAdByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAdByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 下发广告到ou或device
     * @param body (optional) 
     * @return Success
     */
    publishAdsToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishAdsToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAdsToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAdsToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAdsToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 发布或者撤销全部 EntityIds 不需要传值
     * @param body (optional) 
     * @return Success
     */
    publishAllAdsToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishAllAdsToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllAdsToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllAdsToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllAdsToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取广告排程详情
     * @param adSchedulingId (optional) 广告排程ID
     * @return Success
     */
    getSingleScheduling(adSchedulingId: number | undefined): Observable<GetAdSchedulingDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSingleScheduling?";
        if (adSchedulingId === null)
            throw new Error("The parameter 'adSchedulingId' cannot be null.");
        else if (adSchedulingId !== undefined)
            url_ += "adSchedulingId=" + encodeURIComponent("" + adSchedulingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleScheduling(<any>response_);
                } catch (e) {
                    return <Observable<GetAdSchedulingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAdSchedulingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleScheduling(response: HttpResponseBase): Observable<GetAdSchedulingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdSchedulingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAdSchedulingDto>(<any>null);
    }

    /**
     * 获取广告排程列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSchedulings(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetAdSchedulingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSchedulings?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<GetAdSchedulingDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAdSchedulingDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSchedulings(response: HttpResponseBase): Observable<GetAdSchedulingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdSchedulingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAdSchedulingDtoPagedResultDto>(<any>null);
    }

    /**
     * 新增或更新广告排程
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateScheduling(body: AddOrUpdateAdSchedulingInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddOrUpdateScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 批量删除排程
     * @param ids (optional) 排程ID数组
     * @return Success
     */
    deleteSchedulings(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteSchedulings?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSchedulings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新增或更新排程内容，将排程以json方式存入到排程中
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateScheDulingContent(body: SchedulingContent | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddOrUpdateScheDulingContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateScheDulingContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateScheDulingContent(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateScheDulingContent(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除节目单
     * @param ids (optional) 节目单ID
     * @return Success
     */
    deleteSchedulingContents(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteSchedulingContents?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSchedulingContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSchedulingContents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSchedulingContents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addContentToScheduling(body: PublishContentToAdScheduling | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddContentToScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContentToScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContentToScheduling(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddContentToScheduling(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取排程日历
     * @param adSchedulingId (optional) 排程ID
     * @param startTime (optional) 日历开始时间
     * @param endTime (optional) 日历结束时间
     * @return Success
     */
    getScheduleCalendar(adSchedulingId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined): Observable<ScheduleCalendarDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetScheduleCalendar?";
        if (adSchedulingId === null)
            throw new Error("The parameter 'adSchedulingId' cannot be null.");
        else if (adSchedulingId !== undefined)
            url_ += "AdSchedulingId=" + encodeURIComponent("" + adSchedulingId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleCalendar(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleCalendarDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleCalendarDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleCalendar(response: HttpResponseBase): Observable<ScheduleCalendarDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleCalendarDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleCalendarDto>(<any>null);
    }

    /**
     * 更新排程日历
     * @param body (optional) 
     * @return Success
     */
    updateScheduleCalendar(body: SchedulingContentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateScheduleCalendar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleCalendar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleCalendar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取24小时节目单
     * @param adSchedulingId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProgramsIn24HoursList(adSchedulingId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetProgramsIn24HoursDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetProgramsIn24HoursList?";
        if (adSchedulingId === null)
            throw new Error("The parameter 'adSchedulingId' cannot be null.");
        else if (adSchedulingId !== undefined)
            url_ += "AdSchedulingId=" + encodeURIComponent("" + adSchedulingId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramsIn24HoursList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramsIn24HoursList(<any>response_);
                } catch (e) {
                    return <Observable<GetProgramsIn24HoursDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProgramsIn24HoursDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramsIn24HoursList(response: HttpResponseBase): Observable<GetProgramsIn24HoursDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProgramsIn24HoursDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProgramsIn24HoursDtoPagedResultDto>(<any>null);
    }

    /**
     * 给设备发布排程
     * @param body (optional) 
     * @return Success
     */
    publishSchedulingToDevice(body: PublishAdScheduliingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishSchedulingToDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSchedulingToDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSchedulingToDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSchedulingToDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取节目单列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPrograms(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProgramDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetPrograms?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrograms(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrograms(response: HttpResponseBase): Observable<ProgramDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建节目单
     * @param body (optional) 
     * @return Success
     */
    createProgram(body: CreateProgramInput | undefined): Observable<ProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/CreateProgram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProgram(response: HttpResponseBase): Observable<ProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDto>(<any>null);
    }

    /**
     * 更新节目单
     * @param body (optional) 
     * @return Success
     */
    updateProgram(body: UpdateProgramInput | undefined): Observable<ProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateProgram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProgram(response: HttpResponseBase): Observable<ProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDto>(<any>null);
    }

    /**
     * 删除节目单
     * @param id (optional) 
     * @return Success
     */
    deleteProgram(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteProgram?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProgram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProgram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId 设备ID
     * @param id (optional) 广告或应用ID
     * @param auditStatus (optional) 广告或应用上架状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnPublishedAdsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetUnPublishedAdsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnPublishedAdsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnPublishedAdsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<AdOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnPublishedAdsByDeviceId(response: HttpResponseBase): Observable<AdOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdOutDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class AdsPackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 新增或修改广告套餐包
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateAdsPackage(body: AddOrUpdateAdsPackageInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/AddOrUpdateAdsPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateAdsPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateAdsPackage(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateAdsPackage(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 获取已创建的广告套餐
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPackages(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetPackageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetPackages?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackages(<any>response_);
                } catch (e) {
                    return <Observable<GetPackageDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPackageDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackages(response: HttpResponseBase): Observable<GetPackageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPackageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPackageDtoPagedResultDto>(<any>null);
    }

    /**
     * 通过ID获取广告套餐详情
     * @param packageId (optional) 
     * @return Success
     */
    getPackageById(packageId: number | undefined): Observable<AdsPackageDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetPackageById?";
        if (packageId === null)
            throw new Error("The parameter 'packageId' cannot be null.");
        else if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackageById(<any>response_);
                } catch (e) {
                    return <Observable<AdsPackageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsPackageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackageById(response: HttpResponseBase): Observable<AdsPackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdsPackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsPackageDto>(<any>null);
    }

    /**
     * 通过ID数组删除广告套餐
     * @param ids (optional) 
     * @return Success
     */
    deletePackageByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/DeletePackageByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePackageByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePackageByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePackageByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取一个套餐下所有广告信息
     * @param adsPackageId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdInfosInSamePackage(adsPackageId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdPackageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAdInfosInSamePackage?";
        if (adsPackageId === null)
            throw new Error("The parameter 'adsPackageId' cannot be null.");
        else if (adsPackageId !== undefined)
            url_ += "AdsPackageId=" + encodeURIComponent("" + adsPackageId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdInfosInSamePackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdInfosInSamePackage(<any>response_);
                } catch (e) {
                    return <Observable<AdPackageDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdPackageDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdInfosInSamePackage(response: HttpResponseBase): Observable<AdPackageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdPackageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdPackageDtoPagedResultDto>(<any>null);
    }

    /**
     * 更新广告套餐
     * @param body (optional) 
     * @return Success
     */
    updateAdPackage(body: UpdateAdPackageInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/UpdateAdPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdPackage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdPackage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 向广告套餐中添加广告
     * @param body (optional) 
     * @return Success
     */
    addAdsToPackage(body: SetAdsToPackageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/AddAdsToPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdsToPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdsToPackage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdsToPackage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过广告ID获取广告套餐信息
     * @param adId (optional) 
     * @return Success
     */
    getAdPackageByAdId(adId: number | undefined): Observable<AdPackage> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAdPackageByAdId?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdPackageByAdId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdPackageByAdId(<any>response_);
                } catch (e) {
                    return <Observable<AdPackage>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdPackage>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdPackageByAdId(response: HttpResponseBase): Observable<AdPackage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdPackage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdPackage>(<any>null);
    }

    /**
     * 将广告下发给个人账号
     * @param body (optional) 
     * @return Success
     */
    setUserAds(body: SetUserAds | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/SetUserAds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserAds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetUserAds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过广告ID获取用户信息
     * @param adId (optional) 
     * @return Success
     */
    getUserAdByAdId(adId: number | undefined): Observable<UserAd> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetUserAdByAdId?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAdByAdId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAdByAdId(<any>response_);
                } catch (e) {
                    return <Observable<UserAd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAd>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAdByAdId(response: HttpResponseBase): Observable<UserAd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAd>(<any>null);
    }

    /**
     * 获取所有支持的广告切换效果
     * @return Success
     */
    getAllTransitionsInAds(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAllTransitionsInAds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransitionsInAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransitionsInAds(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTransitionsInAds(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class ApplyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 获取审核列表
     * @param type (optional) 
     * @param applyStatus (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyForms(type: string | undefined, applyStatus: string | undefined, start: moment.Moment | undefined, end: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ApplyFormDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyForms?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (applyStatus === null)
            throw new Error("The parameter 'applyStatus' cannot be null.");
        else if (applyStatus !== undefined)
            url_ += "ApplyStatus=" + encodeURIComponent("" + applyStatus) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "End=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyForms(<any>response_);
                } catch (e) {
                    return <Observable<ApplyFormDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplyFormDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyForms(response: HttpResponseBase): Observable<ApplyFormDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyFormDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplyFormDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建上线和下线申请
     * @param body (optional) 
     * @return Success
     */
    createApplyForm(body: CreateApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/CreateApplyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 审批特定提交
     * @param body (optional) 审批结果信息
     * @return Success
     */
    audit(body: AuditApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 特定审批下的内容详细
     * @param appFormId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyFormDetails(appFormId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IdNamePicDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyFormDetails?";
        if (appFormId === null)
            throw new Error("The parameter 'appFormId' cannot be null.");
        else if (appFormId !== undefined)
            url_ += "AppFormId=" + encodeURIComponent("" + appFormId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyFormDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyFormDetails(<any>response_);
                } catch (e) {
                    return <Observable<IdNamePicDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNamePicDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyFormDetails(response: HttpResponseBase): Observable<IdNamePicDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNamePicDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNamePicDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class BatchTaskLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * @param batchType (optional) 
     * @param onlineStoreId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBatchTaskLogs(batchType: string | undefined, onlineStoreId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BatchTaskLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchTaskLog/GetBatchTaskLogs?";
        if (batchType === null)
            throw new Error("The parameter 'batchType' cannot be null.");
        else if (batchType !== undefined)
            url_ += "BatchType=" + encodeURIComponent("" + batchType) + "&";
        if (onlineStoreId === null)
            throw new Error("The parameter 'onlineStoreId' cannot be null.");
        else if (onlineStoreId !== undefined)
            url_ += "OnlineStoreId=" + encodeURIComponent("" + onlineStoreId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchTaskLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchTaskLogs(<any>response_);
                } catch (e) {
                    return <Observable<BatchTaskLogDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BatchTaskLogDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchTaskLogs(response: HttpResponseBase): Observable<BatchTaskLogDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BatchTaskLogDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BatchTaskLogDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class DeviceAdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 获取指定设备下的排程
     * @param deviceId (optional) 设备ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceSchedulings(deviceId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetDeviceSchedulingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAds/GetDeviceSchedulings?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceSchedulingDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceSchedulingDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceSchedulings(response: HttpResponseBase): Observable<GetDeviceSchedulingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDeviceSchedulingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceSchedulingDtoPagedResultDto>(<any>null);
    }

    /**
     * IsUse启用/禁用
     * @param schedulingId (optional) 排程ID
     * @param deviceId (optional) 设备ID
     * @param isOpen (optional) 是否启用
     * @return Success
     */
    openOrShutDeviceScheduling(schedulingId: number | undefined, deviceId: number | undefined, isOpen: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAds/OpenOrShutDeviceScheduling?";
        if (schedulingId === null)
            throw new Error("The parameter 'schedulingId' cannot be null.");
        else if (schedulingId !== undefined)
            url_ += "schedulingId=" + encodeURIComponent("" + schedulingId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (isOpen === null)
            throw new Error("The parameter 'isOpen' cannot be null.");
        else if (isOpen !== undefined)
            url_ += "isOpen=" + encodeURIComponent("" + isOpen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenOrShutDeviceScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenOrShutDeviceScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processOpenOrShutDeviceScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 发布时使用改变IsUser功能（）
     * @param body (optional) 
     * @return Success
     */
    shutDeviceScheduling(body: number[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAds/ShutDeviceScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShutDeviceScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShutDeviceScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processShutDeviceScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 通过设备ID获取设备下的广告
     * @param deviceId 设备ID
     * @param id (optional) 广告或应用ID
     * @param auditStatus (optional) 广告或应用上架状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAds/GetAdsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<AdOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsByDeviceId(response: HttpResponseBase): Observable<AdOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdOutDtoPagedResultDto>(<any>null);
    }

    /**
     * 通知设备更新排程
     * @param body (optional) 
     * @return Success
     */
    informDevicesByMqtt(body: number[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAds/InformDevicesByMqtt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInformDevicesByMqtt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInformDevicesByMqtt(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processInformDevicesByMqtt(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class DeviceSoftwareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 更新设备下某个app
     * @param body (optional) 
     * @return Success
     */
    updateDeviceSoftware(body: UpdateDeviceSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceSoftware/UpdateDeviceSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过设备ID获取应用程序信息列表
     * @param deviceId 设备ID
     * @param id (optional) 广告或应用ID
     * @param auditStatus (optional) 广告或应用上架状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwaresByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceSoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceSoftware/GetSoftwaresByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwaresByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwaresByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<DeviceSoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceSoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwaresByDeviceId(response: HttpResponseBase): Observable<DeviceSoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceSoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceSoftwareDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAbpClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetAbpClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAbpClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAbpClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAbpClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getCacheString(key: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetCacheString?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCacheString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCacheString(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCacheString(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @param value (optional) 
     * @return Success
     */
    setCacheString(key: string | undefined, value: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/Identity/SetCacheString?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCacheString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCacheString(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetCacheString(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ImportAdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * @return Success
     */
    importAdsByZip(): Observable<ImportAdResultDto> {
        let url_ = this.baseUrl + "/ImportAds/ImportAdsByZip";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportAdsByZip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportAdsByZip(<any>response_);
                } catch (e) {
                    return <Observable<ImportAdResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportAdResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportAdsByZip(response: HttpResponseBase): Observable<ImportAdResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportAdResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportAdResultDto>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 特定设备下所有可被播放的广告.需要考虑分页.
     * @param subkey (optional) 设备识别号
     * @param pointRedeemType (optional) 积分兑换类型
     * @param tagNames (optional) 标签名称数组
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAds(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdsSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAds?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAds(<any>response_);
                } catch (e) {
                    return <Observable<AdsSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAds(response: HttpResponseBase): Observable<AdsSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdsSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsSdkModelPagedResultDto>(<any>null);
    }

    /**
     * 获取应用信息
     * @param subkey (optional) 设备识别号
     * @param pointRedeemType (optional) 积分兑换类型
     * @param tagNames (optional) 标签名称数组
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApps(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceSoftwareSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetApps?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApps(<any>response_);
                } catch (e) {
                    return <Observable<DeviceSoftwareSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceSoftwareSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApps(response: HttpResponseBase): Observable<DeviceSoftwareSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceSoftwareSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceSoftwareSdkModelPagedResultDto>(<any>null);
    }

    /**
     * 获取一周之内,Ads和app的Timeline排布.
     * @param subKey (optional) 设备subkey
     * @param startTime (optional) 开始时间
     * @return Success
     */
    getAdAndAppTimelinesInAWeek(subKey: string | undefined, startTime: moment.Moment | undefined): Observable<AdAndAppTimelineScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAdAndAppTimelinesInAWeek?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdAndAppTimelinesInAWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdAndAppTimelinesInAWeek(<any>response_);
                } catch (e) {
                    return <Observable<AdAndAppTimelineScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdAndAppTimelineScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdAndAppTimelinesInAWeek(response: HttpResponseBase): Observable<AdAndAppTimelineScheduleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdAndAppTimelineScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdAndAppTimelineScheduleDto[]>(<any>null);
    }

    /**
     * 获取所有的tag
     * @param subkey (optional) 设备识别号
     * @param pointRedeemType (optional) 积分兑换类型
     * @param tagNames (optional) 标签名称数组
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetTags?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagSdkModelPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SoftwareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 获取应用下拉列表
     * @return Success
     */
    getSoftwares4Dropdownlist(): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftwares4Dropdownlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwares4Dropdownlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwares4Dropdownlist(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwares4Dropdownlist(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }

    /**
     * 获取授权应用列表
     * @param organizationUnitId (optional) 组织机构ID
     * @param softwareType (optional) 应用类型
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuthorizedSoftwares(organizationUnitId: number | undefined, softwareType: SoftwareType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AuthorizatedSoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetAuthorizedSoftwares?";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorizedSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorizedSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<AuthorizatedSoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthorizatedSoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthorizedSoftwares(response: HttpResponseBase): Observable<AuthorizatedSoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizatedSoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorizatedSoftwareDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取租户下所有的应用
     * @param softwareType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getForTenantSoftwares(softwareType: SoftwareType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetForTenantSoftwares?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForTenantSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForTenantSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForTenantSoftwares(response: HttpResponseBase): Observable<SoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取host权限所有应用
     * @param softwareType (optional) 
     * @param isShowToTenant (optional) 是否显示给租户，即应用商店
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwares4Host(softwareType: SoftwareType | undefined, isShowToTenant: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftwares4Host?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (isShowToTenant === null)
            throw new Error("The parameter 'isShowToTenant' cannot be null.");
        else if (isShowToTenant !== undefined)
            url_ += "IsShowToTenant=" + encodeURIComponent("" + isShowToTenant) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwares4Host(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwares4Host(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwares4Host(response: HttpResponseBase): Observable<SoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDtoPagedResultDto>(<any>null);
    }

    /**
     * 导出Host权限应用到excel
     * @param body (optional) 
     * @return Success
     */
    exportSoftwareToExcel(body: GetSoftwareInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Software/ExportSoftwareToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportSoftwareToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportSoftwareToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processExportSoftwareToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取单个应用详情
     * @param id (optional) 应用ID
     * @return Success
     */
    getSingleSoftware(id: number | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSingleSoftware?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * 创建应用
     * @param body (optional) 
     * @return Success
     */
    createSoftware(body: CreateSoftwareInput | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/CreateSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * 更新应用
     * @param body (optional) 
     * @return Success
     */
    updateSoftware(body: UpdateSoftwareInput | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/UpdateSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * 删除应用
     * @param id (optional) 
     * @return Success
     */
    deleteSoftware(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/DeleteSoftware?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 取消软件授权给Tenant
     * @param softwareId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeAuthorizeToTenant(softwareId: number | undefined, tenantId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/RemoveAuthorizeToTenant?";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAuthorizeToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAuthorizeToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAuthorizeToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 软件授权给Tenant
     * @param body (optional) 
     * @return Success
     */
    authorizeToTenant(body: AuthorizeSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/AuthorizeToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorizeToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新已授权的app
     * @param body (optional) 
     * @return Success
     */
    updateAuthorizedSoftware(body: UpdateAuthorizeSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/UpdateAuthorizedSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthorizedSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthorizedSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAuthorizedSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * host 分发app到 tenant
     * @param body (optional) 
     * @return Success
     */
    publishAllSoftwaresToTenant(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishAllSoftwaresToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllSoftwaresToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllSoftwaresToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllSoftwaresToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 部分下发或撤回software
     * @param body (optional) 
     * @return Success
     */
    publishSoftwaresToTenant(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishSoftwaresToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSoftwaresToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSoftwaresToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSoftwaresToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 下发App到ou或device
    EntityIds里是dispatchedsoftwareId
     * @param body (optional) 
     * @return Success
     */
    publishSoftwaresToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishSoftwaresToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSoftwaresToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSoftwaresToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSoftwaresToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 发布或者撤销全部 EntityIds 不需要传值
     * @param body (optional) 
     * @return Success
     */
    publishAllSoftwaresToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishAllSoftwaresToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllSoftwaresToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllSoftwaresToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllSoftwaresToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取授权应用列表
     * @param softwareId (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwareAuthList(softwareId: number | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DispatchedSoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftwareAuthList?";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwareAuthList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwareAuthList(<any>response_);
                } catch (e) {
                    return <Observable<DispatchedSoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DispatchedSoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwareAuthList(response: HttpResponseBase): Observable<DispatchedSoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DispatchedSoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispatchedSoftwareDtoPagedResultDto>(<any>null);
    }

    /**
     * @param deviceId 设备ID
     * @param id (optional) 广告或应用ID
     * @param auditStatus (optional) 广告或应用上架状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedSoftwaresByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceSoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetUnpublishedSoftwaresByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedSoftwaresByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedSoftwaresByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<DeviceSoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceSoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedSoftwaresByDeviceId(response: HttpResponseBase): Observable<DeviceSoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceSoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceSoftwareDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class StoreAdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 获取店铺下所有广告
     * @param auditStatus (optional) 审核状态
     * @param storeId (optional) 店铺ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsByStoreId(auditStatus: AuditStatus | undefined, storeId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AdListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAds/GetAdsByStoreId?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<AdListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsByStoreId(response: HttpResponseBase): Observable<AdListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class StoreSoftwareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 通过店铺ID获取店铺下的所有应用
     * @param softwareType (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwaresByStoreId(softwareType: SoftwareType | undefined, storeId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SoftwareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSoftware/GetSoftwaresByStoreId?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwaresByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwaresByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwaresByStoreId(response: HttpResponseBase): Observable<SoftwareDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTagsToExcel(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: TagType | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class ToolBoxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 创建或修改工具组件
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateTool(id: number | undefined, body: CreateToolBoxInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ToolBox/CreateOrUpdateTool?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateTool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateTool(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateTool(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询组件工具组件列表
     * @param category (optional) 
     * @param enabled (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getToolBoxs(category: CategoryEnum | undefined, enabled: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetToolBoxDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ToolBox/GetToolBoxs?";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        if (enabled === null)
            throw new Error("The parameter 'enabled' cannot be null.");
        else if (enabled !== undefined)
            url_ += "Enabled=" + encodeURIComponent("" + enabled) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToolBoxs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToolBoxs(<any>response_);
                } catch (e) {
                    return <Observable<GetToolBoxDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetToolBoxDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToolBoxs(response: HttpResponseBase): Observable<GetToolBoxDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetToolBoxDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetToolBoxDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除工具组件
     * @param ids (optional) 
     * @return Success
     */
    deleteToolBox(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ToolBox/DeleteToolBox?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteToolBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteToolBox(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteToolBox(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UXPageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ADS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8003";
    }

    /**
     * 创建UXPage页面信息
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUXPage(id: number | undefined, body: CreateUXPageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/CreateOrUpdateUXPage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUXPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUXPage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUXPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取UXPage页面内容
     * @param id (optional) 
     * @return Success
     */
    getUXPageContent(id: number | undefined): Observable<GetUXPageContentDto> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/GetUXPageContent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUXPageContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUXPageContent(<any>response_);
                } catch (e) {
                    return <Observable<GetUXPageContentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUXPageContentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUXPageContent(response: HttpResponseBase): Observable<GetUXPageContentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUXPageContentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUXPageContentDto>(<any>null);
    }

    /**
     * 查询UXPage页面标签
     * @param uxPageId (optional) 
     * @return Success
     */
    getUXPageTags(uxPageId: number | undefined): Observable<TagIds[]> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/GetUXPageTags?";
        if (uxPageId === null)
            throw new Error("The parameter 'uxPageId' cannot be null.");
        else if (uxPageId !== undefined)
            url_ += "uxPageId=" + encodeURIComponent("" + uxPageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUXPageTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUXPageTags(<any>response_);
                } catch (e) {
                    return <Observable<TagIds[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagIds[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUXPageTags(response: HttpResponseBase): Observable<TagIds[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagIds.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagIds[]>(<any>null);
    }

    /**
     * 更新UXPage页面内容
     * @param id (optional) 
     * @param content (optional) 
     * @return Success
     */
    updateUXPageContent(id: number | undefined, content: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/UpdateUXPageContent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (content === null)
            throw new Error("The parameter 'content' cannot be null.");
        else if (content !== undefined)
            url_ += "content=" + encodeURIComponent("" + content) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUXPageContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUXPageContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUXPageContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取所有的自定义页面的列表，支持分页
     * @param from (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUXPages(from: FromEnum | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetUXPageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/GetUXPages?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUXPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUXPages(<any>response_);
                } catch (e) {
                    return <Observable<GetUXPageDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUXPageDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUXPages(response: HttpResponseBase): Observable<GetUXPageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUXPageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUXPageDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除UXPage页面记录
     * @param ids (optional) 
     * @return Success
     */
    deleteUXPage(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UXPage/DeleteUXPage?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUXPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUXPage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUXPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class Ad implements IAd {
    name!: string;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    resourceItemId!: number;
    resourceItem!: ResourceFile;
    usage!: string | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    adsTags!: AdsTag[] | undefined;
    adsPrograms!: AdsProgram[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: moment.Moment | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isCustom!: boolean;
    customContent!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.resourceItem = _data["resourceItem"] ? ResourceFile.fromJS(_data["resourceItem"]) : <any>undefined;
            this.usage = _data["usage"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(AdsTag.fromJS(item));
            }
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgram.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Ad {
        data = typeof data === 'object' ? data : {};
        let result = new Ad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["resourceItem"] = this.resourceItem ? this.resourceItem.toJSON() : <any>undefined;
        data["usage"] = this.usage;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAd {
    name: string;
    tenantId: number;
    organizationUnitId: number | undefined;
    resourceItemId: number;
    resourceItem: ResourceFile;
    usage: string | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    adsTags: AdsTag[] | undefined;
    adsPrograms: AdsProgram[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: moment.Moment | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isCustom: boolean;
    customContent: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdAndAppTimelineScheduleDto implements IAdAndAppTimelineScheduleDto {
    date!: moment.Moment;
    startTime!: string | undefined;
    endTime!: string | undefined;
    scheduleModel!: ScheduleModel;
    adAndApps!: ProgramItem[] | undefined;

    constructor(data?: IAdAndAppTimelineScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.scheduleModel = _data["scheduleModel"] ? ScheduleModel.fromJS(_data["scheduleModel"]) : <any>undefined;
            if (Array.isArray(_data["adAndApps"])) {
                this.adAndApps = [] as any;
                for (let item of _data["adAndApps"])
                    this.adAndApps!.push(ProgramItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdAndAppTimelineScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdAndAppTimelineScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["scheduleModel"] = this.scheduleModel ? this.scheduleModel.toJSON() : <any>undefined;
        if (Array.isArray(this.adAndApps)) {
            data["adAndApps"] = [];
            for (let item of this.adAndApps)
                data["adAndApps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdAndAppTimelineScheduleDto {
    date: moment.Moment;
    startTime: string | undefined;
    endTime: string | undefined;
    scheduleModel: ScheduleModel;
    adAndApps: ProgramItem[] | undefined;
}

/** 给广告添加资源的接口入参 */
export class AddAdResourceFileInput implements IAddAdResourceFileInput {
    /** 广告ID */
    id!: number | undefined;
    /** 资源ID */
    resourceItemId!: number;
    /** 资源用途 */
    usage!: string | undefined;
    /** 描述信息 */
    description!: string | undefined;
    /** 资源内容 */
    content!: string | undefined;
    /** 文件名称 */
    name!: string | undefined;
    /** 广告ID */
    adId!: number;
    /** 排序编号 */
    orderNumber!: number;
    /** 资源来源 */
    fromType!: string | undefined;

    constructor(data?: IAddAdResourceFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resourceItemId = _data["resourceItemId"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.adId = _data["adId"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): AddAdResourceFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddAdResourceFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resourceItemId"] = this.resourceItemId;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["adId"] = this.adId;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

/** 给广告添加资源的接口入参 */
export interface IAddAdResourceFileInput {
    /** 广告ID */
    id: number | undefined;
    /** 资源ID */
    resourceItemId: number;
    /** 资源用途 */
    usage: string | undefined;
    /** 描述信息 */
    description: string | undefined;
    /** 资源内容 */
    content: string | undefined;
    /** 文件名称 */
    name: string | undefined;
    /** 广告ID */
    adId: number;
    /** 排序编号 */
    orderNumber: number;
    /** 资源来源 */
    fromType: string | undefined;
}

/** 添加广告及应用排程的接口入参 */
export class AddOrUpdateAdSchedulingInput implements IAddOrUpdateAdSchedulingInput {
    /** 排程ID */
    id!: number | undefined;
    /** 排程名称 */
    name!: string | undefined;
    /** 排程描述 */
    description!: string | undefined;
    /** 开始时间 */
    activeTime!: moment.Moment | undefined;
    /** 结束时间 */
    endTime!: moment.Moment | undefined;
    /** 图标 */
    iconUrl!: string | undefined;
    playType!: PlayType;

    constructor(data?: IAddOrUpdateAdSchedulingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? moment(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.playType = _data["playType"];
        }
    }

    static fromJS(data: any): AddOrUpdateAdSchedulingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAdSchedulingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["playType"] = this.playType;
        return data; 
    }
}

/** 添加广告及应用排程的接口入参 */
export interface IAddOrUpdateAdSchedulingInput {
    /** 排程ID */
    id: number | undefined;
    /** 排程名称 */
    name: string | undefined;
    /** 排程描述 */
    description: string | undefined;
    /** 开始时间 */
    activeTime: moment.Moment | undefined;
    /** 结束时间 */
    endTime: moment.Moment | undefined;
    /** 图标 */
    iconUrl: string | undefined;
    playType: PlayType;
}

export class AddOrUpdateAdsPackageInput implements IAddOrUpdateAdsPackageInput {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    value!: number;
    isLocationBased!: boolean;
    deviceId!: number | undefined;
    patrolId!: string | undefined;
    patrolName!: string | undefined;
    adPackages!: AdPackageBindingDto[] | undefined;

    constructor(data?: IAddOrUpdateAdsPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isLocationBased = _data["isLocationBased"];
            this.deviceId = _data["deviceId"];
            this.patrolId = _data["patrolId"];
            this.patrolName = _data["patrolName"];
            if (Array.isArray(_data["adPackages"])) {
                this.adPackages = [] as any;
                for (let item of _data["adPackages"])
                    this.adPackages!.push(AdPackageBindingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateAdsPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAdsPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isLocationBased"] = this.isLocationBased;
        data["deviceId"] = this.deviceId;
        data["patrolId"] = this.patrolId;
        data["patrolName"] = this.patrolName;
        if (Array.isArray(this.adPackages)) {
            data["adPackages"] = [];
            for (let item of this.adPackages)
                data["adPackages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateAdsPackageInput {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    value: number;
    isLocationBased: boolean;
    deviceId: number | undefined;
    patrolId: string | undefined;
    patrolName: string | undefined;
    adPackages: AdPackageBindingDto[] | undefined;
}

/** 获取广告详细信息接口的返回对象 */
export class AdDto implements IAdDto {
    name!: string;
    /** 所属的租户 Id */
    tenantId!: number;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 资源ID */
    resourceId!: number;
    /** 资源类型 */
    resourceType!: string | undefined;
    /** 广告资源的地址 */
    fileUrl!: string | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    /** 标签数组 */
    adsTags!: Int64IdNameDto[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes!: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime!: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan!: string | undefined;
    /** 页面切换的动画。 */
    transition!: string | undefined;
    description!: string | undefined;
    isMine!: boolean;
    isCustom!: boolean;
    customContent!: string | undefined;
    /** 关联地图 */
    robotMapName!: string | undefined;
    /** 关联导航点位 */
    robotMapPointName!: string | undefined;
    /** 导航引导词 */
    guideWord!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceId = _data["resourceId"];
            this.resourceType = _data["resourceType"];
            this.fileUrl = _data["fileUrl"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(Int64IdNameDto.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["fileUrl"] = this.fileUrl;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取广告详细信息接口的返回对象 */
export interface IAdDto {
    name: string;
    /** 所属的租户 Id */
    tenantId: number;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 资源ID */
    resourceId: number;
    /** 资源类型 */
    resourceType: string | undefined;
    /** 广告资源的地址 */
    fileUrl: string | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    /** 标签数组 */
    adsTags: Int64IdNameDto[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan: string | undefined;
    /** 页面切换的动画。 */
    transition: string | undefined;
    description: string | undefined;
    isMine: boolean;
    isCustom: boolean;
    customContent: string | undefined;
    /** 关联地图 */
    robotMapName: string | undefined;
    /** 关联导航点位 */
    robotMapPointName: string | undefined;
    /** 导航引导词 */
    guideWord: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 广告详细信息列表对象 */
export class AdListDto implements IAdListDto {
    name!: string;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    resourceType!: FileType;
    type!: AdsType;
    auditStatus!: AuditStatus;
    /** 广告标签数组 */
    adsTags!: Int64IdNameDto[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes!: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber!: number;
    /** 广告资源的地址 */
    fileUrl!: string | undefined;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime!: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan!: string | undefined;
    /** 页面切换的动画。 */
    transition!: string | undefined;
    description!: string | undefined;
    isMine!: boolean;
    /** 是否自定义广告 */
    isCustom!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceType = _data["resourceType"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(Int64IdNameDto.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.fileUrl = _data["fileUrl"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["fileUrl"] = this.fileUrl;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 广告详细信息列表对象 */
export interface IAdListDto {
    name: string;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    resourceType: FileType;
    type: AdsType;
    auditStatus: AuditStatus;
    /** 广告标签数组 */
    adsTags: Int64IdNameDto[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber: number;
    /** 广告资源的地址 */
    fileUrl: string | undefined;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan: string | undefined;
    /** 页面切换的动画。 */
    transition: string | undefined;
    description: string | undefined;
    isMine: boolean;
    /** 是否自定义广告 */
    isCustom: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdListDtoPagedResultDto implements IAdListDtoPagedResultDto {
    totalCount!: number;
    items!: AdListDto[] | undefined;

    constructor(data?: IAdListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdListDtoPagedResultDto {
    totalCount: number;
    items: AdListDto[] | undefined;
}

export class AdOrAppItem implements IAdOrAppItem {
    id!: number;
    duration!: number;
    transition!: string | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;

    constructor(data?: IAdOrAppItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.duration = _data["duration"];
            this.transition = _data["transition"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
        }
    }

    static fromJS(data: any): AdOrAppItem {
        data = typeof data === 'object' ? data : {};
        let result = new AdOrAppItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["duration"] = this.duration;
        data["transition"] = this.transition;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        return data; 
    }
}

export interface IAdOrAppItem {
    id: number;
    duration: number;
    transition: string | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
}

/** 通过设备ID获取广告信息时的返回对象 */
export class AdOutDto implements IAdOutDto {
    /** 广告ID */
    id!: number;
    /** 创建时间 */
    creationTime!: moment.Moment;
    /** 适用人群年龄区间 */
    ageScope!: string | undefined;
    auditStatus!: AuditStatus;
    /** 资源文件地址 */
    fileUrl!: string | undefined;
    /** 广告名称 */
    name!: string | undefined;
    /** 广告标签列表 */
    adsTags!: Int64IdNameDto[] | undefined;
    /** 资源类型 jpg,mp4.... */
    resourceType!: string | undefined;
    organizationUnitId!: number | undefined;
    /** 是否是当前账号创建的 */
    isMine!: boolean;
    /** 是否是自定义类型广告 */
    isCustom!: boolean;

    constructor(data?: IAdOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.ageScope = _data["ageScope"];
            this.auditStatus = _data["auditStatus"];
            this.fileUrl = _data["fileUrl"];
            this.name = _data["name"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(Int64IdNameDto.fromJS(item));
            }
            this.resourceType = _data["resourceType"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
        }
    }

    static fromJS(data: any): AdOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["ageScope"] = this.ageScope;
        data["auditStatus"] = this.auditStatus;
        data["fileUrl"] = this.fileUrl;
        data["name"] = this.name;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["resourceType"] = this.resourceType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        return data; 
    }
}

/** 通过设备ID获取广告信息时的返回对象 */
export interface IAdOutDto {
    /** 广告ID */
    id: number;
    /** 创建时间 */
    creationTime: moment.Moment;
    /** 适用人群年龄区间 */
    ageScope: string | undefined;
    auditStatus: AuditStatus;
    /** 资源文件地址 */
    fileUrl: string | undefined;
    /** 广告名称 */
    name: string | undefined;
    /** 广告标签列表 */
    adsTags: Int64IdNameDto[] | undefined;
    /** 资源类型 jpg,mp4.... */
    resourceType: string | undefined;
    organizationUnitId: number | undefined;
    /** 是否是当前账号创建的 */
    isMine: boolean;
    /** 是否是自定义类型广告 */
    isCustom: boolean;
}

export class AdOutDtoPagedResultDto implements IAdOutDtoPagedResultDto {
    totalCount!: number;
    items!: AdOutDto[] | undefined;

    constructor(data?: IAdOutDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdOutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdOutDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdOutDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdOutDtoPagedResultDto {
    totalCount: number;
    items: AdOutDto[] | undefined;
}

export class AdPackage implements IAdPackage {
    adId!: number;
    ad!: Ad;
    packageId!: number;
    playTransition!: string | undefined;
    playDuration!: number;
    orderNumber!: number;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.ad = _data["ad"] ? Ad.fromJS(_data["ad"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdPackage {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["ad"] = this.ad ? this.ad.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdPackage {
    adId: number;
    ad: Ad;
    packageId: number;
    playTransition: string | undefined;
    playDuration: number;
    orderNumber: number;
    tenantId: number;
    organizationUnitId: number | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 广告套餐包绑定信息 */
export class AdPackageBindingDto implements IAdPackageBindingDto {
    adId!: number;
    playTransition!: string | undefined;
    playDuration!: number;
    orderNumber!: number;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;

    constructor(data?: IAdPackageBindingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
        }
    }

    static fromJS(data: any): AdPackageBindingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackageBindingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        return data; 
    }
}

/** 广告套餐包绑定信息 */
export interface IAdPackageBindingDto {
    adId: number;
    playTransition: string | undefined;
    playDuration: number;
    orderNumber: number;
    startPointName: string | undefined;
    stopPointName: string | undefined;
}

/** 广告套餐包详细信息 */
export class AdPackageDto implements IAdPackageDto {
    /** 套餐ID */
    packageId!: number;
    /** 广告ID */
    adId!: number;
    playTransition!: string | undefined;
    playDuration!: number | undefined;
    orderNumber!: number | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;
    ad!: AdPlayInfoDto;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.adId = _data["adId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
            this.ad = _data["ad"] ? AdPlayInfoDto.fromJS(_data["ad"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["adId"] = this.adId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        data["ad"] = this.ad ? this.ad.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 广告套餐包详细信息 */
export interface IAdPackageDto {
    /** 套餐ID */
    packageId: number;
    /** 广告ID */
    adId: number;
    playTransition: string | undefined;
    playDuration: number | undefined;
    orderNumber: number | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
    ad: AdPlayInfoDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdPackageDtoPagedResultDto implements IAdPackageDtoPagedResultDto {
    totalCount!: number;
    items!: AdPackageDto[] | undefined;

    constructor(data?: IAdPackageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdPackageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdPackageDtoPagedResultDto {
    totalCount: number;
    items: AdPackageDto[] | undefined;
}

export class AdPlayInfoDto implements IAdPlayInfoDto {
    id!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    resourceType!: string | undefined;

    constructor(data?: IAdPlayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.resourceType = _data["resourceType"];
        }
    }

    static fromJS(data: any): AdPlayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPlayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["resourceType"] = this.resourceType;
        return data; 
    }
}

export interface IAdPlayInfoDto {
    id: number;
    name: string | undefined;
    fileUrl: string | undefined;
    resourceType: string | undefined;
}

/** 广告资源详细信息对象 */
export class AdResourcesFileDto implements IAdResourcesFileDto {
    /** 广告ID */
    adId!: number;
    /** 广告资源ID */
    resourceItemId!: number;
    /** 资源名称 */
    name!: string | undefined;
    /** 资源的地址途径 */
    fileUrl!: string | undefined;
    /** 资源类型 */
    category!: string | undefined;
    /** 来源 */
    fromType!: string | undefined;
    type!: string | undefined;
    /** 创建时间 */
    created!: moment.Moment | undefined;
    /** 资源用途 */
    usage!: string | undefined;
    description!: string | undefined;
    /** 排序编号 */
    orderNumber!: number;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdResourcesFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.resourceItemId = _data["resourceItemId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdResourcesFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdResourcesFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["resourceItemId"] = this.resourceItemId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 广告资源详细信息对象 */
export interface IAdResourcesFileDto {
    /** 广告ID */
    adId: number;
    /** 广告资源ID */
    resourceItemId: number;
    /** 资源名称 */
    name: string | undefined;
    /** 资源的地址途径 */
    fileUrl: string | undefined;
    /** 资源类型 */
    category: string | undefined;
    /** 来源 */
    fromType: string | undefined;
    type: string | undefined;
    /** 创建时间 */
    created: moment.Moment | undefined;
    /** 资源用途 */
    usage: string | undefined;
    description: string | undefined;
    /** 排序编号 */
    orderNumber: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AdResourcesFileDtoPagedResultDto implements IAdResourcesFileDtoPagedResultDto {
    totalCount!: number;
    items!: AdResourcesFileDto[] | undefined;

    constructor(data?: IAdResourcesFileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdResourcesFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdResourcesFileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdResourcesFileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdResourcesFileDtoPagedResultDto {
    totalCount: number;
    items: AdResourcesFileDto[] | undefined;
}

/** 广告套餐详情返回对象 */
export class AdsPackageDto implements IAdsPackageDto {
    id!: number;
    name!: string | undefined;
    logoUrl!: string | undefined;
    value!: number;
    description!: string | undefined;
    creationTime!: moment.Moment;
    sumPlayDuration!: number;
    adPackages!: AdPackageDto[] | undefined;

    constructor(data?: IAdsPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.sumPlayDuration = _data["sumPlayDuration"];
            if (Array.isArray(_data["adPackages"])) {
                this.adPackages = [] as any;
                for (let item of _data["adPackages"])
                    this.adPackages!.push(AdPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["value"] = this.value;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sumPlayDuration"] = this.sumPlayDuration;
        if (Array.isArray(this.adPackages)) {
            data["adPackages"] = [];
            for (let item of this.adPackages)
                data["adPackages"].push(item.toJSON());
        }
        return data; 
    }
}

/** 广告套餐详情返回对象 */
export interface IAdsPackageDto {
    id: number;
    name: string | undefined;
    logoUrl: string | undefined;
    value: number;
    description: string | undefined;
    creationTime: moment.Moment;
    sumPlayDuration: number;
    adPackages: AdPackageDto[] | undefined;
}

export class AdsProgram implements IAdsProgram {
    programId!: number;
    program!: Program;
    adsId!: number;
    ads!: Ad;
    startedTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    transition!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : <any>undefined;
            this.adsId = _data["adsId"];
            this.ads = _data["ads"] ? Ad.fromJS(_data["ads"]) : <any>undefined;
            this.startedTime = _data["startedTime"] ? moment(_data["startedTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.transition = _data["transition"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsProgram {
        data = typeof data === 'object' ? data : {};
        let result = new AdsProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["adsId"] = this.adsId;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["startedTime"] = this.startedTime ? this.startedTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["transition"] = this.transition;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdsProgram {
    programId: number;
    program: Program;
    adsId: number;
    ads: Ad;
    startedTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    transition: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 广告节目单详细信息对象 */
export class AdsProgramDto implements IAdsProgramDto {
    program!: ProgramDto;
    ads!: AdDto;
    /** 起始播放时间 */
    startedTime!: moment.Moment | undefined;
    /** 结束播放时间 */
    endTime!: moment.Moment | undefined;
    /** 页面切换的动画. */
    transition!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.program = _data["program"] ? ProgramDto.fromJS(_data["program"]) : <any>undefined;
            this.ads = _data["ads"] ? AdDto.fromJS(_data["ads"]) : <any>undefined;
            this.startedTime = _data["startedTime"] ? moment(_data["startedTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.transition = _data["transition"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["startedTime"] = this.startedTime ? this.startedTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["transition"] = this.transition;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 广告节目单详细信息对象 */
export interface IAdsProgramDto {
    program: ProgramDto;
    ads: AdDto;
    /** 起始播放时间 */
    startedTime: moment.Moment | undefined;
    /** 结束播放时间 */
    endTime: moment.Moment | undefined;
    /** 页面切换的动画. */
    transition: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 返回给线下设备的广告详细信息对象 */
export class AdsSdkModel implements IAdsSdkModel {
    id!: number;
    name!: string | undefined;
    type!: string | undefined;
    pixel!: string | undefined;
    size!: number;
    fileUrl!: string | undefined;
    thumbnailUrl!: string | undefined;
    tagIds!: number[] | undefined;
    productAttributes!: string | undefined;
    isFromOthers!: boolean;
    ageScope!: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber!: number;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime!: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan!: string | undefined;
    /** 页面切换的动画。 */
    transition!: string | undefined;
    description!: string | undefined;
    isCustom!: boolean;
    customContent!: string | undefined;
    adResources!: AdResourcesFileDto[] | undefined;

    constructor(data?: IAdsSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.pixel = _data["pixel"];
            this.size = _data["size"];
            this.fileUrl = _data["fileUrl"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.productAttributes = _data["productAttributes"];
            this.isFromOthers = _data["isFromOthers"];
            this.ageScope = _data["ageScope"];
            this.orderNumber = _data["orderNumber"];
            this.gender = _data["gender"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            if (Array.isArray(_data["adResources"])) {
                this.adResources = [] as any;
                for (let item of _data["adResources"])
                    this.adResources!.push(AdResourcesFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdsSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["pixel"] = this.pixel;
        data["size"] = this.size;
        data["fileUrl"] = this.fileUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["productAttributes"] = this.productAttributes;
        data["isFromOthers"] = this.isFromOthers;
        data["ageScope"] = this.ageScope;
        data["orderNumber"] = this.orderNumber;
        data["gender"] = this.gender;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        if (Array.isArray(this.adResources)) {
            data["adResources"] = [];
            for (let item of this.adResources)
                data["adResources"].push(item.toJSON());
        }
        return data; 
    }
}

/** 返回给线下设备的广告详细信息对象 */
export interface IAdsSdkModel {
    id: number;
    name: string | undefined;
    type: string | undefined;
    pixel: string | undefined;
    size: number;
    fileUrl: string | undefined;
    thumbnailUrl: string | undefined;
    tagIds: number[] | undefined;
    productAttributes: string | undefined;
    isFromOthers: boolean;
    ageScope: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber: number;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan: string | undefined;
    /** 页面切换的动画。 */
    transition: string | undefined;
    description: string | undefined;
    isCustom: boolean;
    customContent: string | undefined;
    adResources: AdResourcesFileDto[] | undefined;
}

export class AdsSdkModelPagedResultDto implements IAdsSdkModelPagedResultDto {
    totalCount!: number;
    items!: AdsSdkModel[] | undefined;

    constructor(data?: IAdsSdkModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdsSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsSdkModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsSdkModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdsSdkModelPagedResultDto {
    totalCount: number;
    items: AdsSdkModel[] | undefined;
}

export class AdsTag implements IAdsTag {
    adsId!: number;
    ads!: Ad;
    tagId!: number;
    tag!: Tag;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adsId = _data["adsId"];
            this.ads = _data["ads"] ? Ad.fromJS(_data["ads"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsTag {
        data = typeof data === 'object' ? data : {};
        let result = new AdsTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adsId"] = this.adsId;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdsTag {
    adsId: number;
    ads: Ad;
    tagId: number;
    tag: Tag;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum AdsType {
    Single = 1,
    Multi = 2,
}

export class ApplyFormDto implements IApplyFormDto {
    reason!: string | undefined;
    applyStatus!: string | undefined;
    applyType!: string | undefined;
    wanted!: string | undefined;
    resultMessage!: string | undefined;
    applyUserName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyStatus = _data["applyStatus"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            this.resultMessage = _data["resultMessage"];
            this.applyUserName = _data["applyUserName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyStatus"] = this.applyStatus;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        data["resultMessage"] = this.resultMessage;
        data["applyUserName"] = this.applyUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplyFormDto {
    reason: string | undefined;
    applyStatus: string | undefined;
    applyType: string | undefined;
    wanted: string | undefined;
    resultMessage: string | undefined;
    applyUserName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ApplyFormDtoPagedResultDto implements IApplyFormDtoPagedResultDto {
    totalCount!: number;
    items!: ApplyFormDto[] | undefined;

    constructor(data?: IApplyFormDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplyFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplyFormDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplyFormDtoPagedResultDto {
    totalCount: number;
    items: ApplyFormDto[] | undefined;
}

export enum ApplyFormType {
    Product = 0,
    Ads = 1,
    App = 2,
    Device = 3,
    Sku = 4,
    Coupon = 5,
    Brand = 6,
}

export enum ApplyStatus {
    Applied = 0,
    Cancel = 1,
    Accepted = 2,
    Rejected = 3,
}

export enum ApplyWanted {
    Online = 0,
    Offline = 1,
}

export class AuditApplyFormInput implements IAuditApplyFormInput {
    applyFormId!: number;
    applyStatus!: ApplyStatus;
    resultMessage!: string | undefined;

    constructor(data?: IAuditApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applyFormId = _data["applyFormId"];
            this.applyStatus = _data["applyStatus"];
            this.resultMessage = _data["resultMessage"];
        }
    }

    static fromJS(data: any): AuditApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applyFormId"] = this.applyFormId;
        data["applyStatus"] = this.applyStatus;
        data["resultMessage"] = this.resultMessage;
        return data; 
    }
}

export interface IAuditApplyFormInput {
    applyFormId: number;
    applyStatus: ApplyStatus;
    resultMessage: string | undefined;
}

export enum AuditStatus {
    Offline = 0,
    Online = 1,
}

/** 获取授权应用列表返回的对象 */
export class AuthorizatedSoftwareDto implements IAuthorizatedSoftwareDto {
    /** 授权之后的别名. */
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    /** 额外的一个配置信息. */
    extensionData!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault!: boolean;
    isExpired!: boolean;
    software!: SoftwareDto;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAuthorizatedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
            this.isExpired = _data["isExpired"];
            this.software = _data["software"] ? SoftwareDto.fromJS(_data["software"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuthorizatedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizatedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        data["isExpired"] = this.isExpired;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取授权应用列表返回的对象 */
export interface IAuthorizatedSoftwareDto {
    /** 授权之后的别名. */
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    /** 额外的一个配置信息. */
    extensionData: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault: boolean;
    isExpired: boolean;
    software: SoftwareDto;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AuthorizatedSoftwareDtoPagedResultDto implements IAuthorizatedSoftwareDtoPagedResultDto {
    totalCount!: number;
    items!: AuthorizatedSoftwareDto[] | undefined;

    constructor(data?: IAuthorizatedSoftwareDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuthorizatedSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthorizatedSoftwareDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizatedSoftwareDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthorizatedSoftwareDtoPagedResultDto {
    totalCount: number;
    items: AuthorizatedSoftwareDto[] | undefined;
}

/** 获取已授权应用列表的入参对象 */
export class AuthorizeSoftwareInput implements IAuthorizeSoftwareInput {
    softwareId!: number;
    /** 授权之后的别名. */
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    tenantId!: number;

    constructor(data?: IAuthorizeSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareId = _data["softwareId"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthorizeSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareId"] = this.softwareId;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

/** 获取已授权应用列表的入参对象 */
export interface IAuthorizeSoftwareInput {
    softwareId: number;
    /** 授权之后的别名. */
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    tenantId: number;
}

export class BatchTaskLogDto implements IBatchTaskLogDto {
    name!: string | undefined;
    batchType!: string | undefined;
    completedCount!: number;
    totalCount!: number;
    status!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBatchTaskLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.batchType = _data["batchType"];
            this.completedCount = _data["completedCount"];
            this.totalCount = _data["totalCount"];
            this.status = _data["status"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BatchTaskLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchTaskLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["batchType"] = this.batchType;
        data["completedCount"] = this.completedCount;
        data["totalCount"] = this.totalCount;
        data["status"] = this.status;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBatchTaskLogDto {
    name: string | undefined;
    batchType: string | undefined;
    completedCount: number;
    totalCount: number;
    status: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class BatchTaskLogDtoPagedResultDto implements IBatchTaskLogDtoPagedResultDto {
    totalCount!: number;
    items!: BatchTaskLogDto[] | undefined;

    constructor(data?: IBatchTaskLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatchTaskLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BatchTaskLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchTaskLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBatchTaskLogDtoPagedResultDto {
    totalCount: number;
    items: BatchTaskLogDto[] | undefined;
}

export enum CategoryEnum {
    Common = 0,
    Custom = 1,
}

/** 创建广告时的入参对象 */
export class CreateAdInput implements ICreateAdInput {
    /** 广告名称 */
    name!: string;
    /** 创建者的组织Id */
    organizationUnitId!: number | undefined;
    /** 资源ID */
    resourceItemId!: number | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    /** 广告标签数组 */
    tags!: number[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes!: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber!: number;
    /** 额外信息 */
    extraInfo!: string | undefined;
    /** 扩展信息 */
    extensionData!: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime!: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan!: string | undefined;
    /** 页面切换的动画。 */
    transition!: string | undefined;
    /** 广告描述信息 */
    description!: string | undefined;
    /** 是否自定义广告 */
    isCustom!: boolean;
    /** 自定义广告Json内容 */
    customContent!: string | undefined;
    robotMapName!: string | undefined;
    robotMapPointName!: string | undefined;
    guideWord!: string | undefined;

    constructor(data?: ICreateAdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
        }
    }

    static fromJS(data: any): CreateAdInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        return data; 
    }
}

/** 创建广告时的入参对象 */
export interface ICreateAdInput {
    /** 广告名称 */
    name: string;
    /** 创建者的组织Id */
    organizationUnitId: number | undefined;
    /** 资源ID */
    resourceItemId: number | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    /** 广告标签数组 */
    tags: number[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber: number;
    /** 额外信息 */
    extraInfo: string | undefined;
    /** 扩展信息 */
    extensionData: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan: string | undefined;
    /** 页面切换的动画。 */
    transition: string | undefined;
    /** 广告描述信息 */
    description: string | undefined;
    /** 是否自定义广告 */
    isCustom: boolean;
    /** 自定义广告Json内容 */
    customContent: string | undefined;
    robotMapName: string | undefined;
    robotMapPointName: string | undefined;
    guideWord: string | undefined;
}

export class CreateApplyFormInput implements ICreateApplyFormInput {
    reason!: string | undefined;
    applyType!: ApplyFormType;
    wanted!: ApplyWanted;
    itemids!: number[] | undefined;
    options!: string | undefined;

    constructor(data?: ICreateApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            if (Array.isArray(_data["itemids"])) {
                this.itemids = [] as any;
                for (let item of _data["itemids"])
                    this.itemids!.push(item);
            }
            this.options = _data["options"];
        }
    }

    static fromJS(data: any): CreateApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        if (Array.isArray(this.itemids)) {
            data["itemids"] = [];
            for (let item of this.itemids)
                data["itemids"].push(item);
        }
        data["options"] = this.options;
        return data; 
    }
}

export interface ICreateApplyFormInput {
    reason: string | undefined;
    applyType: ApplyFormType;
    wanted: ApplyWanted;
    itemids: number[] | undefined;
    options: string | undefined;
}

/** 创建节目单的入参对象 */
export class CreateProgramInput implements ICreateProgramInput {
    /** 节目单名称 */
    name!: string | undefined;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 广告节目列表 */
    adsPrograms!: AdsProgramDto[] | undefined;

    constructor(data?: ICreateProgramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        return data; 
    }
}

/** 创建节目单的入参对象 */
export interface ICreateProgramInput {
    /** 节目单名称 */
    name: string | undefined;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 广告节目列表 */
    adsPrograms: AdsProgramDto[] | undefined;
}

/** 创建应用程序时的入参对象 */
export class CreateSoftwareInput implements ICreateSoftwareInput {
    /** 外设的名称 */
    name!: string | undefined;
    /** 外设的小图标 */
    iconUrl!: string | undefined;
    /** 软件开发的负责人. */
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: EnviormentEnum;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber!: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl!: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath!: string | undefined;
    type!: SoftwareType;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    /** JSON配置文件 */
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount!: number | undefined;
    /** 是否支持同步 */
    isSupportAsync!: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName!: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName!: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction!: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName!: string | undefined;

    constructor(data?: ICreateSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
        }
    }

    static fromJS(data: any): CreateSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        return data; 
    }
}

/** 创建应用程序时的入参对象 */
export interface ICreateSoftwareInput {
    /** 外设的名称 */
    name: string | undefined;
    /** 外设的小图标 */
    iconUrl: string | undefined;
    /** 软件开发的负责人. */
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: EnviormentEnum;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath: string | undefined;
    type: SoftwareType;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    /** JSON配置文件 */
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount: number | undefined;
    /** 是否支持同步 */
    isSupportAsync: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName: string | undefined;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class CreateToolBoxInput implements ICreateToolBoxInput {
    type!: string;
    category!: CategoryEnum;
    icon!: string | undefined;
    iconFocus!: string | undefined;
    displayName!: string | undefined;
    displayImage!: string | undefined;
    orderNumber!: number | undefined;
    enabled!: boolean;

    constructor(data?: ICreateToolBoxInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.category = _data["category"];
            this.icon = _data["icon"];
            this.iconFocus = _data["iconFocus"];
            this.displayName = _data["displayName"];
            this.displayImage = _data["displayImage"];
            this.orderNumber = _data["orderNumber"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): CreateToolBoxInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateToolBoxInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["category"] = this.category;
        data["icon"] = this.icon;
        data["iconFocus"] = this.iconFocus;
        data["displayName"] = this.displayName;
        data["displayImage"] = this.displayImage;
        data["orderNumber"] = this.orderNumber;
        data["enabled"] = this.enabled;
        return data; 
    }
}

export interface ICreateToolBoxInput {
    type: string;
    category: CategoryEnum;
    icon: string | undefined;
    iconFocus: string | undefined;
    displayName: string | undefined;
    displayImage: string | undefined;
    orderNumber: number | undefined;
    enabled: boolean;
}

export class CreateUXPageInput implements ICreateUXPageInput {
    name!: string;
    description!: string | undefined;
    from!: FromEnum;
    tagIds!: number[] | undefined;

    constructor(data?: ICreateUXPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.from = _data["from"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUXPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUXPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["from"] = this.from;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateUXPageInput {
    name: string;
    description: string | undefined;
    from: FromEnum;
    tagIds: number[] | undefined;
}

/** 通过设备ID获取设备下的应用程序时的返回对象 */
export class DeviceSoftwareDto implements IDeviceSoftwareDto {
    /** 应用ID */
    id!: number;
    /** 创建时间 */
    creationTime!: moment.Moment | undefined;
    /** 应用名称 */
    name!: string | undefined;
    /** 软件唯一标号，便于部署的名字. */
    code!: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault!: boolean;
    hostingStatus!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData!: string | undefined;
    /** Software Id */
    softwareId!: number;
    /** Software image */
    largeImageUrl!: string | undefined;
    /** 授权之后的别名. */
    alias!: string | undefined;
    dispatchedId!: number;
    envType!: string | undefined;
    endTime!: moment.Moment | undefined;
    type!: string | undefined;
    isExpired!: boolean;

    constructor(data?: IDeviceSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.hostingStatus = _data["hostingStatus"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.extensionData = _data["extensionData"];
            this.softwareId = _data["softwareId"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.alias = _data["alias"];
            this.dispatchedId = _data["dispatchedId"];
            this.envType = _data["envType"];
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): DeviceSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["hostingStatus"] = this.hostingStatus;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["extensionData"] = this.extensionData;
        data["softwareId"] = this.softwareId;
        data["largeImageUrl"] = this.largeImageUrl;
        data["alias"] = this.alias;
        data["dispatchedId"] = this.dispatchedId;
        data["envType"] = this.envType;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["isExpired"] = this.isExpired;
        return data; 
    }
}

/** 通过设备ID获取设备下的应用程序时的返回对象 */
export interface IDeviceSoftwareDto {
    /** 应用ID */
    id: number;
    /** 创建时间 */
    creationTime: moment.Moment | undefined;
    /** 应用名称 */
    name: string | undefined;
    /** 软件唯一标号，便于部署的名字. */
    code: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault: boolean;
    hostingStatus: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData: string | undefined;
    /** Software Id */
    softwareId: number;
    /** Software image */
    largeImageUrl: string | undefined;
    /** 授权之后的别名. */
    alias: string | undefined;
    dispatchedId: number;
    envType: string | undefined;
    endTime: moment.Moment | undefined;
    type: string | undefined;
    isExpired: boolean;
}

export class DeviceSoftwareDtoPagedResultDto implements IDeviceSoftwareDtoPagedResultDto {
    totalCount!: number;
    items!: DeviceSoftwareDto[] | undefined;

    constructor(data?: IDeviceSoftwareDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceSoftwareDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceSoftwareDtoPagedResultDto {
    totalCount: number;
    items: DeviceSoftwareDto[] | undefined;
}

/** 线下设备获取当前设备下的应用程序返回对象 */
export class DeviceSoftwareSdkModel implements IDeviceSoftwareSdkModel {
    id!: number;
    /** 设备ID */
    deviceId!: number;
    tenantAppSetting!: TenantAppSdkSetting;
    software!: SoftwareSdkModel;
    isDefault!: boolean;
    materialPacketUrl!: string | undefined;
    alias!: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData!: string | undefined;

    constructor(data?: IDeviceSoftwareSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.tenantAppSetting = _data["tenantAppSetting"] ? TenantAppSdkSetting.fromJS(_data["tenantAppSetting"]) : <any>undefined;
            this.software = _data["software"] ? SoftwareSdkModel.fromJS(_data["software"]) : <any>undefined;
            this.isDefault = _data["isDefault"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.alias = _data["alias"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): DeviceSoftwareSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["tenantAppSetting"] = this.tenantAppSetting ? this.tenantAppSetting.toJSON() : <any>undefined;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["alias"] = this.alias;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

/** 线下设备获取当前设备下的应用程序返回对象 */
export interface IDeviceSoftwareSdkModel {
    id: number;
    /** 设备ID */
    deviceId: number;
    tenantAppSetting: TenantAppSdkSetting;
    software: SoftwareSdkModel;
    isDefault: boolean;
    materialPacketUrl: string | undefined;
    alias: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData: string | undefined;
}

export class DeviceSoftwareSdkModelPagedResultDto implements IDeviceSoftwareSdkModelPagedResultDto {
    totalCount!: number;
    items!: DeviceSoftwareSdkModel[] | undefined;

    constructor(data?: IDeviceSoftwareSdkModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSoftwareSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceSoftwareSdkModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareSdkModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceSoftwareSdkModelPagedResultDto {
    totalCount: number;
    items: DeviceSoftwareSdkModel[] | undefined;
}

/** 获取已经发布的应用程序列表时返回的对象 */
export class DispatchedSoftwareDto implements IDispatchedSoftwareDto {
    id!: number;
    softwareId!: number;
    /** 授权之后的别名. */
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    tenantName!: string | undefined;
    organizationUnitName!: string | undefined;
    tenantId!: number;

    constructor(data?: IDispatchedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.softwareId = _data["softwareId"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.tenantName = _data["tenantName"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): DispatchedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["softwareId"] = this.softwareId;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["tenantName"] = this.tenantName;
        data["organizationUnitName"] = this.organizationUnitName;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

/** 获取已经发布的应用程序列表时返回的对象 */
export interface IDispatchedSoftwareDto {
    id: number;
    softwareId: number;
    /** 授权之后的别名. */
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    tenantName: string | undefined;
    organizationUnitName: string | undefined;
    tenantId: number;
}

export class DispatchedSoftwareDtoPagedResultDto implements IDispatchedSoftwareDtoPagedResultDto {
    totalCount!: number;
    items!: DispatchedSoftwareDto[] | undefined;

    constructor(data?: IDispatchedSoftwareDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DispatchedSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DispatchedSoftwareDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftwareDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDispatchedSoftwareDtoPagedResultDto {
    totalCount: number;
    items: DispatchedSoftwareDto[] | undefined;
}

export enum EnviormentEnum {
    H5Screen = 0,
    UWP = 1,
    WPF_Win32 = 2,
    Android = 3,
    IOS = 4,
}

export enum FileType {
    None = 0,
    Text = 1,
    Image = 2,
    Video = 3,
    PPT = 4,
    PDF = 5,
    Web = 6,
    Audio = 7,
    Zip = 8,
    View3DS = 9,
    Other = 10,
    Json = 11,
}

export enum FromEnum {
    Creation = 0,
    Clone = 1,
    Import = 2,
}

export enum GameTypeEnum {
    OffLine = 0,
    OnLine = 1,
}

/** 获取广告排程列表信息的返回对象 */
export class GetAdSchedulingDto implements IGetAdSchedulingDto {
    /** 排程ID */
    id!: number;
    /** 创建时间 */
    creationTime!: moment.Moment;
    /** 排程名称 */
    name!: string | undefined;
    description!: string | undefined;
    /** 开始时间 */
    activeTime!: moment.Moment;
    /** 结束时间 */
    endTime!: moment.Moment;
    /** 图标 */
    iconUrl!: string | undefined;
    playType!: PlayType;
    /** 节目单内容 */
    adschedulingContent!: string | undefined;
    /** 生效时间 */
    effectiveTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;

    constructor(data?: IGetAdSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? moment(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.playType = _data["playType"];
            this.adschedulingContent = _data["adschedulingContent"];
            this.effectiveTime = _data["effectiveTime"] ? moment(_data["effectiveTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAdSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["playType"] = this.playType;
        data["adschedulingContent"] = this.adschedulingContent;
        data["effectiveTime"] = this.effectiveTime ? this.effectiveTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** 获取广告排程列表信息的返回对象 */
export interface IGetAdSchedulingDto {
    /** 排程ID */
    id: number;
    /** 创建时间 */
    creationTime: moment.Moment;
    /** 排程名称 */
    name: string | undefined;
    description: string | undefined;
    /** 开始时间 */
    activeTime: moment.Moment;
    /** 结束时间 */
    endTime: moment.Moment;
    /** 图标 */
    iconUrl: string | undefined;
    playType: PlayType;
    /** 节目单内容 */
    adschedulingContent: string | undefined;
    /** 生效时间 */
    effectiveTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
}

export class GetAdSchedulingDtoPagedResultDto implements IGetAdSchedulingDtoPagedResultDto {
    totalCount!: number;
    items!: GetAdSchedulingDto[] | undefined;

    constructor(data?: IGetAdSchedulingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAdSchedulingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAdSchedulingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdSchedulingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAdSchedulingDtoPagedResultDto {
    totalCount: number;
    items: GetAdSchedulingDto[] | undefined;
}

/** 获取设备排程信息的返回对象 */
export class GetDeviceSchedulingDto implements IGetDeviceSchedulingDto {
    id!: number;
    adSchedulingId!: number;
    adSchedulingParentId!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    activeTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    iconUrl!: string | undefined;
    type!: ScheduleType;
    playType!: PlayType;
    isUse!: boolean;

    constructor(data?: IGetDeviceSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adSchedulingId = _data["adSchedulingId"];
            this.adSchedulingParentId = _data["adSchedulingParentId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? moment(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.type = _data["type"];
            this.playType = _data["playType"];
            this.isUse = _data["isUse"];
        }
    }

    static fromJS(data: any): GetDeviceSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adSchedulingId"] = this.adSchedulingId;
        data["adSchedulingParentId"] = this.adSchedulingParentId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["type"] = this.type;
        data["playType"] = this.playType;
        data["isUse"] = this.isUse;
        return data; 
    }
}

/** 获取设备排程信息的返回对象 */
export interface IGetDeviceSchedulingDto {
    id: number;
    adSchedulingId: number;
    adSchedulingParentId: number | undefined;
    name: string | undefined;
    description: string | undefined;
    activeTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    iconUrl: string | undefined;
    type: ScheduleType;
    playType: PlayType;
    isUse: boolean;
}

export class GetDeviceSchedulingDtoPagedResultDto implements IGetDeviceSchedulingDtoPagedResultDto {
    totalCount!: number;
    items!: GetDeviceSchedulingDto[] | undefined;

    constructor(data?: IGetDeviceSchedulingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDeviceSchedulingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceSchedulingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceSchedulingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDeviceSchedulingDtoPagedResultDto {
    totalCount: number;
    items: GetDeviceSchedulingDto[] | undefined;
}

/** 获取广告套餐详细信息的返回对象 */
export class GetPackageDto implements IGetPackageDto {
    id!: number;
    /** 套餐名称 */
    name!: string | undefined;
    /** 套餐图标 */
    logoUrl!: string | undefined;
    value!: number;
    description!: string | undefined;
    creationTime!: moment.Moment;
    sumPlayDuration!: number;
    adsCount!: number;
    isLocationBased!: boolean;
    deviceId!: number | undefined;
    patrolId!: string | undefined;
    patrolName!: string | undefined;

    constructor(data?: IGetPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.sumPlayDuration = _data["sumPlayDuration"];
            this.adsCount = _data["adsCount"];
            this.isLocationBased = _data["isLocationBased"];
            this.deviceId = _data["deviceId"];
            this.patrolId = _data["patrolId"];
            this.patrolName = _data["patrolName"];
        }
    }

    static fromJS(data: any): GetPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["value"] = this.value;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sumPlayDuration"] = this.sumPlayDuration;
        data["adsCount"] = this.adsCount;
        data["isLocationBased"] = this.isLocationBased;
        data["deviceId"] = this.deviceId;
        data["patrolId"] = this.patrolId;
        data["patrolName"] = this.patrolName;
        return data; 
    }
}

/** 获取广告套餐详细信息的返回对象 */
export interface IGetPackageDto {
    id: number;
    /** 套餐名称 */
    name: string | undefined;
    /** 套餐图标 */
    logoUrl: string | undefined;
    value: number;
    description: string | undefined;
    creationTime: moment.Moment;
    sumPlayDuration: number;
    adsCount: number;
    isLocationBased: boolean;
    deviceId: number | undefined;
    patrolId: string | undefined;
    patrolName: string | undefined;
}

export class GetPackageDtoPagedResultDto implements IGetPackageDtoPagedResultDto {
    totalCount!: number;
    items!: GetPackageDto[] | undefined;

    constructor(data?: IGetPackageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPackageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPackageDtoPagedResultDto {
    totalCount: number;
    items: GetPackageDto[] | undefined;
}

/** 获取24小时节目单详情的返回对象 */
export class GetProgramsIn24HoursDto implements IGetProgramsIn24HoursDto {
    /** 节目单ID */
    id!: number;
    /** 节目单名称 */
    name!: string | undefined;
    /** 节目单内容json字符串 */
    content!: string | undefined;
    /** 开始播放时间 */
    startTime!: string | undefined;
    /** 播放结束时间 */
    endTime!: string | undefined;
    /** 广告数组 */
    ads!: string | undefined;
    /** 广告详细信息列表 */
    adList!: AdListDto[] | undefined;
    /** 应用程序信息列表 */
    softwareList!: SoftwareDto[] | undefined;

    constructor(data?: IGetProgramsIn24HoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.ads = _data["ads"];
            if (Array.isArray(_data["adList"])) {
                this.adList = [] as any;
                for (let item of _data["adList"])
                    this.adList!.push(AdListDto.fromJS(item));
            }
            if (Array.isArray(_data["softwareList"])) {
                this.softwareList = [] as any;
                for (let item of _data["softwareList"])
                    this.softwareList!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProgramsIn24HoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProgramsIn24HoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["content"] = this.content;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["ads"] = this.ads;
        if (Array.isArray(this.adList)) {
            data["adList"] = [];
            for (let item of this.adList)
                data["adList"].push(item.toJSON());
        }
        if (Array.isArray(this.softwareList)) {
            data["softwareList"] = [];
            for (let item of this.softwareList)
                data["softwareList"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取24小时节目单详情的返回对象 */
export interface IGetProgramsIn24HoursDto {
    /** 节目单ID */
    id: number;
    /** 节目单名称 */
    name: string | undefined;
    /** 节目单内容json字符串 */
    content: string | undefined;
    /** 开始播放时间 */
    startTime: string | undefined;
    /** 播放结束时间 */
    endTime: string | undefined;
    /** 广告数组 */
    ads: string | undefined;
    /** 广告详细信息列表 */
    adList: AdListDto[] | undefined;
    /** 应用程序信息列表 */
    softwareList: SoftwareDto[] | undefined;
}

export class GetProgramsIn24HoursDtoPagedResultDto implements IGetProgramsIn24HoursDtoPagedResultDto {
    totalCount!: number;
    items!: GetProgramsIn24HoursDto[] | undefined;

    constructor(data?: IGetProgramsIn24HoursDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProgramsIn24HoursDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProgramsIn24HoursDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProgramsIn24HoursDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProgramsIn24HoursDtoPagedResultDto {
    totalCount: number;
    items: GetProgramsIn24HoursDto[] | undefined;
}

/** 获取用用程序列表的入参对象 */
export class GetSoftwareInput implements IGetSoftwareInput {
    softwareType!: SoftwareType;
    /** 是否显示给租户，即应用商店 */
    isShowToTenant!: boolean | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareType = _data["softwareType"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareType"] = this.softwareType;
        data["isShowToTenant"] = this.isShowToTenant;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

/** 获取用用程序列表的入参对象 */
export interface IGetSoftwareInput {
    softwareType: SoftwareType;
    /** 是否显示给租户，即应用商店 */
    isShowToTenant: boolean | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetToolBoxDto implements IGetToolBoxDto {
    type!: string | undefined;
    category!: CategoryEnum;
    icon!: string | undefined;
    iconFocus!: string | undefined;
    displayName!: string | undefined;
    displayImage!: string | undefined;
    orderNumber!: number | undefined;
    enabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGetToolBoxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.category = _data["category"];
            this.icon = _data["icon"];
            this.iconFocus = _data["iconFocus"];
            this.displayName = _data["displayName"];
            this.displayImage = _data["displayImage"];
            this.orderNumber = _data["orderNumber"];
            this.enabled = _data["enabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetToolBoxDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetToolBoxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["category"] = this.category;
        data["icon"] = this.icon;
        data["iconFocus"] = this.iconFocus;
        data["displayName"] = this.displayName;
        data["displayImage"] = this.displayImage;
        data["orderNumber"] = this.orderNumber;
        data["enabled"] = this.enabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetToolBoxDto {
    type: string | undefined;
    category: CategoryEnum;
    icon: string | undefined;
    iconFocus: string | undefined;
    displayName: string | undefined;
    displayImage: string | undefined;
    orderNumber: number | undefined;
    enabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetToolBoxDtoPagedResultDto implements IGetToolBoxDtoPagedResultDto {
    totalCount!: number;
    items!: GetToolBoxDto[] | undefined;

    constructor(data?: IGetToolBoxDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetToolBoxDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetToolBoxDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetToolBoxDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetToolBoxDtoPagedResultDto {
    totalCount: number;
    items: GetToolBoxDto[] | undefined;
}

/** 自定义页面内容的结构 */
export class GetUXPageContentDto implements IGetUXPageContentDto {
    /** 自定义页面的Id */
    id!: number;
    /** 租户的Id */
    tenantId!: number;
    /** 自定义页面的名字 */
    name!: string | undefined;
    /** 自定义页面的描述 */
    description!: string | undefined;
    from!: FromEnum;
    /** 自定义页面的JSON内容 */
    content!: string | undefined;
    /** 页面的Tag信息 */
    tagIds!: TagIds[] | undefined;

    constructor(data?: IGetUXPageContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.from = _data["from"];
            this.content = _data["content"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(TagIds.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUXPageContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUXPageContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["from"] = this.from;
        data["content"] = this.content;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item.toJSON());
        }
        return data; 
    }
}

/** 自定义页面内容的结构 */
export interface IGetUXPageContentDto {
    /** 自定义页面的Id */
    id: number;
    /** 租户的Id */
    tenantId: number;
    /** 自定义页面的名字 */
    name: string | undefined;
    /** 自定义页面的描述 */
    description: string | undefined;
    from: FromEnum;
    /** 自定义页面的JSON内容 */
    content: string | undefined;
    /** 页面的Tag信息 */
    tagIds: TagIds[] | undefined;
}

export class GetUXPageDto implements IGetUXPageDto {
    name!: string | undefined;
    description!: string | undefined;
    from!: FromEnum;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGetUXPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.from = _data["from"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetUXPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUXPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["from"] = this.from;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetUXPageDto {
    name: string | undefined;
    description: string | undefined;
    from: FromEnum;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetUXPageDtoPagedResultDto implements IGetUXPageDtoPagedResultDto {
    totalCount!: number;
    items!: GetUXPageDto[] | undefined;

    constructor(data?: IGetUXPageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUXPageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUXPageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUXPageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUXPageDtoPagedResultDto {
    totalCount: number;
    items: GetUXPageDto[] | undefined;
}

export class IdNamePicDto implements IIdNamePicDto {
    id!: number;
    name!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IIdNamePicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): IdNamePicDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNamePicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IIdNamePicDto {
    id: number;
    name: string | undefined;
    picUrl: string | undefined;
}

export class IdNamePicDtoPagedResultDto implements IIdNamePicDtoPagedResultDto {
    totalCount!: number;
    items!: IdNamePicDto[] | undefined;

    constructor(data?: IIdNamePicDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdNamePicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdNamePicDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNamePicDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIdNamePicDtoPagedResultDto {
    totalCount: number;
    items: IdNamePicDto[] | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class ImportAdResultDto implements IImportAdResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportAdResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportAdResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAdResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportAdResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class Int64IdNameDto implements IInt64IdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IInt64IdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Int64IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt64IdNameDto {
    id: number;
    name: string | undefined;
}

export enum PlayType {
    Sequence = 0,
    TimeLine = 1,
}

export class Program implements IProgram {
    name!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgram[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgram.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProgram {
    name: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgram[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 获取节目单详情的返回对象 */
export class ProgramDto implements IProgramDto {
    name!: string | undefined;
    /** 所属的租户 Id */
    tenantId!: number;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgramDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取节目单详情的返回对象 */
export interface IProgramDto {
    name: string | undefined;
    /** 所属的租户 Id */
    tenantId: number;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgramDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ProgramDtoPagedResultDto implements IProgramDtoPagedResultDto {
    totalCount!: number;
    items!: ProgramDto[] | undefined;

    constructor(data?: IProgramDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProgramDtoPagedResultDto {
    totalCount: number;
    items: ProgramDto[] | undefined;
}

export class ProgramItem implements IProgramItem {
    scheduleStartTime!: string | undefined;
    scheduleEndTime!: string | undefined;
    idleAble!: boolean;
    unstoppable!: boolean;
    packageName!: string | undefined;
    children!: AdOrAppItem[] | undefined;
    type!: number;

    constructor(data?: IProgramItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleStartTime = _data["scheduleStartTime"];
            this.scheduleEndTime = _data["scheduleEndTime"];
            this.idleAble = _data["idleAble"];
            this.unstoppable = _data["unstoppable"];
            this.packageName = _data["packageName"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(AdOrAppItem.fromJS(item));
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProgramItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleStartTime"] = this.scheduleStartTime;
        data["scheduleEndTime"] = this.scheduleEndTime;
        data["idleAble"] = this.idleAble;
        data["unstoppable"] = this.unstoppable;
        data["packageName"] = this.packageName;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IProgramItem {
    scheduleStartTime: string | undefined;
    scheduleEndTime: string | undefined;
    idleAble: boolean;
    unstoppable: boolean;
    packageName: string | undefined;
    children: AdOrAppItem[] | undefined;
    type: number;
}

/** 发布广告排程到设备时的入参对象 */
export class PublishAdScheduliingInput implements IPublishAdScheduliingInput {
    /** 排程ID数组 */
    adSchedulingIds!: number[] | undefined;
    /** 设备ID数组 */
    deviceIds!: number[] | undefined;
    /** add,addonly,delete */
    action!: string | undefined;
    /** 是否通知设备立即更新 */
    informDevice!: boolean;

    constructor(data?: IPublishAdScheduliingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adSchedulingIds"])) {
                this.adSchedulingIds = [] as any;
                for (let item of _data["adSchedulingIds"])
                    this.adSchedulingIds!.push(item);
            }
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.action = _data["action"];
            this.informDevice = _data["informDevice"];
        }
    }

    static fromJS(data: any): PublishAdScheduliingInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishAdScheduliingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adSchedulingIds)) {
            data["adSchedulingIds"] = [];
            for (let item of this.adSchedulingIds)
                data["adSchedulingIds"].push(item);
        }
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["action"] = this.action;
        data["informDevice"] = this.informDevice;
        return data; 
    }
}

/** 发布广告排程到设备时的入参对象 */
export interface IPublishAdScheduliingInput {
    /** 排程ID数组 */
    adSchedulingIds: number[] | undefined;
    /** 设备ID数组 */
    deviceIds: number[] | undefined;
    /** add,addonly,delete */
    action: string | undefined;
    /** 是否通知设备立即更新 */
    informDevice: boolean;
}

/** 将节目单详细内容发布到广告排程的入参对象 */
export class PublishContentToAdScheduling implements IPublishContentToAdScheduling {
    /** 广告节目单详情ID数组 */
    adSchedulingContentIds!: number[] | undefined;
    /** 排程ID */
    adschedulingId!: number;
    /** 发布方式add,update,delete */
    action!: string | undefined;

    constructor(data?: IPublishContentToAdScheduling) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adSchedulingContentIds"])) {
                this.adSchedulingContentIds = [] as any;
                for (let item of _data["adSchedulingContentIds"])
                    this.adSchedulingContentIds!.push(item);
            }
            this.adschedulingId = _data["adschedulingId"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishContentToAdScheduling {
        data = typeof data === 'object' ? data : {};
        let result = new PublishContentToAdScheduling();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adSchedulingContentIds)) {
            data["adSchedulingContentIds"] = [];
            for (let item of this.adSchedulingContentIds)
                data["adSchedulingContentIds"].push(item);
        }
        data["adschedulingId"] = this.adschedulingId;
        data["action"] = this.action;
        return data; 
    }
}

/** 将节目单详细内容发布到广告排程的入参对象 */
export interface IPublishContentToAdScheduling {
    /** 广告节目单详情ID数组 */
    adSchedulingContentIds: number[] | undefined;
    /** 排程ID */
    adschedulingId: number;
    /** 发布方式add,update,delete */
    action: string | undefined;
}

export class PublishEntitiesInput implements IPublishEntitiesInput {
    entityIds!: number[] | undefined;
    ouOrDeviceOrStoreList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;
    isCreateDefaultSchedule!: boolean;
    informDevice!: boolean;
    type!: string | undefined;

    constructor(data?: IPublishEntitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(_data["ouOrDeviceOrStoreList"])) {
                this.ouOrDeviceOrStoreList = [] as any;
                for (let item of _data["ouOrDeviceOrStoreList"])
                    this.ouOrDeviceOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
            this.isCreateDefaultSchedule = _data["isCreateDefaultSchedule"];
            this.informDevice = _data["informDevice"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PublishEntitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishEntitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouOrDeviceOrStoreList)) {
            data["ouOrDeviceOrStoreList"] = [];
            for (let item of this.ouOrDeviceOrStoreList)
                data["ouOrDeviceOrStoreList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        data["isCreateDefaultSchedule"] = this.isCreateDefaultSchedule;
        data["informDevice"] = this.informDevice;
        data["type"] = this.type;
        return data; 
    }
}

export interface IPublishEntitiesInput {
    entityIds: number[] | undefined;
    ouOrDeviceOrStoreList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
    isCreateDefaultSchedule: boolean;
    informDevice: boolean;
    type: string | undefined;
}

/** 积分兑换方式 */
export enum RedeemType {
    None = 0,
    Full = 1,
    Partial = 2,
}

export class ResourceFile implements IResourceFile {
    name!: string;
    fileUrl!: string;
    content!: string | undefined;
    type!: FileType;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    size!: number;
    orderNumber!: number;
    width!: number | undefined;
    height!: number | undefined;
    thumbnailUrl!: string | undefined;
    category!: string | undefined;
    md5!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IResourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.size = _data["size"];
            this.orderNumber = _data["orderNumber"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.category = _data["category"];
            this.md5 = _data["md5"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["content"] = this.content;
        data["type"] = this.type;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["size"] = this.size;
        data["orderNumber"] = this.orderNumber;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["category"] = this.category;
        data["md5"] = this.md5;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IResourceFile {
    name: string;
    fileUrl: string;
    content: string | undefined;
    type: FileType;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    size: number;
    orderNumber: number;
    width: number | undefined;
    height: number | undefined;
    thumbnailUrl: string | undefined;
    category: string | undefined;
    md5: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 排程日历详细信息返回对象 */
export class ScheduleCalendarDto implements IScheduleCalendarDto {
    /** 返回消息 */
    message!: string | undefined;
    /** 节目单列表 */
    scheduleContents!: ScheduleContent[] | undefined;
    /** 广告数据 */
    ads!: AdListDto[] | undefined;
    /** 应用数据 */
    softwares!: SoftwareDto[] | undefined;

    constructor(data?: IScheduleCalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["scheduleContents"])) {
                this.scheduleContents = [] as any;
                for (let item of _data["scheduleContents"])
                    this.scheduleContents!.push(ScheduleContent.fromJS(item));
            }
            if (Array.isArray(_data["ads"])) {
                this.ads = [] as any;
                for (let item of _data["ads"])
                    this.ads!.push(AdListDto.fromJS(item));
            }
            if (Array.isArray(_data["softwares"])) {
                this.softwares = [] as any;
                for (let item of _data["softwares"])
                    this.softwares!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduleCalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleCalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.scheduleContents)) {
            data["scheduleContents"] = [];
            for (let item of this.scheduleContents)
                data["scheduleContents"].push(item.toJSON());
        }
        if (Array.isArray(this.ads)) {
            data["ads"] = [];
            for (let item of this.ads)
                data["ads"].push(item.toJSON());
        }
        if (Array.isArray(this.softwares)) {
            data["softwares"] = [];
            for (let item of this.softwares)
                data["softwares"].push(item.toJSON());
        }
        return data; 
    }
}

/** 排程日历详细信息返回对象 */
export interface IScheduleCalendarDto {
    /** 返回消息 */
    message: string | undefined;
    /** 节目单列表 */
    scheduleContents: ScheduleContent[] | undefined;
    /** 广告数据 */
    ads: AdListDto[] | undefined;
    /** 应用数据 */
    softwares: SoftwareDto[] | undefined;
}

export class ScheduleContent implements IScheduleContent {
    adSchedulingContentId!: number | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    scheduleModel!: ScheduleModel;
    adIds!: ProgramItem[] | undefined;

    constructor(data?: IScheduleContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adSchedulingContentId = _data["adSchedulingContentId"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.scheduleModel = _data["scheduleModel"] ? ScheduleModel.fromJS(_data["scheduleModel"]) : <any>undefined;
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(ProgramItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduleContent {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adSchedulingContentId"] = this.adSchedulingContentId;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["scheduleModel"] = this.scheduleModel ? this.scheduleModel.toJSON() : <any>undefined;
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IScheduleContent {
    adSchedulingContentId: number | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    scheduleModel: ScheduleModel;
    adIds: ProgramItem[] | undefined;
}

export class ScheduleModel implements IScheduleModel {
    id!: number;
    model!: number;
    monthDay!: number[] | undefined;
    weekdayList!: number[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    playModel!: number;
    priority!: number | undefined;

    constructor(data?: IScheduleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.model = _data["model"];
            if (Array.isArray(_data["monthDay"])) {
                this.monthDay = [] as any;
                for (let item of _data["monthDay"])
                    this.monthDay!.push(item);
            }
            if (Array.isArray(_data["weekdayList"])) {
                this.weekdayList = [] as any;
                for (let item of _data["weekdayList"])
                    this.weekdayList!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.playModel = _data["playModel"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ScheduleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["model"] = this.model;
        if (Array.isArray(this.monthDay)) {
            data["monthDay"] = [];
            for (let item of this.monthDay)
                data["monthDay"].push(item);
        }
        if (Array.isArray(this.weekdayList)) {
            data["weekdayList"] = [];
            for (let item of this.weekdayList)
                data["weekdayList"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["playModel"] = this.playModel;
        data["priority"] = this.priority;
        return data; 
    }
}

export interface IScheduleModel {
    id: number;
    model: number;
    monthDay: number[] | undefined;
    weekdayList: number[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    playModel: number;
    priority: number | undefined;
}

export enum ScheduleType {
    Public = 0,
    Copy = 1,
    Default = 2,
}

/** 排程节目单详细内容对象 */
export class SchedulingContent implements ISchedulingContent {
    /** 排程节目单ID */
    id!: number | undefined;
    /** 排程节目单名称 */
    name!: string | undefined;
    /** 排程节目单内容 */
    content!: string | undefined;
    /** 开始时间 */
    startTime!: string | undefined;
    /** 结束时间 */
    endTime!: string | undefined;
    /** 广告 */
    ads!: ProgramItem[] | undefined;
    playType!: PlayType;

    constructor(data?: ISchedulingContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            if (Array.isArray(_data["ads"])) {
                this.ads = [] as any;
                for (let item of _data["ads"])
                    this.ads!.push(ProgramItem.fromJS(item));
            }
            this.playType = _data["playType"];
        }
    }

    static fromJS(data: any): SchedulingContent {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulingContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["content"] = this.content;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        if (Array.isArray(this.ads)) {
            data["ads"] = [];
            for (let item of this.ads)
                data["ads"].push(item.toJSON());
        }
        data["playType"] = this.playType;
        return data; 
    }
}

/** 排程节目单详细内容对象 */
export interface ISchedulingContent {
    /** 排程节目单ID */
    id: number | undefined;
    /** 排程节目单名称 */
    name: string | undefined;
    /** 排程节目单内容 */
    content: string | undefined;
    /** 开始时间 */
    startTime: string | undefined;
    /** 结束时间 */
    endTime: string | undefined;
    /** 广告 */
    ads: ProgramItem[] | undefined;
    playType: PlayType;
}

/** 更新排程节目单详细内容时的入参对象 */
export class SchedulingContentInput implements ISchedulingContentInput {
    /** 排程ID */
    id!: number;
    schedulingContent!: SchedulingContent;

    constructor(data?: ISchedulingContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schedulingContent = _data["schedulingContent"] ? SchedulingContent.fromJS(_data["schedulingContent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchedulingContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulingContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schedulingContent"] = this.schedulingContent ? this.schedulingContent.toJSON() : <any>undefined;
        return data; 
    }
}

/** 更新排程节目单详细内容时的入参对象 */
export interface ISchedulingContentInput {
    /** 排程ID */
    id: number;
    schedulingContent: SchedulingContent;
}

/** 将广告加入套餐包的入参对象 */
export class SetAdsToPackageInput implements ISetAdsToPackageInput {
    adIds!: number[] | undefined;
    packageId!: number;

    constructor(data?: ISetAdsToPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(item);
            }
            this.packageId = _data["packageId"];
        }
    }

    static fromJS(data: any): SetAdsToPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetAdsToPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item);
        }
        data["packageId"] = this.packageId;
        return data; 
    }
}

/** 将广告加入套餐包的入参对象 */
export interface ISetAdsToPackageInput {
    adIds: number[] | undefined;
    packageId: number;
}

/** 设置广告用户 */
export class SetUserAds implements ISetUserAds {
    adIds!: number[] | undefined;
    userId!: number;

    constructor(data?: ISetUserAds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SetUserAds {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserAds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item);
        }
        data["userId"] = this.userId;
        return data; 
    }
}

/** 设置广告用户 */
export interface ISetUserAds {
    adIds: number[] | undefined;
    userId: number;
}

/** 获取应用程序列表时的返回对象 */
export class SoftwareDto implements ISoftwareDto {
    name!: string | undefined;
    /** 软件唯一标号，便于部署的名字. */
    code!: string | undefined;
    /** 软件开发的负责人. */
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: string | undefined;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber!: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl!: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath!: string | undefined;
    type!: string | undefined;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount!: number | undefined;
    /** 是否支持同步 */
    isSupportAsync!: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName!: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName!: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction!: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取应用程序列表时的返回对象 */
export interface ISoftwareDto {
    name: string | undefined;
    /** 软件唯一标号，便于部署的名字. */
    code: string | undefined;
    /** 软件开发的负责人. */
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: string | undefined;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath: string | undefined;
    type: string | undefined;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount: number | undefined;
    /** 是否支持同步 */
    isSupportAsync: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SoftwareDtoPagedResultDto implements ISoftwareDtoPagedResultDto {
    totalCount!: number;
    items!: SoftwareDto[] | undefined;

    constructor(data?: ISoftwareDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SoftwareDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISoftwareDtoPagedResultDto {
    totalCount: number;
    items: SoftwareDto[] | undefined;
}

/** 线下设备获取应用程序信息返回对象 */
export class SoftwareSdkModel implements ISoftwareSdkModel {
    id!: number;
    /** 应用名称 */
    name!: string | undefined;
    /** 应用编号 */
    code!: string | undefined;
    /** 所有者 */
    owner!: string | undefined;
    /** 应用程序图标 */
    logoUrl!: string | undefined;
    /** 大图标 */
    largeImageUrl!: string | undefined;
    /** 版本号 */
    versionNumber!: string | undefined;
    /** 程序包下载地址 */
    packageUrl!: string | undefined;
    /** 程序类型 */
    type!: string | undefined;
    /** 环境类型 */
    envType!: string | undefined;
    description!: string | undefined;
    /** 语言 */
    language!: string | undefined;
    /** 启动程序目录 */
    exePath!: string | undefined;
    extensionData!: string | undefined;
    /** 游戏类型 */
    gameType!: string | undefined;
    setting!: string | undefined;
    url!: string | undefined;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;

    constructor(data?: ISoftwareSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.type = _data["type"];
            this.envType = _data["envType"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.exePath = _data["exePath"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.setting = _data["setting"];
            this.url = _data["url"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
        }
    }

    static fromJS(data: any): SoftwareSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["type"] = this.type;
        data["envType"] = this.envType;
        data["description"] = this.description;
        data["language"] = this.language;
        data["exePath"] = this.exePath;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["setting"] = this.setting;
        data["url"] = this.url;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        return data; 
    }
}

/** 线下设备获取应用程序信息返回对象 */
export interface ISoftwareSdkModel {
    id: number;
    /** 应用名称 */
    name: string | undefined;
    /** 应用编号 */
    code: string | undefined;
    /** 所有者 */
    owner: string | undefined;
    /** 应用程序图标 */
    logoUrl: string | undefined;
    /** 大图标 */
    largeImageUrl: string | undefined;
    /** 版本号 */
    versionNumber: string | undefined;
    /** 程序包下载地址 */
    packageUrl: string | undefined;
    /** 程序类型 */
    type: string | undefined;
    /** 环境类型 */
    envType: string | undefined;
    description: string | undefined;
    /** 语言 */
    language: string | undefined;
    /** 启动程序目录 */
    exePath: string | undefined;
    extensionData: string | undefined;
    /** 游戏类型 */
    gameType: string | undefined;
    setting: string | undefined;
    url: string | undefined;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
}

export enum SoftwareType {
    None = 0,
    GAME = 1,
    Behavior = 2,
    Shopping = 3,
    Customerize = 4,
}

export class Tag implements ITag {
    value!: string;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDtoPagedResultDto implements ITagDtoPagedResultDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: ITagDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export class TagIds implements ITagIds {
    tagId!: number;
    value!: string | undefined;

    constructor(data?: ITagIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TagIds {
        data = typeof data === 'object' ? data : {};
        let result = new TagIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITagIds {
    tagId: number;
    value: string | undefined;
}

export class TagSdkModel implements ITagSdkModel {
    id!: number;
    value!: string | undefined;
    type!: string | undefined;
    isSpecial!: boolean;
    iconUrl!: string | undefined;

    constructor(data?: ITagSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.isSpecial = _data["isSpecial"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): TagSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new TagSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["isSpecial"] = this.isSpecial;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ITagSdkModel {
    id: number;
    value: string | undefined;
    type: string | undefined;
    isSpecial: boolean;
    iconUrl: string | undefined;
}

export class TagSdkModelPagedResultDto implements ITagSdkModelPagedResultDto {
    totalCount!: number;
    items!: TagSdkModel[] | undefined;

    constructor(data?: ITagSdkModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagSdkModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagSdkModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagSdkModelPagedResultDto {
    totalCount: number;
    items: TagSdkModel[] | undefined;
}

export enum TagType {
    Resource = 0,
    Device = 1,
    Product = 2,
    Ads = 3,
    Other = 4,
    Brand = 5,
    Question = 6,
    Counter = 7,
    WechatPublicMessage = 8,
    UxPage = 9,
}

/** 租户下应用程序设置信息对象 */
export class TenantAppSdkSetting implements ITenantAppSdkSetting {
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    extensionData!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault!: boolean;

    constructor(data?: ITenantAppSdkSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): TenantAppSdkSetting {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppSdkSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

/** 租户下应用程序设置信息对象 */
export interface ITenantAppSdkSetting {
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    extensionData: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault: boolean;
}

/** 更新广告时的入参对象 */
export class UpdateAdInput implements IUpdateAdInput {
    /** 广告ID */
    id!: number;
    /** 广告名称 */
    name!: string;
    /** 创建者的组织Id */
    organizationUnitId!: number | undefined;
    /** 资源ID */
    resourceItemId!: number | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    /** 广告标签数组 */
    tags!: number[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes!: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber!: number;
    /** 额外信息 */
    extraInfo!: string | undefined;
    /** 扩展信息 */
    extensionData!: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime!: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan!: string | undefined;
    /** 页面切换的动画。 */
    transition!: string | undefined;
    /** 广告描述信息 */
    description!: string | undefined;
    /** 是否自定义广告 */
    isCustom!: boolean;
    /** 自定义广告Json内容 */
    customContent!: string | undefined;
    robotMapName!: string | undefined;
    robotMapPointName!: string | undefined;
    guideWord!: string | undefined;

    constructor(data?: IUpdateAdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
        }
    }

    static fromJS(data: any): UpdateAdInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        return data; 
    }
}

/** 更新广告时的入参对象 */
export interface IUpdateAdInput {
    /** 广告ID */
    id: number;
    /** 广告名称 */
    name: string;
    /** 创建者的组织Id */
    organizationUnitId: number | undefined;
    /** 资源ID */
    resourceItemId: number | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    /** 广告标签数组 */
    tags: number[] | undefined;
    /** 广告的关联信息
例：P=1289 */
    productAttributes: string | undefined;
    /** 针对年龄段
例：适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** 显示Entity的排序顺序. */
    orderNumber: number;
    /** 额外信息 */
    extraInfo: string | undefined;
    /** 扩展信息 */
    extensionData: string | undefined;
    /** 视频的情况下，指定开始播放的时间
例：比如从 1:08 处开始播放 */
    startTime: moment.Moment | undefined;
    /** 广告的播放时长 */
    timeSpan: string | undefined;
    /** 页面切换的动画。 */
    transition: string | undefined;
    /** 广告描述信息 */
    description: string | undefined;
    /** 是否自定义广告 */
    isCustom: boolean;
    /** 自定义广告Json内容 */
    customContent: string | undefined;
    robotMapName: string | undefined;
    robotMapPointName: string | undefined;
    guideWord: string | undefined;
}

/** 更新广告套餐包的入参对象 */
export class UpdateAdPackageInput implements IUpdateAdPackageInput {
    packageId!: number;
    adId!: number;
    playTransition!: string | undefined;
    playDuration!: number | undefined;
    orderNumber!: number | undefined;

    constructor(data?: IUpdateAdPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.adId = _data["adId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateAdPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["adId"] = this.adId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

/** 更新广告套餐包的入参对象 */
export interface IUpdateAdPackageInput {
    packageId: number;
    adId: number;
    playTransition: string | undefined;
    playDuration: number | undefined;
    orderNumber: number | undefined;
}

/** 更新已授权的应用程序时的入参对象 */
export class UpdateAuthorizeSoftwareInput implements IUpdateAuthorizeSoftwareInput {
    id!: number;
    /** 授权之后的别名. */
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    extensionData!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault!: boolean;

    constructor(data?: IUpdateAuthorizeSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAuthorizeSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorizeSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

/** 更新已授权的应用程序时的入参对象 */
export interface IUpdateAuthorizeSoftwareInput {
    id: number;
    /** 授权之后的别名. */
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    extensionData: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** 是否是默认启动的程序. */
    isDefault: boolean;
}

/** 更新设备下的应用程序时的入参对象 */
export class UpdateDeviceSoftwareInput implements IUpdateDeviceSoftwareInput {
    softwareId!: number;
    deviceId!: number;
    /** 是否是默认启动的程序. */
    isDefault!: boolean;
    hostingStatus!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData!: string | undefined;
    /** 授权之后的别名. */
    alias!: string | undefined;

    constructor(data?: IUpdateDeviceSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareId = _data["softwareId"];
            this.deviceId = _data["deviceId"];
            this.isDefault = _data["isDefault"];
            this.hostingStatus = _data["hostingStatus"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.extensionData = _data["extensionData"];
            this.alias = _data["alias"];
        }
    }

    static fromJS(data: any): UpdateDeviceSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareId"] = this.softwareId;
        data["deviceId"] = this.deviceId;
        data["isDefault"] = this.isDefault;
        data["hostingStatus"] = this.hostingStatus;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["extensionData"] = this.extensionData;
        data["alias"] = this.alias;
        return data; 
    }
}

/** 更新设备下的应用程序时的入参对象 */
export interface IUpdateDeviceSoftwareInput {
    softwareId: number;
    deviceId: number;
    /** 是否是默认启动的程序. */
    isDefault: boolean;
    hostingStatus: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** json format for customize setting. It's hard to design.`_` */
    extensionData: string | undefined;
    /** 授权之后的别名. */
    alias: string | undefined;
}

/** 更新节目单时的入参对象 */
export class UpdateProgramInput implements IUpdateProgramInput {
    id!: number;
    /** 节目单名称 */
    name!: string | undefined;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 广告节目列表 */
    adsPrograms!: AdsProgramDto[] | undefined;

    constructor(data?: IUpdateProgramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProgramInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        return data; 
    }
}

/** 更新节目单时的入参对象 */
export interface IUpdateProgramInput {
    id: number;
    /** 节目单名称 */
    name: string | undefined;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 广告节目列表 */
    adsPrograms: AdsProgramDto[] | undefined;
}

/** 更新应用程序时的入参对象 */
export class UpdateSoftwareInput implements IUpdateSoftwareInput {
    id!: number;
    /** 外设的名称 */
    name!: string | undefined;
    /** 外设的小图标 */
    iconUrl!: string | undefined;
    /** 软件开发的负责人. */
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: EnviormentEnum;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber!: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl!: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath!: string | undefined;
    type!: SoftwareType;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    /** JSON配置文件 */
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount!: number | undefined;
    /** 是否支持同步 */
    isSupportAsync!: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName!: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame!: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName!: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction!: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName!: string | undefined;

    constructor(data?: IUpdateSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
        }
    }

    static fromJS(data: any): UpdateSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        return data; 
    }
}

/** 更新应用程序时的入参对象 */
export interface IUpdateSoftwareInput {
    id: number;
    /** 外设的名称 */
    name: string | undefined;
    /** 外设的小图标 */
    iconUrl: string | undefined;
    /** 软件开发的负责人. */
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    /** 在线游戏链接地址
OnLine时使用该地址,Offline的h5也使用该地址. */
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: EnviormentEnum;
    /** 版本号,格式为 1.0.0.5 */
    versionNumber: string | undefined;
    /** 软件更新的Patch地址,用户客户端下载. /software/v1.0.0.zip */
    packageUrl: string | undefined;
    /** 如果为绿色软件的时候,需要知道启动程序的路径。 */
    exePath: string | undefined;
    type: SoftwareType;
    /** 最佳分辨率, 1920*1080. */
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    /** JSON配置文件 */
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    /** 游戏支持的同时玩游戏人数 */
    supportedPlayersCount: number | undefined;
    /** 是否支持同步 */
    isSupportAsync: boolean;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendWechatBeforeGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatBeforGameTabName: string | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendWechatAfterGame: boolean;
    /** 表示这个消息什么场景会发，比如游戏前，或者扫码时 */
    sendWeChatAfterGameTabName: string | undefined;
    /** 游戏是否支持分享 */
    isShareAction: boolean;
    /** 表示分享tab的名称 */
    shareActionTabName: string | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class UserAd implements IUserAd {
    adId!: number;
    userId!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.userId = _data["userId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserAd {
        data = typeof data === 'object' ? data : {};
        let result = new UserAd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["userId"] = this.userId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserAd {
    adId: number;
    userId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}