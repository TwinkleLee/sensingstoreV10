/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_ONLINE_URL = new InjectionToken<string>('API_ONLINE_URL');

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    orderStatus(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderStatus(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderStatus(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    orderMemberDiscounts(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderMemberDiscounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderMemberDiscounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderMemberDiscounts(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderMemberDiscounts(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    orderActivityTags(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderActivityTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderActivityTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderActivityTags(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderActivityTags(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrderCategorys(): Observable<OrderCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetOrderCategorys";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderCategorys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderCategorys(<any>response_);
                } catch (e) {
                    return <Observable<OrderCategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderCategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderCategorys(response: HttpResponseBase): Observable<OrderCategoryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderCategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderCategoryDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    memberType(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/MemberType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberType(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processMemberType(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    orderFrom(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderFrom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderFrom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderFrom(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderFrom(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class DataTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sourceTenantId (optional) 
     * @param targetTenantId (optional) 
     * @return Success
     */
    transferMemberAndOrderInfo(sourceTenantId: number | null | undefined, targetTenantId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataTransfer/TransferMemberAndOrderInfo?";
        if (sourceTenantId !== undefined)
            url_ += "sourceTenantId=" + encodeURIComponent("" + sourceTenantId) + "&"; 
        if (targetTenantId !== undefined)
            url_ += "targetTenantId=" + encodeURIComponent("" + targetTenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransferMemberAndOrderInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferMemberAndOrderInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferMemberAndOrderInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GcodeConvertServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param canvasWidth (optional) 
     * @param canvasHeight (optional) 
     * @param strokes (optional) 
     * @param drawOutline (optional) 
     * @param maxWidth (optional) 
     * @param maxHeight (optional) 
     * @param offsetX (optional) 
     * @param offsetY (optional) 
     * @param borderSpeed (optional) 
     * @param signatureImage (optional) 
     * @param strokeFile (optional) 
     * @return Success
     */
    convertStrokeToGcode(canvasWidth: number | null | undefined, canvasHeight: number | null | undefined, strokes: any[][] | null | undefined, drawOutline: boolean | null | undefined, maxWidth: number | null | undefined, maxHeight: number | null | undefined, offsetX: number | null | undefined, offsetY: number | null | undefined, borderSpeed: number | null | undefined, signatureImage: FileParameter | null | undefined, strokeFile: FileParameter | null | undefined): Observable<TinyFileOutput> {
        let url_ = this.baseUrl + "/api/GcodeConvert/ConvertStrokeToGcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (canvasWidth !== null && canvasWidth !== undefined)
            content_.append("CanvasWidth", canvasWidth.toString());
        if (canvasHeight !== null && canvasHeight !== undefined)
            content_.append("CanvasHeight", canvasHeight.toString());
        if (strokes !== null && strokes !== undefined)
            content_.append("Strokes", strokes.toString());
        if (drawOutline !== null && drawOutline !== undefined)
            content_.append("DrawOutline", drawOutline.toString());
        if (maxWidth !== null && maxWidth !== undefined)
            content_.append("MaxWidth", maxWidth.toString());
        if (maxHeight !== null && maxHeight !== undefined)
            content_.append("MaxHeight", maxHeight.toString());
        if (offsetX !== null && offsetX !== undefined)
            content_.append("OffsetX", offsetX.toString());
        if (offsetY !== null && offsetY !== undefined)
            content_.append("OffsetY", offsetY.toString());
        if (borderSpeed !== null && borderSpeed !== undefined)
            content_.append("BorderSpeed", borderSpeed.toString());
        if (signatureImage !== null && signatureImage !== undefined)
            content_.append("SignatureImage", signatureImage.data, signatureImage.fileName ? signatureImage.fileName : "SignatureImage");
        if (strokeFile !== null && strokeFile !== undefined)
            content_.append("StrokeFile", strokeFile.data, strokeFile.fileName ? strokeFile.fileName : "StrokeFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertStrokeToGcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertStrokeToGcode(<any>response_);
                } catch (e) {
                    return <Observable<TinyFileOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinyFileOutput>><any>_observableThrow(response_);
        }));
    }

    protected processConvertStrokeToGcode(response: HttpResponseBase): Observable<TinyFileOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinyFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinyFileOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    convertTextToGcode(input: PostSignatureTextDataInput | null | undefined): Observable<TinyFileOutput> {
        let url_ = this.baseUrl + "/api/GcodeConvert/ConvertTextToGcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertTextToGcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertTextToGcode(<any>response_);
                } catch (e) {
                    return <Observable<TinyFileOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinyFileOutput>><any>_observableThrow(response_);
        }));
    }

    protected processConvertTextToGcode(response: HttpResponseBase): Observable<TinyFileOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinyFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinyFileOutput>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param registerdTimeStart (optional) 
     * @param registerdTimeEnd (optional) 
     * @param type (optional) 
     * @param storeIds (optional) 
     * @param customerIds (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMembers(name: string | null | undefined, registerdTimeStart: moment.Moment | null | undefined, registerdTimeEnd: moment.Moment | null | undefined, type: string | null | undefined, storeIds: number[] | null | undefined, customerIds: number[] | null | undefined, sorting: string | null | undefined, filter: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMembers?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (registerdTimeStart !== undefined)
            url_ += "RegisterdTimeStart=" + encodeURIComponent(registerdTimeStart ? "" + registerdTimeStart.toJSON() : "") + "&"; 
        if (registerdTimeEnd !== undefined)
            url_ += "RegisterdTimeEnd=" + encodeURIComponent(registerdTimeEnd ? "" + registerdTimeEnd.toJSON() : "") + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (customerIds !== undefined)
            customerIds && customerIds.forEach(item => { url_ += "CustomerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMembers(response: HttpResponseBase): Observable<PagedResultDtoOfMemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param registerdTimeStart (optional) 
     * @param registerdTimeEnd (optional) 
     * @param type (optional) 
     * @param storeIds (optional) 
     * @param customerIds (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberListToExcel(name: string | null | undefined, registerdTimeStart: moment.Moment | null | undefined, registerdTimeEnd: moment.Moment | null | undefined, type: string | null | undefined, storeIds: number[] | null | undefined, customerIds: number[] | null | undefined, sorting: string | null | undefined, filter: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberListToExcel?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (registerdTimeStart !== undefined)
            url_ += "RegisterdTimeStart=" + encodeURIComponent(registerdTimeStart ? "" + registerdTimeStart.toJSON() : "") + "&"; 
        if (registerdTimeEnd !== undefined)
            url_ += "RegisterdTimeEnd=" + encodeURIComponent(registerdTimeEnd ? "" + registerdTimeEnd.toJSON() : "") + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (customerIds !== undefined)
            customerIds && customerIds.forEach(item => { url_ += "CustomerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMemberById(input: number | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createMember(input: CreateMemberInput | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/CreateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateMember(input: UpdateMemberInput | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/UpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateMemberInfo(input: UpdateMemberInput | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/UpdateMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMemberInfo(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMember(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMember?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMembers(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMembers?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberLevels(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMemberLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberLevels?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMemberLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMemberLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberLevels(response: HttpResponseBase): Observable<PagedResultDtoOfGetMemberLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMemberLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMemberLevelDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateMemberLevel(input: AddOrUpdateMemberLevelInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddOrUpdateMemberLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMemberLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMemberLevel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMemberLevel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMemberLevels(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMemberLevels?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberLevels(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    addMemberTags(memberId: number | null | undefined, tagIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddMemberTags?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMemberTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMemberTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMemberTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateCustomer(input: AddOrUpdateCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddOrUpdateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCustomers(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetCustomers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addSalesToCustomer(input: AddSalesToCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddSalesToCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSalesToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSalesToCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSalesToCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCustomers(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteCustomers?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addMembersToCustomer(input: AddMemberToCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddMembersToCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMembersToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMembersToCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMembersToCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    mergeMembers(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/MergeMembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    addCustomerTags(customerId: number | null | undefined, tagIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddCustomerTags?";
        if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCustomerTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCustomerTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCustomerTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    deleteCustomerTags(customerId: number | null | undefined, tagIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteCustomerTags?";
        if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomerTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomerTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomerTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    deleteMemberTags(memberId: number | null | undefined, tagIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMemberTags?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopMembers(id: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfMemberOuterDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetWeishopMembers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopMembers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberOuterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberOuterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopMembers(response: HttpResponseBase): Observable<PagedResultDtoOfMemberOuterDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMemberOuterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberOuterDto>(<any>null);
    }
}

@Injectable()
export class MemberPointOperatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addPointLogByMemberId(input: AddPointLogByMemberIdInput | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/MemberPointOperator/AddPointLogByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPointLogByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPointLogByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddPointLogByMemberId(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrders(memberId: number | null | undefined, memberName: string | null | undefined, regPhone: string | null | undefined, orderNO: string | null | undefined, orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, from: string | null | undefined, orderDateTimeStartString: string | null | undefined, orderDateTimeEndString: string | null | undefined, status: string | null | undefined, storeIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedTotalResultDtoOfOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrders?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&"; 
        if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&"; 
        if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&"; 
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&"; 
        if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedTotalResultDtoOfOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedTotalResultDtoOfOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<PagedTotalResultDtoOfOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedTotalResultDtoOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedTotalResultDtoOfOrderDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrderListToExcelBackup(memberId: number | null | undefined, memberName: string | null | undefined, regPhone: string | null | undefined, orderNO: string | null | undefined, orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, from: string | null | undefined, orderDateTimeStartString: string | null | undefined, orderDateTimeEndString: string | null | undefined, status: string | null | undefined, storeIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrderListToExcelBackup?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&"; 
        if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&"; 
        if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&"; 
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&"; 
        if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderListToExcelBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderListToExcelBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderListToExcelBackup(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrderListToExcel(memberId: number | null | undefined, memberName: string | null | undefined, regPhone: string | null | undefined, orderNO: string | null | undefined, orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, from: string | null | undefined, orderDateTimeStartString: string | null | undefined, orderDateTimeEndString: string | null | undefined, status: string | null | undefined, storeIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrderListToExcel?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&"; 
        if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&"; 
        if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&"; 
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&"; 
        if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrdersByMemberId(memberId: number | null | undefined, memberName: string | null | undefined, regPhone: string | null | undefined, orderNO: string | null | undefined, orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, from: string | null | undefined, orderDateTimeStartString: string | null | undefined, orderDateTimeEndString: string | null | undefined, status: string | null | undefined, storeIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<OrderWithTotalSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrdersByMemberId?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&"; 
        if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&"; 
        if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&"; 
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&"; 
        if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<OrderWithTotalSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderWithTotalSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrdersByMemberId(response: HttpResponseBase): Observable<OrderWithTotalSaleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderWithTotalSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderWithTotalSaleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getItemSalesBySkuIds(input: GetItemSalesBySkuIdInput | null | undefined): Observable<GetItemSalesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetItemSalesBySkuIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemSalesBySkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemSalesBySkuIds(<any>response_);
                } catch (e) {
                    return <Observable<GetItemSalesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetItemSalesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetItemSalesBySkuIds(response: HttpResponseBase): Observable<GetItemSalesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetItemSalesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetItemSalesDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    orderSkuByMemberId(input: OrderSkuInput | null | undefined): Observable<PagedResultDtoOfOrderSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/OrderSkuByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSkuByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSkuByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSkuByMemberId(response: HttpResponseBase): Observable<PagedResultDtoOfOrderSkuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrderSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrderSkuDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrder(input: CreateOrderInput | null | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/CreateOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrder(input: UpdateOrderInput | null | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/UpdateOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrder(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrderItem(input: UpdateOrderItemInput | null | undefined): Observable<OrderItemDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/UpdateOrderItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderItem(<any>response_);
                } catch (e) {
                    return <Observable<OrderItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrderItem(response: HttpResponseBase): Observable<OrderItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderItemDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrder(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/DeleteOrder?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    batchDeleteOrders(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/BatchDeleteOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteOrders(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteOrderItems(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/DeleteOrderItems?";
        if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrderItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrderItems(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrderItems(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    healthCheck(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Order/HealthCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealthCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealthCheck(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processHealthCheck(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    salesReport(input: SaleReportInput | null | undefined): Observable<PagedResultDtoOfSalesCurrentDayReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/SalesReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSalesCurrentDayReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSalesCurrentDayReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processSalesReport(response: HttpResponseBase): Observable<PagedResultDtoOfSalesCurrentDayReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSalesCurrentDayReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSalesCurrentDayReportDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    salesItemDetailReport(input: GetSaleItemDetailInput | null | undefined): Observable<PagedResultDtoOfSalesItemDetailReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/SalesItemDetailReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesItemDetailReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesItemDetailReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSalesItemDetailReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSalesItemDetailReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processSalesItemDetailReport(response: HttpResponseBase): Observable<PagedResultDtoOfSalesItemDetailReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSalesItemDetailReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSalesItemDetailReportDto>(<any>null);
    }
}

@Injectable()
export class OrderExtensionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getPrintOrderCount(tenantId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrderCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrderCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrderCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrderCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    confirmPrintOrder(tenantId: number | null | undefined, orderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/ConfirmPrintOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPrintOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPrintOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPrintOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param skuId (optional) 
     * @return Success
     */
    getPrintOrder(tenantId: number | null | undefined, memberId: number | null | undefined, skuId: number | null | undefined): Observable<PrintOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrder?";
        if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrder(<any>response_);
                } catch (e) {
                    return <Observable<PrintOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrder(response: HttpResponseBase): Observable<PrintOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintOrderDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateOrderExtension(tenantId: number | null | undefined, memberId: number | null | undefined, input: AddOrUpdateOrderExtensionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/AddOrUpdateOrderExtension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateOrderExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateOrderExtension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateOrderExtension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getPrintOrderCountForReport(subKey: string | null | undefined): Observable<PrintOrderCountDto> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrderCountForReport?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrderCountForReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrderCountForReport(<any>response_);
                } catch (e) {
                    return <Observable<PrintOrderCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintOrderCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrderCountForReport(response: HttpResponseBase): Observable<PrintOrderCountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintOrderCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintOrderCountDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getNextOrderGcodeFile(tenantId: number | null | undefined, type: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetNextOrderGcodeFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "type": type !== undefined && type !== null ? "" + type : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextOrderGcodeFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextOrderGcodeFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextOrderGcodeFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearGcodeFileSessions(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/ClearGcodeFileSessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearGcodeFileSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearGcodeFileSessions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearGcodeFileSessions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}


@Injectable()
export class PayCenterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param payTimeStart (optional) 
     * @param payTimeEnd (optional) 
     * @param orderFrom (optional) 
     * @param payFrom (optional) 
     * @param payType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPayRecords(payTimeStart: moment.Moment | null | undefined, payTimeEnd: moment.Moment | null | undefined, orderFrom: string | null | undefined, payFrom: string | null | undefined, payType: PayType | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPayRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/GetPayRecords?";
        if (payTimeStart !== undefined)
            url_ += "PayTimeStart=" + encodeURIComponent(payTimeStart ? "" + payTimeStart.toJSON() : "") + "&"; 
        if (payTimeEnd !== undefined)
            url_ += "PayTimeEnd=" + encodeURIComponent(payTimeEnd ? "" + payTimeEnd.toJSON() : "") + "&"; 
        if (orderFrom !== undefined)
            url_ += "OrderFrom=" + encodeURIComponent("" + orderFrom) + "&"; 
        if (payFrom !== undefined)
            url_ += "PayFrom=" + encodeURIComponent("" + payFrom) + "&"; 
        if (payType !== undefined)
            url_ += "PayType=" + encodeURIComponent("" + payType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPayRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPayRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayRecords(response: HttpResponseBase): Observable<PagedResultDtoOfGetPayRecordDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPayRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPayRecordDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdatePayAccount(input: AddOrUpdatePayAccountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/AddOrUpdatePayAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdatePayAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdatePayAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdatePayAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPayAccounts(from: string | null | undefined, auditStatus: boolean | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPayAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/GetPayAccounts?";
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayAccounts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPayAccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPayAccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayAccounts(response: HttpResponseBase): Observable<PagedResultDtoOfGetPayAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPayAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPayAccountDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePayAccount(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/DeletePayAccount?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePayAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePayAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePayAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReleaseApiTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    releaseApiTest(): Observable<NameValueTimeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReleaseApiTest/ReleaseApiTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseApiTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseApiTest(<any>response_);
                } catch (e) {
                    return <Observable<NameValueTimeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueTimeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseApiTest(response: HttpResponseBase): Observable<NameValueTimeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueTimeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueTimeDto[]>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getTotalOrderAndSale(subKey: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, chartType: string | null | undefined): Observable<TotalOrderAndSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetTotalOrderAndSale?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalOrderAndSale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalOrderAndSale(<any>response_);
                } catch (e) {
                    return <Observable<TotalOrderAndSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TotalOrderAndSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotalOrderAndSale(response: HttpResponseBase): Observable<TotalOrderAndSaleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TotalOrderAndSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TotalOrderAndSaleDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getRetailingReport(subKey: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, chartType: string | null | undefined): Observable<RetailingReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetRetailingReport?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailingReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailingReport(<any>response_);
                } catch (e) {
                    return <Observable<RetailingReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailingReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailingReport(response: HttpResponseBase): Observable<RetailingReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailingReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailingReportDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    membersCount(input: MembersCountInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/MembersCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMembersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMembersCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processMembersCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    refundCount(input: ReportInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/RefundCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRefundCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    topSkus(input: TopSkusInput | null | undefined): Observable<SkuSaleListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/TopSkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopSkus(<any>response_);
                } catch (e) {
                    return <Observable<SkuSaleListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSaleListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTopSkus(response: HttpResponseBase): Observable<SkuSaleListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkuSaleListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSaleListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    skuTotalSales(input: SkuTotalSalesInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuTotalSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuTotalSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuTotalSales(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSkuTotalSales(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    orderCountAndSales(input: OrderCountAndSalesInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/OrderCountAndSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderCountAndSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderCountAndSales(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processOrderCountAndSales(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    buyerCount(input: BuyerCountInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/BuyerCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyerCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyerCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processBuyerCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    skuFromBuyer(input: SkuFromBuyerInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuFromBuyer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuFromBuyer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuFromBuyer(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSkuFromBuyer(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    orderInformation(input: OrderInformationInput | null | undefined): Observable<PagedResultDtoOfOrderInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/OrderInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderInformation(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderInformationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderInformationDto>><any>_observableThrow(response_);
        }));
    }

    protected processOrderInformation(response: HttpResponseBase): Observable<PagedResultDtoOfOrderInformationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrderInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrderInformationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    skuSaleList(input: SkuSaleListInput | null | undefined): Observable<PagedTotalResultDtoOfSkuSaleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuSaleList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuSaleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuSaleList(<any>response_);
                } catch (e) {
                    return <Observable<PagedTotalResultDtoOfSkuSaleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedTotalResultDtoOfSkuSaleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processSkuSaleList(response: HttpResponseBase): Observable<PagedTotalResultDtoOfSkuSaleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedTotalResultDtoOfSkuSaleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedTotalResultDtoOfSkuSaleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dailySaleList(input: SkuSaleListInput | null | undefined): Observable<PagedTotalResultDtoOfOrderItem> {
        let url_ = this.baseUrl + "/api/services/app/Report/DailySaleList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDailySaleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDailySaleList(<any>response_);
                } catch (e) {
                    return <Observable<PagedTotalResultDtoOfOrderItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedTotalResultDtoOfOrderItem>><any>_observableThrow(response_);
        }));
    }

    protected processDailySaleList(response: HttpResponseBase): Observable<PagedTotalResultDtoOfOrderItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedTotalResultDtoOfOrderItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedTotalResultDtoOfOrderItem>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    skuDaySale(input: SkuDaySaleInput | null | undefined): Observable<PagedResultDtoOfSkuDaySaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuDaySale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuDaySale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuDaySale(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuDaySaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuDaySaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processSkuDaySale(response: HttpResponseBase): Observable<PagedResultDtoOfSkuDaySaleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuDaySaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuDaySaleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    memberCostList(input: MemberCostInput | null | undefined): Observable<PagedResultDtoOfMemberCostListDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/MemberCostList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberCostList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberCostList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberCostListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberCostListDto>><any>_observableThrow(response_);
        }));
    }

    protected processMemberCostList(response: HttpResponseBase): Observable<PagedResultDtoOfMemberCostListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMemberCostListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberCostListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    memberDaySkus(input: MemberDaySkusInput | null | undefined): Observable<PagedResultDtoOfMemberDaySkusDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/MemberDaySkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberDaySkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberDaySkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberDaySkusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberDaySkusDto>><any>_observableThrow(response_);
        }));
    }

    protected processMemberDaySkus(response: HttpResponseBase): Observable<PagedResultDtoOfMemberDaySkusDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMemberDaySkusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberDaySkusDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param skuName (optional) 
     * @param skuId (optional) 
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuSaleListToExcel(filter: string | null | undefined, skuName: string | null | undefined, skuId: string | null | undefined, storeIds: number[] | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSkuSaleListToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (skuName !== undefined)
            url_ += "SkuName=" + encodeURIComponent("" + skuName) + "&"; 
        if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&"; 
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuSaleListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuSaleListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuSaleListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesDayReport(storeIds: number[] | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesDayReport?";
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesDayReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesDayReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesDayReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesMonthReport(storeIds: number[] | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesMonthReport?";
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesMonthReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesMonthReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesMonthReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesCurrentDayReport(storeIds: number[] | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesCurrentDayReport?";
        if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesCurrentDayReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesCurrentDayReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesCurrentDayReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saleDetailToExcel(input: GetSaleItemDetailInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SaleDetailToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleDetailToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleDetailToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaleDetailToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saleDetailToExcelAsUrl(input: GetSaleItemDetailInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SaleDetailToExcelAsUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleDetailToExcelAsUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleDetailToExcelAsUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaleDetailToExcelAsUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param memberId (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderStartDateTime (optional) 
     * @param orderEndDateTime (optional) 
     * @param from (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrders(subKey: string | null | undefined, memberId: number | null | undefined, regPhone: string | null | undefined, orderNO: string | null | undefined, orderStartDateTime: moment.Moment | null | undefined, orderEndDateTime: moment.Moment | null | undefined, from: string | null | undefined, status: string | null | undefined, sorting: string | null | undefined, filter: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/GetOrders?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&"; 
        if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&"; 
        if (orderStartDateTime !== undefined)
            url_ += "OrderStartDateTime=" + encodeURIComponent(orderStartDateTime ? "" + orderStartDateTime.toJSON() : "") + "&"; 
        if (orderEndDateTime !== undefined)
            url_ += "OrderEndDateTime=" + encodeURIComponent(orderEndDateTime ? "" + orderEndDateTime.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<PagedResultDtoOfOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrderDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param orderId (optional) 
     * @param memberId (optional) 
     * @param orderStartDateTime (optional) 
     * @param orderEndDateTime (optional) 
     * @param printStateDescription (optional) 
     * @param from (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExtensionOrders(subKey: string | null | undefined, orderId: number | null | undefined, memberId: number | null | undefined, orderStartDateTime: moment.Moment | null | undefined, orderEndDateTime: moment.Moment | null | undefined, printStateDescription: string | null | undefined, from: string | null | undefined, sorting: string | null | undefined, filter: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfExtensionOrdersDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/GetExtensionOrders?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (orderStartDateTime !== undefined)
            url_ += "OrderStartDateTime=" + encodeURIComponent(orderStartDateTime ? "" + orderStartDateTime.toJSON() : "") + "&"; 
        if (orderEndDateTime !== undefined)
            url_ += "OrderEndDateTime=" + encodeURIComponent(orderEndDateTime ? "" + orderEndDateTime.toJSON() : "") + "&"; 
        if (printStateDescription !== undefined)
            url_ += "PrintStateDescription=" + encodeURIComponent("" + printStateDescription) + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExtensionOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExtensionOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExtensionOrdersDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExtensionOrdersDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExtensionOrders(response: HttpResponseBase): Observable<PagedResultDtoOfExtensionOrdersDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExtensionOrdersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExtensionOrdersDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param fileBase (optional) 
     * @return Success
     */
    saveUploadFile(subKey: string | null | undefined, fileBase: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/SaveUploadFile?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fileBase !== null && fileBase !== undefined)
            content_.append("fileBase", fileBase.data, fileBase.fileName ? fileBase.fileName : "fileBase");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUploadFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateExtensionOrder(input: AddOrUpdateExtensionOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/AddOrUpdateExtensionOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateExtensionOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateExtensionOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateExtensionOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrderMakingInfo(input: UpdateOrderMakingInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/UpdateOrderMakingInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderMakingInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderMakingInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrderMakingInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingShopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateMember(input: MemberInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateShippingAddress(tenantId: number | null | undefined, memberId: number | null | undefined, input: AddOrUpdateAddressInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateShippingAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateShippingAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateShippingAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateShippingAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberShippingAddresses(tenantId: number | null | undefined, memberId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetShippingAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberShippingAddresses?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberShippingAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberShippingAddresses(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetShippingAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetShippingAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberShippingAddresses(response: HttpResponseBase): Observable<PagedResultDtoOfGetShippingAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetShippingAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetShippingAddressDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getDefaultShippingAddress(tenantId: number | null | undefined, memberId: number | null | undefined): Observable<GetShippingAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetDefaultShippingAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultShippingAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultShippingAddress(<any>response_);
                } catch (e) {
                    return <Observable<GetShippingAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetShippingAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultShippingAddress(response: HttpResponseBase): Observable<GetShippingAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetShippingAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetShippingAddressDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param ids (optional) 
     * @return Success
     */
    deleteShippingAddresses(tenantId: number | null | undefined, memberId: number | null | undefined, ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteShippingAddresses?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShippingAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShippingAddresses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShippingAddresses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param deviceId (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: string | null | undefined, deviceId: number | null | undefined, input: AddOrUpdateWeishopOrderInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "deviceId": deviceId !== undefined && deviceId !== null ? "" + deviceId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWeishopOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param subkey (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateBigScreenOrder(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: string | null | undefined, subkey: string | null | undefined, input: AddOrUpdateHaierOrderInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateBigScreenOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "subkey": subkey !== undefined && subkey !== null ? "" + subkey : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateBigScreenOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateBigScreenOrder(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateBigScreenOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param subkey (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateBigScreenOrderForConfirm(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: string | null | undefined, subkey: string | null | undefined, input: AddOrUpdateHaierOrderInput | null | undefined): Observable<AddOrUpdateBigScreenOrderForConfirmDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateBigScreenOrderForConfirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "subkey": subkey !== undefined && subkey !== null ? "" + subkey : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateBigScreenOrderForConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateBigScreenOrderForConfirm(<any>response_);
                } catch (e) {
                    return <Observable<AddOrUpdateBigScreenOrderForConfirmDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddOrUpdateBigScreenOrderForConfirmDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateBigScreenOrderForConfirm(response: HttpResponseBase): Observable<AddOrUpdateBigScreenOrderForConfirmDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddOrUpdateBigScreenOrderForConfirmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddOrUpdateBigScreenOrderForConfirmDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @param extensionData (optional) 
     * @param roomId (optional) 
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param awardId (optional) 
     * @return Success
     */
    wxPayOrderForActivity(actionId: number | null | undefined, securityKey: string | null | undefined, ticketId: number | null | undefined, extensionData: string | null | undefined, roomId: string | null | undefined, productId: number | null | undefined, skuId: number | null | undefined, awardId: number | null | undefined): Observable<WxPayDataDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxPayOrderForActivity?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        if (extensionData !== undefined)
            url_ += "extensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&"; 
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&"; 
        if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<WxPayDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxPayDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayOrderForActivity(response: HttpResponseBase): Observable<WxPayDataDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WxPayDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxPayDataDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @param extensionData (optional) 
     * @param turnUrl (optional) 
     * @param roomId (optional) 
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param awardId (optional) 
     * @return Success
     */
    aliPayOrderForActivity(actionId: number | null | undefined, securityKey: string | null | undefined, ticketId: number | null | undefined, extensionData: string | null | undefined, turnUrl: string | null | undefined, roomId: string | null | undefined, productId: number | null | undefined, skuId: number | null | undefined, awardId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayOrderForActivity?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        if (extensionData !== undefined)
            url_ += "extensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (turnUrl !== undefined)
            url_ += "turnUrl=" + encodeURIComponent("" + turnUrl) + "&"; 
        if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&"; 
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&"; 
        if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayOrderForActivity(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aliPayNotifyForActivity(input: AlipayNotifyInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayNotifyForActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayNotifyForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayNotifyForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayNotifyForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    wxPayNotifyForActivity(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/wxPayNotifyForActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayNotifyForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayNotifyForActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayNotifyForActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param device_info (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    sendSignalRCommand(device_info: string | null | undefined, actionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendSignalRCommand?";
        if (device_info !== undefined)
            url_ += "device_info=" + encodeURIComponent("" + device_info) + "&"; 
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSignalRCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSignalRCommand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendSignalRCommand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    pointPayOrderForActivity(actionId: number | null | undefined, securityKey: string | null | undefined, ticketId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointPayOrderForActivity?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointPayOrderForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    pointAwardForActivity(actionId: number | null | undefined, securityKey: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointAwardForActivity?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointAwardForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointAwardForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointAwardForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    wxPayOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<WxPayDataDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxPayOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<WxPayDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxPayDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayOrder(response: HttpResponseBase): Observable<WxPayDataDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WxPayDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxPayDataDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @param turnUrl (optional) 
     * @return Success
     */
    aliPayOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined, turnUrl: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (turnUrl !== undefined)
            url_ += "turnUrl=" + encodeURIComponent("" + turnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayOrder(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    pointPayOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointPayOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointPayOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    wxAndPointPayOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxAndPointPayOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxAndPointPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxAndPointPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processWxAndPointPayOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getAliPaySetting(tenantId: number | null | undefined): Observable<GetAliPaySettingDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetAliPaySetting?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAliPaySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAliPaySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetAliPaySettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAliPaySettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAliPaySetting(response: HttpResponseBase): Observable<GetAliPaySettingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAliPaySettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAliPaySettingDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getwxPayResult(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/getwxPayResult?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwxPayResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwxPayResult(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetwxPayResult(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    wxPayNotify(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/wxPayNotify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aliPayNotify(input: AlipayNotifyInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayNotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayNotify(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayNotify(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getWeishopOrderDetail(tenantId: number | null | undefined, memberId: number | null | undefined, id: number | null | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopOrderDetail?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrderDetail(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param storeId (optional) 
     * @param activityId (optional) 
     * @param status (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopOrders(tenantId: number | null | undefined, memberId: number | null | undefined, orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, storeId: number | null | undefined, activityId: number | null | undefined, status: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopOrders?";
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrders(response: HttpResponseBase): Observable<PagedResultDtoOfOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrderDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getOrderCount(tenantId: number | null | undefined, memberId: number | null | undefined): Observable<WeishopOrderCountDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetOrderCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderCount(<any>response_);
                } catch (e) {
                    return <Observable<WeishopOrderCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeishopOrderCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderCount(response: HttpResponseBase): Observable<WeishopOrderCountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeishopOrderCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeishopOrderCountDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    refundWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, input: RefundOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RefundWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRefundWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    cancelWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CancelWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    confirmWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ConfirmWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @param payType (optional) 
     * @param tradNumber (optional) 
     * @param payAccount (optional) 
     * @param rfidCodes (optional) 
     * @param onCreditPay (optional) 
     * @return Success
     */
    confirmBigScreenOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined, payType: string | null | undefined, tradNumber: string | null | undefined, payAccount: string | null | undefined, rfidCodes: string[] | null | undefined, onCreditPay: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ConfirmBigScreenOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (payType !== undefined)
            url_ += "payType=" + encodeURIComponent("" + payType) + "&"; 
        if (tradNumber !== undefined)
            url_ += "tradNumber=" + encodeURIComponent("" + tradNumber) + "&"; 
        if (payAccount !== undefined)
            url_ += "payAccount=" + encodeURIComponent("" + payAccount) + "&"; 
        if (onCreditPay !== undefined)
            url_ += "OnCreditPay=" + encodeURIComponent("" + onCreditPay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rfidCodes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmBigScreenOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmBigScreenOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmBigScreenOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    deleteWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRefundReasons(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetRefundReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundReasons(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundReasons(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getMemberPointLevelAndRegPhone(tenantId: number | null | undefined, memberId: number | null | undefined): Observable<PointLevelRegPhoneDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberPointLevelAndRegPhone?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPointLevelAndRegPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPointLevelAndRegPhone(<any>response_);
                } catch (e) {
                    return <Observable<PointLevelRegPhoneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PointLevelRegPhoneDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPointLevelAndRegPhone(response: HttpResponseBase): Observable<PointLevelRegPhoneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PointLevelRegPhoneDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PointLevelRegPhoneDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getRefundDetail(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetRefundDetail?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundDetail(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    evaluateWeishopOrder(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/EvaluateWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processEvaluateWeishopOrder(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    uploadRefundExpress(tenantId: number | null | undefined, memberId: number | null | undefined, input: UploadExpressInput | null | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UploadRefundExpress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadRefundExpress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadRefundExpress(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadRefundExpress(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExpressCompanies(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetExpressCompaniesDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetExpressCompanies?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpressCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpressCompanies(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetExpressCompaniesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetExpressCompaniesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpressCompanies(response: HttpResponseBase): Observable<PagedResultDtoOfGetExpressCompaniesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExpressCompaniesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExpressCompaniesDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getOrderTracking(tenantId: number | null | undefined, memberId: number | null | undefined, orderId: number | null | undefined): Observable<ExpressTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetOrderTracking?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderTracking(<any>response_);
                } catch (e) {
                    return <Observable<ExpressTrackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressTrackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderTracking(response: HttpResponseBase): Observable<ExpressTrackingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpressTrackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpressTrackingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUserToOvoPark(input: AddUserToOvoParkInput | null | undefined): Observable<AddUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddUserToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<AddUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserToOvoPark(response: HttpResponseBase): Observable<AddUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddUserDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    registerUserToWeiShop(tenantId: number | null | undefined, memberId: number | null | undefined, input: RegisterUserToWeiShopInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterUserToWeiShop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUserToWeiShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUserToWeiShop(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUserToWeiShop(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param rfidCode (optional) 
     * @param templateMessageType (optional) 
     * @return Success
     */
    sendTemplateMessageByDevice(subkey: string | null | undefined, rfidCode: string | null | undefined, templateMessageType: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendTemplateMessageByDevice?";
        if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (rfidCode !== undefined)
            url_ += "rfidCode=" + encodeURIComponent("" + rfidCode) + "&"; 
        if (templateMessageType !== undefined)
            url_ += "templateMessageType=" + encodeURIComponent("" + templateMessageType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTemplateMessageByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTemplateMessageByDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendTemplateMessageByDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    queryUserByFace(input: QueryUserByFaceInput | null | undefined): Observable<QueryUserByFaceDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/QueryUserByFace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUserByFace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUserByFace(<any>response_);
                } catch (e) {
                    return <Observable<QueryUserByFaceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QueryUserByFaceDto>><any>_observableThrow(response_);
        }));
    }

    protected processQueryUserByFace(response: HttpResponseBase): Observable<QueryUserByFaceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryUserByFaceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QueryUserByFaceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerFaceByUser(input: RegisterFaceByUserInput | null | undefined): Observable<RegisterFaceByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterFaceByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceByUser(<any>response_);
                } catch (e) {
                    return <Observable<RegisterFaceByUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterFaceByUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceByUser(response: HttpResponseBase): Observable<RegisterFaceByUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterFaceByUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterFaceByUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addGroupToOvoPark(input: AddGroupToOvoParkInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddGroupToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddGroupToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddGroupToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddGroupToOvoPark(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param faceUrl (optional) 
     * @param _aid (optional) 
     * @param _akey (optional) 
     * @param orgid (optional) 
     * @param depid (optional) 
     * @return Success
     */
    searchUserFromOvoPark(faceUrl: string | null | undefined, _aid: string | null | undefined, _akey: string | null | undefined, orgid: number | null | undefined, depid: number | null | undefined): Observable<OvoParkUserInfo> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SearchUserFromOvoPark?";
        if (faceUrl !== undefined)
            url_ += "faceUrl=" + encodeURIComponent("" + faceUrl) + "&"; 
        if (_aid !== undefined)
            url_ += "_aid=" + encodeURIComponent("" + _aid) + "&"; 
        if (_akey !== undefined)
            url_ += "_akey=" + encodeURIComponent("" + _akey) + "&"; 
        if (orgid !== undefined)
            url_ += "orgid=" + encodeURIComponent("" + orgid) + "&"; 
        if (depid !== undefined)
            url_ += "depid=" + encodeURIComponent("" + depid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUserFromOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUserFromOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<OvoParkUserInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<OvoParkUserInfo>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUserFromOvoPark(response: HttpResponseBase): Observable<OvoParkUserInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OvoParkUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OvoParkUserInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerMemberToOvoPark(input: AddUserInput | null | undefined): Observable<AddUserResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterMemberToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMemberToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMemberToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<AddUserResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddUserResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMemberToOvoPark(response: HttpResponseBase): Observable<AddUserResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddUserResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param openId (optional) 
     * @param from (optional) 
     * @return Success
     */
    checkMemberByOpenId(tenantId: number | null | undefined, openId: string | null | undefined, from: string | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckMemberByOpenId?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckMemberByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckMemberByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckMemberByOpenId(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getAuthorizeToken(tenantId: number | null | undefined, memberId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetAuthorizeToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthorizeToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param deviceId (optional) 
     * @param longitude (optional) 
     * @param latitude (optional) 
     * @return Success
     */
    controlOpenDoor(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, deviceId: number | null | undefined, longitude: number | null | undefined, latitude: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ControlOpenDoor?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&"; 
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&"; 
        if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processControlOpenDoor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processControlOpenDoor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processControlOpenDoor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param token (optional) 
     * @return Success
     */
    checkAuthorizeToken(subkey: string | null | undefined, token: string | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckAuthorizeToken?";
        if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckAuthorizeToken(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    isManagerFromSession(memberId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/IsManagerFromSession?";
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsManagerFromSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsManagerFromSession(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsManagerFromSession(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    isTokenChecked(token: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/IsTokenChecked?";
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTokenChecked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTokenChecked(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processIsTokenChecked(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param from (optional) 
     * @return Success
     */
    getMemberInfoById(tenantId: number | null | undefined, memberId: string | null | undefined, from: string | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberInfoById?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfoById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfoById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getBigChartReport(subKey: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, chartType: string | null | undefined): Observable<BigChart> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetBigChartReport?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigChartReport(<any>response_);
                } catch (e) {
                    return <Observable<BigChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<BigChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigChartReport(response: HttpResponseBase): Observable<BigChart> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BigChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BigChart>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getMemberPointLog(tenantId: number | null | undefined, memberId: string | null | undefined, input: GetMemberPointLogInput | null | undefined): Observable<PagedResultDtoOfMemberPointLogDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberPointLog?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPointLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPointLog(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberPointLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberPointLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPointLog(response: HttpResponseBase): Observable<PagedResultDtoOfMemberPointLogDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMemberPointLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberPointLogDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param ticketStatus (optional) 
     * @param ticketType (optional) 
     * @param takeType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTickets(subKey: string | null | undefined, ticketStatus: TicketStatus | null | undefined, ticketType: TicketType | null | undefined, takeType: TakeType | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetTickets?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (ticketStatus !== undefined)
            url_ += "TicketStatus=" + encodeURIComponent("" + ticketStatus) + "&"; 
        if (ticketType !== undefined)
            url_ += "TicketType=" + encodeURIComponent("" + ticketType) + "&"; 
        if (takeType !== undefined)
            url_ += "TakeType=" + encodeURIComponent("" + takeType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<PagedResultDtoOfGetTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTicketDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicket(id: number | null | undefined): Observable<GetTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetTicket?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicket(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicket(response: HttpResponseBase): Observable<GetTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto>(<any>null);
    }

    /**
     * @param epc (optional) 
     * @return Success
     */
    deleteHaierRfid(epc: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteHaierRfid?";
        if (epc !== undefined)
            url_ += "epc=" + encodeURIComponent("" + epc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHaierRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHaierRfid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHaierRfid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemberById(id: number | null | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberById?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @return Success
     */
    clearRfidSession(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ClearRfidSession";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearRfidSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearRfidSession(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearRfidSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeExpiredAuthorizeToken(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RemoveExpiredAuthorizeToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveExpiredAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveExpiredAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveExpiredAuthorizeToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWeishopSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderPay(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderPay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderPay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderPay(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderPay(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderFinish(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderFinish";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderFinish(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderConfirm(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderConfirm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderConfirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addCustomerMemberFromOnline(input: AddCustomerMemberFromOnlineInput | null | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddCustomerMemberFromOnline";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCustomerMemberFromOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCustomerMemberFromOnline(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddCustomerMemberFromOnline(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param pickNo (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    usePickNo(pickNo: string | null | undefined, subKey: string | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UsePickNo?";
        if (pickNo !== undefined)
            url_ += "pickNo=" + encodeURIComponent("" + pickNo) + "&"; 
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsePickNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsePickNo(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUsePickNo(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }
}

@Injectable()
export class SensingShopManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateWeishopOrder(input: AddOrUpdateWeishopOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/AddOrUpdateWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param orderNo (optional) 
     * @return Success
     */
    getWeishopOrderDetail(id: number | null | undefined, orderNo: string | null | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetWeishopOrderDetail?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (orderNo !== undefined)
            url_ += "orderNo=" + encodeURIComponent("" + orderNo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrderDetail(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param storeId (optional) 
     * @param activityId (optional) 
     * @param status (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopOrders(orderDateTimeStart: moment.Moment | null | undefined, orderDateTimeEnd: moment.Moment | null | undefined, storeId: number | null | undefined, activityId: number | null | undefined, status: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetWeishopOrders?";
        if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&"; 
        if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&"; 
        if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrders(response: HttpResponseBase): Observable<PagedResultDtoOfOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrderDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verificateOrderItem(input: VerificatOrderItemInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/VerificateOrderItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificateOrderItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificateOrderItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerificateOrderItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    getOrderReportByActivity(activityId: number | null | undefined, storeId: number | null | undefined): Observable<OrderReportByActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetOrderReportByActivity?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderReportByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderReportByActivity(<any>response_);
                } catch (e) {
                    return <Observable<OrderReportByActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderReportByActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderReportByActivity(response: HttpResponseBase): Observable<OrderReportByActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderReportByActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderReportByActivityDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deliverWeishopOrder(input: DeliverOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DeliverWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliverWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliverWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeliverWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getRefundDetail(orderId: number | null | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetRefundDetail?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundDetail(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    acceptRefundOrder(orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/AcceptRefundOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptRefundOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptRefundOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptRefundOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    closeWeishopOrder(orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/CloseWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCloseWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    comfirmWeishopOrder(orderId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/ComfirmWeishopOrder?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComfirmWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComfirmWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processComfirmWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setTrackKeyInfo(input: TrackKeyInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/SetTrackKeyInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTrackKeyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTrackKeyInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTrackKeyInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @return Success
     */
    getTrackKeyInfo(from: string | null | undefined): Observable<TrackKeyInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetTrackKeyInfo?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrackKeyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrackKeyInfo(<any>response_);
                } catch (e) {
                    return <Observable<TrackKeyInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackKeyInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrackKeyInfo(response: HttpResponseBase): Observable<TrackKeyInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackKeyInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackKeyInfoDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExpressCompanies(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetExpressCompaniesDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetExpressCompanies?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpressCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpressCompanies(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetExpressCompaniesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetExpressCompaniesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpressCompanies(response: HttpResponseBase): Observable<PagedResultDtoOfGetExpressCompaniesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExpressCompaniesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExpressCompaniesDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getOrderDeliverInfo(orderId: number | null | undefined): Observable<OrderDeliverInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetOrderDeliverInfo?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDeliverInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDeliverInfo(<any>response_);
                } catch (e) {
                    return <Observable<OrderDeliverInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDeliverInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderDeliverInfo(response: HttpResponseBase): Observable<OrderDeliverInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDeliverInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDeliverInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setShopPaySetting(input: SetShopPayInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/SetShopPaySetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetShopPaySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetShopPaySetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetShopPaySetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopPaySettings(from: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPayAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetShopPaySettings?";
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopPaySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopPaySettings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPayAccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPayAccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopPaySettings(response: HttpResponseBase): Observable<PagedResultDtoOfGetPayAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPayAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPayAccountDto>(<any>null);
    }

    /**
     * @param payAccountIds (optional) 
     * @return Success
     */
    deleteShopPaySettings(payAccountIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DeleteShopPaySettings?";
        if (payAccountIds !== undefined)
            payAccountIds && payAccountIds.forEach(item => { url_ += "payAccountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopPaySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopPaySettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopPaySettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    refuseRefundApply(input: RefuseRefundApplyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/RefuseRefundApply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefuseRefundApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefuseRefundApply(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRefuseRefundApply(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dispatchPointToMember(input: DispatchPointToMemberInput | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DispatchPointToMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispatchPointToMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispatchPointToMember(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processDispatchPointToMember(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class SensingTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getTicketsForProductByTagAndCategory(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, input: GetTicketsByTagAndCategoryInput | null | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForProductByTagAndCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForProductByTagAndCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForProductByTagAndCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForProductByTagAndCategory(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getTicketUseConditionById(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, ticketId: number | null | undefined): Observable<TicketTagAndCategoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketUseConditionById?";
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketUseConditionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketUseConditionById(<any>response_);
                } catch (e) {
                    return <Observable<TicketTagAndCategoryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketTagAndCategoryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketUseConditionById(response: HttpResponseBase): Observable<TicketTagAndCategoryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketTagAndCategoryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketTagAndCategoryOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getTicketsForOrder(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, input: GetTicketsForOrderInput | null | undefined): Observable<SkuTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForOrder(<any>response_);
                } catch (e) {
                    return <Observable<SkuTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForOrder(response: HttpResponseBase): Observable<SkuTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuTicketDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getTickets(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, input: GetTicketsInput | null | undefined): Observable<SimpleTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<SimpleTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<SimpleTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleTicketDto[]>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    getTicketsForActivity(actionId: number | null | undefined, securityKey: string | null | undefined): Observable<SimpleTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForActivity?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForActivity(<any>response_);
                } catch (e) {
                    return <Observable<SimpleTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForActivity(response: HttpResponseBase): Observable<SimpleTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleTicketDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    takeTicketForActivity(input: TakeTicketForActivityInput | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicketForActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicketForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicketForActivity(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicketForActivity(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    takeTicketForActivity_Jingmei(input: TakeTicketForActivityInput | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicketForActivity_Jingmei";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicketForActivity_Jingmei(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicketForActivity_Jingmei(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicketForActivity_Jingmei(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param memberTicketId (optional) 
     * @return Success
     */
    getTakedTicketByMemberIdAndTicketId(memberTicketId: number | null | undefined): Observable<GetTakedTicketInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakedTicketByMemberIdAndTicketId?";
        if (memberTicketId !== undefined)
            url_ += "memberTicketId=" + encodeURIComponent("" + memberTicketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakedTicketByMemberIdAndTicketId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakedTicketByMemberIdAndTicketId(<any>response_);
                } catch (e) {
                    return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakedTicketByMemberIdAndTicketId(response: HttpResponseBase): Observable<GetTakedTicketInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTakedTicketInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTakedTicketInfoDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    getTakedTicketByActionId(actionId: number | null | undefined): Observable<GetTakedTicketInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakedTicketByActionId?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakedTicketByActionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakedTicketByActionId(<any>response_);
                } catch (e) {
                    return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakedTicketByActionId(response: HttpResponseBase): Observable<GetTakedTicketInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTakedTicketInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTakedTicketInfoDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getPointPreOrder(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, input: GetPointPreOrderInput | null | undefined): Observable<SimplePointOrderDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetPointPreOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPointPreOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPointPreOrder(<any>response_);
                } catch (e) {
                    return <Observable<SimplePointOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimplePointOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPointPreOrder(response: HttpResponseBase): Observable<SimplePointOrderDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimplePointOrderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePointOrderDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    getTicketsByMemberId(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsByMemberId(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketId (optional) 
     * @param actionId (optional) 
     * @param sendMessage (optional) 
     * @return Success
     */
    takeTicket(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, ticketId: number | null | undefined, actionId: number | null | undefined, sendMessage: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicket?";
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (sendMessage !== undefined)
            url_ += "SendMessage=" + encodeURIComponent("" + sendMessage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ticketNo (optional) 
     * @param securityKey (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    useTicketByTicketNo(ticketNo: string | null | undefined, securityKey: string | null | undefined, subKey: string | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/UseTicketByTicketNo?";
        if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseTicketByTicketNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseTicketByTicketNo(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUseTicketByTicketNo(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketIds (optional) 
     * @return Success
     */
    getTicketInfosByIds(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, ticketIds: number[] | null | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketInfosByIds?";
        if (ticketIds !== undefined)
            ticketIds && ticketIds.forEach(item => { url_ += "ticketIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInfosByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInfosByIds(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInfosByIds(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param productId (optional) 
     * @return Success
     */
    getTicketCenter(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, productId: number | null | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketCenter?";
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketCenter(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketCenter(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param skuId (optional) 
     * @return Success
     */
    getOtherTickets(tenantId: number | null | undefined, memberId: number | null | undefined, storeId: number | null | undefined, skuId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetOtherTickets?";
        if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOtherTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOtherTickets(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetOtherTickets(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPickNobyUser(input: TaketicketForUserInput | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetPickNobyUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickNobyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickNobyUser(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickNobyUser(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAwardsByUser(input: TakeTicketRepInput | null | undefined): Observable<PagedResultDtoOfTakeTicketRepDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAwardsByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTakeTicketRepDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTakeTicketRepDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByUser(response: HttpResponseBase): Observable<PagedResultDtoOfTakeTicketRepDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTakeTicketRepDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTakeTicketRepDto>(<any>null);
    }

    /**
     * @param ticketNo (optional) 
     * @param securityKey (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    checkTicketNo(ticketNo: string | null | undefined, securityKey: string | null | undefined, subKey: string | null | undefined): Observable<CheckTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/CheckTicketNo?";
        if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTicketNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTicketNo(<any>response_);
                } catch (e) {
                    return <Observable<CheckTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTicketNo(response: HttpResponseBase): Observable<CheckTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckTicketDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param ticketNo (optional) 
     * @param isSuccess (optional) 
     * @param operationTime (optional) 
     * @param cargoRoadId (optional) 
     * @param thingId (optional) 
     * @param thingname (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    useTicketAfterCheck(subKey: string | null | undefined, ticketNo: string | null | undefined, isSuccess: boolean | null | undefined, operationTime: number | null | undefined, cargoRoadId: number | null | undefined, thingId: number | null | undefined, thingname: string | null | undefined, tenantId: number | null | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/UseTicketAfterCheck?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&"; 
        if (isSuccess !== undefined)
            url_ += "IsSuccess=" + encodeURIComponent("" + isSuccess) + "&"; 
        if (operationTime !== undefined)
            url_ += "OperationTime=" + encodeURIComponent("" + operationTime) + "&"; 
        if (cargoRoadId !== undefined)
            url_ += "CargoRoadId=" + encodeURIComponent("" + cargoRoadId) + "&"; 
        if (thingId !== undefined)
            url_ += "thingId=" + encodeURIComponent("" + thingId) + "&"; 
        if (thingname !== undefined)
            url_ += "thingname=" + encodeURIComponent("" + thingname) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseTicketAfterCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseTicketAfterCheck(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUseTicketAfterCheck(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getAvgOperationTime(subKey: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAvgOperationTime?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvgOperationTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvgOperationTime(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvgOperationTime(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAwardsUserRep(): Observable<TakeTicketRepDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAwardsUserRep";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsUserRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsUserRep(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketRepDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketRepDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsUserRep(response: HttpResponseBase): Observable<TakeTicketRepDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TakeTicketRepDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketRepDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTakeTicketRep(): Observable<TicketRep[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakeTicketRep";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakeTicketRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakeTicketRep(<any>response_);
                } catch (e) {
                    return <Observable<TicketRep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketRep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakeTicketRep(response: HttpResponseBase): Observable<TicketRep[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketRep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketRep[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTakeTicketListToExcel(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakeTicketListToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakeTicketListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakeTicketListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakeTicketListToExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param stream (optional) 
     * @param name (optional) 
     * @return Success
     */
    addAttachments(stream: Stream | null | undefined, name: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/AddAttachments?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stream);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAttachments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    sendMail(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, type: Type | null | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTag(input: CreateTagInput | null | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTag(input: UpdateTagInput | null | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteTag(input: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | null | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class TicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param ticketStatus (optional) 
     * @param ticketType (optional) 
     * @param takeType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTickets(ticketStatus: TicketStatus2 | null | undefined, ticketType: TicketType2 | null | undefined, takeType: TakeType2 | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetTickets?";
        if (ticketStatus !== undefined)
            url_ += "TicketStatus=" + encodeURIComponent("" + ticketStatus) + "&"; 
        if (ticketType !== undefined)
            url_ += "TicketType=" + encodeURIComponent("" + ticketType) + "&"; 
        if (takeType !== undefined)
            url_ += "TakeType=" + encodeURIComponent("" + takeType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<PagedResultDtoOfGetTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTicketDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateTicket(input: AddOrUpdateTicketInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/AddOrUpdateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteTickets(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/DeleteTickets?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTickets(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTickets(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    grantTicketByTags(input: GrantTicketByTagsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GrantTicketByTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantTicketByTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantTicketByTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantTicketByTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    grantTicketByMemberLevels(input: GrantTicketByMemberLevelsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GrantTicketByMemberLevels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantTicketByMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantTicketByMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantTicketByMemberLevels(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ticketId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTicketMembers(ticketId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetTicketMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetTicketMembers?";
        if (ticketId !== undefined)
            url_ += "TicketId=" + encodeURIComponent("" + ticketId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketMembers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTicketMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTicketMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketMembers(response: HttpResponseBase): Observable<PagedResultDtoOfGetTicketMemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTicketMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTicketMemberDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setTicketStatus(input: SetTicketStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/SetTicketStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTicketStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTicketStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTicketStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class OrderCategoryDto implements IOrderCategoryDto {
    category!: string | undefined;
    subCategory!: string[] | undefined;

    constructor(data?: IOrderCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            if (Array.isArray(data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of data["subCategory"])
                    this.subCategory!.push(item);
            }
        }
    }

    static fromJS(data: any): OrderCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item);
        }
        return data; 
    }
}

export interface IOrderCategoryDto {
    category: string | undefined;
    subCategory: string[] | undefined;
}

export class PointF implements IPointF {
    readonly isEmpty!: boolean | undefined;
    x!: number | undefined;
    y!: number | undefined;

    constructor(data?: IPointF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).isEmpty = data["isEmpty"];
            this.x = data["x"];
            this.y = data["y"];
        }
    }

    static fromJS(data: any): PointF {
        data = typeof data === 'object' ? data : {};
        let result = new PointF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmpty"] = this.isEmpty;
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }
}

export interface IPointF {
    isEmpty: boolean | undefined;
    x: number | undefined;
    y: number | undefined;
}

export class TinyFileOutput implements ITinyFileOutput {
    resourceId!: number | undefined;
    fileUri!: string | undefined;
    thumbnailUri!: string | undefined;
    code!: number | undefined;
    message!: string | undefined;
    details!: string | undefined;
    validationErrors!: ValidationErrorInfo[] | undefined;

    constructor(data?: ITinyFileOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resourceId = data["resourceId"];
            this.fileUri = data["fileUri"];
            this.thumbnailUri = data["thumbnailUri"];
            this.code = data["code"];
            this.message = data["message"];
            this.details = data["details"];
            if (Array.isArray(data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of data["validationErrors"])
                    this.validationErrors!.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TinyFileOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TinyFileOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["fileUri"] = this.fileUri;
        data["thumbnailUri"] = this.thumbnailUri;
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITinyFileOutput {
    resourceId: number | undefined;
    fileUri: string | undefined;
    thumbnailUri: string | undefined;
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            if (Array.isArray(data["members"])) {
                this.members = [] as any;
                for (let item of data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class PostSignatureTextDataInput implements IPostSignatureTextDataInput {
    text!: string | undefined;
    signatureImage!: string | undefined;
    layoutWidth!: number | undefined;
    layoutHeight!: number | undefined;
    fontSize!: number | undefined;
    drawOutline!: boolean | undefined;
    maxWidth!: number | undefined;
    maxHeight!: number | undefined;
    offsetX!: number | undefined;
    offsetY!: number | undefined;
    borderSpeed!: number | undefined;

    constructor(data?: IPostSignatureTextDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.signatureImage = data["signatureImage"];
            this.layoutWidth = data["layoutWidth"];
            this.layoutHeight = data["layoutHeight"];
            this.fontSize = data["fontSize"];
            this.drawOutline = data["drawOutline"];
            this.maxWidth = data["maxWidth"];
            this.maxHeight = data["maxHeight"];
            this.offsetX = data["offsetX"];
            this.offsetY = data["offsetY"];
            this.borderSpeed = data["borderSpeed"];
        }
    }

    static fromJS(data: any): PostSignatureTextDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostSignatureTextDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["signatureImage"] = this.signatureImage;
        data["layoutWidth"] = this.layoutWidth;
        data["layoutHeight"] = this.layoutHeight;
        data["fontSize"] = this.fontSize;
        data["drawOutline"] = this.drawOutline;
        data["maxWidth"] = this.maxWidth;
        data["maxHeight"] = this.maxHeight;
        data["offsetX"] = this.offsetX;
        data["offsetY"] = this.offsetY;
        data["borderSpeed"] = this.borderSpeed;
        return data; 
    }
}

export interface IPostSignatureTextDataInput {
    text: string | undefined;
    signatureImage: string | undefined;
    layoutWidth: number | undefined;
    layoutHeight: number | undefined;
    fontSize: number | undefined;
    drawOutline: boolean | undefined;
    maxWidth: number | undefined;
    maxHeight: number | undefined;
    offsetX: number | undefined;
    offsetY: number | undefined;
    borderSpeed: number | undefined;
}

export class PagedResultDtoOfMemberDto implements IPagedResultDtoOfMemberDto {
    totalCount!: number | undefined;
    items!: MemberDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMemberDto {
    totalCount: number | undefined;
    items: MemberDto[] | undefined;
}

export class MemberDto implements IMemberDto {
    memberNo!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    id!: number | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;
    storeId!: string | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    registerdTime!: moment.Moment | undefined;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string | undefined;
    career!: string | undefined;
    income!: string | undefined;
    shippingAddresses!: ShippingAddressDto[] | undefined;
    from!: string | undefined;
    orders!: OrderDto[] | undefined;
    memberTags!: IdNameDto[] | undefined;
    status!: string | undefined;
    canCreditPay!: boolean | undefined;
    snsUserInfo!: SnsUserInfoDto | undefined;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberNo = data["memberNo"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.outerId = data["outerId"];
            this.name = data["name"];
            this.type = data["type"];
            this.storeId = data["storeId"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.registerdTime = data["registerdTime"] ? moment(data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
            this.from = data["from"];
            if (Array.isArray(data["orders"])) {
                this.orders = [] as any;
                for (let item of data["orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
            if (Array.isArray(data["memberTags"])) {
                this.memberTags = [] as any;
                for (let item of data["memberTags"])
                    this.memberTags!.push(IdNameDto.fromJS(item));
            }
            this.status = data["status"];
            this.canCreditPay = data["canCreditPay"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoDto.fromJS(data["snsUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.memberTags)) {
            data["memberTags"] = [];
            for (let item of this.memberTags)
                data["memberTags"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["canCreditPay"] = this.canCreditPay;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberDto {
    memberNo: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    id: number | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    outerId: string | undefined;
    name: string | undefined;
    type: string | undefined;
    storeId: string | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    registerdTime: moment.Moment | undefined;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    weChatNickName: string | undefined;
    regPhone: string | undefined;
    career: string | undefined;
    income: string | undefined;
    shippingAddresses: ShippingAddressDto[] | undefined;
    from: string | undefined;
    orders: OrderDto[] | undefined;
    memberTags: IdNameDto[] | undefined;
    status: string | undefined;
    canCreditPay: boolean | undefined;
    snsUserInfo: SnsUserInfoDto | undefined;
}

export class ShippingAddressDto implements IShippingAddressDto {
    id!: number | undefined;
    outerId!: string | undefined;
    postPhone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    adress!: string | undefined;
    zipCode!: string | undefined;
    normalizeName!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    regPhone!: string | undefined;
    idNumber!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.outerId = data["outerId"];
            this.postPhone = data["postPhone"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.adress = data["adress"];
            this.zipCode = data["zipCode"];
            this.normalizeName = data["normalizeName"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.regPhone = data["regPhone"];
            this.idNumber = data["idNumber"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): ShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["postPhone"] = this.postPhone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["adress"] = this.adress;
        data["zipCode"] = this.zipCode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["regPhone"] = this.regPhone;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IShippingAddressDto {
    id: number | undefined;
    outerId: string | undefined;
    postPhone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    adress: string | undefined;
    zipCode: string | undefined;
    normalizeName: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    regPhone: string | undefined;
    idNumber: string | undefined;
    isDefault: boolean | undefined;
}

export class OrderDto implements IOrderDto {
    id!: number | undefined;
    orderNO!: string | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    number!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    status!: string | undefined;
    payment!: number | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    postFee!: number | undefined;
    taxFee!: number | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    payType!: string | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    addressId!: number | undefined;
    orderItems!: OrderItemDto[] | undefined;
    from!: string | undefined;
    note!: string | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    isCanPay!: boolean | undefined;
    expirePayTime!: moment.Moment | undefined;
    isCanRefund!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    memberId!: number | undefined;
    member!: MemberDto | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orderNO = data["orderNO"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.storeId = data["storeId"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.number = data["number"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.status = data["status"];
            this.payment = data["payment"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.postFee = data["postFee"];
            this.taxFee = data["taxFee"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.payType = data["payType"];
            this.consignTime = data["consignTime"] ? moment(data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = data["returnsTime"] ? moment(data["returnsTime"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(OrderItemDto.fromJS(item));
            }
            this.from = data["from"];
            this.note = data["note"];
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
            this.isCanPay = data["isCanPay"];
            this.expirePayTime = data["expirePayTime"] ? moment(data["expirePayTime"].toString()) : <any>undefined;
            this.isCanRefund = data["isCanRefund"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.memberId = data["memberId"];
            this.member = data["member"] ? MemberDto.fromJS(data["member"]) : <any>undefined;
            this.pointReduction = data["pointReduction"];
            this.deductionAmount = data["deductionAmount"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNO"] = this.orderNO;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["number"] = this.number;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["postFee"] = this.postFee;
        data["taxFee"] = this.taxFee;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        data["isCanPay"] = this.isCanPay;
        data["expirePayTime"] = this.expirePayTime ? this.expirePayTime.toISOString() : <any>undefined;
        data["isCanRefund"] = this.isCanRefund;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface IOrderDto {
    id: number | undefined;
    orderNO: string | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    storeId: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    number: string | undefined;
    orderDateTime: moment.Moment | undefined;
    status: string | undefined;
    payment: number | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    postFee: number | undefined;
    taxFee: number | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    payType: string | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    addressId: number | undefined;
    orderItems: OrderItemDto[] | undefined;
    from: string | undefined;
    note: string | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    isCanPay: boolean | undefined;
    expirePayTime: moment.Moment | undefined;
    isCanRefund: boolean | undefined;
    creationTime: moment.Moment | undefined;
    memberId: number | undefined;
    member: MemberDto | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class IdNameDto implements IIdNameDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number | undefined;
    name: string | undefined;
}

export class SnsUserInfoDto implements ISnsUserInfoDto {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    isBecomeFans!: boolean | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoDtoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.isBecomeFans = data["isBecomeFans"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
            this.memberId = data["memberId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoDto {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    isBecomeFans: boolean | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoDtoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number | undefined;
}

export class OrderItemDto implements IOrderItemDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    orderId!: number | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number | undefined;
    totalFee!: number | undefined;
    taxFee!: number | undefined;
    payment!: number | undefined;
    status!: string | undefined;
    outerId!: string | undefined;
    currentSkuPropertyValues!: SkuPropertyValues[] | undefined;
    productId!: number | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.orderId = data["orderId"];
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.payment = data["payment"];
            this.status = data["status"];
            this.outerId = data["outerId"];
            if (Array.isArray(data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(SkuPropertyValues.fromJS(item));
            }
            this.productId = data["productId"];
            this.pointReduction = data["pointReduction"];
            this.deductionAmount = data["deductionAmount"];
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderId"] = this.orderId;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface IOrderItemDto {
    id: number | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    orderId: number | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number | undefined;
    totalFee: number | undefined;
    taxFee: number | undefined;
    payment: number | undefined;
    status: string | undefined;
    outerId: string | undefined;
    currentSkuPropertyValues: SkuPropertyValues[] | undefined;
    productId: number | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class SkuPropertyValues implements ISkuPropertyValues {
    propertyId!: number | undefined;
    propertyValueId!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISkuPropertyValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyId = data["propertyId"];
            this.propertyValueId = data["propertyValueId"];
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): SkuPropertyValues {
        data = typeof data === 'object' ? data : {};
        let result = new SkuPropertyValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyValueId"] = this.propertyValueId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISkuPropertyValues {
    propertyId: number | undefined;
    propertyValueId: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class CreateMemberInput implements ICreateMemberInput {
    storeOuterId!: string | undefined;
    memberNo!: string | undefined;
    name!: string;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    type!: string | undefined;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string | undefined;
    career!: string | undefined;
    income!: string | undefined;
    shippingAddresses!: ShippingAddressDto[] | undefined;
    from!: string | undefined;
    status!: string | undefined;

    constructor(data?: ICreateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeOuterId = data["storeOuterId"];
            this.memberNo = data["memberNo"];
            this.name = data["name"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.type = data["type"];
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
            this.from = data["from"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): CreateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["memberNo"] = this.memberNo;
        data["name"] = this.name;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["status"] = this.status;
        return data; 
    }
}

export interface ICreateMemberInput {
    storeOuterId: string | undefined;
    memberNo: string | undefined;
    name: string;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    type: string | undefined;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    weChatNickName: string | undefined;
    regPhone: string | undefined;
    career: string | undefined;
    income: string | undefined;
    shippingAddresses: ShippingAddressDto[] | undefined;
    from: string | undefined;
    status: string | undefined;
}

export class UpdateMemberInput implements IUpdateMemberInput {
    storeOuterId!: string | undefined;
    id!: number | undefined;
    memberNo!: string | undefined;
    name!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    type!: string | undefined;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string | undefined;
    career!: string | undefined;
    income!: string | undefined;
    shippingAddresses!: ShippingAddressDto[] | undefined;

    constructor(data?: IUpdateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeOuterId = data["storeOuterId"];
            this.id = data["id"];
            this.memberNo = data["memberNo"];
            this.name = data["name"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.type = data["type"];
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["name"] = this.name;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateMemberInput {
    storeOuterId: string | undefined;
    id: number | undefined;
    memberNo: string | undefined;
    name: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    type: string | undefined;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    weChatNickName: string | undefined;
    regPhone: string | undefined;
    career: string | undefined;
    income: string | undefined;
    shippingAddresses: ShippingAddressDto[] | undefined;
}

export class PagedResultDtoOfGetMemberLevelDto implements IPagedResultDtoOfGetMemberLevelDto {
    totalCount!: number | undefined;
    items!: GetMemberLevelDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMemberLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMemberLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMemberLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMemberLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMemberLevelDto {
    totalCount: number | undefined;
    items: GetMemberLevelDto[] | undefined;
}

export class GetMemberLevelDto implements IGetMemberLevelDto {
    id!: number | undefined;
    name!: string | undefined;
    levelKey!: string | undefined;
    condition!: number | undefined;
    discount!: number | undefined;

    constructor(data?: IGetMemberLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.levelKey = data["levelKey"];
            this.condition = data["condition"];
            this.discount = data["discount"];
        }
    }

    static fromJS(data: any): GetMemberLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["levelKey"] = this.levelKey;
        data["condition"] = this.condition;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IGetMemberLevelDto {
    id: number | undefined;
    name: string | undefined;
    levelKey: string | undefined;
    condition: number | undefined;
    discount: number | undefined;
}

export class AddOrUpdateMemberLevelInput implements IAddOrUpdateMemberLevelInput {
    id!: number | undefined;
    name!: string | undefined;
    levelKey!: string | undefined;
    condition!: number | undefined;
    discount!: number | undefined;

    constructor(data?: IAddOrUpdateMemberLevelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.levelKey = data["levelKey"];
            this.condition = data["condition"];
            this.discount = data["discount"];
        }
    }

    static fromJS(data: any): AddOrUpdateMemberLevelInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMemberLevelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["levelKey"] = this.levelKey;
        data["condition"] = this.condition;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IAddOrUpdateMemberLevelInput {
    id: number | undefined;
    name: string | undefined;
    levelKey: string | undefined;
    condition: number | undefined;
    discount: number | undefined;
}

export class AddOrUpdateCustomerInput implements IAddOrUpdateCustomerInput {
    id!: number | undefined;
    name!: string | undefined;
    legalPerson!: string | undefined;
    registeredCapital!: string | undefined;
    businessCode!: string | undefined;
    address!: string | undefined;
    description!: string | undefined;
    interest!: string | undefined;

    constructor(data?: IAddOrUpdateCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.legalPerson = data["legalPerson"];
            this.registeredCapital = data["registeredCapital"];
            this.businessCode = data["businessCode"];
            this.address = data["address"];
            this.description = data["description"];
            this.interest = data["interest"];
        }
    }

    static fromJS(data: any): AddOrUpdateCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["legalPerson"] = this.legalPerson;
        data["registeredCapital"] = this.registeredCapital;
        data["businessCode"] = this.businessCode;
        data["address"] = this.address;
        data["description"] = this.description;
        data["interest"] = this.interest;
        return data; 
    }
}

export interface IAddOrUpdateCustomerInput {
    id: number | undefined;
    name: string | undefined;
    legalPerson: string | undefined;
    registeredCapital: string | undefined;
    businessCode: string | undefined;
    address: string | undefined;
    description: string | undefined;
    interest: string | undefined;
}

export class PagedResultDtoOfCustomerDto implements IPagedResultDtoOfCustomerDto {
    totalCount!: number | undefined;
    items!: CustomerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerDto {
    totalCount: number | undefined;
    items: CustomerDto[] | undefined;
}

export class CustomerDto implements ICustomerDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    name!: string | undefined;
    legalPerson!: string | undefined;
    registeredCapital!: string | undefined;
    businessCode!: string | undefined;
    address!: string | undefined;
    description!: string | undefined;
    interest!: string | undefined;
    customerTags!: IdNameDto[] | undefined;
    customerSales!: IdNameDto[] | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.legalPerson = data["legalPerson"];
            this.registeredCapital = data["registeredCapital"];
            this.businessCode = data["businessCode"];
            this.address = data["address"];
            this.description = data["description"];
            this.interest = data["interest"];
            if (Array.isArray(data["customerTags"])) {
                this.customerTags = [] as any;
                for (let item of data["customerTags"])
                    this.customerTags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(data["customerSales"])) {
                this.customerSales = [] as any;
                for (let item of data["customerSales"])
                    this.customerSales!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["legalPerson"] = this.legalPerson;
        data["registeredCapital"] = this.registeredCapital;
        data["businessCode"] = this.businessCode;
        data["address"] = this.address;
        data["description"] = this.description;
        data["interest"] = this.interest;
        if (Array.isArray(this.customerTags)) {
            data["customerTags"] = [];
            for (let item of this.customerTags)
                data["customerTags"].push(item.toJSON());
        }
        if (Array.isArray(this.customerSales)) {
            data["customerSales"] = [];
            for (let item of this.customerSales)
                data["customerSales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    name: string | undefined;
    legalPerson: string | undefined;
    registeredCapital: string | undefined;
    businessCode: string | undefined;
    address: string | undefined;
    description: string | undefined;
    interest: string | undefined;
    customerTags: IdNameDto[] | undefined;
    customerSales: IdNameDto[] | undefined;
}

export class AddSalesToCustomerInput implements IAddSalesToCustomerInput {
    sales!: IdNameDto[] | undefined;
    customerId!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IAddSalesToCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["sales"])) {
                this.sales = [] as any;
                for (let item of data["sales"])
                    this.sales!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(data["customerId"])) {
                this.customerId = [] as any;
                for (let item of data["customerId"])
                    this.customerId!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): AddSalesToCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSalesToCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        if (Array.isArray(this.customerId)) {
            data["customerId"] = [];
            for (let item of this.customerId)
                data["customerId"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IAddSalesToCustomerInput {
    sales: IdNameDto[] | undefined;
    customerId: number[] | undefined;
    action: string | undefined;
}

export class AddMemberToCustomerInput implements IAddMemberToCustomerInput {
    memberIds!: number[] | undefined;
    customerId!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IAddMemberToCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of data["memberIds"])
                    this.memberIds!.push(item);
            }
            if (Array.isArray(data["customerId"])) {
                this.customerId = [] as any;
                for (let item of data["customerId"])
                    this.customerId!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): AddMemberToCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddMemberToCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        if (Array.isArray(this.customerId)) {
            data["customerId"] = [];
            for (let item of this.customerId)
                data["customerId"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IAddMemberToCustomerInput {
    memberIds: number[] | undefined;
    customerId: number[] | undefined;
    action: string | undefined;
}

export class PagedResultDtoOfMemberOuterDto implements IPagedResultDtoOfMemberOuterDto {
    totalCount!: number | undefined;
    items!: MemberOuterDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MemberOuterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMemberOuterDto {
    totalCount: number | undefined;
    items: MemberOuterDto[] | undefined;
}

export class MemberOuterDto implements IMemberOuterDto {
    id!: string | undefined;
    type!: string | undefined;
    storeId!: string | undefined;
    storeName!: string | undefined;
    registerdTime!: moment.Moment | undefined;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string | undefined;
    career!: string | undefined;
    income!: string | undefined;
    address!: ShippingAddressOuterDto[] | undefined;
    from!: string | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;

    constructor(data?: IMemberOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.registerdTime = data["registerdTime"] ? moment(data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["address"])) {
                this.address = [] as any;
                for (let item of data["address"])
                    this.address!.push(ShippingAddressOuterDto.fromJS(item));
            }
            this.from = data["from"];
            this.extraInfo1 = data["extraInfo1"];
            this.extraInfo2 = data["extraInfo2"];
            this.extraInfo3 = data["extraInfo3"];
            this.extraInfoX = data["extraInfoX"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): MemberOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        return data; 
    }
}

export interface IMemberOuterDto {
    id: string | undefined;
    type: string | undefined;
    storeId: string | undefined;
    storeName: string | undefined;
    registerdTime: moment.Moment | undefined;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    weChatNickName: string | undefined;
    regPhone: string | undefined;
    career: string | undefined;
    income: string | undefined;
    address: ShippingAddressOuterDto[] | undefined;
    from: string | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
}

export class ShippingAddressOuterDto implements IShippingAddressOuterDto {
    code!: string | undefined;
    phone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    normalizeName!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;

    constructor(data?: IShippingAddressOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phone = data["phone"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.normalizeName = data["normalizeName"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
        }
    }

    static fromJS(data: any): ShippingAddressOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddressOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        return data; 
    }
}

export interface IShippingAddressOuterDto {
    code: string | undefined;
    phone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    normalizeName: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
}

export class AddOrUpdateMemberOuterInput implements IAddOrUpdateMemberOuterInput {
    id!: string;
    type!: string;
    storeId!: string | undefined;
    storeName!: string | undefined;
    registerdTime!: moment.Moment;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    openId!: string | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string;
    career!: string | undefined;
    income!: string | undefined;
    address!: ShippingAddressOuterDto[] | undefined;
    from!: string | undefined;
    source!: string | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;

    constructor(data?: IAddOrUpdateMemberOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.registerdTime = data["registerdTime"] ? moment(data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.openId = data["openId"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["address"])) {
                this.address = [] as any;
                for (let item of data["address"])
                    this.address!.push(ShippingAddressOuterDto.fromJS(item));
            }
            this.from = data["from"];
            this.source = data["source"];
            this.extraInfo1 = data["extraInfo1"];
            this.extraInfo2 = data["extraInfo2"];
            this.extraInfo3 = data["extraInfo3"];
            this.extraInfoX = data["extraInfoX"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): AddOrUpdateMemberOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMemberOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["openId"] = this.openId;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["source"] = this.source;
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        return data; 
    }
}

export interface IAddOrUpdateMemberOuterInput {
    id: string;
    type: string;
    storeId: string | undefined;
    storeName: string | undefined;
    registerdTime: moment.Moment;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    openId: string | undefined;
    weChatNickName: string | undefined;
    regPhone: string;
    career: string | undefined;
    income: string | undefined;
    address: ShippingAddressOuterDto[] | undefined;
    from: string | undefined;
    source: string | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
}

export class DispatchPointToMemberInput implements IDispatchPointToMemberInput {
    memberIds!: number[] | undefined;
    openIds!: string[] | undefined;
    dispatchAmount!: number | undefined;
    pointFromType!: DispatchPointToMemberInputPointFromType | undefined;
    inOrOutType!: DispatchPointToMemberInputInOrOutType | undefined;
    thingId!: string | undefined;
    from!: string | undefined;
    description!: string | undefined;

    constructor(data?: IDispatchPointToMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of data["memberIds"])
                    this.memberIds!.push(item);
            }
            if (Array.isArray(data["openIds"])) {
                this.openIds = [] as any;
                for (let item of data["openIds"])
                    this.openIds!.push(item);
            }
            this.dispatchAmount = data["dispatchAmount"];
            this.pointFromType = data["pointFromType"];
            this.inOrOutType = data["inOrOutType"];
            this.thingId = data["thingId"];
            this.from = data["from"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): DispatchPointToMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchPointToMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        if (Array.isArray(this.openIds)) {
            data["openIds"] = [];
            for (let item of this.openIds)
                data["openIds"].push(item);
        }
        data["dispatchAmount"] = this.dispatchAmount;
        data["pointFromType"] = this.pointFromType;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["from"] = this.from;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDispatchPointToMemberInput {
    memberIds: number[] | undefined;
    openIds: string[] | undefined;
    dispatchAmount: number | undefined;
    pointFromType: DispatchPointToMemberInputPointFromType | undefined;
    inOrOutType: DispatchPointToMemberInputInOrOutType | undefined;
    thingId: string | undefined;
    from: string | undefined;
    description: string | undefined;
}

export class AddPointLogByMemberIdInput implements IAddPointLogByMemberIdInput {
    tenantId!: number | undefined;
    dispatchPointToMemberInput!: DispatchPointToMemberInput1 | undefined;

    constructor(data?: IAddPointLogByMemberIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.dispatchPointToMemberInput = data["dispatchPointToMemberInput"] ? DispatchPointToMemberInput1.fromJS(data["dispatchPointToMemberInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddPointLogByMemberIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddPointLogByMemberIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["dispatchPointToMemberInput"] = this.dispatchPointToMemberInput ? this.dispatchPointToMemberInput.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddPointLogByMemberIdInput {
    tenantId: number | undefined;
    dispatchPointToMemberInput: DispatchPointToMemberInput1 | undefined;
}

export class DispatchPointToMemberInput1 implements IDispatchPointToMemberInput1 {
    openId!: string | undefined;
    dispatchAmount!: number | undefined;
    pointFromType!: DispatchPointToMemberInput1PointFromType | undefined;
    inOrOutType!: DispatchPointToMemberInput1InOrOutType | undefined;
    thingId!: string | undefined;
    from!: string | undefined;
    description!: string | undefined;

    constructor(data?: IDispatchPointToMemberInput1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.dispatchAmount = data["dispatchAmount"];
            this.pointFromType = data["pointFromType"];
            this.inOrOutType = data["inOrOutType"];
            this.thingId = data["thingId"];
            this.from = data["from"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): DispatchPointToMemberInput1 {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchPointToMemberInput1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["dispatchAmount"] = this.dispatchAmount;
        data["pointFromType"] = this.pointFromType;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["from"] = this.from;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDispatchPointToMemberInput1 {
    openId: string | undefined;
    dispatchAmount: number | undefined;
    pointFromType: DispatchPointToMemberInput1PointFromType | undefined;
    inOrOutType: DispatchPointToMemberInput1InOrOutType | undefined;
    thingId: string | undefined;
    from: string | undefined;
    description: string | undefined;
}

export class PagedTotalResultDtoOfOrderDto implements IPagedTotalResultDtoOfOrderDto {
    totalSale!: number | undefined;
    totalCount!: number | undefined;
    items!: OrderDto[] | undefined;

    constructor(data?: IPagedTotalResultDtoOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSale = data["totalSale"];
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedTotalResultDtoOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedTotalResultDtoOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedTotalResultDtoOfOrderDto {
    totalSale: number | undefined;
    totalCount: number | undefined;
    items: OrderDto[] | undefined;
}

export class OrderWithTotalSaleDto implements IOrderWithTotalSaleDto {
    amount!: number | undefined;
    orders!: PagedResultDtoOfOrderDto | undefined;

    constructor(data?: IOrderWithTotalSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.orders = data["orders"] ? PagedResultDtoOfOrderDto.fromJS(data["orders"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderWithTotalSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderWithTotalSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["orders"] = this.orders ? this.orders.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOrderWithTotalSaleDto {
    amount: number | undefined;
    orders: PagedResultDtoOfOrderDto | undefined;
}

export class PagedResultDtoOfOrderDto implements IPagedResultDtoOfOrderDto {
    totalCount!: number | undefined;
    items!: OrderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrderDto {
    totalCount: number | undefined;
    items: OrderDto[] | undefined;
}

export class GetItemSalesBySkuIdInput implements IGetItemSalesBySkuIdInput {
    skuIds!: string[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IGetItemSalesBySkuIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetItemSalesBySkuIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemSalesBySkuIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetItemSalesBySkuIdInput {
    skuIds: string[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class GetItemSalesDto implements IGetItemSalesDto {
    skuId!: string | undefined;
    saleNumber!: number | undefined;
    saleAmount!: number | undefined;

    constructor(data?: IGetItemSalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.saleNumber = data["saleNumber"];
            this.saleAmount = data["saleAmount"];
        }
    }

    static fromJS(data: any): GetItemSalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemSalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["saleNumber"] = this.saleNumber;
        data["saleAmount"] = this.saleAmount;
        return data; 
    }
}

export interface IGetItemSalesDto {
    skuId: string | undefined;
    saleNumber: number | undefined;
    saleAmount: number | undefined;
}

export class OrderSkuInput implements IOrderSkuInput {
    memberId!: number | undefined;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IOrderSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.orderDateTimeStart = data["orderDateTimeStart"] ? moment(data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = data["orderDateTimeEnd"] ? moment(data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): OrderSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IOrderSkuInput {
    memberId: number | undefined;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfOrderSkuDto implements IPagedResultDtoOfOrderSkuDto {
    totalCount!: number | undefined;
    items!: OrderSkuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrderSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderSkuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrderSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrderSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrderSkuDto {
    totalCount: number | undefined;
    items: OrderSkuDto[] | undefined;
}

export class OrderSkuDto implements IOrderSkuDto {
    orderDateTime!: moment.Moment | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number | undefined;
    totalFee!: number | undefined;
    taxFee!: number | undefined;
    discountFee!: number | undefined;
    payment!: number | undefined;

    constructor(data?: IOrderSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.discountFee = data["discountFee"];
            this.payment = data["payment"];
        }
    }

    static fromJS(data: any): OrderSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["discountFee"] = this.discountFee;
        data["payment"] = this.payment;
        return data; 
    }
}

export interface IOrderSkuDto {
    orderDateTime: moment.Moment | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number | undefined;
    totalFee: number | undefined;
    taxFee: number | undefined;
    discountFee: number | undefined;
    payment: number | undefined;
}

export class CreateOrderInput implements ICreateOrderInput {
    orderNO!: string;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    number!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    status!: string | undefined;
    payment!: number;
    totalFee!: number;
    discountFee!: number;
    postFee!: number;
    taxFee!: number | undefined;
    payTime!: moment.Moment | undefined;
    payType!: string | undefined;
    addressId!: number | undefined;
    orderItems!: OrderItemDto[] | undefined;

    constructor(data?: ICreateOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderNO = data["orderNO"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.number = data["number"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.status = data["status"];
            this.payment = data["payment"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.postFee = data["postFee"];
            this.taxFee = data["taxFee"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.payType = data["payType"];
            this.addressId = data["addressId"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(OrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNO"] = this.orderNO;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["number"] = this.number;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["postFee"] = this.postFee;
        data["taxFee"] = this.taxFee;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["addressId"] = this.addressId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrderInput {
    orderNO: string;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    number: string | undefined;
    orderDateTime: moment.Moment | undefined;
    status: string | undefined;
    payment: number;
    totalFee: number;
    discountFee: number;
    postFee: number;
    taxFee: number | undefined;
    payTime: moment.Moment | undefined;
    payType: string | undefined;
    addressId: number | undefined;
    orderItems: OrderItemDto[] | undefined;
}

export class UpdateOrderInput implements IUpdateOrderInput {
    id!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    status!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    payType!: string | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    addressId!: number | undefined;

    constructor(data?: IUpdateOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.status = data["status"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.payType = data["payType"];
            this.consignTime = data["consignTime"] ? moment(data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = data["returnsTime"] ? moment(data["returnsTime"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
        }
    }

    static fromJS(data: any): UpdateOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["status"] = this.status;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        return data; 
    }
}

export interface IUpdateOrderInput {
    id: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    status: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    payType: string | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    addressId: number | undefined;
}

export class UpdateOrderItemInput implements IUpdateOrderItemInput {
    id!: number | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number | undefined;
    totalFee!: number | undefined;
    taxFee!: number | undefined;
    payment!: number | undefined;
    status!: string | undefined;

    constructor(data?: IUpdateOrderItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.payment = data["payment"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): UpdateOrderItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateOrderItemInput {
    id: number | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number | undefined;
    totalFee: number | undefined;
    taxFee: number | undefined;
    payment: number | undefined;
    status: string | undefined;
}

export class SaleReportInput implements ISaleReportInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    storeIds!: number[] | undefined;
    type!: string | undefined;
    storeDeviceInfo!: string | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: ISaleReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.type = data["type"];
            this.storeDeviceInfo = data["storeDeviceInfo"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): SaleReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["type"] = this.type;
        data["storeDeviceInfo"] = this.storeDeviceInfo;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISaleReportInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    storeIds: number[] | undefined;
    type: string | undefined;
    storeDeviceInfo: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfSalesCurrentDayReportDto implements IPagedResultDtoOfSalesCurrentDayReportDto {
    totalCount!: number | undefined;
    items!: SalesCurrentDayReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSalesCurrentDayReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SalesCurrentDayReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSalesCurrentDayReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSalesCurrentDayReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSalesCurrentDayReportDto {
    totalCount: number | undefined;
    items: SalesCurrentDayReportDto[] | undefined;
}

export class SalesCurrentDayReportDto implements ISalesCurrentDayReportDto {
    areaName!: string | undefined;
    provinceName!: string | undefined;
    cityName!: string | undefined;
    outerId!: string | undefined;
    storeName!: string | undefined;
    storeType!: string | undefined;
    deviceType!: string | undefined;
    storeStatus!: string | undefined;
    registMemberCount!: number | undefined;
    orderCount!: number | undefined;
    orderItemsCount!: number | undefined;
    sumPayment!: number | undefined;
    totalCount!: number | undefined;

    constructor(data?: ISalesCurrentDayReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.areaName = data["areaName"];
            this.provinceName = data["provinceName"];
            this.cityName = data["cityName"];
            this.outerId = data["outerId"];
            this.storeName = data["storeName"];
            this.storeType = data["storeType"];
            this.deviceType = data["deviceType"];
            this.storeStatus = data["storeStatus"];
            this.registMemberCount = data["registMemberCount"];
            this.orderCount = data["orderCount"];
            this.orderItemsCount = data["orderItemsCount"];
            this.sumPayment = data["sumPayment"];
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): SalesCurrentDayReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesCurrentDayReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaName"] = this.areaName;
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["storeType"] = this.storeType;
        data["deviceType"] = this.deviceType;
        data["storeStatus"] = this.storeStatus;
        data["registMemberCount"] = this.registMemberCount;
        data["orderCount"] = this.orderCount;
        data["orderItemsCount"] = this.orderItemsCount;
        data["sumPayment"] = this.sumPayment;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface ISalesCurrentDayReportDto {
    areaName: string | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    outerId: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    deviceType: string | undefined;
    storeStatus: string | undefined;
    registMemberCount: number | undefined;
    orderCount: number | undefined;
    orderItemsCount: number | undefined;
    sumPayment: number | undefined;
    totalCount: number | undefined;
}

export class GetSaleItemDetailInput implements IGetSaleItemDetailInput {
    storeIds!: number[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    activtyTags!: string[] | undefined;
    brandNames!: string[] | undefined;
    discounts!: string[] | undefined;
    categorys!: string[] | undefined;
    subCategorys!: string[] | undefined;
    skuId!: string | undefined;
    groupByStore!: string | undefined;
    groupByProduct!: string | undefined;
    groupByMember!: string | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IGetSaleItemDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["activtyTags"])) {
                this.activtyTags = [] as any;
                for (let item of data["activtyTags"])
                    this.activtyTags!.push(item);
            }
            if (Array.isArray(data["brandNames"])) {
                this.brandNames = [] as any;
                for (let item of data["brandNames"])
                    this.brandNames!.push(item);
            }
            if (Array.isArray(data["discounts"])) {
                this.discounts = [] as any;
                for (let item of data["discounts"])
                    this.discounts!.push(item);
            }
            if (Array.isArray(data["categorys"])) {
                this.categorys = [] as any;
                for (let item of data["categorys"])
                    this.categorys!.push(item);
            }
            if (Array.isArray(data["subCategorys"])) {
                this.subCategorys = [] as any;
                for (let item of data["subCategorys"])
                    this.subCategorys!.push(item);
            }
            this.skuId = data["skuId"];
            this.groupByStore = data["groupByStore"];
            this.groupByProduct = data["groupByProduct"];
            this.groupByMember = data["groupByMember"];
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetSaleItemDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSaleItemDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.activtyTags)) {
            data["activtyTags"] = [];
            for (let item of this.activtyTags)
                data["activtyTags"].push(item);
        }
        if (Array.isArray(this.brandNames)) {
            data["brandNames"] = [];
            for (let item of this.brandNames)
                data["brandNames"].push(item);
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item);
        }
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        if (Array.isArray(this.subCategorys)) {
            data["subCategorys"] = [];
            for (let item of this.subCategorys)
                data["subCategorys"].push(item);
        }
        data["skuId"] = this.skuId;
        data["groupByStore"] = this.groupByStore;
        data["groupByProduct"] = this.groupByProduct;
        data["groupByMember"] = this.groupByMember;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetSaleItemDetailInput {
    storeIds: number[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    activtyTags: string[] | undefined;
    brandNames: string[] | undefined;
    discounts: string[] | undefined;
    categorys: string[] | undefined;
    subCategorys: string[] | undefined;
    skuId: string | undefined;
    groupByStore: string | undefined;
    groupByProduct: string | undefined;
    groupByMember: string | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfSalesItemDetailReportDto implements IPagedResultDtoOfSalesItemDetailReportDto {
    totalCount!: number | undefined;
    items!: SalesItemDetailReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSalesItemDetailReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SalesItemDetailReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSalesItemDetailReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSalesItemDetailReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSalesItemDetailReportDto {
    totalCount: number | undefined;
    items: SalesItemDetailReportDto[] | undefined;
}

export class SalesItemDetailReportDto implements ISalesItemDetailReportDto {
    areaName!: string | undefined;
    provinceName!: string | undefined;
    cityName!: string | undefined;
    outerId!: string | undefined;
    storeName!: string | undefined;
    storeType!: string | undefined;
    deviceType!: string | undefined;
    storeStatus!: string | undefined;
    memberNo!: string | undefined;
    memberLevel!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    orderNO!: string | undefined;
    brandName!: string | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    category!: string | undefined;
    subCategory!: string | undefined;
    payTime!: moment.Moment | undefined;
    orderStatus!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean | undefined;
    number!: number | undefined;
    payment!: number | undefined;
    nullValue!: any | undefined;

    constructor(data?: ISalesItemDetailReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.areaName = data["areaName"];
            this.provinceName = data["provinceName"];
            this.cityName = data["cityName"];
            this.outerId = data["outerId"];
            this.storeName = data["storeName"];
            this.storeType = data["storeType"];
            this.deviceType = data["deviceType"];
            this.storeStatus = data["storeStatus"];
            this.memberNo = data["memberNo"];
            this.memberLevel = data["memberLevel"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.orderNO = data["orderNO"];
            this.brandName = data["brandName"];
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.category = data["category"];
            this.subCategory = data["subCategory"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.orderStatus = data["orderStatus"];
            this.activityTag = data["activityTag"];
            this.discount = data["discount"];
            this.isSuite = data["isSuite"];
            this.number = data["number"];
            this.payment = data["payment"];
            this.nullValue = data["nullValue"];
        }
    }

    static fromJS(data: any): SalesItemDetailReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesItemDetailReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaName"] = this.areaName;
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["storeType"] = this.storeType;
        data["deviceType"] = this.deviceType;
        data["storeStatus"] = this.storeStatus;
        data["memberNo"] = this.memberNo;
        data["memberLevel"] = this.memberLevel;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["orderNO"] = this.orderNO;
        data["brandName"] = this.brandName;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["number"] = this.number;
        data["payment"] = this.payment;
        data["nullValue"] = this.nullValue;
        return data; 
    }
}

export interface ISalesItemDetailReportDto {
    areaName: string | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    outerId: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    deviceType: string | undefined;
    storeStatus: string | undefined;
    memberNo: string | undefined;
    memberLevel: string | undefined;
    orderDateTime: moment.Moment | undefined;
    orderNO: string | undefined;
    brandName: string | undefined;
    skuId: string | undefined;
    title: string | undefined;
    category: string | undefined;
    subCategory: string | undefined;
    payTime: moment.Moment | undefined;
    orderStatus: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean | undefined;
    number: number | undefined;
    payment: number | undefined;
    nullValue: any | undefined;
}

export class PrintOrderDto implements IPrintOrderDto {
    orderId!: number | undefined;
    printPicUrl!: string | undefined;
    picUrl!: string | undefined;
    gcodeFileUrl!: string | undefined;
    printState!: PrintOrderDtoPrintState | undefined;
    printStateDescription!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;

    constructor(data?: IPrintOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.printPicUrl = data["printPicUrl"];
            this.picUrl = data["picUrl"];
            this.gcodeFileUrl = data["gcodeFileUrl"];
            this.printState = data["printState"];
            this.printStateDescription = data["printStateDescription"];
            this.startPrintDataTime = data["startPrintDataTime"] ? moment(data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = data["endPrintDateTime"] ? moment(data["endPrintDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrintOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["printPicUrl"] = this.printPicUrl;
        data["picUrl"] = this.picUrl;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        data["printState"] = this.printState;
        data["printStateDescription"] = this.printStateDescription;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPrintOrderDto {
    orderId: number | undefined;
    printPicUrl: string | undefined;
    picUrl: string | undefined;
    gcodeFileUrl: string | undefined;
    printState: PrintOrderDtoPrintState | undefined;
    printStateDescription: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
}

export class AddOrUpdateOrderExtensionInput implements IAddOrUpdateOrderExtensionInput {
    orderId!: number | undefined;
    skuId!: number | undefined;
    mediaId!: string | undefined;
    printState!: AddOrUpdateOrderExtensionInputPrintState | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IAddOrUpdateOrderExtensionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.skuId = data["skuId"];
            this.mediaId = data["mediaId"];
            this.printState = data["printState"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderExtensionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderExtensionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["skuId"] = this.skuId;
        data["mediaId"] = this.mediaId;
        data["printState"] = this.printState;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IAddOrUpdateOrderExtensionInput {
    orderId: number | undefined;
    skuId: number | undefined;
    mediaId: string | undefined;
    printState: AddOrUpdateOrderExtensionInputPrintState | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class PrintOrderCountDto implements IPrintOrderCountDto {
    totalOrderCount!: number | undefined;
    completeOrderCount!: number | undefined;
    incompleteOrderCount!: number | undefined;
    totalPrintOrderActions!: PrintOrderAction[] | undefined;
    completePrintOrderActions!: PrintOrderAction[] | undefined;
    incompletePrintOrderActions!: PrintOrderAction[] | undefined;

    constructor(data?: IPrintOrderCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalOrderCount = data["totalOrderCount"];
            this.completeOrderCount = data["completeOrderCount"];
            this.incompleteOrderCount = data["incompleteOrderCount"];
            if (Array.isArray(data["totalPrintOrderActions"])) {
                this.totalPrintOrderActions = [] as any;
                for (let item of data["totalPrintOrderActions"])
                    this.totalPrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
            if (Array.isArray(data["completePrintOrderActions"])) {
                this.completePrintOrderActions = [] as any;
                for (let item of data["completePrintOrderActions"])
                    this.completePrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
            if (Array.isArray(data["incompletePrintOrderActions"])) {
                this.incompletePrintOrderActions = [] as any;
                for (let item of data["incompletePrintOrderActions"])
                    this.incompletePrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrintOrderCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderCount"] = this.totalOrderCount;
        data["completeOrderCount"] = this.completeOrderCount;
        data["incompleteOrderCount"] = this.incompleteOrderCount;
        if (Array.isArray(this.totalPrintOrderActions)) {
            data["totalPrintOrderActions"] = [];
            for (let item of this.totalPrintOrderActions)
                data["totalPrintOrderActions"].push(item.toJSON());
        }
        if (Array.isArray(this.completePrintOrderActions)) {
            data["completePrintOrderActions"] = [];
            for (let item of this.completePrintOrderActions)
                data["completePrintOrderActions"].push(item.toJSON());
        }
        if (Array.isArray(this.incompletePrintOrderActions)) {
            data["incompletePrintOrderActions"] = [];
            for (let item of this.incompletePrintOrderActions)
                data["incompletePrintOrderActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPrintOrderCountDto {
    totalOrderCount: number | undefined;
    completeOrderCount: number | undefined;
    incompleteOrderCount: number | undefined;
    totalPrintOrderActions: PrintOrderAction[] | undefined;
    completePrintOrderActions: PrintOrderAction[] | undefined;
    incompletePrintOrderActions: PrintOrderAction[] | undefined;
}

export class PrintOrderAction implements IPrintOrderAction {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    dateTime!: moment.Moment | undefined;
    printState!: PrintOrderActionPrintState | undefined;

    constructor(data?: IPrintOrderAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headImgUrl = data["headImgUrl"];
            this.nickName = data["nickName"];
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.printState = data["printState"];
        }
    }

    static fromJS(data: any): PrintOrderAction {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["printState"] = this.printState;
        return data; 
    }
}

export interface IPrintOrderAction {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    dateTime: moment.Moment | undefined;
    printState: PrintOrderActionPrintState | undefined;
}

export class PagedResultDtoOfOrderOuterDto implements IPagedResultDtoOfOrderOuterDto {
    totalCount!: number | undefined;
    items!: OrderOuterDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrderOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderOuterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrderOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrderOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrderOuterDto {
    totalCount: number | undefined;
    items: OrderOuterDto[] | undefined;
}

export class OrderOuterDto implements IOrderOuterDto {
    id!: string | undefined;
    orderDateTime!: string | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    taxFee!: number | undefined;
    postFee!: number | undefined;
    payment!: number | undefined;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    status!: string | undefined;
    storeId!: string | undefined;
    storeName!: string | undefined;
    from!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    memberId!: number | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;

    constructor(data?: IOrderOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orderDateTime = data["orderDateTime"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.taxFee = data["taxFee"];
            this.postFee = data["postFee"];
            this.payment = data["payment"];
            this.payType = data["payType"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.consignTime = data["consignTime"] ? moment(data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = data["returnsTime"] ? moment(data["returnsTime"].toString()) : <any>undefined;
            this.status = data["status"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.from = data["from"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.memberId = data["memberId"];
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
        }
    }

    static fromJS(data: any): OrderOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderDateTime"] = this.orderDateTime;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        return data; 
    }
}

export interface IOrderOuterDto {
    id: string | undefined;
    orderDateTime: string | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    taxFee: number | undefined;
    postFee: number | undefined;
    payment: number | undefined;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    status: string | undefined;
    storeId: string | undefined;
    storeName: string | undefined;
    from: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    memberId: number | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
}

export class AddOrUpdateOrderItemOuterInput implements IAddOrUpdateOrderItemOuterInput {
    skuId!: string;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number;
    totalFee!: number;
    taxFee!: number;
    payment!: number;
    status!: string | undefined;
    brandName!: string | undefined;
    category!: string | undefined;
    subCategory!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean | undefined;
    rfid!: string | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateOrderItemOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.payment = data["payment"];
            this.status = data["status"];
            this.brandName = data["brandName"];
            this.category = data["category"];
            this.subCategory = data["subCategory"];
            this.activityTag = data["activityTag"];
            this.discount = data["discount"];
            this.isSuite = data["isSuite"];
            this.rfid = data["rfid"];
            this.activityId = data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderItemOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderItemOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["rfid"] = this.rfid;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateOrderItemOuterInput {
    skuId: string;
    title: string | undefined;
    picUrl: string | undefined;
    number: number;
    totalFee: number;
    taxFee: number;
    payment: number;
    status: string | undefined;
    brandName: string | undefined;
    category: string | undefined;
    subCategory: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean | undefined;
    rfid: string | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateOrderOuterInput implements IAddOrUpdateOrderOuterInput {
    id!: string;
    orderDateTime!: moment.Moment;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    status!: string;
    storeId!: string | undefined;
    storeName!: string | undefined;
    from!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    buyer!: Buyer | undefined;
    source!: string | undefined;

    constructor(data?: IAddOrUpdateOrderOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.taxFee = data["taxFee"];
            this.postFee = data["postFee"];
            this.payment = data["payment"];
            this.payType = data["payType"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.consignTime = data["consignTime"] ? moment(data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = data["returnsTime"] ? moment(data["returnsTime"].toString()) : <any>undefined;
            this.status = data["status"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.from = data["from"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.buyer = data["buyer"] ? Buyer.fromJS(data["buyer"]) : <any>undefined;
            this.source = data["source"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["buyer"] = this.buyer ? this.buyer.toJSON() : <any>undefined;
        data["source"] = this.source;
        return data; 
    }
}

export interface IAddOrUpdateOrderOuterInput {
    id: string;
    orderDateTime: moment.Moment;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    status: string;
    storeId: string | undefined;
    storeName: string | undefined;
    from: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    buyer: Buyer | undefined;
    source: string | undefined;
}

export class Buyer implements IBuyer {
    memberId!: string | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;

    constructor(data?: IBuyer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
        }
    }

    static fromJS(data: any): Buyer {
        data = typeof data === 'object' ? data : {};
        let result = new Buyer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        return data; 
    }
}

export interface IBuyer {
    memberId: string | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
}

export class PagedResultDtoOfGetPayRecordDto implements IPagedResultDtoOfGetPayRecordDto {
    totalCount!: number | undefined;
    items!: GetPayRecordDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPayRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPayRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPayRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPayRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPayRecordDto {
    totalCount: number | undefined;
    items: GetPayRecordDto[] | undefined;
}

export class GetPayRecordDto implements IGetPayRecordDto {
    id!: number | undefined;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    memberId!: number | undefined;
    orderNo!: string | undefined;
    orderId!: number | undefined;
    orderFrom!: string | undefined;
    payFrom!: string | undefined;
    tradNumber!: string | undefined;
    payAccount!: string | undefined;
    payTime!: moment.Moment | undefined;
    payAmount!: number | undefined;
    payType!: GetPayRecordDtoPayType | undefined;

    constructor(data?: IGetPayRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.storeId = data["storeId"];
            this.storeOuterId = data["storeOuterId"];
            this.memberId = data["memberId"];
            this.orderNo = data["orderNo"];
            this.orderId = data["orderId"];
            this.orderFrom = data["orderFrom"];
            this.payFrom = data["payFrom"];
            this.tradNumber = data["tradNumber"];
            this.payAccount = data["payAccount"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.payAmount = data["payAmount"];
            this.payType = data["payType"];
        }
    }

    static fromJS(data: any): GetPayRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["memberId"] = this.memberId;
        data["orderNo"] = this.orderNo;
        data["orderId"] = this.orderId;
        data["orderFrom"] = this.orderFrom;
        data["payFrom"] = this.payFrom;
        data["tradNumber"] = this.tradNumber;
        data["payAccount"] = this.payAccount;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["payAmount"] = this.payAmount;
        data["payType"] = this.payType;
        return data; 
    }
}

export interface IGetPayRecordDto {
    id: number | undefined;
    storeId: number | undefined;
    storeOuterId: string | undefined;
    memberId: number | undefined;
    orderNo: string | undefined;
    orderId: number | undefined;
    orderFrom: string | undefined;
    payFrom: string | undefined;
    tradNumber: string | undefined;
    payAccount: string | undefined;
    payTime: moment.Moment | undefined;
    payAmount: number | undefined;
    payType: GetPayRecordDtoPayType | undefined;
}

export class AddOrUpdatePayAccountInput implements IAddOrUpdatePayAccountInput {
    id!: number | undefined;
    appID!: string | undefined;
    from!: string | undefined;
    parameters!: any | undefined;
    name!: string | undefined;
    description!: string | undefined;
    auditStatus!: boolean | undefined;

    constructor(data?: IAddOrUpdatePayAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appID = data["appID"];
            this.from = data["from"];
            this.parameters = data["parameters"];
            this.name = data["name"];
            this.description = data["description"];
            this.auditStatus = data["auditStatus"];
        }
    }

    static fromJS(data: any): AddOrUpdatePayAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdatePayAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appID"] = this.appID;
        data["from"] = this.from;
        data["parameters"] = this.parameters;
        data["name"] = this.name;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        return data; 
    }
}

export interface IAddOrUpdatePayAccountInput {
    id: number | undefined;
    appID: string | undefined;
    from: string | undefined;
    parameters: any | undefined;
    name: string | undefined;
    description: string | undefined;
    auditStatus: boolean | undefined;
}

export class PagedResultDtoOfGetPayAccountDto implements IPagedResultDtoOfGetPayAccountDto {
    totalCount!: number | undefined;
    items!: GetPayAccountDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPayAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPayAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPayAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPayAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPayAccountDto {
    totalCount: number | undefined;
    items: GetPayAccountDto[] | undefined;
}

export class GetPayAccountDto implements IGetPayAccountDto {
    id!: number | undefined;
    appID!: string | undefined;
    from!: string | undefined;
    parameters!: any | undefined;
    name!: string | undefined;
    description!: string | undefined;
    auditStatus!: boolean | undefined;

    constructor(data?: IGetPayAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appID = data["appID"];
            this.from = data["from"];
            this.parameters = data["parameters"];
            this.name = data["name"];
            this.description = data["description"];
            this.auditStatus = data["auditStatus"];
        }
    }

    static fromJS(data: any): GetPayAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appID"] = this.appID;
        data["from"] = this.from;
        data["parameters"] = this.parameters;
        data["name"] = this.name;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        return data; 
    }
}

export interface IGetPayAccountDto {
    id: number | undefined;
    appID: string | undefined;
    from: string | undefined;
    parameters: any | undefined;
    name: string | undefined;
    description: string | undefined;
    auditStatus: boolean | undefined;
}

export class NameValueTimeDto implements INameValueTimeDto {
    seconds!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seconds = data["seconds"];
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seconds"] = this.seconds;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueTimeDto {
    seconds: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class TotalOrderAndSaleDto implements ITotalOrderAndSaleDto {
    orderCount!: number | undefined;
    consumerCount!: number | undefined;
    orderSales!: number | undefined;

    constructor(data?: ITotalOrderAndSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCount = data["orderCount"];
            this.consumerCount = data["consumerCount"];
            this.orderSales = data["orderSales"];
        }
    }

    static fromJS(data: any): TotalOrderAndSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalOrderAndSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCount"] = this.orderCount;
        data["consumerCount"] = this.consumerCount;
        data["orderSales"] = this.orderSales;
        return data; 
    }
}

export interface ITotalOrderAndSaleDto {
    orderCount: number | undefined;
    consumerCount: number | undefined;
    orderSales: number | undefined;
}

export class RetailingReportDto implements IRetailingReportDto {
    totalOrderAndSaleDto!: TotalOrderAndSaleDto | undefined;
    orderSalesChartDto!: OrderSalesChartDto | undefined;
    productSaleChartDto!: ProductSaleChartDto | undefined;
    userActionsDto!: UserActionsDto | undefined;
    behaviorDto!: BehaviorDto | undefined;
    interactiveAndShareDto!: InteractiveShareAndFansDto | undefined;
    gameActionEffectDto!: GameActionEffectDto | undefined;
    gameScoreDto!: GameScoreDto | undefined;

    constructor(data?: IRetailingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalOrderAndSaleDto = data["totalOrderAndSaleDto"] ? TotalOrderAndSaleDto.fromJS(data["totalOrderAndSaleDto"]) : <any>undefined;
            this.orderSalesChartDto = data["orderSalesChartDto"] ? OrderSalesChartDto.fromJS(data["orderSalesChartDto"]) : <any>undefined;
            this.productSaleChartDto = data["productSaleChartDto"] ? ProductSaleChartDto.fromJS(data["productSaleChartDto"]) : <any>undefined;
            this.userActionsDto = data["userActionsDto"] ? UserActionsDto.fromJS(data["userActionsDto"]) : <any>undefined;
            this.behaviorDto = data["behaviorDto"] ? BehaviorDto.fromJS(data["behaviorDto"]) : <any>undefined;
            this.interactiveAndShareDto = data["interactiveAndShareDto"] ? InteractiveShareAndFansDto.fromJS(data["interactiveAndShareDto"]) : <any>undefined;
            this.gameActionEffectDto = data["gameActionEffectDto"] ? GameActionEffectDto.fromJS(data["gameActionEffectDto"]) : <any>undefined;
            this.gameScoreDto = data["gameScoreDto"] ? GameScoreDto.fromJS(data["gameScoreDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetailingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderAndSaleDto"] = this.totalOrderAndSaleDto ? this.totalOrderAndSaleDto.toJSON() : <any>undefined;
        data["orderSalesChartDto"] = this.orderSalesChartDto ? this.orderSalesChartDto.toJSON() : <any>undefined;
        data["productSaleChartDto"] = this.productSaleChartDto ? this.productSaleChartDto.toJSON() : <any>undefined;
        data["userActionsDto"] = this.userActionsDto ? this.userActionsDto.toJSON() : <any>undefined;
        data["behaviorDto"] = this.behaviorDto ? this.behaviorDto.toJSON() : <any>undefined;
        data["interactiveAndShareDto"] = this.interactiveAndShareDto ? this.interactiveAndShareDto.toJSON() : <any>undefined;
        data["gameActionEffectDto"] = this.gameActionEffectDto ? this.gameActionEffectDto.toJSON() : <any>undefined;
        data["gameScoreDto"] = this.gameScoreDto ? this.gameScoreDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRetailingReportDto {
    totalOrderAndSaleDto: TotalOrderAndSaleDto | undefined;
    orderSalesChartDto: OrderSalesChartDto | undefined;
    productSaleChartDto: ProductSaleChartDto | undefined;
    userActionsDto: UserActionsDto | undefined;
    behaviorDto: BehaviorDto | undefined;
    interactiveAndShareDto: InteractiveShareAndFansDto | undefined;
    gameActionEffectDto: GameActionEffectDto | undefined;
    gameScoreDto: GameScoreDto | undefined;
}

export class OrderSalesChartDto implements IOrderSalesChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalSale!: number | undefined;

    constructor(data?: IOrderSalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.totalSale = data["totalSale"];
        }
    }

    static fromJS(data: any): OrderSalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalSale"] = this.totalSale;
        return data; 
    }
}

export interface IOrderSalesChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalSale: number | undefined;
}

export class ProductSaleChartDto implements IProductSaleChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IProductSaleChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductSaleChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSaleChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IProductSaleChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
}

export class UserActionsDto implements IUserActionsDto {
    userActions!: SimpleUserAction[] | undefined;

    constructor(data?: IUserActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["userActions"])) {
                this.userActions = [] as any;
                for (let item of data["userActions"])
                    this.userActions!.push(SimpleUserAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserActionsDto {
    userActions: SimpleUserAction[] | undefined;
}

export class BehaviorDto implements IBehaviorDto {
    templateChartDtos!: TemplateChartDto[] | undefined;

    constructor(data?: IBehaviorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["templateChartDtos"])) {
                this.templateChartDtos = [] as any;
                for (let item of data["templateChartDtos"])
                    this.templateChartDtos!.push(TemplateChartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BehaviorDto {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.templateChartDtos)) {
            data["templateChartDtos"] = [];
            for (let item of this.templateChartDtos)
                data["templateChartDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBehaviorDto {
    templateChartDtos: TemplateChartDto[] | undefined;
}

export class InteractiveShareAndFansDto implements IInteractiveShareAndFansDto {
    interactives!: InteractiveDto[] | undefined;
    totalInteractives!: number | undefined;
    shares!: ShareDto[] | undefined;
    totalShares!: number | undefined;
    fans!: FanDto[] | undefined;
    totalFans!: number | undefined;

    constructor(data?: IInteractiveShareAndFansDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["interactives"])) {
                this.interactives = [] as any;
                for (let item of data["interactives"])
                    this.interactives!.push(InteractiveDto.fromJS(item));
            }
            this.totalInteractives = data["totalInteractives"];
            if (Array.isArray(data["shares"])) {
                this.shares = [] as any;
                for (let item of data["shares"])
                    this.shares!.push(ShareDto.fromJS(item));
            }
            this.totalShares = data["totalShares"];
            if (Array.isArray(data["fans"])) {
                this.fans = [] as any;
                for (let item of data["fans"])
                    this.fans!.push(FanDto.fromJS(item));
            }
            this.totalFans = data["totalFans"];
        }
    }

    static fromJS(data: any): InteractiveShareAndFansDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveShareAndFansDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.interactives)) {
            data["interactives"] = [];
            for (let item of this.interactives)
                data["interactives"].push(item.toJSON());
        }
        data["totalInteractives"] = this.totalInteractives;
        if (Array.isArray(this.shares)) {
            data["shares"] = [];
            for (let item of this.shares)
                data["shares"].push(item.toJSON());
        }
        data["totalShares"] = this.totalShares;
        if (Array.isArray(this.fans)) {
            data["fans"] = [];
            for (let item of this.fans)
                data["fans"].push(item.toJSON());
        }
        data["totalFans"] = this.totalFans;
        return data; 
    }
}

export interface IInteractiveShareAndFansDto {
    interactives: InteractiveDto[] | undefined;
    totalInteractives: number | undefined;
    shares: ShareDto[] | undefined;
    totalShares: number | undefined;
    fans: FanDto[] | undefined;
    totalFans: number | undefined;
}

export class GameActionEffectDto implements IGameActionEffectDto {
    cargo!: DollMachine | undefined;
    doll!: DollMachine | undefined;
    others!: DollMachine | undefined;

    constructor(data?: IGameActionEffectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cargo = data["cargo"] ? DollMachine.fromJS(data["cargo"]) : <any>undefined;
            this.doll = data["doll"] ? DollMachine.fromJS(data["doll"]) : <any>undefined;
            this.others = data["others"] ? DollMachine.fromJS(data["others"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GameActionEffectDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameActionEffectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargo"] = this.cargo ? this.cargo.toJSON() : <any>undefined;
        data["doll"] = this.doll ? this.doll.toJSON() : <any>undefined;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGameActionEffectDto {
    cargo: DollMachine | undefined;
    doll: DollMachine | undefined;
    others: DollMachine | undefined;
}

export class GameScoreDto implements IGameScoreDto {
    gameRanks!: GameRanks[] | undefined;

    constructor(data?: IGameScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["gameRanks"])) {
                this.gameRanks = [] as any;
                for (let item of data["gameRanks"])
                    this.gameRanks!.push(GameRanks.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gameRanks)) {
            data["gameRanks"] = [];
            for (let item of this.gameRanks)
                data["gameRanks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGameScoreDto {
    gameRanks: GameRanks[] | undefined;
}

export class SimpleUserAction implements ISimpleUserAction {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    interactiveCount!: number | undefined;

    constructor(data?: ISimpleUserAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headImgUrl = data["headImgUrl"];
            this.nickName = data["nickName"];
            this.interactiveCount = data["interactiveCount"];
        }
    }

    static fromJS(data: any): SimpleUserAction {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUserAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["interactiveCount"] = this.interactiveCount;
        return data; 
    }
}

export interface ISimpleUserAction {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    interactiveCount: number | undefined;
}

export class TemplateChartDto implements ITemplateChartDto {
    templates!: IntValueNameDto[] | undefined;
    totalCount!: number | undefined;
    title!: string | undefined;

    constructor(data?: ITemplateChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["templates"])) {
                this.templates = [] as any;
                for (let item of data["templates"])
                    this.templates!.push(IntValueNameDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): TemplateChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["title"] = this.title;
        return data; 
    }
}

export interface ITemplateChartDto {
    templates: IntValueNameDto[] | undefined;
    totalCount: number | undefined;
    title: string | undefined;
}

export class InteractiveDto implements IInteractiveDto {
    interactiveCount!: number | undefined;
    activityName!: string | undefined;

    constructor(data?: IInteractiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.interactiveCount = data["interactiveCount"];
            this.activityName = data["activityName"];
        }
    }

    static fromJS(data: any): InteractiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interactiveCount"] = this.interactiveCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IInteractiveDto {
    interactiveCount: number | undefined;
    activityName: string | undefined;
}

export class ShareDto implements IShareDto {
    shareCount!: number | undefined;
    activityName!: string | undefined;

    constructor(data?: IShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareCount = data["shareCount"];
            this.activityName = data["activityName"];
        }
    }

    static fromJS(data: any): ShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareCount"] = this.shareCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IShareDto {
    shareCount: number | undefined;
    activityName: string | undefined;
}

export class FanDto implements IFanDto {
    fanCount!: number | undefined;
    activityName!: string | undefined;

    constructor(data?: IFanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fanCount = data["fanCount"];
            this.activityName = data["activityName"];
        }
    }

    static fromJS(data: any): FanDto {
        data = typeof data === 'object' ? data : {};
        let result = new FanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fanCount"] = this.fanCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IFanDto {
    fanCount: number | undefined;
    activityName: string | undefined;
}

export class DollMachine implements IDollMachine {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IDollMachine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): DollMachine {
        data = typeof data === 'object' ? data : {};
        let result = new DollMachine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IDollMachine {
    key: string[] | undefined;
    value: number[] | undefined;
}

export class GameRanks implements IGameRanks {
    gameRank!: GameRank[] | undefined;
    gameName!: string | undefined;

    constructor(data?: IGameRanks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["gameRank"])) {
                this.gameRank = [] as any;
                for (let item of data["gameRank"])
                    this.gameRank!.push(GameRank.fromJS(item));
            }
            this.gameName = data["gameName"];
        }
    }

    static fromJS(data: any): GameRanks {
        data = typeof data === 'object' ? data : {};
        let result = new GameRanks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gameRank)) {
            data["gameRank"] = [];
            for (let item of this.gameRank)
                data["gameRank"].push(item.toJSON());
        }
        data["gameName"] = this.gameName;
        return data; 
    }
}

export interface IGameRanks {
    gameRank: GameRank[] | undefined;
    gameName: string | undefined;
}

export class IntValueNameDto implements IIntValueNameDto {
    value!: number | undefined;
    name!: string | undefined;

    constructor(data?: IIntValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): IntValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIntValueNameDto {
    value: number | undefined;
    name: string | undefined;
}

export class GameRank implements IGameRank {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    score!: number | undefined;

    constructor(data?: IGameRank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headImgUrl = data["headImgUrl"];
            this.nickName = data["nickName"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): GameRank {
        data = typeof data === 'object' ? data : {};
        let result = new GameRank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IGameRank {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    score: number | undefined;
}

export class MembersCountInput implements IMembersCountInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IMembersCountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MembersCountInput {
        data = typeof data === 'object' ? data : {};
        let result = new MembersCountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMembersCountInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number | undefined;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number | undefined;
    type: string | undefined;
}

export class ReportInput implements IReportInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IReportInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class TopSkusInput implements ITopSkusInput {
    top!: number | undefined;
    brandId!: number | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ITopSkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.top = data["top"];
            this.brandId = data["brandId"];
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TopSkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new TopSkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["top"] = this.top;
        data["brandId"] = this.brandId;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITopSkusInput {
    top: number | undefined;
    brandId: number | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class SkuSaleListDto implements ISkuSaleListDto {
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number | undefined;
    saleAmout!: number | undefined;

    constructor(data?: ISkuSaleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.saleAmout = data["saleAmout"];
        }
    }

    static fromJS(data: any): SkuSaleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSaleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["saleAmout"] = this.saleAmout;
        return data; 
    }
}

export interface ISkuSaleListDto {
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number | undefined;
    saleAmout: number | undefined;
}

export class SkuTotalSalesInput implements ISkuTotalSalesInput {
    skuId!: string | undefined;
    storeId!: number | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ISkuTotalSalesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.storeId = data["storeId"];
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuTotalSalesInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTotalSalesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuTotalSalesInput {
    skuId: string | undefined;
    storeId: number | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class OrderCountAndSalesInput implements IOrderCountAndSalesInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IOrderCountAndSalesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderCountAndSalesInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCountAndSalesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderCountAndSalesInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class BuyerCountInput implements IBuyerCountInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IBuyerCountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuyerCountInput {
        data = typeof data === 'object' ? data : {};
        let result = new BuyerCountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuyerCountInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class SkuFromBuyerInput implements ISkuFromBuyerInput {
    memberId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ISkuFromBuyerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuFromBuyerInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuFromBuyerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuFromBuyerInput {
    memberId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class OrderInformationInput implements IOrderInformationInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IOrderInformationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): OrderInformationInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInformationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IOrderInformationInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfOrderInformationDto implements IPagedResultDtoOfOrderInformationDto {
    totalCount!: number | undefined;
    items!: OrderInformationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrderInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderInformationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrderInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrderInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrderInformationDto {
    totalCount: number | undefined;
    items: OrderInformationDto[] | undefined;
}

export class OrderInformationDto implements IOrderInformationDto {
    memberId!: number | undefined;
    memberName!: string | undefined;
    memberNo!: string | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    orderDateTime!: moment.Moment | undefined;

    constructor(data?: IOrderInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.memberName = data["memberName"];
            this.memberNo = data["memberNo"];
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["memberNo"] = this.memberNo;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderInformationDto {
    memberId: number | undefined;
    memberName: string | undefined;
    memberNo: string | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    orderDateTime: moment.Moment | undefined;
}

export class SkuSaleListInput implements ISkuSaleListInput {
    filter!: string | undefined;
    skuName!: string | undefined;
    skuId!: string | undefined;
    storeIds!: number[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    sorting!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: ISkuSaleListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.skuName = data["skuName"];
            this.skuId = data["skuId"];
            if (Array.isArray(data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): SkuSaleListInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSaleListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["skuName"] = this.skuName;
        data["skuId"] = this.skuId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISkuSaleListInput {
    filter: string | undefined;
    skuName: string | undefined;
    skuId: string | undefined;
    storeIds: number[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedTotalResultDtoOfSkuSaleListDto implements IPagedTotalResultDtoOfSkuSaleListDto {
    totalSale!: number | undefined;
    totalCount!: number | undefined;
    items!: SkuSaleListDto[] | undefined;

    constructor(data?: IPagedTotalResultDtoOfSkuSaleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSale = data["totalSale"];
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SkuSaleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedTotalResultDtoOfSkuSaleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedTotalResultDtoOfSkuSaleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedTotalResultDtoOfSkuSaleListDto {
    totalSale: number | undefined;
    totalCount: number | undefined;
    items: SkuSaleListDto[] | undefined;
}

export class PagedTotalResultDtoOfOrderItem implements IPagedTotalResultDtoOfOrderItem {
    totalSale!: number | undefined;
    totalCount!: number | undefined;
    items!: OrderItem[] | undefined;

    constructor(data?: IPagedTotalResultDtoOfOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSale = data["totalSale"];
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedTotalResultDtoOfOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedTotalResultDtoOfOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedTotalResultDtoOfOrderItem {
    totalSale: number | undefined;
    totalCount: number | undefined;
    items: OrderItem[] | undefined;
}

export class OrderItem implements IOrderItem {
    outerId!: string | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number | undefined;
    totalFee!: number | undefined;
    taxFee!: number | undefined;
    discountFee!: number | undefined;
    payment!: number | undefined;
    pointPayment!: number | undefined;
    deductionAmount!: number | undefined;
    status!: string | undefined;
    orderId!: number | undefined;
    propertyValues!: string | undefined;
    productId!: number | undefined;
    order!: Order | undefined;
    brandName!: string | undefined;
    category!: string | undefined;
    subCategory!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean | undefined;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    activityId!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.outerId = data["outerId"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.discountFee = data["discountFee"];
            this.payment = data["payment"];
            this.pointPayment = data["pointPayment"];
            this.deductionAmount = data["deductionAmount"];
            this.status = data["status"];
            this.orderId = data["orderId"];
            this.propertyValues = data["propertyValues"];
            this.productId = data["productId"];
            this.order = data["order"] ? Order.fromJS(data["order"]) : <any>undefined;
            this.brandName = data["brandName"];
            this.category = data["category"];
            this.subCategory = data["subCategory"];
            this.activityTag = data["activityTag"];
            this.discount = data["discount"];
            this.isSuite = data["isSuite"];
            this.storeId = data["storeId"];
            this.storeOuterId = data["storeOuterId"];
            this.activityId = data["activityId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["discountFee"] = this.discountFee;
        data["payment"] = this.payment;
        data["pointPayment"] = this.pointPayment;
        data["deductionAmount"] = this.deductionAmount;
        data["status"] = this.status;
        data["orderId"] = this.orderId;
        data["propertyValues"] = this.propertyValues;
        data["productId"] = this.productId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["activityId"] = this.activityId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderItem {
    outerId: string | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number | undefined;
    totalFee: number | undefined;
    taxFee: number | undefined;
    discountFee: number | undefined;
    payment: number | undefined;
    pointPayment: number | undefined;
    deductionAmount: number | undefined;
    status: string | undefined;
    orderId: number | undefined;
    propertyValues: string | undefined;
    productId: number | undefined;
    order: Order | undefined;
    brandName: string | undefined;
    category: string | undefined;
    subCategory: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean | undefined;
    storeId: number | undefined;
    storeOuterId: string | undefined;
    activityId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Order implements IOrder {
    orderNO!: string | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    outerId!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    taxFee!: number | undefined;
    postFee!: number | undefined;
    payment!: number | undefined;
    pointPayment!: number | undefined;
    deductionAmount!: number | undefined;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    number!: string | undefined;
    status!: string | undefined;
    note!: string | undefined;
    storeId!: number | undefined;
    deviceId!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    memberId!: number | undefined;
    memberOuterId!: string | undefined;
    member!: Member | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    from!: string | undefined;
    orderItems!: OrderItem[] | undefined;
    activityId!: number | undefined;
    pickNo!: string | undefined;
    isuse!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderNO = data["orderNO"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.outerId = data["outerId"];
            this.orderDateTime = data["orderDateTime"] ? moment(data["orderDateTime"].toString()) : <any>undefined;
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.taxFee = data["taxFee"];
            this.postFee = data["postFee"];
            this.payment = data["payment"];
            this.pointPayment = data["pointPayment"];
            this.deductionAmount = data["deductionAmount"];
            this.payType = data["payType"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.consignTime = data["consignTime"] ? moment(data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = data["returnsTime"] ? moment(data["returnsTime"].toString()) : <any>undefined;
            this.number = data["number"];
            this.status = data["status"];
            this.note = data["note"];
            this.storeId = data["storeId"];
            this.deviceId = data["deviceId"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.memberId = data["memberId"];
            this.memberOuterId = data["memberOuterId"];
            this.member = data["member"] ? Member.fromJS(data["member"]) : <any>undefined;
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
            this.from = data["from"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(OrderItem.fromJS(item));
            }
            this.activityId = data["activityId"];
            this.pickNo = data["pickNo"];
            this.isuse = data["isuse"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNO"] = this.orderNO;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outerId"] = this.outerId;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["pointPayment"] = this.pointPayment;
        data["deductionAmount"] = this.deductionAmount;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["status"] = this.status;
        data["note"] = this.note;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["memberId"] = this.memberId;
        data["memberOuterId"] = this.memberOuterId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["activityId"] = this.activityId;
        data["pickNo"] = this.pickNo;
        data["isuse"] = this.isuse;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrder {
    orderNO: string | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    outerId: string | undefined;
    orderDateTime: moment.Moment | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    taxFee: number | undefined;
    postFee: number | undefined;
    payment: number | undefined;
    pointPayment: number | undefined;
    deductionAmount: number | undefined;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    number: string | undefined;
    status: string | undefined;
    note: string | undefined;
    storeId: number | undefined;
    deviceId: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    memberId: number | undefined;
    memberOuterId: string | undefined;
    member: Member | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    from: string | undefined;
    orderItems: OrderItem[] | undefined;
    activityId: number | undefined;
    pickNo: string | undefined;
    isuse: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Member implements IMember {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    memberNo!: string | undefined;
    outerId!: string | undefined;
    openId!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;
    storeId!: number | undefined;
    deviceId!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    registerdTime!: moment.Moment;
    firstBuyTime!: moment.Moment | undefined;
    point!: number | undefined;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    snsNickName!: string | undefined;
    snsPlatformType!: string | undefined;
    faceUrl!: string | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string;
    career!: string | undefined;
    income!: string | undefined;
    shippingAddresses!: ShippingAddress[] | undefined;
    from!: string | undefined;
    orders!: Order[] | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.memberNo = data["memberNo"];
            this.outerId = data["outerId"];
            this.openId = data["openId"];
            this.name = data["name"];
            this.type = data["type"];
            this.storeId = data["storeId"];
            this.deviceId = data["deviceId"];
            this.storeOuterId = data["storeOuterId"];
            this.storeName = data["storeName"];
            this.registerdTime = data["registerdTime"] ? moment(data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = data["firstBuyTime"] ? moment(data["firstBuyTime"].toString()) : <any>undefined;
            this.point = data["point"];
            this.pointRate = data["pointRate"];
            this.canExchangeGifts = data["canExchangeGifts"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.snsNickName = data["snsNickName"];
            this.snsPlatformType = data["snsPlatformType"];
            this.faceUrl = data["faceUrl"];
            this.weChatNickName = data["weChatNickName"];
            this.regPhone = data["regPhone"];
            this.career = data["career"];
            this.income = data["income"];
            if (Array.isArray(data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddress.fromJS(item));
            }
            this.from = data["from"];
            if (Array.isArray(data["orders"])) {
                this.orders = [] as any;
                for (let item of data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            this.extraInfo1 = data["extraInfo1"];
            this.extraInfo2 = data["extraInfo2"];
            this.extraInfo3 = data["extraInfo3"];
            this.extraInfoX = data["extraInfoX"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["memberNo"] = this.memberNo;
        data["outerId"] = this.outerId;
        data["openId"] = this.openId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["snsNickName"] = this.snsNickName;
        data["snsPlatformType"] = this.snsPlatformType;
        data["faceUrl"] = this.faceUrl;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMember {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    memberNo: string | undefined;
    outerId: string | undefined;
    openId: string | undefined;
    name: string | undefined;
    type: string | undefined;
    storeId: number | undefined;
    deviceId: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    registerdTime: moment.Moment;
    firstBuyTime: moment.Moment | undefined;
    point: number | undefined;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    snsNickName: string | undefined;
    snsPlatformType: string | undefined;
    faceUrl: string | undefined;
    weChatNickName: string | undefined;
    regPhone: string;
    career: string | undefined;
    income: string | undefined;
    shippingAddresses: ShippingAddress[] | undefined;
    from: string | undefined;
    orders: Order[] | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ShippingAddress implements IShippingAddress {
    outerId!: string | undefined;
    memberId!: number | undefined;
    member!: Member | undefined;
    phone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    zipcode!: string | undefined;
    normalizeName!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    isDefault!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IShippingAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.outerId = data["outerId"];
            this.memberId = data["memberId"];
            this.member = data["member"] ? Member.fromJS(data["member"]) : <any>undefined;
            this.phone = data["phone"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.address = data["address"];
            this.zipcode = data["zipcode"];
            this.normalizeName = data["normalizeName"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.isDefault = data["isDefault"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ShippingAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipcode"] = this.zipcode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IShippingAddress {
    outerId: string | undefined;
    memberId: number | undefined;
    member: Member | undefined;
    phone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    zipcode: string | undefined;
    normalizeName: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    isDefault: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SkuDaySaleInput implements ISkuDaySaleInput {
    skuId!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: ISkuDaySaleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): SkuDaySaleInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDaySaleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISkuDaySaleInput {
    skuId: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfSkuDaySaleDto implements IPagedResultDtoOfSkuDaySaleDto {
    totalCount!: number | undefined;
    items!: SkuDaySaleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSkuDaySaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SkuDaySaleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSkuDaySaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSkuDaySaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSkuDaySaleDto {
    totalCount: number | undefined;
    items: SkuDaySaleDto[] | undefined;
}

export class SkuDaySaleDto implements ISkuDaySaleDto {
    skuId!: string | undefined;
    date!: moment.Moment | undefined;
    saleNumber!: number | undefined;
    saleAmout!: number | undefined;

    constructor(data?: ISkuDaySaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.saleNumber = data["saleNumber"];
            this.saleAmout = data["saleAmout"];
        }
    }

    static fromJS(data: any): SkuDaySaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDaySaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["saleNumber"] = this.saleNumber;
        data["saleAmout"] = this.saleAmout;
        return data; 
    }
}

export interface ISkuDaySaleDto {
    skuId: string | undefined;
    date: moment.Moment | undefined;
    saleNumber: number | undefined;
    saleAmout: number | undefined;
}

export class MemberCostInput implements IMemberCostInput {
    memberName!: string | undefined;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    type!: string | undefined;
    storeId!: number | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IMemberCostInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberName = data["memberName"];
            this.orderDateTimeStart = data["orderDateTimeStart"] ? moment(data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = data["orderDateTimeEnd"] ? moment(data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.type = data["type"];
            this.storeId = data["storeId"];
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): MemberCostInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCostInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberName"] = this.memberName;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IMemberCostInput {
    memberName: string | undefined;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    type: string | undefined;
    storeId: number | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfMemberCostListDto implements IPagedResultDtoOfMemberCostListDto {
    totalCount!: number | undefined;
    items!: MemberCostListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberCostListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MemberCostListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberCostListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberCostListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMemberCostListDto {
    totalCount: number | undefined;
    items: MemberCostListDto[] | undefined;
}

export class MemberCostListDto implements IMemberCostListDto {
    memberId!: number | undefined;
    amount!: number | undefined;
    memberNo!: string | undefined;
    registerdTime!: moment.Moment | undefined;
    type!: string | undefined;
    snsNickName!: string | undefined;
    name!: string | undefined;
    gender!: string | undefined;
    regPhone!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;

    constructor(data?: IMemberCostListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.amount = data["amount"];
            this.memberNo = data["memberNo"];
            this.registerdTime = data["registerdTime"] ? moment(data["registerdTime"].toString()) : <any>undefined;
            this.type = data["type"];
            this.snsNickName = data["snsNickName"];
            this.name = data["name"];
            this.gender = data["gender"];
            this.regPhone = data["regPhone"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
        }
    }

    static fromJS(data: any): MemberCostListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCostListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["amount"] = this.amount;
        data["memberNo"] = this.memberNo;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["snsNickName"] = this.snsNickName;
        data["name"] = this.name;
        data["gender"] = this.gender;
        data["regPhone"] = this.regPhone;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        return data; 
    }
}

export interface IMemberCostListDto {
    memberId: number | undefined;
    amount: number | undefined;
    memberNo: string | undefined;
    registerdTime: moment.Moment | undefined;
    type: string | undefined;
    snsNickName: string | undefined;
    name: string | undefined;
    gender: string | undefined;
    regPhone: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
}

export class MemberDaySkusInput implements IMemberDaySkusInput {
    memberId!: number | undefined;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IMemberDaySkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.orderDateTimeStart = data["orderDateTimeStart"] ? moment(data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = data["orderDateTimeEnd"] ? moment(data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.sorting = data["sorting"];
            this.filter = data["filter"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): MemberDaySkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDaySkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IMemberDaySkusInput {
    memberId: number | undefined;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfMemberDaySkusDto implements IPagedResultDtoOfMemberDaySkusDto {
    totalCount!: number | undefined;
    items!: MemberDaySkusDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberDaySkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MemberDaySkusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberDaySkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberDaySkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMemberDaySkusDto {
    totalCount: number | undefined;
    items: MemberDaySkusDto[] | undefined;
}

export class MemberDaySkusDto implements IMemberDaySkusDto {
    memberId!: number | undefined;
    date!: moment.Moment | undefined;
    skuId!: string | undefined;
    skuName!: string | undefined;
    number!: number | undefined;

    constructor(data?: IMemberDaySkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.skuId = data["skuId"];
            this.skuName = data["skuName"];
            this.number = data["number"];
        }
    }

    static fromJS(data: any): MemberDaySkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDaySkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["skuId"] = this.skuId;
        data["skuName"] = this.skuName;
        data["number"] = this.number;
        return data; 
    }
}

export interface IMemberDaySkusDto {
    memberId: number | undefined;
    date: moment.Moment | undefined;
    skuId: string | undefined;
    skuName: string | undefined;
    number: number | undefined;
}

export class PagedResultDtoOfExtensionOrdersDto implements IPagedResultDtoOfExtensionOrdersDto {
    totalCount!: number | undefined;
    items!: ExtensionOrdersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExtensionOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ExtensionOrdersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExtensionOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExtensionOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExtensionOrdersDto {
    totalCount: number | undefined;
    items: ExtensionOrdersDto[] | undefined;
}

export class ExtensionOrdersDto implements IExtensionOrdersDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    from!: string | undefined;
    orderId!: number | undefined;
    printPicUrl!: string | undefined;
    picUrl!: string | undefined;
    gcodeFileUrl!: string | undefined;
    printStateDescription!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;
    memberId!: number | undefined;
    memberName!: string | undefined;

    constructor(data?: IExtensionOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.from = data["from"];
            this.orderId = data["orderId"];
            this.printPicUrl = data["printPicUrl"];
            this.picUrl = data["picUrl"];
            this.gcodeFileUrl = data["gcodeFileUrl"];
            this.printStateDescription = data["printStateDescription"];
            this.startPrintDataTime = data["startPrintDataTime"] ? moment(data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = data["endPrintDateTime"] ? moment(data["endPrintDateTime"].toString()) : <any>undefined;
            this.memberId = data["memberId"];
            this.memberName = data["memberName"];
        }
    }

    static fromJS(data: any): ExtensionOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["from"] = this.from;
        data["orderId"] = this.orderId;
        data["printPicUrl"] = this.printPicUrl;
        data["picUrl"] = this.picUrl;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        data["printStateDescription"] = this.printStateDescription;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        return data; 
    }
}

export interface IExtensionOrdersDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    from: string | undefined;
    orderId: number | undefined;
    printPicUrl: string | undefined;
    picUrl: string | undefined;
    gcodeFileUrl: string | undefined;
    printStateDescription: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
    memberId: number | undefined;
    memberName: string | undefined;
}

export class AddOrUpdateExtensionOrderInput implements IAddOrUpdateExtensionOrderInput {
    subKey!: string;
    orderId!: number;
    memberId!: number | undefined;
    skuId!: number | undefined;
    mediaId!: string | undefined;
    printStateDescription!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    from!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;
    gcodeFileUrl!: string | undefined;

    constructor(data?: IAddOrUpdateExtensionOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            this.orderId = data["orderId"];
            this.memberId = data["memberId"];
            this.skuId = data["skuId"];
            this.mediaId = data["mediaId"];
            this.printStateDescription = data["printStateDescription"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.from = data["from"];
            this.startPrintDataTime = data["startPrintDataTime"] ? moment(data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = data["endPrintDateTime"] ? moment(data["endPrintDateTime"].toString()) : <any>undefined;
            this.gcodeFileUrl = data["gcodeFileUrl"];
        }
    }

    static fromJS(data: any): AddOrUpdateExtensionOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateExtensionOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["orderId"] = this.orderId;
        data["memberId"] = this.memberId;
        data["skuId"] = this.skuId;
        data["mediaId"] = this.mediaId;
        data["printStateDescription"] = this.printStateDescription;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["from"] = this.from;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        return data; 
    }
}

export interface IAddOrUpdateExtensionOrderInput {
    subKey: string;
    orderId: number;
    memberId: number | undefined;
    skuId: number | undefined;
    mediaId: string | undefined;
    printStateDescription: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    from: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
    gcodeFileUrl: string | undefined;
}

export class UpdateOrderMakingInfoInput implements IUpdateOrderMakingInfoInput {
    subKey!: string;
    orderId!: number;
    printStateDescription!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderMakingInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            this.orderId = data["orderId"];
            this.printStateDescription = data["printStateDescription"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.startPrintDataTime = data["startPrintDataTime"] ? moment(data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = data["endPrintDateTime"] ? moment(data["endPrintDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderMakingInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderMakingInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["orderId"] = this.orderId;
        data["printStateDescription"] = this.printStateDescription;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateOrderMakingInfoInput {
    subKey: string;
    orderId: number;
    printStateDescription: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
}

export class MemberInput implements IMemberInput {
    tenantId!: number | undefined;
    openId!: string | undefined;
    storeId!: string | undefined;
    deviceId!: number | undefined;
    weChatNickName!: string | undefined;
    name!: string | undefined;
    age!: number | undefined;
    gender!: string | undefined;
    birthTime!: moment.Moment | undefined;
    regPhone!: string | undefined;
    faceUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.openId = data["openId"];
            this.storeId = data["storeId"];
            this.deviceId = data["deviceId"];
            this.weChatNickName = data["weChatNickName"];
            this.name = data["name"];
            this.age = data["age"];
            this.gender = data["gender"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.regPhone = data["regPhone"];
            this.faceUrl = data["faceUrl"];
            this.from = data["from"];
        }
    }

    static fromJS(data: any): MemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["openId"] = this.openId;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["weChatNickName"] = this.weChatNickName;
        data["name"] = this.name;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["regPhone"] = this.regPhone;
        data["faceUrl"] = this.faceUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IMemberInput {
    tenantId: number | undefined;
    openId: string | undefined;
    storeId: string | undefined;
    deviceId: number | undefined;
    weChatNickName: string | undefined;
    name: string | undefined;
    age: number | undefined;
    gender: string | undefined;
    birthTime: moment.Moment | undefined;
    regPhone: string | undefined;
    faceUrl: string | undefined;
    from: string | undefined;
}

export class AddOrUpdateAddressInput implements IAddOrUpdateAddressInput {
    id!: number | undefined;
    phone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    zipcode!: string | undefined;
    normalizeName!: string | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IAddOrUpdateAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phone = data["phone"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.address = data["address"];
            this.zipcode = data["zipcode"];
            this.normalizeName = data["normalizeName"];
            this.gender = data["gender"];
            this.idNumber = data["idNumber"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): AddOrUpdateAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipcode"] = this.zipcode;
        data["normalizeName"] = this.normalizeName;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IAddOrUpdateAddressInput {
    id: number | undefined;
    phone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    zipcode: string | undefined;
    normalizeName: string | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    isDefault: boolean | undefined;
}

export class PagedResultDtoOfGetShippingAddressDto implements IPagedResultDtoOfGetShippingAddressDto {
    totalCount!: number | undefined;
    items!: GetShippingAddressDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetShippingAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetShippingAddressDto {
    totalCount: number | undefined;
    items: GetShippingAddressDto[] | undefined;
}

export class GetShippingAddressDto implements IGetShippingAddressDto {
    id!: number | undefined;
    phone!: string | undefined;
    normalizeName!: string | undefined;
    zipcode!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IGetShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phone = data["phone"];
            this.normalizeName = data["normalizeName"];
            this.zipcode = data["zipcode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.address = data["address"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): GetShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["normalizeName"] = this.normalizeName;
        data["zipcode"] = this.zipcode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IGetShippingAddressDto {
    id: number | undefined;
    phone: string | undefined;
    normalizeName: string | undefined;
    zipcode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    isDefault: boolean | undefined;
}

export class AddOrUpdateWeishopOrderInput implements IAddOrUpdateWeishopOrderInput {
    id!: number | undefined;
    organizationUnitId!: number | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    taxFee!: number | undefined;
    postFee!: number | undefined;
    payment!: number | undefined;
    number!: string | undefined;
    storeId!: string | undefined;
    note!: string | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    ticketId!: number | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;
    activityId!: number | undefined;
    status!: string | undefined;

    constructor(data?: IAddOrUpdateWeishopOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationUnitId = data["organizationUnitId"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.taxFee = data["taxFee"];
            this.postFee = data["postFee"];
            this.payment = data["payment"];
            this.number = data["number"];
            this.storeId = data["storeId"];
            this.note = data["note"];
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.ticketId = data["ticketId"];
            this.pointReduction = data["pointReduction"];
            this.deductionAmount = data["deductionAmount"];
            this.activityId = data["activityId"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): AddOrUpdateWeishopOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateWeishopOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationUnitId"] = this.organizationUnitId;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["number"] = this.number;
        data["storeId"] = this.storeId;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["ticketId"] = this.ticketId;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        data["activityId"] = this.activityId;
        data["status"] = this.status;
        return data; 
    }
}

export interface IAddOrUpdateWeishopOrderInput {
    id: number | undefined;
    organizationUnitId: number | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    taxFee: number | undefined;
    postFee: number | undefined;
    payment: number | undefined;
    number: string | undefined;
    storeId: string | undefined;
    note: string | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    ticketId: number | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
    activityId: number | undefined;
    status: string | undefined;
}

export class AddOrUpdateHaierOrderInput implements IAddOrUpdateHaierOrderInput {
    id!: number | undefined;
    organizationUnitId!: number | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    taxFee!: number | undefined;
    postFee!: number | undefined;
    payment!: number | undefined;
    number!: string | undefined;
    storeId!: string | undefined;
    note!: string | undefined;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    orderItems!: AddOrUpdateHaierOrderItemOuterInput[] | undefined;
    ticketId!: number | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateHaierOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationUnitId = data["organizationUnitId"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.taxFee = data["taxFee"];
            this.postFee = data["postFee"];
            this.payment = data["payment"];
            this.number = data["number"];
            this.storeId = data["storeId"];
            this.note = data["note"];
            this.memberName = data["memberName"];
            this.province = data["province"];
            this.city = data["city"];
            this.address = data["address"];
            this.zipCode = data["zipCode"];
            this.postPhone = data["postPhone"];
            if (Array.isArray(data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of data["orderItems"])
                    this.orderItems!.push(AddOrUpdateHaierOrderItemOuterInput.fromJS(item));
            }
            this.ticketId = data["ticketId"];
            this.activityId = data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateHaierOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateHaierOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationUnitId"] = this.organizationUnitId;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["number"] = this.number;
        data["storeId"] = this.storeId;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["ticketId"] = this.ticketId;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateHaierOrderInput {
    id: number | undefined;
    organizationUnitId: number | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    taxFee: number | undefined;
    postFee: number | undefined;
    payment: number | undefined;
    number: string | undefined;
    storeId: string | undefined;
    note: string | undefined;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    orderItems: AddOrUpdateHaierOrderItemOuterInput[] | undefined;
    ticketId: number | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateHaierOrderItemOuterInput implements IAddOrUpdateHaierOrderItemOuterInput {
    skuId!: string;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number;
    totalFee!: number;
    taxFee!: number;
    payment!: number;
    status!: string | undefined;
    brandName!: string | undefined;
    category!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean | undefined;
    rfidCode!: string | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateHaierOrderItemOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.number = data["number"];
            this.totalFee = data["totalFee"];
            this.taxFee = data["taxFee"];
            this.payment = data["payment"];
            this.status = data["status"];
            this.brandName = data["brandName"];
            this.category = data["category"];
            this.activityTag = data["activityTag"];
            this.discount = data["discount"];
            this.isSuite = data["isSuite"];
            this.rfidCode = data["rfidCode"];
            this.activityId = data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateHaierOrderItemOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateHaierOrderItemOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["rfidCode"] = this.rfidCode;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateHaierOrderItemOuterInput {
    skuId: string;
    title: string | undefined;
    picUrl: string | undefined;
    number: number;
    totalFee: number;
    taxFee: number;
    payment: number;
    status: string | undefined;
    brandName: string | undefined;
    category: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean | undefined;
    rfidCode: string | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateBigScreenOrderForConfirmDto implements IAddOrUpdateBigScreenOrderForConfirmDto {
    orderId!: number | undefined;
    orderNO!: string | undefined;

    constructor(data?: IAddOrUpdateBigScreenOrderForConfirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.orderNO = data["orderNO"];
        }
    }

    static fromJS(data: any): AddOrUpdateBigScreenOrderForConfirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateBigScreenOrderForConfirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNO"] = this.orderNO;
        return data; 
    }
}

export interface IAddOrUpdateBigScreenOrderForConfirmDto {
    orderId: number | undefined;
    orderNO: string | undefined;
}

export class WxPayDataDto implements IWxPayDataDto {
    appId!: string | undefined;
    timeStamp!: string | undefined;
    nonceStr!: string | undefined;
    package!: string | undefined;
    signType!: string | undefined;
    paySign!: string | undefined;

    constructor(data?: IWxPayDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.timeStamp = data["timeStamp"];
            this.nonceStr = data["nonceStr"];
            this.package = data["package"];
            this.signType = data["signType"];
            this.paySign = data["paySign"];
        }
    }

    static fromJS(data: any): WxPayDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WxPayDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["timeStamp"] = this.timeStamp;
        data["nonceStr"] = this.nonceStr;
        data["package"] = this.package;
        data["signType"] = this.signType;
        data["paySign"] = this.paySign;
        return data; 
    }
}

export interface IWxPayDataDto {
    appId: string | undefined;
    timeStamp: string | undefined;
    nonceStr: string | undefined;
    package: string | undefined;
    signType: string | undefined;
    paySign: string | undefined;
}

export class AlipayNotifyInput implements IAlipayNotifyInput {
    trade_no!: string | undefined;
    order_no!: string | undefined;
    total_fee!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    buyer_email!: string | undefined;
    trade_status!: string | undefined;

    constructor(data?: IAlipayNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trade_no = data["trade_no"];
            this.order_no = data["order_no"];
            this.total_fee = data["total_fee"];
            this.subject = data["subject"];
            this.body = data["body"];
            this.buyer_email = data["buyer_email"];
            this.trade_status = data["trade_status"];
        }
    }

    static fromJS(data: any): AlipayNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new AlipayNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trade_no"] = this.trade_no;
        data["order_no"] = this.order_no;
        data["total_fee"] = this.total_fee;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["buyer_email"] = this.buyer_email;
        data["trade_status"] = this.trade_status;
        return data; 
    }
}

export interface IAlipayNotifyInput {
    trade_no: string | undefined;
    order_no: string | undefined;
    total_fee: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    buyer_email: string | undefined;
    trade_status: string | undefined;
}

export class GetAliPaySettingDto implements IGetAliPaySettingDto {
    appID!: string | undefined;
    parameters!: AliPayParameters | undefined;

    constructor(data?: IGetAliPaySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appID = data["appID"];
            this.parameters = data["parameters"] ? AliPayParameters.fromJS(data["parameters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAliPaySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAliPaySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appID"] = this.appID;
        data["parameters"] = this.parameters ? this.parameters.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAliPaySettingDto {
    appID: string | undefined;
    parameters: AliPayParameters | undefined;
}

export class AliPayParameters implements IAliPayParameters {
    apP_PRIVATE_KEY!: string | undefined;
    alipaY_PUBLIC_KEY!: string | undefined;

    constructor(data?: IAliPayParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apP_PRIVATE_KEY = data["apP_PRIVATE_KEY"];
            this.alipaY_PUBLIC_KEY = data["alipaY_PUBLIC_KEY"];
        }
    }

    static fromJS(data: any): AliPayParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AliPayParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apP_PRIVATE_KEY"] = this.apP_PRIVATE_KEY;
        data["alipaY_PUBLIC_KEY"] = this.alipaY_PUBLIC_KEY;
        return data; 
    }
}

export interface IAliPayParameters {
    apP_PRIVATE_KEY: string | undefined;
    alipaY_PUBLIC_KEY: string | undefined;
}

export class WeishopOrderCountDto implements IWeishopOrderCountDto {
    toPay!: number | undefined;
    toDeliver!: number | undefined;
    toReceive!: number | undefined;
    toRefund!: number | undefined;

    constructor(data?: IWeishopOrderCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.toPay = data["toPay"];
            this.toDeliver = data["toDeliver"];
            this.toReceive = data["toReceive"];
            this.toRefund = data["toRefund"];
        }
    }

    static fromJS(data: any): WeishopOrderCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeishopOrderCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toPay"] = this.toPay;
        data["toDeliver"] = this.toDeliver;
        data["toReceive"] = this.toReceive;
        data["toRefund"] = this.toRefund;
        return data; 
    }
}

export interface IWeishopOrderCountDto {
    toPay: number | undefined;
    toDeliver: number | undefined;
    toReceive: number | undefined;
    toRefund: number | undefined;
}

export class RefundOrderInput implements IRefundOrderInput {
    orderId!: number | undefined;
    refundWay!: RefundOrderInputRefundWay | undefined;
    refundReason!: string | undefined;
    description!: string | undefined;
    imageUrls!: string[] | undefined;
    refundAmount!: number | undefined;

    constructor(data?: IRefundOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.refundWay = data["refundWay"];
            this.refundReason = data["refundReason"];
            this.description = data["description"];
            if (Array.isArray(data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            this.refundAmount = data["refundAmount"];
        }
    }

    static fromJS(data: any): RefundOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new RefundOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["refundWay"] = this.refundWay;
        data["refundReason"] = this.refundReason;
        data["description"] = this.description;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        data["refundAmount"] = this.refundAmount;
        return data; 
    }
}

export interface IRefundOrderInput {
    orderId: number | undefined;
    refundWay: RefundOrderInputRefundWay | undefined;
    refundReason: string | undefined;
    description: string | undefined;
    imageUrls: string[] | undefined;
    refundAmount: number | undefined;
}

export class PointLevelRegPhoneDto implements IPointLevelRegPhoneDto {
    point!: number | undefined;
    memberLevel!: string | undefined;
    regPhone!: string | undefined;
    name!: string | undefined;

    constructor(data?: IPointLevelRegPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.point = data["point"];
            this.memberLevel = data["memberLevel"];
            this.regPhone = data["regPhone"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PointLevelRegPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new PointLevelRegPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["point"] = this.point;
        data["memberLevel"] = this.memberLevel;
        data["regPhone"] = this.regPhone;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPointLevelRegPhoneDto {
    point: number | undefined;
    memberLevel: string | undefined;
    regPhone: string | undefined;
    name: string | undefined;
}

export class GetRefundDetailDto implements IGetRefundDetailDto {
    order!: OrderDto | undefined;
    refundWay!: GetRefundDetailDtoRefundWay | undefined;
    refundReason!: string | undefined;
    description!: string | undefined;
    creationTime!: moment.Moment | undefined;
    refundAmount!: number | undefined;
    companyName!: string | undefined;
    expressNumber!: string | undefined;
    imageUrls!: string[] | undefined;
    status!: GetRefundDetailDtoStatus | undefined;
    lastModificationTime!: moment.Moment | undefined;

    constructor(data?: IGetRefundDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.order = data["order"] ? OrderDto.fromJS(data["order"]) : <any>undefined;
            this.refundWay = data["refundWay"];
            this.refundReason = data["refundReason"];
            this.description = data["description"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.refundAmount = data["refundAmount"];
            this.companyName = data["companyName"];
            this.expressNumber = data["expressNumber"];
            if (Array.isArray(data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            this.status = data["status"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRefundDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRefundDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["refundWay"] = this.refundWay;
        data["refundReason"] = this.refundReason;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["refundAmount"] = this.refundAmount;
        data["companyName"] = this.companyName;
        data["expressNumber"] = this.expressNumber;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        data["status"] = this.status;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRefundDetailDto {
    order: OrderDto | undefined;
    refundWay: GetRefundDetailDtoRefundWay | undefined;
    refundReason: string | undefined;
    description: string | undefined;
    creationTime: moment.Moment | undefined;
    refundAmount: number | undefined;
    companyName: string | undefined;
    expressNumber: string | undefined;
    imageUrls: string[] | undefined;
    status: GetRefundDetailDtoStatus | undefined;
    lastModificationTime: moment.Moment | undefined;
}

export class UploadExpressInput implements IUploadExpressInput {
    orderId!: number | undefined;
    expressCompanyId!: number | undefined;
    expressNumber!: string | undefined;

    constructor(data?: IUploadExpressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.expressCompanyId = data["expressCompanyId"];
            this.expressNumber = data["expressNumber"];
        }
    }

    static fromJS(data: any): UploadExpressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExpressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["expressCompanyId"] = this.expressCompanyId;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IUploadExpressInput {
    orderId: number | undefined;
    expressCompanyId: number | undefined;
    expressNumber: string | undefined;
}

export class PagedResultDtoOfGetExpressCompaniesDto implements IPagedResultDtoOfGetExpressCompaniesDto {
    totalCount!: number | undefined;
    items!: GetExpressCompaniesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetExpressCompaniesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetExpressCompaniesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetExpressCompaniesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetExpressCompaniesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetExpressCompaniesDto {
    totalCount: number | undefined;
    items: GetExpressCompaniesDto[] | undefined;
}

export class GetExpressCompaniesDto implements IGetExpressCompaniesDto {
    id!: number | undefined;
    companyName!: string | undefined;

    constructor(data?: IGetExpressCompaniesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyName = data["companyName"];
        }
    }

    static fromJS(data: any): GetExpressCompaniesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpressCompaniesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IGetExpressCompaniesDto {
    id: number | undefined;
    companyName: string | undefined;
}

export class ExpressTrackingDto implements IExpressTrackingDto {
    logisticCode!: string | undefined;
    shipperCode!: string | undefined;
    companyName!: string | undefined;
    traces!: Traces[] | undefined;

    constructor(data?: IExpressTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.logisticCode = data["logisticCode"];
            this.shipperCode = data["shipperCode"];
            this.companyName = data["companyName"];
            if (Array.isArray(data["traces"])) {
                this.traces = [] as any;
                for (let item of data["traces"])
                    this.traces!.push(Traces.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExpressTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpressTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logisticCode"] = this.logisticCode;
        data["shipperCode"] = this.shipperCode;
        data["companyName"] = this.companyName;
        if (Array.isArray(this.traces)) {
            data["traces"] = [];
            for (let item of this.traces)
                data["traces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExpressTrackingDto {
    logisticCode: string | undefined;
    shipperCode: string | undefined;
    companyName: string | undefined;
    traces: Traces[] | undefined;
}

export class Traces implements ITraces {
    acceptTime!: moment.Moment | undefined;
    acceptStation!: string | undefined;

    constructor(data?: ITraces) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.acceptTime = data["acceptTime"] ? moment(data["acceptTime"].toString()) : <any>undefined;
            this.acceptStation = data["acceptStation"];
        }
    }

    static fromJS(data: any): Traces {
        data = typeof data === 'object' ? data : {};
        let result = new Traces();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptTime"] = this.acceptTime ? this.acceptTime.toISOString() : <any>undefined;
        data["acceptStation"] = this.acceptStation;
        return data; 
    }
}

export interface ITraces {
    acceptTime: moment.Moment | undefined;
    acceptStation: string | undefined;
}

export class AddUserToOvoParkInput implements IAddUserToOvoParkInput {
    deviceId!: number | undefined;
    securityKey!: string | undefined;
    username!: string | undefined;
    gender!: string | undefined;
    from!: string | undefined;
    thirdpicurl!: string | undefined;
    mobilephone!: string | undefined;
    openId!: string | undefined;
    birthTime!: moment.Moment | undefined;
    faceId!: string | undefined;

    constructor(data?: IAddUserToOvoParkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.securityKey = data["securityKey"];
            this.username = data["username"];
            this.gender = data["gender"];
            this.from = data["from"];
            this.thirdpicurl = data["thirdpicurl"];
            this.mobilephone = data["mobilephone"];
            this.openId = data["openId"];
            this.birthTime = data["birthTime"] ? moment(data["birthTime"].toString()) : <any>undefined;
            this.faceId = data["faceId"];
        }
    }

    static fromJS(data: any): AddUserToOvoParkInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToOvoParkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["securityKey"] = this.securityKey;
        data["username"] = this.username;
        data["gender"] = this.gender;
        data["from"] = this.from;
        data["thirdpicurl"] = this.thirdpicurl;
        data["mobilephone"] = this.mobilephone;
        data["openId"] = this.openId;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["faceId"] = this.faceId;
        return data; 
    }
}

export interface IAddUserToOvoParkInput {
    deviceId: number | undefined;
    securityKey: string | undefined;
    username: string | undefined;
    gender: string | undefined;
    from: string | undefined;
    thirdpicurl: string | undefined;
    mobilephone: string | undefined;
    openId: string | undefined;
    birthTime: moment.Moment | undefined;
    faceId: string | undefined;
}

export class AddUserDto implements IAddUserDto {
    success!: boolean | undefined;
    errorMessage!: string | undefined;

    constructor(data?: IAddUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): AddUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface IAddUserDto {
    success: boolean | undefined;
    errorMessage: string | undefined;
}

export class RegisterUserToWeiShopInput implements IRegisterUserToWeiShopInput {
    userName!: string | undefined;
    mobilephone!: string | undefined;

    constructor(data?: IRegisterUserToWeiShopInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.mobilephone = data["mobilephone"];
        }
    }

    static fromJS(data: any): RegisterUserToWeiShopInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserToWeiShopInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["mobilephone"] = this.mobilephone;
        return data; 
    }
}

export interface IRegisterUserToWeiShopInput {
    userName: string | undefined;
    mobilephone: string | undefined;
}

export class QueryUserByFaceInput implements IQueryUserByFaceInput {
    faceBytes!: string | undefined;
    faceUrl!: string | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;

    constructor(data?: IQueryUserByFaceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.faceBytes = data["faceBytes"];
            this.faceUrl = data["faceUrl"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): QueryUserByFaceInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryUserByFaceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceBytes"] = this.faceBytes;
        data["faceUrl"] = this.faceUrl;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IQueryUserByFaceInput {
    faceBytes: string | undefined;
    faceUrl: string | undefined;
    securityKey: string | undefined;
    params: string | undefined;
}

export class QueryUserByFaceDto implements IQueryUserByFaceDto {
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    imageUrl!: string | undefined;
    vendor!: string | undefined;
    tenantId!: number | undefined;
    extensionData!: string | undefined;
    gender!: string | undefined;
    age!: number | undefined;
    happiness!: string | undefined;
    emotion!: string | undefined;
    score!: string | undefined;
    parentUserId!: number | undefined;
    groupName!: string | undefined;
    name!: string | undefined;

    constructor(data?: IQueryUserByFaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.imageUrl = data["imageUrl"];
            this.vendor = data["vendor"];
            this.tenantId = data["tenantId"];
            this.extensionData = data["extensionData"];
            this.gender = data["gender"];
            this.age = data["age"];
            this.happiness = data["happiness"];
            this.emotion = data["emotion"];
            this.score = data["score"];
            this.parentUserId = data["parentUserId"];
            this.groupName = data["groupName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): QueryUserByFaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryUserByFaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["vendor"] = this.vendor;
        data["tenantId"] = this.tenantId;
        data["extensionData"] = this.extensionData;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["happiness"] = this.happiness;
        data["emotion"] = this.emotion;
        data["score"] = this.score;
        data["parentUserId"] = this.parentUserId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        return data; 
    }
}

export interface IQueryUserByFaceDto {
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    imageUrl: string | undefined;
    vendor: string | undefined;
    tenantId: number | undefined;
    extensionData: string | undefined;
    gender: string | undefined;
    age: number | undefined;
    happiness: string | undefined;
    emotion: string | undefined;
    score: string | undefined;
    parentUserId: number | undefined;
    groupName: string | undefined;
    name: string | undefined;
}

export class SnsUserInfo implements ISnsUserInfo {
    id!: number | undefined;
    tenantId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;

    constructor(data?: ISnsUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.weixinGroupid = data["weixinGroupid"];
            this.memberId = data["memberId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
        }
    }

    static fromJS(data: any): SnsUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        return data; 
    }
}

export interface ISnsUserInfo {
    id: number | undefined;
    tenantId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
}

export class RegisterFaceByUserInput implements IRegisterFaceByUserInput {
    openId!: string | undefined;
    snsType!: RegisterFaceByUserInputSnsType | undefined;
    faceBytes!: string | undefined;
    faceUrl!: string | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;

    constructor(data?: IRegisterFaceByUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.snsType = data["snsType"];
            this.faceBytes = data["faceBytes"];
            this.faceUrl = data["faceUrl"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): RegisterFaceByUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterFaceByUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["faceBytes"] = this.faceBytes;
        data["faceUrl"] = this.faceUrl;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IRegisterFaceByUserInput {
    openId: string | undefined;
    snsType: RegisterFaceByUserInputSnsType | undefined;
    faceBytes: string | undefined;
    faceUrl: string | undefined;
    securityKey: string | undefined;
    params: string | undefined;
}

export class RegisterFaceByUserDto implements IRegisterFaceByUserDto {
    gender!: string | undefined;
    age!: number | undefined;

    constructor(data?: IRegisterFaceByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gender = data["gender"];
            this.age = data["age"];
        }
    }

    static fromJS(data: any): RegisterFaceByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterFaceByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["age"] = this.age;
        return data; 
    }
}

export interface IRegisterFaceByUserDto {
    gender: string | undefined;
    age: number | undefined;
}

export class AddGroupToOvoParkInput implements IAddGroupToOvoParkInput {
    groupname!: string | undefined;
    orgid!: number | undefined;

    constructor(data?: IAddGroupToOvoParkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupname = data["groupname"];
            this.orgid = data["orgid"];
        }
    }

    static fromJS(data: any): AddGroupToOvoParkInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupToOvoParkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupname"] = this.groupname;
        data["orgid"] = this.orgid;
        return data; 
    }
}

export interface IAddGroupToOvoParkInput {
    groupname: string | undefined;
    orgid: number | undefined;
}

export class OvoParkUserInfo implements IOvoParkUserInfo {
    data!: UserData | undefined;
    result!: string | undefined;

    constructor(data?: IOvoParkUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? UserData.fromJS(data["data"]) : <any>undefined;
            this.result = data["result"];
        }
    }

    static fromJS(data: any): OvoParkUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OvoParkUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOvoParkUserInfo {
    data: UserData | undefined;
    result: string | undefined;
}

export class UserData implements IUserData {
    useid!: string | undefined;
    username!: string | undefined;
    age!: string | undefined;
    deviceMac!: string | undefined;
    mobilephone!: string | undefined;
    gender!: string | undefined;
    memberUrl!: string | undefined;
    arriveUrl!: string | undefined;
    arriveTime!: string | undefined;
    cardNumber!: string | undefined;
    memberType!: string | undefined;
    repeatedArrivalTimes!: string | undefined;
    faceId!: string | undefined;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useid = data["useid"];
            this.username = data["username"];
            this.age = data["age"];
            this.deviceMac = data["deviceMac"];
            this.mobilephone = data["mobilephone"];
            this.gender = data["gender"];
            this.memberUrl = data["memberUrl"];
            this.arriveUrl = data["arriveUrl"];
            this.arriveTime = data["arriveTime"];
            this.cardNumber = data["cardNumber"];
            this.memberType = data["memberType"];
            this.repeatedArrivalTimes = data["repeatedArrivalTimes"];
            this.faceId = data["faceId"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useid"] = this.useid;
        data["username"] = this.username;
        data["age"] = this.age;
        data["deviceMac"] = this.deviceMac;
        data["mobilephone"] = this.mobilephone;
        data["gender"] = this.gender;
        data["memberUrl"] = this.memberUrl;
        data["arriveUrl"] = this.arriveUrl;
        data["arriveTime"] = this.arriveTime;
        data["cardNumber"] = this.cardNumber;
        data["memberType"] = this.memberType;
        data["repeatedArrivalTimes"] = this.repeatedArrivalTimes;
        data["faceId"] = this.faceId;
        return data; 
    }
}

export interface IUserData {
    useid: string | undefined;
    username: string | undefined;
    age: string | undefined;
    deviceMac: string | undefined;
    mobilephone: string | undefined;
    gender: string | undefined;
    memberUrl: string | undefined;
    arriveUrl: string | undefined;
    arriveTime: string | undefined;
    cardNumber: string | undefined;
    memberType: string | undefined;
    repeatedArrivalTimes: string | undefined;
    faceId: string | undefined;
}

export class AddUserInput implements IAddUserInput {
    useid!: string | undefined;
    userid!: string | undefined;
    orgid!: number | undefined;
    depid!: number | undefined;
    thirdpicurl!: string | undefined;
    faceid!: string | undefined;
    version!: string | undefined;

    constructor(data?: IAddUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useid = data["useid"];
            this.userid = data["userid"];
            this.orgid = data["orgid"];
            this.depid = data["depid"];
            this.thirdpicurl = data["thirdpicurl"];
            this.faceid = data["faceid"];
            this.version = data["version"];
        }
    }

    static fromJS(data: any): AddUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useid"] = this.useid;
        data["userid"] = this.userid;
        data["orgid"] = this.orgid;
        data["depid"] = this.depid;
        data["thirdpicurl"] = this.thirdpicurl;
        data["faceid"] = this.faceid;
        data["version"] = this.version;
        return data; 
    }
}

export interface IAddUserInput {
    useid: string | undefined;
    userid: string | undefined;
    orgid: number | undefined;
    depid: number | undefined;
    thirdpicurl: string | undefined;
    faceid: string | undefined;
    version: string | undefined;
}

export class AddUserResultDto implements IAddUserResultDto {
    data!: Data | undefined;
    result!: string | undefined;

    constructor(data?: IAddUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? Data.fromJS(data["data"]) : <any>undefined;
            this.result = data["result"];
        }
    }

    static fromJS(data: any): AddUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["result"] = this.result;
        return data; 
    }
}

export interface IAddUserResultDto {
    data: Data | undefined;
    result: string | undefined;
}

export class Data implements IData {
    order_sn!: string | undefined;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.order_sn = data["order_sn"];
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order_sn"] = this.order_sn;
        return data; 
    }
}

export interface IData {
    order_sn: string | undefined;
}

export class BigChart implements IBigChart {
    orderChart!: OrderChartDto | undefined;
    ageChart!: AgeChartDto | undefined;
    sexChart!: ValueNameDto[] | undefined;
    payChart!: ValueNameDto[] | undefined;
    guestChart!: GuestChartDto | undefined;
    perHourOrderChart!: PerHourOrderChartDto | undefined;
    mainChart!: MainChartDto | undefined;
    memberChart!: MemberChartDto | undefined;
    productChart!: ProductChartDto | undefined;
    orderSalesChart!: OrderSalesChartDto | undefined;
    lastSalesChart!: LastSalesChartDto | undefined;
    categorySalesChart!: CategorySalesChartDto[] | undefined;
    dailyGuestChart!: GuestChartDto1 | undefined;
    dailyOrderSalesChart!: OrderSalesChartDto | undefined;
    dailyOrderCountChart!: OrderCountChartDto | undefined;
    dailyBuyerCountChart!: BuyerCountChartDto | undefined;

    constructor(data?: IBigChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderChart = data["orderChart"] ? OrderChartDto.fromJS(data["orderChart"]) : <any>undefined;
            this.ageChart = data["ageChart"] ? AgeChartDto.fromJS(data["ageChart"]) : <any>undefined;
            if (Array.isArray(data["sexChart"])) {
                this.sexChart = [] as any;
                for (let item of data["sexChart"])
                    this.sexChart!.push(ValueNameDto.fromJS(item));
            }
            if (Array.isArray(data["payChart"])) {
                this.payChart = [] as any;
                for (let item of data["payChart"])
                    this.payChart!.push(ValueNameDto.fromJS(item));
            }
            this.guestChart = data["guestChart"] ? GuestChartDto.fromJS(data["guestChart"]) : <any>undefined;
            this.perHourOrderChart = data["perHourOrderChart"] ? PerHourOrderChartDto.fromJS(data["perHourOrderChart"]) : <any>undefined;
            this.mainChart = data["mainChart"] ? MainChartDto.fromJS(data["mainChart"]) : <any>undefined;
            this.memberChart = data["memberChart"] ? MemberChartDto.fromJS(data["memberChart"]) : <any>undefined;
            this.productChart = data["productChart"] ? ProductChartDto.fromJS(data["productChart"]) : <any>undefined;
            this.orderSalesChart = data["orderSalesChart"] ? OrderSalesChartDto.fromJS(data["orderSalesChart"]) : <any>undefined;
            this.lastSalesChart = data["lastSalesChart"] ? LastSalesChartDto.fromJS(data["lastSalesChart"]) : <any>undefined;
            if (Array.isArray(data["categorySalesChart"])) {
                this.categorySalesChart = [] as any;
                for (let item of data["categorySalesChart"])
                    this.categorySalesChart!.push(CategorySalesChartDto.fromJS(item));
            }
            this.dailyGuestChart = data["dailyGuestChart"] ? GuestChartDto1.fromJS(data["dailyGuestChart"]) : <any>undefined;
            this.dailyOrderSalesChart = data["dailyOrderSalesChart"] ? OrderSalesChartDto.fromJS(data["dailyOrderSalesChart"]) : <any>undefined;
            this.dailyOrderCountChart = data["dailyOrderCountChart"] ? OrderCountChartDto.fromJS(data["dailyOrderCountChart"]) : <any>undefined;
            this.dailyBuyerCountChart = data["dailyBuyerCountChart"] ? BuyerCountChartDto.fromJS(data["dailyBuyerCountChart"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BigChart {
        data = typeof data === 'object' ? data : {};
        let result = new BigChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderChart"] = this.orderChart ? this.orderChart.toJSON() : <any>undefined;
        data["ageChart"] = this.ageChart ? this.ageChart.toJSON() : <any>undefined;
        if (Array.isArray(this.sexChart)) {
            data["sexChart"] = [];
            for (let item of this.sexChart)
                data["sexChart"].push(item.toJSON());
        }
        if (Array.isArray(this.payChart)) {
            data["payChart"] = [];
            for (let item of this.payChart)
                data["payChart"].push(item.toJSON());
        }
        data["guestChart"] = this.guestChart ? this.guestChart.toJSON() : <any>undefined;
        data["perHourOrderChart"] = this.perHourOrderChart ? this.perHourOrderChart.toJSON() : <any>undefined;
        data["mainChart"] = this.mainChart ? this.mainChart.toJSON() : <any>undefined;
        data["memberChart"] = this.memberChart ? this.memberChart.toJSON() : <any>undefined;
        data["productChart"] = this.productChart ? this.productChart.toJSON() : <any>undefined;
        data["orderSalesChart"] = this.orderSalesChart ? this.orderSalesChart.toJSON() : <any>undefined;
        data["lastSalesChart"] = this.lastSalesChart ? this.lastSalesChart.toJSON() : <any>undefined;
        if (Array.isArray(this.categorySalesChart)) {
            data["categorySalesChart"] = [];
            for (let item of this.categorySalesChart)
                data["categorySalesChart"].push(item.toJSON());
        }
        data["dailyGuestChart"] = this.dailyGuestChart ? this.dailyGuestChart.toJSON() : <any>undefined;
        data["dailyOrderSalesChart"] = this.dailyOrderSalesChart ? this.dailyOrderSalesChart.toJSON() : <any>undefined;
        data["dailyOrderCountChart"] = this.dailyOrderCountChart ? this.dailyOrderCountChart.toJSON() : <any>undefined;
        data["dailyBuyerCountChart"] = this.dailyBuyerCountChart ? this.dailyBuyerCountChart.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBigChart {
    orderChart: OrderChartDto | undefined;
    ageChart: AgeChartDto | undefined;
    sexChart: ValueNameDto[] | undefined;
    payChart: ValueNameDto[] | undefined;
    guestChart: GuestChartDto | undefined;
    perHourOrderChart: PerHourOrderChartDto | undefined;
    mainChart: MainChartDto | undefined;
    memberChart: MemberChartDto | undefined;
    productChart: ProductChartDto | undefined;
    orderSalesChart: OrderSalesChartDto | undefined;
    lastSalesChart: LastSalesChartDto | undefined;
    categorySalesChart: CategorySalesChartDto[] | undefined;
    dailyGuestChart: GuestChartDto1 | undefined;
    dailyOrderSalesChart: OrderSalesChartDto | undefined;
    dailyOrderCountChart: OrderCountChartDto | undefined;
    dailyBuyerCountChart: BuyerCountChartDto | undefined;
}

export class OrderChartDto implements IOrderChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalOrderCount!: number | undefined;

    constructor(data?: IOrderChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.totalOrderCount = data["totalOrderCount"];
        }
    }

    static fromJS(data: any): OrderChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalOrderCount"] = this.totalOrderCount;
        return data; 
    }
}

export interface IOrderChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalOrderCount: number | undefined;
}

export class AgeChartDto implements IAgeChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IAgeChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): AgeChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgeChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IAgeChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
}

export class ValueNameDto implements IValueNameDto {
    value!: number | undefined;
    name!: string | undefined;

    constructor(data?: IValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IValueNameDto {
    value: number | undefined;
    name: string | undefined;
}

export class GuestChartDto implements IGuestChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number | undefined;
    yesterday!: number | undefined;

    constructor(data?: IGuestChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.today = data["today"];
            this.yesterday = data["yesterday"];
        }
    }

    static fromJS(data: any): GuestChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuestChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

export interface IGuestChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number | undefined;
    yesterday: number | undefined;
}

export class PerHourOrderChartDto implements IPerHourOrderChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number | undefined;
    yesterday!: number | undefined;

    constructor(data?: IPerHourOrderChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.today = data["today"];
            this.yesterday = data["yesterday"];
        }
    }

    static fromJS(data: any): PerHourOrderChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerHourOrderChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

export interface IPerHourOrderChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number | undefined;
    yesterday: number | undefined;
}

export class MainChartDto implements IMainChartDto {
    order!: number | undefined;
    ticket!: GuestChartDto1 | undefined;
    voucher!: number | undefined;
    today!: number | undefined;
    yesterday!: number | undefined;
    week!: number | undefined;
    lastWeek!: number | undefined;
    month!: number | undefined;
    lastMonth!: number | undefined;

    constructor(data?: IMainChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.order = data["order"];
            this.ticket = data["ticket"] ? GuestChartDto1.fromJS(data["ticket"]) : <any>undefined;
            this.voucher = data["voucher"];
            this.today = data["today"];
            this.yesterday = data["yesterday"];
            this.week = data["week"];
            this.lastWeek = data["lastWeek"];
            this.month = data["month"];
            this.lastMonth = data["lastMonth"];
        }
    }

    static fromJS(data: any): MainChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["voucher"] = this.voucher;
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        data["week"] = this.week;
        data["lastWeek"] = this.lastWeek;
        data["month"] = this.month;
        data["lastMonth"] = this.lastMonth;
        return data; 
    }
}

export interface IMainChartDto {
    order: number | undefined;
    ticket: GuestChartDto1 | undefined;
    voucher: number | undefined;
    today: number | undefined;
    yesterday: number | undefined;
    week: number | undefined;
    lastWeek: number | undefined;
    month: number | undefined;
    lastMonth: number | undefined;
}

export class MemberChartDto implements IMemberChartDto {
    actionNumber!: number[] | undefined;
    newNumber!: number[] | undefined;
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IMemberChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["actionNumber"])) {
                this.actionNumber = [] as any;
                for (let item of data["actionNumber"])
                    this.actionNumber!.push(item);
            }
            if (Array.isArray(data["newNumber"])) {
                this.newNumber = [] as any;
                for (let item of data["newNumber"])
                    this.newNumber!.push(item);
            }
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): MemberChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actionNumber)) {
            data["actionNumber"] = [];
            for (let item of this.actionNumber)
                data["actionNumber"].push(item);
        }
        if (Array.isArray(this.newNumber)) {
            data["newNumber"] = [];
            for (let item of this.newNumber)
                data["newNumber"].push(item);
        }
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IMemberChartDto {
    actionNumber: number[] | undefined;
    newNumber: number[] | undefined;
    key: string[] | undefined;
    value: number[] | undefined;
}

export class ProductChartDto implements IProductChartDto {
    sales!: SalesDto[] | undefined;
    storage!: StorageDto[] | undefined;
    totalCount!: number | undefined;
    skuCount!: number | undefined;
    totalSkuCount!: number | undefined;

    constructor(data?: IProductChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["sales"])) {
                this.sales = [] as any;
                for (let item of data["sales"])
                    this.sales!.push(SalesDto.fromJS(item));
            }
            if (Array.isArray(data["storage"])) {
                this.storage = [] as any;
                for (let item of data["storage"])
                    this.storage!.push(StorageDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
            this.skuCount = data["skuCount"];
            this.totalSkuCount = data["totalSkuCount"];
        }
    }

    static fromJS(data: any): ProductChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        if (Array.isArray(this.storage)) {
            data["storage"] = [];
            for (let item of this.storage)
                data["storage"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["skuCount"] = this.skuCount;
        data["totalSkuCount"] = this.totalSkuCount;
        return data; 
    }
}

export interface IProductChartDto {
    sales: SalesDto[] | undefined;
    storage: StorageDto[] | undefined;
    totalCount: number | undefined;
    skuCount: number | undefined;
    totalSkuCount: number | undefined;
}

export class LastSalesChartDto implements ILastSalesChartDto {
    sales!: ValueNamePicUrlDto[] | undefined;

    constructor(data?: ILastSalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["sales"])) {
                this.sales = [] as any;
                for (let item of data["sales"])
                    this.sales!.push(ValueNamePicUrlDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LastSalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new LastSalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILastSalesChartDto {
    sales: ValueNamePicUrlDto[] | undefined;
}

export class CategorySalesChartDto implements ICategorySalesChartDto {
    date!: string | undefined;
    todaySales!: number | undefined;
    categorySales!: ValueNameDto[] | undefined;

    constructor(data?: ICategorySalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.todaySales = data["todaySales"];
            if (Array.isArray(data["categorySales"])) {
                this.categorySales = [] as any;
                for (let item of data["categorySales"])
                    this.categorySales!.push(ValueNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategorySalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["todaySales"] = this.todaySales;
        if (Array.isArray(this.categorySales)) {
            data["categorySales"] = [];
            for (let item of this.categorySales)
                data["categorySales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategorySalesChartDto {
    date: string | undefined;
    todaySales: number | undefined;
    categorySales: ValueNameDto[] | undefined;
}

export class GuestChartDto1 implements IGuestChartDto1 {
    key!: string[] | undefined;
    value!: number[] | undefined;
    total!: number | undefined;

    constructor(data?: IGuestChartDto1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): GuestChartDto1 {
        data = typeof data === 'object' ? data : {};
        let result = new GuestChartDto1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IGuestChartDto1 {
    key: string[] | undefined;
    value: number[] | undefined;
    total: number | undefined;
}

export class OrderCountChartDto implements IOrderCountChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalOrderCount!: number | undefined;

    constructor(data?: IOrderCountChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.totalOrderCount = data["totalOrderCount"];
        }
    }

    static fromJS(data: any): OrderCountChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCountChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalOrderCount"] = this.totalOrderCount;
        return data; 
    }
}

export interface IOrderCountChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalOrderCount: number | undefined;
}

export class BuyerCountChartDto implements IBuyerCountChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalBuyerCount!: number | undefined;

    constructor(data?: IBuyerCountChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["key"])) {
                this.key = [] as any;
                for (let item of data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(data["value"])) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
            this.totalBuyerCount = data["totalBuyerCount"];
        }
    }

    static fromJS(data: any): BuyerCountChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuyerCountChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalBuyerCount"] = this.totalBuyerCount;
        return data; 
    }
}

export interface IBuyerCountChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalBuyerCount: number | undefined;
}

export class SalesDto implements ISalesDto {
    value!: number | undefined;
    name!: string | undefined;
    picUrl!: string | undefined;
    price!: string | undefined;
    quantity!: string | undefined;
    saleCount!: number | undefined;

    constructor(data?: ISalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
            this.picUrl = data["picUrl"];
            this.price = data["price"];
            this.quantity = data["quantity"];
            this.saleCount = data["saleCount"];
        }
    }

    static fromJS(data: any): SalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["saleCount"] = this.saleCount;
        return data; 
    }
}

export interface ISalesDto {
    value: number | undefined;
    name: string | undefined;
    picUrl: string | undefined;
    price: string | undefined;
    quantity: string | undefined;
    saleCount: number | undefined;
}

export class StorageDto implements IStorageDto {
    value!: number | undefined;
    name!: string | undefined;
    picUrl!: string | undefined;
    price!: string | undefined;
    saleCount!: number | undefined;

    constructor(data?: IStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
            this.picUrl = data["picUrl"];
            this.price = data["price"];
            this.saleCount = data["saleCount"];
        }
    }

    static fromJS(data: any): StorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["price"] = this.price;
        data["saleCount"] = this.saleCount;
        return data; 
    }
}

export interface IStorageDto {
    value: number | undefined;
    name: string | undefined;
    picUrl: string | undefined;
    price: string | undefined;
    saleCount: number | undefined;
}

export class ValueNamePicUrlDto implements IValueNamePicUrlDto {
    value!: number | undefined;
    name!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IValueNamePicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
            this.picUrl = data["picUrl"];
        }
    }

    static fromJS(data: any): ValueNamePicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueNamePicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IValueNamePicUrlDto {
    value: number | undefined;
    name: string | undefined;
    picUrl: string | undefined;
}

export class GetMemberPointLogInput implements IGetMemberPointLogInput {
    inOrOutType!: GetMemberPointLogInputInOrOutType | undefined;
    pointFromType!: PointFromType[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IGetMemberPointLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inOrOutType = data["inOrOutType"];
            if (Array.isArray(data["pointFromType"])) {
                this.pointFromType = [] as any;
                for (let item of data["pointFromType"])
                    this.pointFromType!.push(item);
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetMemberPointLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberPointLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inOrOutType"] = this.inOrOutType;
        if (Array.isArray(this.pointFromType)) {
            data["pointFromType"] = [];
            for (let item of this.pointFromType)
                data["pointFromType"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetMemberPointLogInput {
    inOrOutType: GetMemberPointLogInputInOrOutType | undefined;
    pointFromType: PointFromType[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfMemberPointLogDto implements IPagedResultDtoOfMemberPointLogDto {
    totalCount!: number | undefined;
    items!: MemberPointLogDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberPointLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MemberPointLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberPointLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberPointLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMemberPointLogDto {
    totalCount: number | undefined;
    items: MemberPointLogDto[] | undefined;
}

export class MemberPointLogDto implements IMemberPointLogDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    openId!: string | undefined;
    from!: string | undefined;
    inOrOutType!: MemberPointLogDtoInOrOutType | undefined;
    thingId!: string | undefined;
    description!: string | undefined;
    amount!: number | undefined;
    amountBefore!: number | undefined;
    amountAfter!: number | undefined;

    constructor(data?: IMemberPointLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.openId = data["openId"];
            this.from = data["from"];
            this.inOrOutType = data["inOrOutType"];
            this.thingId = data["thingId"];
            this.description = data["description"];
            this.amount = data["amount"];
            this.amountBefore = data["amountBefore"];
            this.amountAfter = data["amountAfter"];
        }
    }

    static fromJS(data: any): MemberPointLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPointLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["openId"] = this.openId;
        data["from"] = this.from;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["amountBefore"] = this.amountBefore;
        data["amountAfter"] = this.amountAfter;
        return data; 
    }
}

export interface IMemberPointLogDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    openId: string | undefined;
    from: string | undefined;
    inOrOutType: MemberPointLogDtoInOrOutType | undefined;
    thingId: string | undefined;
    description: string | undefined;
    amount: number | undefined;
    amountBefore: number | undefined;
    amountAfter: number | undefined;
}

export class PagedResultDtoOfGetTicketDto implements IPagedResultDtoOfGetTicketDto {
    totalCount!: number | undefined;
    items!: GetTicketDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTicketDto {
    totalCount: number | undefined;
    items: GetTicketDto[] | undefined;
}

export class GetTicketDto implements IGetTicketDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    expireTime!: moment.Moment | undefined;
    isTaked!: boolean | undefined;
    canTake!: boolean | undefined;
    description!: string | undefined;
    ticketType!: GetTicketDtoTicketType | undefined;
    takeType!: GetTicketDtoTakeType | undefined;
    value!: number | undefined;
    useCondition!: TicketUseCondition | undefined;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number | undefined;
    mergeUse!: boolean | undefined;
    ticketStatus!: GetTicketDtoTicketStatus | undefined;
    storeId!: number | undefined;

    constructor(data?: IGetTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = data["avaliableDays"];
            this.expireTime = data["expireTime"] ? moment(data["expireTime"].toString()) : <any>undefined;
            this.isTaked = data["isTaked"];
            this.canTake = data["canTake"];
            this.description = data["description"];
            this.ticketType = data["ticketType"];
            this.takeType = data["takeType"];
            this.value = data["value"];
            this.useCondition = data["useCondition"] ? TicketUseCondition.fromJS(data["useCondition"]) : <any>undefined;
            if (Array.isArray(data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = data["usage"];
            this.picUrl = data["picUrl"];
            this.color = data["color"];
            this.limitTimes = data["limitTimes"];
            this.takeTimes = data["takeTimes"];
            this.repeatTakeTimes = data["repeatTakeTimes"];
            this.mergeUse = data["mergeUse"];
            this.ticketStatus = data["ticketStatus"];
            this.storeId = data["storeId"];
        }
    }

    static fromJS(data: any): GetTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["isTaked"] = this.isTaked;
        data["canTake"] = this.canTake;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IGetTicketDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    expireTime: moment.Moment | undefined;
    isTaked: boolean | undefined;
    canTake: boolean | undefined;
    description: string | undefined;
    ticketType: GetTicketDtoTicketType | undefined;
    takeType: GetTicketDtoTakeType | undefined;
    value: number | undefined;
    useCondition: TicketUseCondition | undefined;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number | undefined;
    mergeUse: boolean | undefined;
    ticketStatus: GetTicketDtoTicketStatus | undefined;
    storeId: number | undefined;
}

export class TicketUseCondition implements ITicketUseCondition {
    amount!: number | undefined;
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketUseCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketUseCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUseCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketUseCondition {
    amount: number | undefined;
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class AddCustomerMemberFromOnlineInput implements IAddCustomerMemberFromOnlineInput {
    subkey!: string | undefined;
    tenantId!: number | undefined;
    openId!: string | undefined;
    name!: string | undefined;
    tel!: string | undefined;
    company!: string | undefined;
    interest!: string | undefined;
    type!: string | undefined;
    from!: string | undefined;
    informManager!: boolean | undefined;

    constructor(data?: IAddCustomerMemberFromOnlineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subkey = data["subkey"];
            this.tenantId = data["tenantId"];
            this.openId = data["openId"];
            this.name = data["name"];
            this.tel = data["tel"];
            this.company = data["company"];
            this.interest = data["interest"];
            this.type = data["type"];
            this.from = data["from"];
            this.informManager = data["informManager"];
        }
    }

    static fromJS(data: any): AddCustomerMemberFromOnlineInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddCustomerMemberFromOnlineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["tenantId"] = this.tenantId;
        data["openId"] = this.openId;
        data["name"] = this.name;
        data["tel"] = this.tel;
        data["company"] = this.company;
        data["interest"] = this.interest;
        data["type"] = this.type;
        data["from"] = this.from;
        data["informManager"] = this.informManager;
        return data; 
    }
}

export interface IAddCustomerMemberFromOnlineInput {
    subkey: string | undefined;
    tenantId: number | undefined;
    openId: string | undefined;
    name: string | undefined;
    tel: string | undefined;
    company: string | undefined;
    interest: string | undefined;
    type: string | undefined;
    from: string | undefined;
    informManager: boolean | undefined;
}

export class TakeTicketResultDto implements ITakeTicketResultDto {
    success!: boolean | undefined;
    errorMessage!: string | undefined;
    outerId!: string | undefined;
    ticketNo!: string | undefined;
    memberNo!: string | undefined;
    openId!: string | undefined;

    constructor(data?: ITakeTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.errorMessage = data["errorMessage"];
            this.outerId = data["outerId"];
            this.ticketNo = data["ticketNo"];
            this.memberNo = data["memberNo"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): TakeTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["outerId"] = this.outerId;
        data["ticketNo"] = this.ticketNo;
        data["memberNo"] = this.memberNo;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface ITakeTicketResultDto {
    success: boolean | undefined;
    errorMessage: string | undefined;
    outerId: string | undefined;
    ticketNo: string | undefined;
    memberNo: string | undefined;
    openId: string | undefined;
}

export class VerificatOrderItemInput implements IVerificatOrderItemInput {
    orderId!: number | undefined;
    orderItemId!: number | undefined;
    storeId!: number | undefined;
    activityId!: number | undefined;

    constructor(data?: IVerificatOrderItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.orderItemId = data["orderItemId"];
            this.storeId = data["storeId"];
            this.activityId = data["activityId"];
        }
    }

    static fromJS(data: any): VerificatOrderItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerificatOrderItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderItemId"] = this.orderItemId;
        data["storeId"] = this.storeId;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IVerificatOrderItemInput {
    orderId: number | undefined;
    orderItemId: number | undefined;
    storeId: number | undefined;
    activityId: number | undefined;
}

export class OrderReportByActivityDto implements IOrderReportByActivityDto {
    orderItemCount!: number | undefined;
    orderItemPayment!: number | undefined;
    verificatedCount!: number | undefined;
    verificatedPayment!: number | undefined;

    constructor(data?: IOrderReportByActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderItemCount = data["orderItemCount"];
            this.orderItemPayment = data["orderItemPayment"];
            this.verificatedCount = data["verificatedCount"];
            this.verificatedPayment = data["verificatedPayment"];
        }
    }

    static fromJS(data: any): OrderReportByActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderReportByActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemCount"] = this.orderItemCount;
        data["orderItemPayment"] = this.orderItemPayment;
        data["verificatedCount"] = this.verificatedCount;
        data["verificatedPayment"] = this.verificatedPayment;
        return data; 
    }
}

export interface IOrderReportByActivityDto {
    orderItemCount: number | undefined;
    orderItemPayment: number | undefined;
    verificatedCount: number | undefined;
    verificatedPayment: number | undefined;
}

export class DeliverOrderInput implements IDeliverOrderInput {
    orderId!: number | undefined;
    expressCompanyId!: number | undefined;
    expressNumber!: string | undefined;

    constructor(data?: IDeliverOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.expressCompanyId = data["expressCompanyId"];
            this.expressNumber = data["expressNumber"];
        }
    }

    static fromJS(data: any): DeliverOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeliverOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["expressCompanyId"] = this.expressCompanyId;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IDeliverOrderInput {
    orderId: number | undefined;
    expressCompanyId: number | undefined;
    expressNumber: string | undefined;
}

export class TrackKeyInfoDto implements ITrackKeyInfoDto {
    key!: string | undefined;
    secret!: string | undefined;
    from!: string | undefined;

    constructor(data?: ITrackKeyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.secret = data["secret"];
            this.from = data["from"];
        }
    }

    static fromJS(data: any): TrackKeyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackKeyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["secret"] = this.secret;
        data["from"] = this.from;
        return data; 
    }
}

export interface ITrackKeyInfoDto {
    key: string | undefined;
    secret: string | undefined;
    from: string | undefined;
}

export class OrderDeliverInfoDto implements IOrderDeliverInfoDto {
    id!: number | undefined;
    expressCompanyId!: number | undefined;
    companyName!: string | undefined;
    expressNumber!: string | undefined;

    constructor(data?: IOrderDeliverInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.expressCompanyId = data["expressCompanyId"];
            this.companyName = data["companyName"];
            this.expressNumber = data["expressNumber"];
        }
    }

    static fromJS(data: any): OrderDeliverInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDeliverInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expressCompanyId"] = this.expressCompanyId;
        data["companyName"] = this.companyName;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IOrderDeliverInfoDto {
    id: number | undefined;
    expressCompanyId: number | undefined;
    companyName: string | undefined;
    expressNumber: string | undefined;
}

export class SetShopPayInput implements ISetShopPayInput {
    payAccountId!: number[] | undefined;

    constructor(data?: ISetShopPayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["payAccountId"])) {
                this.payAccountId = [] as any;
                for (let item of data["payAccountId"])
                    this.payAccountId!.push(item);
            }
        }
    }

    static fromJS(data: any): SetShopPayInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetShopPayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.payAccountId)) {
            data["payAccountId"] = [];
            for (let item of this.payAccountId)
                data["payAccountId"].push(item);
        }
        return data; 
    }
}

export interface ISetShopPayInput {
    payAccountId: number[] | undefined;
}

export class RefuseRefundApplyInput implements IRefuseRefundApplyInput {
    id!: number | undefined;
    refundReason!: string | undefined;

    constructor(data?: IRefuseRefundApplyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.refundReason = data["refundReason"];
        }
    }

    static fromJS(data: any): RefuseRefundApplyInput {
        data = typeof data === 'object' ? data : {};
        let result = new RefuseRefundApplyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refundReason"] = this.refundReason;
        return data; 
    }
}

export interface IRefuseRefundApplyInput {
    id: number | undefined;
    refundReason: string | undefined;
}

export class GetTicketsByTagAndCategoryInput implements IGetTicketsByTagAndCategoryInput {
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: IGetTicketsByTagAndCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTicketsByTagAndCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsByTagAndCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface IGetTicketsByTagAndCategoryInput {
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class TicketTagAndCategoryOutput implements ITicketTagAndCategoryOutput {
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketTagAndCategoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketTagAndCategoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TicketTagAndCategoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketTagAndCategoryOutput {
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class GetTicketsForOrderInput implements IGetTicketsForOrderInput {
    ticketInfos!: ProductIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetTicketsForOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ticketInfos"])) {
                this.ticketInfos = [] as any;
                for (let item of data["ticketInfos"])
                    this.ticketInfos!.push(ProductIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketsForOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsForOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketInfos)) {
            data["ticketInfos"] = [];
            for (let item of this.ticketInfos)
                data["ticketInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketsForOrderInput {
    ticketInfos: ProductIdAndTicketIdDto[] | undefined;
}

export class ProductIdAndTicketIdDto implements IProductIdAndTicketIdDto {
    skuId!: number | undefined;
    number!: number | undefined;
    ticketId!: number | undefined;

    constructor(data?: IProductIdAndTicketIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.number = data["number"];
            this.ticketId = data["ticketId"];
        }
    }

    static fromJS(data: any): ProductIdAndTicketIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIdAndTicketIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        data["ticketId"] = this.ticketId;
        return data; 
    }
}

export interface IProductIdAndTicketIdDto {
    skuId: number | undefined;
    number: number | undefined;
    ticketId: number | undefined;
}

export class SkuTicketDto implements ISkuTicketDto {
    skuTickets!: SkuTicket[] | undefined;
    tickets!: GetTicketDto[] | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;

    constructor(data?: ISkuTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["skuTickets"])) {
                this.skuTickets = [] as any;
                for (let item of data["skuTickets"])
                    this.skuTickets!.push(SkuTicket.fromJS(item));
            }
            if (Array.isArray(data["tickets"])) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets!.push(GetTicketDto.fromJS(item));
            }
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
        }
    }

    static fromJS(data: any): SkuTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuTickets)) {
            data["skuTickets"] = [];
            for (let item of this.skuTickets)
                data["skuTickets"].push(item.toJSON());
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        return data; 
    }
}

export interface ISkuTicketDto {
    skuTickets: SkuTicket[] | undefined;
    tickets: GetTicketDto[] | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
}

export class SkuTicket implements ISkuTicket {
    skuId!: number | undefined;
    tickets!: GetTicketDto[] | undefined;

    constructor(data?: ISkuTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            if (Array.isArray(data["tickets"])) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets!.push(GetTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuTicket {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuTicket {
    skuId: number | undefined;
    tickets: GetTicketDto[] | undefined;
}

export class GetTicketsInput implements IGetTicketsInput {
    ticketInfos!: SkuIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetTicketsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ticketInfos"])) {
                this.ticketInfos = [] as any;
                for (let item of data["ticketInfos"])
                    this.ticketInfos!.push(SkuIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketInfos)) {
            data["ticketInfos"] = [];
            for (let item of this.ticketInfos)
                data["ticketInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketsInput {
    ticketInfos: SkuIdAndTicketIdDto[] | undefined;
}

export class SkuIdAndTicketIdDto implements ISkuIdAndTicketIdDto {
    skuId!: number | undefined;
    number!: number | undefined;

    constructor(data?: ISkuIdAndTicketIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skuId = data["skuId"];
            this.number = data["number"];
        }
    }

    static fromJS(data: any): SkuIdAndTicketIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuIdAndTicketIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        return data; 
    }
}

export interface ISkuIdAndTicketIdDto {
    skuId: number | undefined;
    number: number | undefined;
}

export class SimpleTicketDto implements ISimpleTicketDto {
    id!: number | undefined;
    ticketType!: SimpleTicketDtoTicketType | undefined;
    useCondition!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    value!: number | undefined;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    isRecommend!: boolean | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: ISimpleTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketType = data["ticketType"];
            this.useCondition = data["useCondition"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.value = data["value"];
            this.totalFee = data["totalFee"];
            this.discountFee = data["discountFee"];
            this.isRecommend = data["isRecommend"];
            this.pointReduction = data["pointReduction"];
            this.deductionAmount = data["deductionAmount"];
        }
    }

    static fromJS(data: any): SimpleTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketType"] = this.ticketType;
        data["useCondition"] = this.useCondition;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["value"] = this.value;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["isRecommend"] = this.isRecommend;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface ISimpleTicketDto {
    id: number | undefined;
    ticketType: SimpleTicketDtoTicketType | undefined;
    useCondition: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    value: number | undefined;
    totalFee: number | undefined;
    discountFee: number | undefined;
    isRecommend: boolean | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class TakeTicketForActivityInput implements ITakeTicketForActivityInput {
    ticket!: number | undefined;
    actionId!: number | undefined;
    securityKey!: string | undefined;
    sendMessage!: boolean | undefined;

    constructor(data?: ITakeTicketForActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"];
            this.actionId = data["actionId"];
            this.securityKey = data["securityKey"];
            this.sendMessage = data["sendMessage"];
        }
    }

    static fromJS(data: any): TakeTicketForActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketForActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["sendMessage"] = this.sendMessage;
        return data; 
    }
}

export interface ITakeTicketForActivityInput {
    ticket: number | undefined;
    actionId: number | undefined;
    securityKey: string | undefined;
    sendMessage: boolean | undefined;
}

export class GetTakedTicketInfoDto implements IGetTakedTicketInfoDto {
    memberId!: number | undefined;
    ticketId!: number | undefined;
    used!: boolean | undefined;
    useTime!: moment.Moment | undefined;
    ticketNo!: string | undefined;
    actionId!: number | undefined;
    ticketInfo!: Ticket | undefined;

    constructor(data?: IGetTakedTicketInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.ticketId = data["ticketId"];
            this.used = data["used"];
            this.useTime = data["useTime"] ? moment(data["useTime"].toString()) : <any>undefined;
            this.ticketNo = data["ticketNo"];
            this.actionId = data["actionId"];
            this.ticketInfo = data["ticketInfo"] ? Ticket.fromJS(data["ticketInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTakedTicketInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTakedTicketInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["ticketId"] = this.ticketId;
        data["used"] = this.used;
        data["useTime"] = this.useTime ? this.useTime.toISOString() : <any>undefined;
        data["ticketNo"] = this.ticketNo;
        data["actionId"] = this.actionId;
        data["ticketInfo"] = this.ticketInfo ? this.ticketInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTakedTicketInfoDto {
    memberId: number | undefined;
    ticketId: number | undefined;
    used: boolean | undefined;
    useTime: moment.Moment | undefined;
    ticketNo: string | undefined;
    actionId: number | undefined;
    ticketInfo: Ticket | undefined;
}

export class Ticket implements ITicket {
    tenantId!: number | undefined;
    storeId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    description!: string | undefined;
    ticketType!: TicketType3 | undefined;
    takeType!: TicketTakeType | undefined;
    value!: number | undefined;
    useCondition!: string | undefined;
    takeCondition!: string | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number | undefined;
    mergeUse!: boolean | undefined;
    ticketStatus!: TicketStatus3 | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.storeId = data["storeId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = data["avaliableDays"];
            this.description = data["description"];
            this.ticketType = data["ticketType"];
            this.takeType = data["takeType"];
            this.value = data["value"];
            this.useCondition = data["useCondition"];
            this.takeCondition = data["takeCondition"];
            this.usage = data["usage"];
            this.picUrl = data["picUrl"];
            this.color = data["color"];
            this.limitTimes = data["limitTimes"];
            this.takeTimes = data["takeTimes"];
            this.repeatTakeTimes = data["repeatTakeTimes"];
            this.mergeUse = data["mergeUse"];
            this.ticketStatus = data["ticketStatus"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition;
        data["takeCondition"] = this.takeCondition;
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITicket {
    tenantId: number | undefined;
    storeId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    description: string | undefined;
    ticketType: TicketType3 | undefined;
    takeType: TicketTakeType | undefined;
    value: number | undefined;
    useCondition: string | undefined;
    takeCondition: string | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number | undefined;
    mergeUse: boolean | undefined;
    ticketStatus: TicketStatus3 | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetPointPreOrderInput implements IGetPointPreOrderInput {
    pointOrderInfos!: SkuIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetPointPreOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["pointOrderInfos"])) {
                this.pointOrderInfos = [] as any;
                for (let item of data["pointOrderInfos"])
                    this.pointOrderInfos!.push(SkuIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPointPreOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPointPreOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pointOrderInfos)) {
            data["pointOrderInfos"] = [];
            for (let item of this.pointOrderInfos)
                data["pointOrderInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPointPreOrderInput {
    pointOrderInfos: SkuIdAndTicketIdDto[] | undefined;
}

export class SimplePointOrderDto implements ISimplePointOrderDto {
    canPointPurchase!: boolean | undefined;
    reason!: string | undefined;
    totalFee!: number | undefined;
    takePoint!: number | undefined;

    constructor(data?: ISimplePointOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canPointPurchase = data["canPointPurchase"];
            this.reason = data["reason"];
            this.totalFee = data["totalFee"];
            this.takePoint = data["takePoint"];
        }
    }

    static fromJS(data: any): SimplePointOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePointOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canPointPurchase"] = this.canPointPurchase;
        data["reason"] = this.reason;
        data["totalFee"] = this.totalFee;
        data["takePoint"] = this.takePoint;
        return data; 
    }
}

export interface ISimplePointOrderDto {
    canPointPurchase: boolean | undefined;
    reason: string | undefined;
    totalFee: number | undefined;
    takePoint: number | undefined;
}

export class TaketicketForUserInput implements ITaketicketForUserInput {
    openId!: string | undefined;
    appId!: string | undefined;
    securityKey!: string | undefined;
    memberNo!: string | undefined;
    memberType!: string | undefined;
    ticketId!: number | undefined;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;

    constructor(data?: ITaketicketForUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.appId = data["appId"];
            this.securityKey = data["securityKey"];
            this.memberNo = data["memberNo"];
            this.memberType = data["memberType"];
            this.ticketId = data["ticketId"];
            this.nickName = data["nickName"];
            this.headImgUrl = data["headImgUrl"];
        }
    }

    static fromJS(data: any): TaketicketForUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new TaketicketForUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["appId"] = this.appId;
        data["securityKey"] = this.securityKey;
        data["memberNo"] = this.memberNo;
        data["memberType"] = this.memberType;
        data["ticketId"] = this.ticketId;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        return data; 
    }
}

export interface ITaketicketForUserInput {
    openId: string | undefined;
    appId: string | undefined;
    securityKey: string | undefined;
    memberNo: string | undefined;
    memberType: string | undefined;
    ticketId: number | undefined;
    nickName: string | undefined;
    headImgUrl: string | undefined;
}

export class TakeTicketRepInput implements ITakeTicketRepInput {
    openId!: string | undefined;
    appId!: string | undefined;
    endTime!: moment.Moment | undefined;
    startTime!: moment.Moment | undefined;
    ticktId!: number | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    isUsed!: number | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: ITakeTicketRepInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.appId = data["appId"];
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.ticktId = data["ticktId"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.isUsed = data["isUsed"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): TakeTicketRepInput {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketRepInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["appId"] = this.appId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ticktId"] = this.ticktId;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["isUsed"] = this.isUsed;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface ITakeTicketRepInput {
    openId: string | undefined;
    appId: string | undefined;
    endTime: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    ticktId: number | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    isUsed: number | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfTakeTicketRepDto implements IPagedResultDtoOfTakeTicketRepDto {
    totalCount!: number | undefined;
    items!: TakeTicketRepDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTakeTicketRepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TakeTicketRepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTakeTicketRepDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTakeTicketRepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTakeTicketRepDto {
    totalCount: number | undefined;
    items: TakeTicketRepDto[] | undefined;
}

export class TakeTicketRepDto implements ITakeTicketRepDto {
    id!: number | undefined;
    isSuccess!: boolean | undefined;
    memberNo!: string | undefined;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;
    operationTime!: string | undefined;
    openId!: string | undefined;
    storeId!: string | undefined;
    storename!: string | undefined;
    pickDate!: moment.Moment | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    activityId!: number | undefined;
    activityName!: string | undefined;
    activityNote!: string | undefined;
    awardName!: string | undefined;
    memberType!: string | undefined;

    constructor(data?: ITakeTicketRepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isSuccess = data["isSuccess"];
            this.memberNo = data["memberNo"];
            this.nickName = data["nickName"];
            this.headImgUrl = data["headImgUrl"];
            this.operationTime = data["operationTime"];
            this.openId = data["openId"];
            this.storeId = data["storeId"];
            this.storename = data["storename"];
            this.pickDate = data["pickDate"] ? moment(data["pickDate"].toString()) : <any>undefined;
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.activityId = data["activityId"];
            this.activityName = data["activityName"];
            this.activityNote = data["activityNote"];
            this.awardName = data["awardName"];
            this.memberType = data["memberType"];
        }
    }

    static fromJS(data: any): TakeTicketRepDto {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketRepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSuccess"] = this.isSuccess;
        data["memberNo"] = this.memberNo;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        data["operationTime"] = this.operationTime;
        data["openId"] = this.openId;
        data["storeId"] = this.storeId;
        data["storename"] = this.storename;
        data["pickDate"] = this.pickDate ? this.pickDate.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["activityNote"] = this.activityNote;
        data["awardName"] = this.awardName;
        data["memberType"] = this.memberType;
        return data; 
    }
}

export interface ITakeTicketRepDto {
    id: number | undefined;
    isSuccess: boolean | undefined;
    memberNo: string | undefined;
    nickName: string | undefined;
    headImgUrl: string | undefined;
    operationTime: string | undefined;
    openId: string | undefined;
    storeId: string | undefined;
    storename: string | undefined;
    pickDate: moment.Moment | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    activityId: number | undefined;
    activityName: string | undefined;
    activityNote: string | undefined;
    awardName: string | undefined;
    memberType: string | undefined;
}

export class CheckTicketDto implements ICheckTicketDto {
    actionId!: number | undefined;
    cargoRoadId!: number | undefined;
    thingName!: string | undefined;
    thingId!: number | undefined;
    success!: boolean | undefined;
    errorMessage!: string | undefined;
    outerId!: string | undefined;
    ticketNo!: string | undefined;
    memberNo!: string | undefined;
    openId!: string | undefined;

    constructor(data?: ICheckTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionId = data["actionId"];
            this.cargoRoadId = data["cargoRoadId"];
            this.thingName = data["thingName"];
            this.thingId = data["thingId"];
            this.success = data["success"];
            this.errorMessage = data["errorMessage"];
            this.outerId = data["outerId"];
            this.ticketNo = data["ticketNo"];
            this.memberNo = data["memberNo"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): CheckTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["thingName"] = this.thingName;
        data["thingId"] = this.thingId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["outerId"] = this.outerId;
        data["ticketNo"] = this.ticketNo;
        data["memberNo"] = this.memberNo;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface ICheckTicketDto {
    actionId: number | undefined;
    cargoRoadId: number | undefined;
    thingName: string | undefined;
    thingId: number | undefined;
    success: boolean | undefined;
    errorMessage: string | undefined;
    outerId: string | undefined;
    ticketNo: string | undefined;
    memberNo: string | undefined;
    openId: string | undefined;
}

export class TicketRep implements ITicketRep {
    area!: string | undefined;
    storeNo!: string | undefined;
    storeName!: string | undefined;
    deviceName!: string | undefined;
    schedule!: string | undefined;
    totalLeft!: string | undefined;
    newMemberToday!: number | undefined;
    oldMemberToday!: number | undefined;
    todayCount!: number | undefined;
    newMember!: number | undefined;
    oldMember!: number | undefined;
    totalCount!: number | undefined;
    avgNum!: number | undefined;

    constructor(data?: ITicketRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.area = data["area"];
            this.storeNo = data["storeNo"];
            this.storeName = data["storeName"];
            this.deviceName = data["deviceName"];
            this.schedule = data["schedule"];
            this.totalLeft = data["totalLeft"];
            this.newMemberToday = data["newMemberToday"];
            this.oldMemberToday = data["oldMemberToday"];
            this.todayCount = data["todayCount"];
            this.newMember = data["newMember"];
            this.oldMember = data["oldMember"];
            this.totalCount = data["totalCount"];
            this.avgNum = data["avgNum"];
        }
    }

    static fromJS(data: any): TicketRep {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["storeNo"] = this.storeNo;
        data["storeName"] = this.storeName;
        data["deviceName"] = this.deviceName;
        data["schedule"] = this.schedule;
        data["totalLeft"] = this.totalLeft;
        data["newMemberToday"] = this.newMemberToday;
        data["oldMemberToday"] = this.oldMemberToday;
        data["todayCount"] = this.todayCount;
        data["newMember"] = this.newMember;
        data["oldMember"] = this.oldMember;
        data["totalCount"] = this.totalCount;
        data["avgNum"] = this.avgNum;
        return data; 
    }
}

export interface ITicketRep {
    area: string | undefined;
    storeNo: string | undefined;
    storeName: string | undefined;
    deviceName: string | undefined;
    schedule: string | undefined;
    totalLeft: string | undefined;
    newMemberToday: number | undefined;
    oldMemberToday: number | undefined;
    todayCount: number | undefined;
    newMember: number | undefined;
    oldMember: number | undefined;
    totalCount: number | undefined;
    avgNum: number | undefined;
}

export class Stream implements IStream {
    readonly canRead!: boolean | undefined;
    readonly canSeek!: boolean | undefined;
    readonly canTimeout!: boolean | undefined;
    readonly canWrite!: boolean | undefined;
    readonly length!: number | undefined;
    position!: number | undefined;
    readTimeout!: number | undefined;
    writeTimeout!: number | undefined;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).canRead = data["canRead"];
            (<any>this).canSeek = data["canSeek"];
            (<any>this).canTimeout = data["canTimeout"];
            (<any>this).canWrite = data["canWrite"];
            (<any>this).length = data["length"];
            this.position = data["position"];
            this.readTimeout = data["readTimeout"];
            this.writeTimeout = data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }
}

export interface IStream {
    canRead: boolean | undefined;
    canSeek: boolean | undefined;
    canTimeout: boolean | undefined;
    canWrite: boolean | undefined;
    length: number | undefined;
    position: number | undefined;
    readTimeout: number | undefined;
    writeTimeout: number | undefined;
}

export class PagedResultDtoOfTagDto implements IPagedResultDtoOfTagDto {
    totalCount!: number | undefined;
    items!: TagDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTagDto {
    totalCount: number | undefined;
    items: TagDto[] | undefined;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagDtoType | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.type = data["type"];
            this.iconUrl = data["iconUrl"];
            this.isSpecial = data["isSpecial"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.orderNumber = data["orderNumber"];
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagDtoType | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: CreateTagInputType | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.type = data["type"];
            this.iconUrl = data["iconUrl"];
            this.isSpecial = data["isSpecial"];
            this.orderNumber = data["orderNumber"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: CreateTagInputType | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number | undefined;
    value!: string | undefined;
    type!: UpdateTagInputType | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.value = data["value"];
            this.type = data["type"];
            this.iconUrl = data["iconUrl"];
            this.isSpecial = data["isSpecial"];
            this.orderNumber = data["orderNumber"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number | undefined;
    value: string | undefined;
    type: UpdateTagInputType | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
}

export class AddOrUpdateTicketInput implements IAddOrUpdateTicketInput {
    id!: number | undefined;
    storeId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    ticketType!: AddOrUpdateTicketInputTicketType | undefined;
    takeType!: AddOrUpdateTicketInputTakeType | undefined;
    value!: number | undefined;
    useCondition!: TicketUseCondition | undefined;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number | undefined;
    mergeUse!: boolean | undefined;
    ticketStatus!: AddOrUpdateTicketInputTicketStatus | undefined;

    constructor(data?: IAddOrUpdateTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.storeId = data["storeId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = data["avaliableDays"];
            this.ticketType = data["ticketType"];
            this.takeType = data["takeType"];
            this.value = data["value"];
            this.useCondition = data["useCondition"] ? TicketUseCondition.fromJS(data["useCondition"]) : <any>undefined;
            if (Array.isArray(data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = data["usage"];
            this.picUrl = data["picUrl"];
            this.color = data["color"];
            this.limitTimes = data["limitTimes"];
            this.takeTimes = data["takeTimes"];
            this.repeatTakeTimes = data["repeatTakeTimes"];
            this.mergeUse = data["mergeUse"];
            this.ticketStatus = data["ticketStatus"];
        }
    }

    static fromJS(data: any): AddOrUpdateTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface IAddOrUpdateTicketInput {
    id: number | undefined;
    storeId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    ticketType: AddOrUpdateTicketInputTicketType | undefined;
    takeType: AddOrUpdateTicketInputTakeType | undefined;
    value: number | undefined;
    useCondition: TicketUseCondition | undefined;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number | undefined;
    mergeUse: boolean | undefined;
    ticketStatus: AddOrUpdateTicketInputTicketStatus | undefined;
}

export class GrantTicketByTagsInput implements IGrantTicketByTagsInput {
    ticketIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IGrantTicketByTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GrantTicketByTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantTicketByTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IGrantTicketByTagsInput {
    ticketIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class GrantTicketByMemberLevelsInput implements IGrantTicketByMemberLevelsInput {
    ticketIds!: number[] | undefined;
    memberLevels!: string[] | undefined;

    constructor(data?: IGrantTicketByMemberLevelsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            if (Array.isArray(data["memberLevels"])) {
                this.memberLevels = [] as any;
                for (let item of data["memberLevels"])
                    this.memberLevels!.push(item);
            }
        }
    }

    static fromJS(data: any): GrantTicketByMemberLevelsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantTicketByMemberLevelsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        if (Array.isArray(this.memberLevels)) {
            data["memberLevels"] = [];
            for (let item of this.memberLevels)
                data["memberLevels"].push(item);
        }
        return data; 
    }
}

export interface IGrantTicketByMemberLevelsInput {
    ticketIds: number[] | undefined;
    memberLevels: string[] | undefined;
}

export class PagedResultDtoOfGetTicketMemberDto implements IPagedResultDtoOfGetTicketMemberDto {
    totalCount!: number | undefined;
    items!: GetTicketMemberDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTicketMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTicketMemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTicketMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTicketMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTicketMemberDto {
    totalCount: number | undefined;
    items: GetTicketMemberDto[] | undefined;
}

export class GetTicketMemberDto implements IGetTicketMemberDto {
    memberTicketId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    used!: boolean | undefined;
    useTime!: moment.Moment | undefined;
    memberId!: number | undefined;
    wechatNickName!: string | undefined;
    openId!: string | undefined;
    storeName!: string | undefined;
    deviceId!: number | undefined;

    constructor(data?: IGetTicketMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberTicketId = data["memberTicketId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.used = data["used"];
            this.useTime = data["useTime"] ? moment(data["useTime"].toString()) : <any>undefined;
            this.memberId = data["memberId"];
            this.wechatNickName = data["wechatNickName"];
            this.openId = data["openId"];
            this.storeName = data["storeName"];
            this.deviceId = data["deviceId"];
        }
    }

    static fromJS(data: any): GetTicketMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberTicketId"] = this.memberTicketId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["used"] = this.used;
        data["useTime"] = this.useTime ? this.useTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["wechatNickName"] = this.wechatNickName;
        data["openId"] = this.openId;
        data["storeName"] = this.storeName;
        data["deviceId"] = this.deviceId;
        return data; 
    }
}

export interface IGetTicketMemberDto {
    memberTicketId: number | undefined;
    creationTime: moment.Moment | undefined;
    used: boolean | undefined;
    useTime: moment.Moment | undefined;
    memberId: number | undefined;
    wechatNickName: string | undefined;
    openId: string | undefined;
    storeName: string | undefined;
    deviceId: number | undefined;
}

export class SetTicketStatusInput implements ISetTicketStatusInput {
    ticketIds!: number[] | undefined;
    ticketStatus!: SetTicketStatusInputTicketStatus | undefined;

    constructor(data?: ISetTicketStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            this.ticketStatus = data["ticketStatus"];
        }
    }

    static fromJS(data: any): SetTicketStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetTicketStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface ISetTicketStatusInput {
    ticketIds: number[] | undefined;
    ticketStatus: SetTicketStatusInputTicketStatus | undefined;
}

export enum PayType {
    Pay = "Pay",
    Refund = "Refund",
}

export enum TicketStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum TicketType {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum TakeType {
    UserTake = "UserTake",
    ManagerGrant = "ManagerGrant",
    RegisterAutoGrant = "RegisterAutoGrant",
    GameAutoGrant = "GameAutoGrant",
}

export enum Type {
    Member = "Member",
    Customer = "Customer",
}

export enum TicketStatus2 {
    Offline = "Offline",
    Online = "Online",
}

export enum TicketType2 {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum TakeType2 {
    UserTake = "UserTake",
    ManagerGrant = "ManagerGrant",
    RegisterAutoGrant = "RegisterAutoGrant",
    GameAutoGrant = "GameAutoGrant",
}

export enum SnsUserInfoDtoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    Others = "Others",
}

export enum DispatchPointToMemberInputPointFromType {
    CashPayment = "CashPayment",
    Exchange = "Exchange",
    Activity = "Activity",
    Dispatch = "Dispatch",
    ThirdParty = "ThirdParty",
}

export enum DispatchPointToMemberInputInOrOutType {
    In = "In",
    Out = "Out",
}

export enum DispatchPointToMemberInput1PointFromType {
    CashPayment = "CashPayment",
    Exchange = "Exchange",
    Activity = "Activity",
    Dispatch = "Dispatch",
    ThirdParty = "ThirdParty",
}

export enum DispatchPointToMemberInput1InOrOutType {
    In = "In",
    Out = "Out",
}

export enum PrintOrderDtoPrintState {
    None = "None",
    WaitingForPrint = "WaitingForPrint",
    Printing = "Printing",
    Printed = "Printed",
    Failed = "Failed",
}

export enum AddOrUpdateOrderExtensionInputPrintState {
    None = "None",
    WaitingForPrint = "WaitingForPrint",
    Printing = "Printing",
    Printed = "Printed",
    Failed = "Failed",
}

export enum PrintOrderActionPrintState {
    None = "None",
    WaitingForPrint = "WaitingForPrint",
    Printing = "Printing",
    Printed = "Printed",
    Failed = "Failed",
}

export enum GetPayRecordDtoPayType {
    Pay = "Pay",
    Refund = "Refund",
}

export enum RefundOrderInputRefundWay {
    Refund = "Refund",
    Return = "Return",
    Exchange = "Exchange",
}

export enum GetRefundDetailDtoRefundWay {
    Refund = "Refund",
    Return = "Return",
    Exchange = "Exchange",
}

export enum GetRefundDetailDtoStatus {
    Submitted = "Submitted",
    CheckPassed = "CheckPassed",
    Returned = "Returned",
    Delivered = "Delivered",
    CheckRefused = "CheckRefused",
}

export enum SnsUserInfoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    Others = "Others",
}

export enum RegisterFaceByUserInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    Others = "Others",
}

export enum GetMemberPointLogInputInOrOutType {
    In = "In",
    Out = "Out",
}

export enum PointFromType {
    CashPayment = "CashPayment",
    Exchange = "Exchange",
    Activity = "Activity",
    Dispatch = "Dispatch",
    ThirdParty = "ThirdParty",
}

export enum MemberPointLogDtoInOrOutType {
    In = "In",
    Out = "Out",
}

export enum GetTicketDtoTicketType {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum GetTicketDtoTakeType {
    UserTake = "UserTake",
    ManagerGrant = "ManagerGrant",
    RegisterAutoGrant = "RegisterAutoGrant",
    GameAutoGrant = "GameAutoGrant",
}

export enum GetTicketDtoTicketStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum SimpleTicketDtoTicketType {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum TicketType3 {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum TicketTakeType {
    UserTake = "UserTake",
    ManagerGrant = "ManagerGrant",
    RegisterAutoGrant = "RegisterAutoGrant",
    GameAutoGrant = "GameAutoGrant",
}

export enum TicketStatus3 {
    Offline = "Offline",
    Online = "Online",
}

export enum TagDtoType {
    Resource = "Resource",
    Device = "Device",
    Product = "Product",
    Ads = "Ads",
    Other = "Other",
    Brand = "Brand",
    Question = "Question",
    Counter = "Counter",
    WechatPublicMessage = "WechatPublicMessage",
}

export enum CreateTagInputType {
    Member = "Member",
    Customer = "Customer",
}

export enum UpdateTagInputType {
    Member = "Member",
    Customer = "Customer",
}

export enum AddOrUpdateTicketInputTicketType {
    Voucher = "Voucher",
    Discount = "Discount",
}

export enum AddOrUpdateTicketInputTakeType {
    UserTake = "UserTake",
    ManagerGrant = "ManagerGrant",
    RegisterAutoGrant = "RegisterAutoGrant",
    GameAutoGrant = "GameAutoGrant",
}

export enum AddOrUpdateTicketInputTicketStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum SetTicketStatusInputTicketStatus {
    Offline = "Offline",
    Online = "Online",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}