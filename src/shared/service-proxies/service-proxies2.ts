/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.3.0 (NJsonSchema v10.3.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_ONLINE_URL = new InjectionToken<string>('API_ONLINE_URL');

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Order Status list for Tenant
     * @return Success
     */
    orderStatus(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderStatus(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderStatus(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    orderMemberDiscounts(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderMemberDiscounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderMemberDiscounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderMemberDiscounts(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderMemberDiscounts(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    orderActivityTags(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderActivityTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderActivityTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderActivityTags(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderActivityTags(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrderCategorys(): Observable<OrderCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetOrderCategorys";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderCategorys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderCategorys(<any>response_);
                } catch (e) {
                    return <Observable<OrderCategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderCategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderCategorys(response: HttpResponseBase): Observable<OrderCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderCategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderCategoryDto[]>(<any>null);
    }

    /**
     * Get Member Type list for tenant
     * @return Success
     */
    memberType(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/MemberType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberType(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processMemberType(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * Get Order Status list for Tenant
     * @return Success
     */
    orderFrom(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/OrderFrom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderFrom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderFrom(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderFrom(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class DataTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 转移会员信息
     * @param sourceTenantId (optional) 
     * @param targetTenantId (optional) 
     * @return Success
     */
    transferMemberAndOrderInfo(sourceTenantId: number | undefined, targetTenantId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataTransfer/TransferMemberAndOrderInfo?";
        if (sourceTenantId === null)
            throw new Error("The parameter 'sourceTenantId' cannot be null.");
        else if (sourceTenantId !== undefined)
            url_ += "sourceTenantId=" + encodeURIComponent("" + sourceTenantId) + "&";
        if (targetTenantId === null)
            throw new Error("The parameter 'targetTenantId' cannot be null.");
        else if (targetTenantId !== undefined)
            url_ += "targetTenantId=" + encodeURIComponent("" + targetTenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransferMemberAndOrderInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferMemberAndOrderInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferMemberAndOrderInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&";
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GcodeConvertServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param canvasWidth (optional) 
     * @param canvasHeight (optional) 
     * @param signatureImage (optional) 
     * @param strokeFile (optional) 
     * @param strokes (optional) 
     * @param strokeJson (optional) 
     * @param drawOutline (optional) 
     * @param maxWidth (optional) 
     * @param maxHeight (optional) 
     * @param offsetX (optional) 
     * @param offsetY (optional) 
     * @param borderSpeed (optional) 
     * @return Success
     */
    convertStrokeToGcode(canvasWidth: number | undefined, canvasHeight: number | undefined, signatureImage: FileParameter | undefined, strokeFile: FileParameter | undefined, strokes: PointF[][] | undefined, strokeJson: string | undefined, drawOutline: boolean | undefined, maxWidth: number | undefined, maxHeight: number | undefined, offsetX: number | undefined, offsetY: number | undefined, borderSpeed: number | undefined): Observable<TinyFileOutput> {
        let url_ = this.baseUrl + "/api/GcodeConvert/ConvertStrokeToGcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (canvasWidth === null || canvasWidth === undefined)
            throw new Error("The parameter 'canvasWidth' cannot be null.");
        else
            content_.append("CanvasWidth", canvasWidth.toString());
        if (canvasHeight === null || canvasHeight === undefined)
            throw new Error("The parameter 'canvasHeight' cannot be null.");
        else
            content_.append("CanvasHeight", canvasHeight.toString());
        if (signatureImage === null || signatureImage === undefined)
            throw new Error("The parameter 'signatureImage' cannot be null.");
        else
            content_.append("SignatureImage", signatureImage.data, signatureImage.fileName ? signatureImage.fileName : "SignatureImage");
        if (strokeFile === null || strokeFile === undefined)
            throw new Error("The parameter 'strokeFile' cannot be null.");
        else
            content_.append("StrokeFile", strokeFile.data, strokeFile.fileName ? strokeFile.fileName : "StrokeFile");
        if (strokes === null || strokes === undefined)
            throw new Error("The parameter 'strokes' cannot be null.");
        else
            strokes.forEach(item_ => content_.append("Strokes", item_.toString()));
        if (strokeJson === null || strokeJson === undefined)
            throw new Error("The parameter 'strokeJson' cannot be null.");
        else
            content_.append("StrokeJson", strokeJson.toString());
        if (drawOutline === null || drawOutline === undefined)
            throw new Error("The parameter 'drawOutline' cannot be null.");
        else
            content_.append("DrawOutline", drawOutline.toString());
        if (maxWidth === null || maxWidth === undefined)
            throw new Error("The parameter 'maxWidth' cannot be null.");
        else
            content_.append("MaxWidth", maxWidth.toString());
        if (maxHeight === null || maxHeight === undefined)
            throw new Error("The parameter 'maxHeight' cannot be null.");
        else
            content_.append("MaxHeight", maxHeight.toString());
        if (offsetX === null || offsetX === undefined)
            throw new Error("The parameter 'offsetX' cannot be null.");
        else
            content_.append("OffsetX", offsetX.toString());
        if (offsetY === null || offsetY === undefined)
            throw new Error("The parameter 'offsetY' cannot be null.");
        else
            content_.append("OffsetY", offsetY.toString());
        if (borderSpeed === null || borderSpeed === undefined)
            throw new Error("The parameter 'borderSpeed' cannot be null.");
        else
            content_.append("BorderSpeed", borderSpeed.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertStrokeToGcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertStrokeToGcode(<any>response_);
                } catch (e) {
                    return <Observable<TinyFileOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinyFileOutput>><any>_observableThrow(response_);
        }));
    }

    protected processConvertStrokeToGcode(response: HttpResponseBase): Observable<TinyFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinyFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinyFileOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    convertTextToGcode(body: PostSignatureTextDataInput | undefined): Observable<TinyFileOutput> {
        let url_ = this.baseUrl + "/api/GcodeConvert/ConvertTextToGcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertTextToGcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertTextToGcode(<any>response_);
                } catch (e) {
                    return <Observable<TinyFileOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinyFileOutput>><any>_observableThrow(response_);
        }));
    }

    protected processConvertTextToGcode(response: HttpResponseBase): Observable<TinyFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinyFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinyFileOutput>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 会员姓名
     * @param registerdTimeStart (optional) 
     * @param registerdTimeEnd (optional) 
     * @param type (optional) 
     * @param storeIds (optional) 
     * @param customerIds (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMembers(name: string | undefined, registerdTimeStart: moment.Moment | undefined, registerdTimeEnd: moment.Moment | undefined, type: string | undefined, storeIds: number[] | undefined, customerIds: number[] | undefined, sorting: string | undefined, filter: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<MemberDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMembers?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (registerdTimeStart === null)
            throw new Error("The parameter 'registerdTimeStart' cannot be null.");
        else if (registerdTimeStart !== undefined)
            url_ += "RegisterdTimeStart=" + encodeURIComponent(registerdTimeStart ? "" + registerdTimeStart.toJSON() : "") + "&";
        if (registerdTimeEnd === null)
            throw new Error("The parameter 'registerdTimeEnd' cannot be null.");
        else if (registerdTimeEnd !== undefined)
            url_ += "RegisterdTimeEnd=" + encodeURIComponent(registerdTimeEnd ? "" + registerdTimeEnd.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (customerIds === null)
            throw new Error("The parameter 'customerIds' cannot be null.");
        else if (customerIds !== undefined)
            customerIds && customerIds.forEach(item => { url_ += "CustomerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembers(<any>response_);
                } catch (e) {
                    return <Observable<MemberDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMembers(response: HttpResponseBase): Observable<MemberDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDtoPagedResultDto>(<any>null);
    }

    /**
     * @param name (optional) 会员姓名
     * @param registerdTimeStart (optional) 
     * @param registerdTimeEnd (optional) 
     * @param type (optional) 
     * @param storeIds (optional) 
     * @param customerIds (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberListToExcel(name: string | undefined, registerdTimeStart: moment.Moment | undefined, registerdTimeEnd: moment.Moment | undefined, type: string | undefined, storeIds: number[] | undefined, customerIds: number[] | undefined, sorting: string | undefined, filter: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberListToExcel?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (registerdTimeStart === null)
            throw new Error("The parameter 'registerdTimeStart' cannot be null.");
        else if (registerdTimeStart !== undefined)
            url_ += "RegisterdTimeStart=" + encodeURIComponent(registerdTimeStart ? "" + registerdTimeStart.toJSON() : "") + "&";
        if (registerdTimeEnd === null)
            throw new Error("The parameter 'registerdTimeEnd' cannot be null.");
        else if (registerdTimeEnd !== undefined)
            url_ += "RegisterdTimeEnd=" + encodeURIComponent(registerdTimeEnd ? "" + registerdTimeEnd.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (customerIds === null)
            throw new Error("The parameter 'customerIds' cannot be null.");
        else if (customerIds !== undefined)
            customerIds && customerIds.forEach(item => { url_ += "CustomerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMemberById(input: number | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMember(body: CreateMemberInput | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/CreateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMember(body: UpdateMemberInput | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/UpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMember(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMemberInfo(body: UpdateMemberInput | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/UpdateMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMemberInfo(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMember(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMember?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMembers(input: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMembers?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberLevels(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetMemberLevelDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetMemberLevels?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberLevelDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberLevelDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberLevels(response: HttpResponseBase): Observable<GetMemberLevelDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberLevelDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberLevelDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateMemberLevel(body: AddOrUpdateMemberLevelInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddOrUpdateMemberLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMemberLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMemberLevel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMemberLevel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMemberLevels(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMemberLevels?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberLevels(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addMemberTags(memberId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddMemberTags?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMemberTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMemberTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMemberTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateCustomer(body: AddOrUpdateCustomerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddOrUpdateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCustomers(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CustomerDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetCustomers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSalesToCustomer(body: AddSalesToCustomerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddSalesToCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSalesToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSalesToCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSalesToCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCustomers(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteCustomers?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addMembersToCustomer(body: AddMemberToCustomerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddMembersToCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMembersToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMembersToCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMembersToCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeMembers(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/MergeMembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addCustomerTags(customerId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/AddCustomerTags?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCustomerTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCustomerTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCustomerTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    deleteCustomerTags(customerId: number | undefined, tagIds: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteCustomerTags?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomerTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomerTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomerTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param tagIds (optional) 
     * @return Success
     */
    deleteMemberTags(memberId: number | undefined, tagIds: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/DeleteMemberTags?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopMembers(id: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<MemberOuterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetWeishopMembers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopMembers(<any>response_);
                } catch (e) {
                    return <Observable<MemberOuterDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberOuterDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopMembers(response: HttpResponseBase): Observable<MemberOuterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberOuterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberOuterDtoPagedResultDto>(<any>null);
    }
}


@Injectable()
export class MemberPointOperatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPointLogByMemberId(body: AddPointLogByMemberIdInput | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/MemberPointOperator/AddPointLogByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPointLogByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPointLogByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddPointLogByMemberId(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Current OU orders
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 订单编号
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 订单状态
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrders(memberId: number | undefined, memberName: string | undefined, regPhone: string | undefined, orderNO: string | undefined, orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, from: string | undefined, orderDateTimeStartString: string | undefined, orderDateTimeEndString: string | undefined, status: string | undefined, storeIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<OrderDtoPagedTotalResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrders?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (memberName === null)
            throw new Error("The parameter 'memberName' cannot be null.");
        else if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&";
        if (regPhone === null)
            throw new Error("The parameter 'regPhone' cannot be null.");
        else if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&";
        if (orderNO === null)
            throw new Error("The parameter 'orderNO' cannot be null.");
        else if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (orderDateTimeStartString === null)
            throw new Error("The parameter 'orderDateTimeStartString' cannot be null.");
        else if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&";
        if (orderDateTimeEndString === null)
            throw new Error("The parameter 'orderDateTimeEndString' cannot be null.");
        else if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoPagedTotalResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoPagedTotalResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<OrderDtoPagedTotalResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoPagedTotalResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoPagedTotalResultDto>(<any>null);
    }

    /**
     * 导出订单信息到excel
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 订单编号
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 订单状态
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrderListToExcelBackup(memberId: number | undefined, memberName: string | undefined, regPhone: string | undefined, orderNO: string | undefined, orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, from: string | undefined, orderDateTimeStartString: string | undefined, orderDateTimeEndString: string | undefined, status: string | undefined, storeIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrderListToExcelBackup?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (memberName === null)
            throw new Error("The parameter 'memberName' cannot be null.");
        else if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&";
        if (regPhone === null)
            throw new Error("The parameter 'regPhone' cannot be null.");
        else if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&";
        if (orderNO === null)
            throw new Error("The parameter 'orderNO' cannot be null.");
        else if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (orderDateTimeStartString === null)
            throw new Error("The parameter 'orderDateTimeStartString' cannot be null.");
        else if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&";
        if (orderDateTimeEndString === null)
            throw new Error("The parameter 'orderDateTimeEndString' cannot be null.");
        else if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderListToExcelBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderListToExcelBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderListToExcelBackup(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 订单编号
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 订单状态
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrderListToExcel(memberId: number | undefined, memberName: string | undefined, regPhone: string | undefined, orderNO: string | undefined, orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, from: string | undefined, orderDateTimeStartString: string | undefined, orderDateTimeEndString: string | undefined, status: string | undefined, storeIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrderListToExcel?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (memberName === null)
            throw new Error("The parameter 'memberName' cannot be null.");
        else if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&";
        if (regPhone === null)
            throw new Error("The parameter 'regPhone' cannot be null.");
        else if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&";
        if (orderNO === null)
            throw new Error("The parameter 'orderNO' cannot be null.");
        else if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (orderDateTimeStartString === null)
            throw new Error("The parameter 'orderDateTimeStartString' cannot be null.");
        else if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&";
        if (orderDateTimeEndString === null)
            throw new Error("The parameter 'orderDateTimeEndString' cannot be null.");
        else if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param memberName (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 订单编号
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param from (optional) 
     * @param orderDateTimeStartString (optional) 
     * @param orderDateTimeEndString (optional) 
     * @param status (optional) 订单状态
     * @param storeIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrdersByMemberId(memberId: number | undefined, memberName: string | undefined, regPhone: string | undefined, orderNO: string | undefined, orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, from: string | undefined, orderDateTimeStartString: string | undefined, orderDateTimeEndString: string | undefined, status: string | undefined, storeIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<OrderWithTotalSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetOrdersByMemberId?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (memberName === null)
            throw new Error("The parameter 'memberName' cannot be null.");
        else if (memberName !== undefined)
            url_ += "MemberName=" + encodeURIComponent("" + memberName) + "&";
        if (regPhone === null)
            throw new Error("The parameter 'regPhone' cannot be null.");
        else if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&";
        if (orderNO === null)
            throw new Error("The parameter 'orderNO' cannot be null.");
        else if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (orderDateTimeStartString === null)
            throw new Error("The parameter 'orderDateTimeStartString' cannot be null.");
        else if (orderDateTimeStartString !== undefined)
            url_ += "OrderDateTimeStartString=" + encodeURIComponent("" + orderDateTimeStartString) + "&";
        if (orderDateTimeEndString === null)
            throw new Error("The parameter 'orderDateTimeEndString' cannot be null.");
        else if (orderDateTimeEndString !== undefined)
            url_ += "OrderDateTimeEndString=" + encodeURIComponent("" + orderDateTimeEndString) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<OrderWithTotalSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderWithTotalSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrdersByMemberId(response: HttpResponseBase): Observable<OrderWithTotalSaleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderWithTotalSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderWithTotalSaleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getItemSalesBySkuIds(body: GetItemSalesBySkuIdInput | undefined): Observable<GetItemSalesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetItemSalesBySkuIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemSalesBySkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemSalesBySkuIds(<any>response_);
                } catch (e) {
                    return <Observable<GetItemSalesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetItemSalesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetItemSalesBySkuIds(response: HttpResponseBase): Observable<GetItemSalesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetItemSalesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetItemSalesDto[]>(<any>null);
    }

    /**
     * 通过会员id查SKU
     * @param body (optional) 
     * @return Success
     */
    orderSkuByMemberId(body: OrderSkuInput | undefined): Observable<OrderSkuDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/OrderSkuByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSkuByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSkuByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<OrderSkuDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderSkuDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSkuByMemberId(response: HttpResponseBase): Observable<OrderSkuDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderSkuDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSkuDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrder(body: CreateOrderInput | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/CreateOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrder(body: UpdateOrderInput | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/UpdateOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrder(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrderItem(body: UpdateOrderItemInput | undefined): Observable<OrderItemDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/UpdateOrderItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderItem(<any>response_);
                } catch (e) {
                    return <Observable<OrderItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrderItem(response: HttpResponseBase): Observable<OrderItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderItemDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrder(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/DeleteOrder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteOrders(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/BatchDeleteOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteOrders(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteOrderItems(input: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Order/DeleteOrderItems?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrderItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrderItems(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrderItems(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    healthCheck(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Order/HealthCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealthCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealthCheck(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processHealthCheck(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesReport(body: SaleReportInput | undefined): Observable<SalesCurrentDayReportDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/SalesReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesReport(<any>response_);
                } catch (e) {
                    return <Observable<SalesCurrentDayReportDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalesCurrentDayReportDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSalesReport(response: HttpResponseBase): Observable<SalesCurrentDayReportDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesCurrentDayReportDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesCurrentDayReportDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取销售详细
     * @param body (optional) 
     * @return Success
     */
    salesItemDetailReport(body: GetSaleItemDetailInput | undefined): Observable<SalesItemDetailReportDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Order/SalesItemDetailReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesItemDetailReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesItemDetailReport(<any>response_);
                } catch (e) {
                    return <Observable<SalesItemDetailReportDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalesItemDetailReportDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSalesItemDetailReport(response: HttpResponseBase): Observable<SalesItemDetailReportDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesItemDetailReportDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesItemDetailReportDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class OrderExtensionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getPrintOrderCount(tenantId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrderCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrderCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrderCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrderCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    confirmPrintOrder(tenantId: number | undefined, orderId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/ConfirmPrintOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPrintOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPrintOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPrintOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param skuId (optional) 
     * @return Success
     */
    getPrintOrder(tenantId: number | undefined, memberId: number | undefined, skuId: number | undefined): Observable<PrintOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrder?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrder(<any>response_);
                } catch (e) {
                    return <Observable<PrintOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrder(response: HttpResponseBase): Observable<PrintOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintOrderDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateOrderExtension(tenantId: number | undefined, memberId: number | undefined, body: AddOrUpdateOrderExtensionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/AddOrUpdateOrderExtension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateOrderExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateOrderExtension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateOrderExtension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getPrintOrderCountForReport(subKey: string | undefined): Observable<PrintOrderCountDto> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetPrintOrderCountForReport?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrintOrderCountForReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrintOrderCountForReport(<any>response_);
                } catch (e) {
                    return <Observable<PrintOrderCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintOrderCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrintOrderCountForReport(response: HttpResponseBase): Observable<PrintOrderCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintOrderCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintOrderCountDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getNextOrderGcodeFile(tenantId: number | undefined, type: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/GetNextOrderGcodeFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "type": type !== undefined && type !== null ? "" + type : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextOrderGcodeFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextOrderGcodeFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextOrderGcodeFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearGcodeFileSessions(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExtension/ClearGcodeFileSessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearGcodeFileSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearGcodeFileSessions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearGcodeFileSessions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}


@Injectable()
export class PayCenterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param payTimeStart (optional) 
     * @param payTimeEnd (optional) 
     * @param orderFrom (optional) 
     * @param payFrom (optional) 
     * @param payType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPayRecords(payTimeStart: moment.Moment | undefined, payTimeEnd: moment.Moment | undefined, orderFrom: string | undefined, payFrom: string | undefined, payType: PayType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetPayRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/GetPayRecords?";
        if (payTimeStart === null)
            throw new Error("The parameter 'payTimeStart' cannot be null.");
        else if (payTimeStart !== undefined)
            url_ += "PayTimeStart=" + encodeURIComponent(payTimeStart ? "" + payTimeStart.toJSON() : "") + "&";
        if (payTimeEnd === null)
            throw new Error("The parameter 'payTimeEnd' cannot be null.");
        else if (payTimeEnd !== undefined)
            url_ += "PayTimeEnd=" + encodeURIComponent(payTimeEnd ? "" + payTimeEnd.toJSON() : "") + "&";
        if (orderFrom === null)
            throw new Error("The parameter 'orderFrom' cannot be null.");
        else if (orderFrom !== undefined)
            url_ += "OrderFrom=" + encodeURIComponent("" + orderFrom) + "&";
        if (payFrom === null)
            throw new Error("The parameter 'payFrom' cannot be null.");
        else if (payFrom !== undefined)
            url_ += "PayFrom=" + encodeURIComponent("" + payFrom) + "&";
        if (payType === null)
            throw new Error("The parameter 'payType' cannot be null.");
        else if (payType !== undefined)
            url_ += "PayType=" + encodeURIComponent("" + payType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayRecords(<any>response_);
                } catch (e) {
                    return <Observable<GetPayRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPayRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayRecords(response: HttpResponseBase): Observable<GetPayRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPayRecordDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPayRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdatePayAccount(body: AddOrUpdatePayAccountInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/AddOrUpdatePayAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdatePayAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdatePayAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdatePayAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPayAccounts(from: string | undefined, auditStatus: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetPayAccountDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/GetPayAccounts?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayAccounts(<any>response_);
                } catch (e) {
                    return <Observable<GetPayAccountDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPayAccountDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayAccounts(response: HttpResponseBase): Observable<GetPayAccountDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPayAccountDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPayAccountDtoPagedResultDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePayAccount(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayCenter/DeletePayAccount?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePayAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePayAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePayAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReleaseApiTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    releaseApiTest(): Observable<NameValueTimeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReleaseApiTest/ReleaseApiTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseApiTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseApiTest(<any>response_);
                } catch (e) {
                    return <Observable<NameValueTimeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueTimeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseApiTest(response: HttpResponseBase): Observable<NameValueTimeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueTimeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueTimeDto[]>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getTotalOrderAndSale(subKey: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, chartType: string | undefined): Observable<TotalOrderAndSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetTotalOrderAndSale?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (chartType === null)
            throw new Error("The parameter 'chartType' cannot be null.");
        else if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalOrderAndSale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalOrderAndSale(<any>response_);
                } catch (e) {
                    return <Observable<TotalOrderAndSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TotalOrderAndSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotalOrderAndSale(response: HttpResponseBase): Observable<TotalOrderAndSaleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TotalOrderAndSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TotalOrderAndSaleDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getRetailingReport(subKey: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, chartType: string | undefined): Observable<RetailingReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetRetailingReport?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (chartType === null)
            throw new Error("The parameter 'chartType' cannot be null.");
        else if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailingReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailingReport(<any>response_);
                } catch (e) {
                    return <Observable<RetailingReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailingReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailingReport(response: HttpResponseBase): Observable<RetailingReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailingReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailingReportDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersCount(body: MembersCountInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/MembersCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMembersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMembersCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processMembersCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 退款个数
     * @param body (optional) 
     * @return Success
     */
    refundCount(body: ReportInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/RefundCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRefundCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    topSkus(body: TopSkusInput | undefined): Observable<SkuSaleListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/TopSkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopSkus(<any>response_);
                } catch (e) {
                    return <Observable<SkuSaleListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSaleListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTopSkus(response: HttpResponseBase): Observable<SkuSaleListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkuSaleListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSaleListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skuTotalSales(body: SkuTotalSalesInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuTotalSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuTotalSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuTotalSales(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSkuTotalSales(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderCountAndSales(body: OrderCountAndSalesInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/OrderCountAndSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderCountAndSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderCountAndSales(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processOrderCountAndSales(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    buyerCount(body: BuyerCountInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/BuyerCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyerCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyerCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processBuyerCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skuFromBuyer(body: SkuFromBuyerInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuFromBuyer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuFromBuyer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuFromBuyer(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSkuFromBuyer(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 传入起止时间,返回期间发生购买的会员名,id,所买的商品,购买时间
     * @param body (optional) 
     * @return Success
     */
    orderInformation(body: OrderInformationInput | undefined): Observable<OrderInformationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/OrderInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderInformation(<any>response_);
                } catch (e) {
                    return <Observable<OrderInformationDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderInformationDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processOrderInformation(response: HttpResponseBase): Observable<OrderInformationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderInformationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderInformationDtoPagedResultDto>(<any>null);
    }

    /**
     * SKU销售列表
     * @param body (optional) 
     * @return Success
     */
    skuSaleList(body: SkuSaleListInput | undefined): Observable<SkuSaleListDtoPagedTotalResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuSaleList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuSaleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuSaleList(<any>response_);
                } catch (e) {
                    return <Observable<SkuSaleListDtoPagedTotalResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSaleListDtoPagedTotalResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSkuSaleList(response: HttpResponseBase): Observable<SkuSaleListDtoPagedTotalResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuSaleListDtoPagedTotalResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSaleListDtoPagedTotalResultDto>(<any>null);
    }

    /**
     * SKU销售列表(单个)
     * @param body (optional) 
     * @return Success
     */
    dailySaleList(body: SkuSaleListInput | undefined): Observable<OrderItemPagedTotalResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/DailySaleList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDailySaleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDailySaleList(<any>response_);
                } catch (e) {
                    return <Observable<OrderItemPagedTotalResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderItemPagedTotalResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDailySaleList(response: HttpResponseBase): Observable<OrderItemPagedTotalResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderItemPagedTotalResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderItemPagedTotalResultDto>(<any>null);
    }

    /**
     * SKU销售详情
     * @param body (optional) 
     * @return Success
     */
    skuDaySale(body: SkuDaySaleInput | undefined): Observable<SkuDaySaleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SkuDaySale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuDaySale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuDaySale(<any>response_);
                } catch (e) {
                    return <Observable<SkuDaySaleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuDaySaleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSkuDaySale(response: HttpResponseBase): Observable<SkuDaySaleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuDaySaleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuDaySaleDtoPagedResultDto>(<any>null);
    }

    /**
     * 会员消费列表
     * @param body (optional) 
     * @return Success
     */
    memberCostList(body: MemberCostInput | undefined): Observable<MemberCostListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/MemberCostList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberCostList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberCostList(<any>response_);
                } catch (e) {
                    return <Observable<MemberCostListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberCostListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processMemberCostList(response: HttpResponseBase): Observable<MemberCostListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberCostListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberCostListDtoPagedResultDto>(<any>null);
    }

    /**
     * 通过会员id查每一天SKU的总数
     * @param body (optional) 
     * @return Success
     */
    memberDaySkus(body: MemberDaySkusInput | undefined): Observable<MemberDaySkusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/MemberDaySkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMemberDaySkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMemberDaySkus(<any>response_);
                } catch (e) {
                    return <Observable<MemberDaySkusDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDaySkusDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processMemberDaySkus(response: HttpResponseBase): Observable<MemberDaySkusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDaySkusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDaySkusDtoPagedResultDto>(<any>null);
    }

    /**
     * excel 销售
     * @param filter (optional) 
     * @param skuName (optional) 
     * @param skuId (optional) 
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuSaleListToExcel(filter: string | undefined, skuName: string | undefined, skuId: string | undefined, storeIds: number[] | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSkuSaleListToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (skuName === null)
            throw new Error("The parameter 'skuName' cannot be null.");
        else if (skuName !== undefined)
            url_ += "SkuName=" + encodeURIComponent("" + skuName) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuSaleListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuSaleListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuSaleListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 销售日报
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesDayReport(storeIds: number[] | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesDayReport?";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesDayReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesDayReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesDayReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 销售月报
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesMonthReport(storeIds: number[] | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesMonthReport?";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesMonthReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesMonthReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesMonthReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 销售速报
     * @param storeIds (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getSalesCurrentDayReport(storeIds: number[] | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetSalesCurrentDayReport?";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesCurrentDayReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesCurrentDayReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesCurrentDayReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * excel 销售明细
     * @param body (optional) 
     * @return Success
     */
    saleDetailToExcel(body: GetSaleItemDetailInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/SaleDetailToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleDetailToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleDetailToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaleDetailToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * excel 销售明细
     * @param body (optional) 
     * @return Success
     */
    saleDetailToExcelAsUrl(body: GetSaleItemDetailInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/SaleDetailToExcelAsUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleDetailToExcelAsUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleDetailToExcelAsUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaleDetailToExcelAsUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param memberId (optional) 
     * @param regPhone (optional) 
     * @param orderNO (optional) 
     * @param orderStartDateTime (optional) 
     * @param orderEndDateTime (optional) 
     * @param from (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrders(subKey: string | undefined, memberId: number | undefined, regPhone: string | undefined, orderNO: string | undefined, orderStartDateTime: moment.Moment | undefined, orderEndDateTime: moment.Moment | undefined, from: string | undefined, status: string | undefined, sorting: string | undefined, filter: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<OrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/GetOrders?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (regPhone === null)
            throw new Error("The parameter 'regPhone' cannot be null.");
        else if (regPhone !== undefined)
            url_ += "RegPhone=" + encodeURIComponent("" + regPhone) + "&";
        if (orderNO === null)
            throw new Error("The parameter 'orderNO' cannot be null.");
        else if (orderNO !== undefined)
            url_ += "OrderNO=" + encodeURIComponent("" + orderNO) + "&";
        if (orderStartDateTime === null)
            throw new Error("The parameter 'orderStartDateTime' cannot be null.");
        else if (orderStartDateTime !== undefined)
            url_ += "OrderStartDateTime=" + encodeURIComponent(orderStartDateTime ? "" + orderStartDateTime.toJSON() : "") + "&";
        if (orderEndDateTime === null)
            throw new Error("The parameter 'orderEndDateTime' cannot be null.");
        else if (orderEndDateTime !== undefined)
            url_ += "OrderEndDateTime=" + encodeURIComponent(orderEndDateTime ? "" + orderEndDateTime.toJSON() : "") + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<OrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param orderId (optional) 
     * @param memberId (optional) 
     * @param orderStartDateTime (optional) 
     * @param orderEndDateTime (optional) 
     * @param printStateDescription (optional) 
     * @param from (optional) 
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExtensionOrders(subKey: string | undefined, orderId: number | undefined, memberId: number | undefined, orderStartDateTime: moment.Moment | undefined, orderEndDateTime: moment.Moment | undefined, printStateDescription: string | undefined, from: string | undefined, sorting: string | undefined, filter: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ExtensionOrdersDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/GetExtensionOrders?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (orderStartDateTime === null)
            throw new Error("The parameter 'orderStartDateTime' cannot be null.");
        else if (orderStartDateTime !== undefined)
            url_ += "OrderStartDateTime=" + encodeURIComponent(orderStartDateTime ? "" + orderStartDateTime.toJSON() : "") + "&";
        if (orderEndDateTime === null)
            throw new Error("The parameter 'orderEndDateTime' cannot be null.");
        else if (orderEndDateTime !== undefined)
            url_ += "OrderEndDateTime=" + encodeURIComponent(orderEndDateTime ? "" + orderEndDateTime.toJSON() : "") + "&";
        if (printStateDescription === null)
            throw new Error("The parameter 'printStateDescription' cannot be null.");
        else if (printStateDescription !== undefined)
            url_ += "PrintStateDescription=" + encodeURIComponent("" + printStateDescription) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExtensionOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExtensionOrders(<any>response_);
                } catch (e) {
                    return <Observable<ExtensionOrdersDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtensionOrdersDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExtensionOrders(response: HttpResponseBase): Observable<ExtensionOrdersDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtensionOrdersDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtensionOrdersDtoPagedResultDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param fileBase (optional) 
     * @return Success
     */
    saveUploadFile(subKey: string | undefined, fileBase: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/SaveUploadFile?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fileBase === null || fileBase === undefined)
            throw new Error("The parameter 'fileBase' cannot be null.");
        else
            content_.append("fileBase", fileBase.data, fileBase.fileName ? fileBase.fileName : "fileBase");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUploadFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateExtensionOrder(body: AddOrUpdateExtensionOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/AddOrUpdateExtensionOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateExtensionOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateExtensionOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateExtensionOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrderMakingInfo(body: UpdateOrderMakingInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingOrder/UpdateOrderMakingInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderMakingInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderMakingInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrderMakingInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingShopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateMember(body: MemberInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateShippingAddress(tenantId: number | undefined, memberId: number | undefined, body: AddOrUpdateAddressInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateShippingAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateShippingAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateShippingAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateShippingAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMemberShippingAddresses(tenantId: number | undefined, memberId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetShippingAddressDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberShippingAddresses?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberShippingAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberShippingAddresses(<any>response_);
                } catch (e) {
                    return <Observable<GetShippingAddressDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetShippingAddressDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberShippingAddresses(response: HttpResponseBase): Observable<GetShippingAddressDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetShippingAddressDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetShippingAddressDtoPagedResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getDefaultShippingAddress(tenantId: number | undefined, memberId: number | undefined): Observable<GetShippingAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetDefaultShippingAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultShippingAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultShippingAddress(<any>response_);
                } catch (e) {
                    return <Observable<GetShippingAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetShippingAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultShippingAddress(response: HttpResponseBase): Observable<GetShippingAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetShippingAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetShippingAddressDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param ids (optional) 
     * @return Success
     */
    deleteShippingAddresses(tenantId: number | undefined, memberId: number | undefined, ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteShippingAddresses?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShippingAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShippingAddresses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShippingAddresses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeOuterId (optional) 
     * @param deviceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWeishopOrder(tenantId: number | undefined, memberId: number | undefined, storeOuterId: string | undefined, deviceId: number | undefined, body: AddOrUpdateWeishopOrderInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeOuterId": storeOuterId !== undefined && storeOuterId !== null ? "" + storeOuterId : "",
                "deviceId": deviceId !== undefined && deviceId !== null ? "" + deviceId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWeishopOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param subkey (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateBigScreenOrder(tenantId: number | undefined, memberId: number | undefined, storeId: string | undefined, subkey: string | undefined, body: AddOrUpdateHaierOrderInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateBigScreenOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "subkey": subkey !== undefined && subkey !== null ? "" + subkey : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateBigScreenOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateBigScreenOrder(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateBigScreenOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param subkey (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateBigScreenOrderForConfirm(tenantId: number | undefined, memberId: number | undefined, storeId: string | undefined, subkey: string | undefined, body: AddOrUpdateHaierOrderInput | undefined): Observable<AddOrUpdateBigScreenOrderForConfirmDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrUpdateBigScreenOrderForConfirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "subkey": subkey !== undefined && subkey !== null ? "" + subkey : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateBigScreenOrderForConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateBigScreenOrderForConfirm(<any>response_);
                } catch (e) {
                    return <Observable<AddOrUpdateBigScreenOrderForConfirmDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddOrUpdateBigScreenOrderForConfirmDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateBigScreenOrderForConfirm(response: HttpResponseBase): Observable<AddOrUpdateBigScreenOrderForConfirmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddOrUpdateBigScreenOrderForConfirmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddOrUpdateBigScreenOrderForConfirmDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @param extensionData (optional) 
     * @param roomId (optional) 
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param awardId (optional) 
     * @return Success
     */
    wxPayOrderForActivity(actionId: number | undefined, securityKey: string | undefined, ticketId: number | undefined, extensionData: string | undefined, roomId: string | undefined, productId: number | undefined, skuId: number | undefined, awardId: number | undefined): Observable<WxPayDataDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxPayOrderForActivity?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "extensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (awardId === null)
            throw new Error("The parameter 'awardId' cannot be null.");
        else if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<WxPayDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxPayDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayOrderForActivity(response: HttpResponseBase): Observable<WxPayDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WxPayDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxPayDataDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @param extensionData (optional) 
     * @param turnUrl (optional) 
     * @param roomId (optional) 
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param awardId (optional) 
     * @return Success
     */
    aliPayOrderForActivity(actionId: number | undefined, securityKey: string | undefined, ticketId: number | undefined, extensionData: string | undefined, turnUrl: string | undefined, roomId: string | undefined, productId: number | undefined, skuId: number | undefined, awardId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayOrderForActivity?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "extensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (turnUrl === null)
            throw new Error("The parameter 'turnUrl' cannot be null.");
        else if (turnUrl !== undefined)
            url_ += "turnUrl=" + encodeURIComponent("" + turnUrl) + "&";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (awardId === null)
            throw new Error("The parameter 'awardId' cannot be null.");
        else if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayOrderForActivity(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aliPayNotifyForActivity(body: AlipayNotifyInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayNotifyForActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayNotifyForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayNotifyForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayNotifyForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    wxPayNotifyForActivity(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/wxPayNotifyForActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayNotifyForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayNotifyForActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayNotifyForActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param device_info (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    sendSignalRCommand(device_info: string | undefined, actionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendSignalRCommand?";
        if (device_info === null)
            throw new Error("The parameter 'device_info' cannot be null.");
        else if (device_info !== undefined)
            url_ += "device_info=" + encodeURIComponent("" + device_info) + "&";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSignalRCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSignalRCommand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendSignalRCommand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    pointPayOrderForActivity(actionId: number | undefined, securityKey: string | undefined, ticketId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointPayOrderForActivity?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointPayOrderForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointPayOrderForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointPayOrderForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    pointAwardForActivity(actionId: number | undefined, securityKey: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointAwardForActivity?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointAwardForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointAwardForActivity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointAwardForActivity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    wxPayOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<WxPayDataDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxPayOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<WxPayDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WxPayDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayOrder(response: HttpResponseBase): Observable<WxPayDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WxPayDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WxPayDataDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @param turnUrl (optional) 
     * @return Success
     */
    aliPayOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined, turnUrl: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (turnUrl === null)
            throw new Error("The parameter 'turnUrl' cannot be null.");
        else if (turnUrl !== undefined)
            url_ += "turnUrl=" + encodeURIComponent("" + turnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayOrder(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    pointPayOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/PointPayOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPointPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPointPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPointPayOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    wxAndPointPayOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/WxAndPointPayOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxAndPointPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxAndPointPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processWxAndPointPayOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getAliPaySetting(tenantId: number | undefined): Observable<GetAliPaySettingDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetAliPaySetting?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAliPaySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAliPaySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetAliPaySettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAliPaySettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAliPaySetting(response: HttpResponseBase): Observable<GetAliPaySettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAliPaySettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAliPaySettingDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getwxPayResult(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/getwxPayResult?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwxPayResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwxPayResult(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetwxPayResult(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    wxPayNotify(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/wxPayNotify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWxPayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWxPayNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWxPayNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aliPayNotify(body: AlipayNotifyInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AliPayNotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAliPayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAliPayNotify(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAliPayNotify(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getWeishopOrderDetail(tenantId: number | undefined, memberId: number | undefined, id: number | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopOrderDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrderDetail(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param storeId (optional) 
     * @param activityId (optional) 
     * @param status (optional) 订单状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopOrders(tenantId: number | undefined, memberId: number | undefined, orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, storeId: number | undefined, activityId: number | undefined, status: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<OrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopOrders?";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrders(response: HttpResponseBase): Observable<OrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getOrderCount(tenantId: number | undefined, memberId: number | undefined): Observable<WeishopOrderCountDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetOrderCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderCount(<any>response_);
                } catch (e) {
                    return <Observable<WeishopOrderCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeishopOrderCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderCount(response: HttpResponseBase): Observable<WeishopOrderCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeishopOrderCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeishopOrderCountDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    refundWeishopOrder(tenantId: number | undefined, memberId: number | undefined, body: RefundOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RefundWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRefundWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    cancelWeishopOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CancelWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    confirmWeishopOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ConfirmWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 确认大屏订单
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @param payType (optional) 
     * @param tradNumber (optional) 
     * @param payAccount (optional) 
     * @param onCreditPay (optional) 
     * @param body (optional) 
     * @return Success
     */
    confirmBigScreenOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined, payType: string | undefined, tradNumber: string | undefined, payAccount: string | undefined, onCreditPay: boolean | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ConfirmBigScreenOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (payType === null)
            throw new Error("The parameter 'payType' cannot be null.");
        else if (payType !== undefined)
            url_ += "payType=" + encodeURIComponent("" + payType) + "&";
        if (tradNumber === null)
            throw new Error("The parameter 'tradNumber' cannot be null.");
        else if (tradNumber !== undefined)
            url_ += "tradNumber=" + encodeURIComponent("" + tradNumber) + "&";
        if (payAccount === null)
            throw new Error("The parameter 'payAccount' cannot be null.");
        else if (payAccount !== undefined)
            url_ += "payAccount=" + encodeURIComponent("" + payAccount) + "&";
        if (onCreditPay === null)
            throw new Error("The parameter 'onCreditPay' cannot be null.");
        else if (onCreditPay !== undefined)
            url_ += "OnCreditPay=" + encodeURIComponent("" + onCreditPay) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmBigScreenOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmBigScreenOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmBigScreenOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    deleteWeishopOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRefundReasons(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetRefundReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundReasons(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundReasons(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getMemberPointLevelAndRegPhone(tenantId: number | undefined, memberId: number | undefined): Observable<PointLevelRegPhoneDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberPointLevelAndRegPhone?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPointLevelAndRegPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPointLevelAndRegPhone(<any>response_);
                } catch (e) {
                    return <Observable<PointLevelRegPhoneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PointLevelRegPhoneDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPointLevelAndRegPhone(response: HttpResponseBase): Observable<PointLevelRegPhoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PointLevelRegPhoneDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PointLevelRegPhoneDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getRefundDetail(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetRefundDetail?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundDetail(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    evaluateWeishopOrder(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/EvaluateWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processEvaluateWeishopOrder(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    uploadRefundExpress(tenantId: number | undefined, memberId: number | undefined, body: UploadExpressInput | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UploadRefundExpress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadRefundExpress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadRefundExpress(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadRefundExpress(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExpressCompanies(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetExpressCompaniesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetExpressCompanies?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpressCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpressCompanies(<any>response_);
                } catch (e) {
                    return <Observable<GetExpressCompaniesDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExpressCompaniesDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpressCompanies(response: HttpResponseBase): Observable<GetExpressCompaniesDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpressCompaniesDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpressCompaniesDtoPagedResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param orderId (optional) 
     * @return Success
     */
    getOrderTracking(tenantId: number | undefined, memberId: number | undefined, orderId: number | undefined): Observable<ExpressTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetOrderTracking?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderTracking(<any>response_);
                } catch (e) {
                    return <Observable<ExpressTrackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressTrackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderTracking(response: HttpResponseBase): Observable<ExpressTrackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpressTrackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpressTrackingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserToOvoPark(body: AddUserToOvoParkInput | undefined): Observable<AddUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddUserToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<AddUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserToOvoPark(response: HttpResponseBase): Observable<AddUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddUserDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    registerUserToWeiShop(tenantId: number | undefined, memberId: number | undefined, body: RegisterUserToWeiShopInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterUserToWeiShop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUserToWeiShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUserToWeiShop(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUserToWeiShop(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param rfidCode (optional) 
     * @param templateMessageType (optional) 
     * @return Success
     */
    sendTemplateMessageByDevice(subkey: string | undefined, rfidCode: string | undefined, templateMessageType: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendTemplateMessageByDevice?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        if (rfidCode === null)
            throw new Error("The parameter 'rfidCode' cannot be null.");
        else if (rfidCode !== undefined)
            url_ += "rfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        if (templateMessageType === null)
            throw new Error("The parameter 'templateMessageType' cannot be null.");
        else if (templateMessageType !== undefined)
            url_ += "templateMessageType=" + encodeURIComponent("" + templateMessageType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTemplateMessageByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTemplateMessageByDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendTemplateMessageByDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    queryUserByFace(body: QueryUserByFaceInput | undefined): Observable<QueryUserByFaceDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/QueryUserByFace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUserByFace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUserByFace(<any>response_);
                } catch (e) {
                    return <Observable<QueryUserByFaceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QueryUserByFaceDto>><any>_observableThrow(response_);
        }));
    }

    protected processQueryUserByFace(response: HttpResponseBase): Observable<QueryUserByFaceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryUserByFaceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QueryUserByFaceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerFaceByUser(body: RegisterFaceByUserInput | undefined): Observable<RegisterFaceByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterFaceByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceByUser(<any>response_);
                } catch (e) {
                    return <Observable<RegisterFaceByUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterFaceByUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceByUser(response: HttpResponseBase): Observable<RegisterFaceByUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterFaceByUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterFaceByUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addGroupToOvoPark(body: AddGroupToOvoParkInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddGroupToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddGroupToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddGroupToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddGroupToOvoPark(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param faceUrl (optional) 
     * @param _aid (optional) 
     * @param _akey (optional) 
     * @param orgid (optional) 
     * @param depid (optional) 
     * @return Success
     */
    searchUserFromOvoPark(faceUrl: string | undefined, _aid: string | undefined, _akey: string | undefined, orgid: number | undefined, depid: number | undefined): Observable<OvoParkUserInfo> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SearchUserFromOvoPark?";
        if (faceUrl === null)
            throw new Error("The parameter 'faceUrl' cannot be null.");
        else if (faceUrl !== undefined)
            url_ += "faceUrl=" + encodeURIComponent("" + faceUrl) + "&";
        if (_aid === null)
            throw new Error("The parameter '_aid' cannot be null.");
        else if (_aid !== undefined)
            url_ += "_aid=" + encodeURIComponent("" + _aid) + "&";
        if (_akey === null)
            throw new Error("The parameter '_akey' cannot be null.");
        else if (_akey !== undefined)
            url_ += "_akey=" + encodeURIComponent("" + _akey) + "&";
        if (orgid === null)
            throw new Error("The parameter 'orgid' cannot be null.");
        else if (orgid !== undefined)
            url_ += "orgid=" + encodeURIComponent("" + orgid) + "&";
        if (depid === null)
            throw new Error("The parameter 'depid' cannot be null.");
        else if (depid !== undefined)
            url_ += "depid=" + encodeURIComponent("" + depid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUserFromOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUserFromOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<OvoParkUserInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<OvoParkUserInfo>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUserFromOvoPark(response: HttpResponseBase): Observable<OvoParkUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OvoParkUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OvoParkUserInfo>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerMemberToOvoPark(body: AddUserInput | undefined): Observable<AddUserResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RegisterMemberToOvoPark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMemberToOvoPark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMemberToOvoPark(<any>response_);
                } catch (e) {
                    return <Observable<AddUserResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddUserResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMemberToOvoPark(response: HttpResponseBase): Observable<AddUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddUserResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param openId (optional) 
     * @param from (optional) 
     * @return Success
     */
    checkMemberByOpenId(tenantId: number | undefined, openId: string | undefined, from: string | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckMemberByOpenId?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckMemberByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckMemberByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckMemberByOpenId(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getAuthorizeToken(tenantId: number | undefined, memberId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetAuthorizeToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthorizeToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param deviceId (optional) 
     * @param longitude (optional) 
     * @param latitude (optional) 
     * @return Success
     */
    controlOpenDoor(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, deviceId: number | undefined, longitude: number | undefined, latitude: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ControlOpenDoor?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processControlOpenDoor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processControlOpenDoor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processControlOpenDoor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param token (optional) 
     * @return Success
     */
    checkAuthorizeToken(subkey: string | undefined, token: string | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckAuthorizeToken?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckAuthorizeToken(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    isManagerFromSession(memberId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/IsManagerFromSession?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsManagerFromSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsManagerFromSession(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsManagerFromSession(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    isTokenChecked(token: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/IsTokenChecked?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTokenChecked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTokenChecked(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processIsTokenChecked(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param from (optional) 
     * @return Success
     */
    getMemberInfoById(tenantId: number | undefined, memberId: string | undefined, from: string | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberInfoById?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfoById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfoById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param chartType (optional) 
     * @return Success
     */
    getBigChartReport(subKey: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, chartType: string | undefined): Observable<BigChart> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetBigChartReport?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (chartType === null)
            throw new Error("The parameter 'chartType' cannot be null.");
        else if (chartType !== undefined)
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigChartReport(<any>response_);
                } catch (e) {
                    return <Observable<BigChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<BigChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetBigChartReport(response: HttpResponseBase): Observable<BigChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BigChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BigChart>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getMemberPointLog(tenantId: number | undefined, memberId: string | undefined, body: GetMemberPointLogInput | undefined): Observable<MemberPointLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberPointLog?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPointLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPointLog(<any>response_);
                } catch (e) {
                    return <Observable<MemberPointLogDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberPointLogDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPointLog(response: HttpResponseBase): Observable<MemberPointLogDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberPointLogDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberPointLogDtoPagedResultDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param ticketStatus (optional) 
     * @param ticketType (optional) 
     * @param takeType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTickets(subKey: string | undefined, ticketStatus: AuditStatus | undefined, ticketType: TicketType | undefined, takeType: TakeType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetTicketDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetTickets?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (ticketStatus === null)
            throw new Error("The parameter 'ticketStatus' cannot be null.");
        else if (ticketStatus !== undefined)
            url_ += "TicketStatus=" + encodeURIComponent("" + ticketStatus) + "&";
        if (ticketType === null)
            throw new Error("The parameter 'ticketType' cannot be null.");
        else if (ticketType !== undefined)
            url_ += "TicketType=" + encodeURIComponent("" + ticketType) + "&";
        if (takeType === null)
            throw new Error("The parameter 'takeType' cannot be null.");
        else if (takeType !== undefined)
            url_ += "TakeType=" + encodeURIComponent("" + takeType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<GetTicketDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTicket(id: number | undefined): Observable<GetTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetTicket?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicket(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicket(response: HttpResponseBase): Observable<GetTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto>(<any>null);
    }

    /**
     * @param epc (optional) 
     * @return Success
     */
    deleteHaierRfid(epc: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteHaierRfid?";
        if (epc === null)
            throw new Error("The parameter 'epc' cannot be null.");
        else if (epc !== undefined)
            url_ += "epc=" + encodeURIComponent("" + epc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHaierRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHaierRfid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHaierRfid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMemberById(id: number | undefined): Observable<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetMemberById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberById(<any>response_);
                } catch (e) {
                    return <Observable<MemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberById(response: HttpResponseBase): Observable<MemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDto>(<any>null);
    }

    /**
     * @return Success
     */
    clearRfidSession(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/ClearRfidSession";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearRfidSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearRfidSession(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearRfidSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeExpiredAuthorizeToken(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/RemoveExpiredAuthorizeToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveExpiredAuthorizeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveExpiredAuthorizeToken(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveExpiredAuthorizeToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWeishopSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetWeishopSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderPay(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderPay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderPay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderPay(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderPay(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderFinish(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderFinish";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderFinish(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkOrderConfirm(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CheckOrderConfirm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOrderConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOrderConfirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOrderConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCustomerMemberFromOnline(body: AddCustomerMemberFromOnlineInput | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddCustomerMemberFromOnline";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCustomerMemberFromOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCustomerMemberFromOnline(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddCustomerMemberFromOnline(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param pickNo (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    usePickNo(pickNo: string | undefined, subKey: string | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UsePickNo?";
        if (pickNo === null)
            throw new Error("The parameter 'pickNo' cannot be null.");
        else if (pickNo !== undefined)
            url_ += "pickNo=" + encodeURIComponent("" + pickNo) + "&";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsePickNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsePickNo(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUsePickNo(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }
}

@Injectable()
export class SensingShopManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWeishopOrder(body: AddOrUpdateWeishopOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/AddOrUpdateWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param orderNo (optional) 
     * @return Success
     */
    getWeishopOrderDetail(id: number | undefined, orderNo: string | undefined): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetWeishopOrderDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (orderNo === null)
            throw new Error("The parameter 'orderNo' cannot be null.");
        else if (orderNo !== undefined)
            url_ += "orderNo=" + encodeURIComponent("" + orderNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrderDetail(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDto>(<any>null);
    }

    /**
     * @param orderDateTimeStart (optional) 
     * @param orderDateTimeEnd (optional) 
     * @param storeId (optional) 
     * @param activityId (optional) 
     * @param status (optional) 订单状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeishopOrders(orderDateTimeStart: moment.Moment | undefined, orderDateTimeEnd: moment.Moment | undefined, storeId: number | undefined, activityId: number | undefined, status: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<OrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetWeishopOrders?";
        if (orderDateTimeStart === null)
            throw new Error("The parameter 'orderDateTimeStart' cannot be null.");
        else if (orderDateTimeStart !== undefined)
            url_ += "OrderDateTimeStart=" + encodeURIComponent(orderDateTimeStart ? "" + orderDateTimeStart.toJSON() : "") + "&";
        if (orderDateTimeEnd === null)
            throw new Error("The parameter 'orderDateTimeEnd' cannot be null.");
        else if (orderDateTimeEnd !== undefined)
            url_ += "OrderDateTimeEnd=" + encodeURIComponent(orderDateTimeEnd ? "" + orderDateTimeEnd.toJSON() : "") + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopOrders(response: HttpResponseBase): Observable<OrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verificateOrderItem(body: VerificatOrderItemInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/VerificateOrderItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificateOrderItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificateOrderItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerificateOrderItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    getOrderReportByActivity(activityId: number | undefined, storeId: number | undefined): Observable<OrderReportByActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetOrderReportByActivity?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderReportByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderReportByActivity(<any>response_);
                } catch (e) {
                    return <Observable<OrderReportByActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderReportByActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderReportByActivity(response: HttpResponseBase): Observable<OrderReportByActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderReportByActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderReportByActivityDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deliverWeishopOrder(body: DeliverOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DeliverWeishopOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliverWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliverWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeliverWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getRefundDetail(orderId: number | undefined): Observable<GetRefundDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetRefundDetail?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundDetail(response: HttpResponseBase): Observable<GetRefundDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRefundDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundDetailDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    acceptRefundOrder(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/AcceptRefundOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptRefundOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptRefundOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptRefundOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    closeWeishopOrder(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/CloseWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCloseWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    comfirmWeishopOrder(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/ComfirmWeishopOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComfirmWeishopOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComfirmWeishopOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processComfirmWeishopOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTrackKeyInfo(body: TrackKeyInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/SetTrackKeyInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTrackKeyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTrackKeyInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTrackKeyInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @return Success
     */
    getTrackKeyInfo(from: string | undefined): Observable<TrackKeyInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetTrackKeyInfo?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrackKeyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrackKeyInfo(<any>response_);
                } catch (e) {
                    return <Observable<TrackKeyInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrackKeyInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrackKeyInfo(response: HttpResponseBase): Observable<TrackKeyInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackKeyInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrackKeyInfoDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExpressCompanies(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetExpressCompaniesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetExpressCompanies?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpressCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpressCompanies(<any>response_);
                } catch (e) {
                    return <Observable<GetExpressCompaniesDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExpressCompaniesDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpressCompanies(response: HttpResponseBase): Observable<GetExpressCompaniesDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpressCompaniesDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpressCompaniesDtoPagedResultDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getOrderDeliverInfo(orderId: number | undefined): Observable<OrderDeliverInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetOrderDeliverInfo?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDeliverInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDeliverInfo(<any>response_);
                } catch (e) {
                    return <Observable<OrderDeliverInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDeliverInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderDeliverInfo(response: HttpResponseBase): Observable<OrderDeliverInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDeliverInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDeliverInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setShopPaySetting(body: SetShopPayInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/SetShopPaySetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetShopPaySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetShopPaySetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetShopPaySetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopPaySettings(from: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetPayAccountDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/GetShopPaySettings?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopPaySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopPaySettings(<any>response_);
                } catch (e) {
                    return <Observable<GetPayAccountDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPayAccountDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopPaySettings(response: HttpResponseBase): Observable<GetPayAccountDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPayAccountDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPayAccountDtoPagedResultDto>(<any>null);
    }

    /**
     * @param payAccountIds (optional) 
     * @return Success
     */
    deleteShopPaySettings(payAccountIds: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DeleteShopPaySettings?";
        if (payAccountIds === null)
            throw new Error("The parameter 'payAccountIds' cannot be null.");
        else if (payAccountIds !== undefined)
            payAccountIds && payAccountIds.forEach(item => { url_ += "payAccountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopPaySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopPaySettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopPaySettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refuseRefundApply(body: RefuseRefundApplyInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/RefuseRefundApply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefuseRefundApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefuseRefundApply(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRefuseRefundApply(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dispatchPointToMember(body: DispatchPointToMemberInput | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShopManage/DispatchPointToMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispatchPointToMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispatchPointToMember(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processDispatchPointToMember(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class SensingTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTicketsForProductByTagAndCategory(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, body: GetTicketsByTagAndCategoryInput | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForProductByTagAndCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForProductByTagAndCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForProductByTagAndCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForProductByTagAndCategory(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getTicketUseConditionById(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, ticketId: number | undefined): Observable<TicketTagAndCategoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketUseConditionById?";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketUseConditionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketUseConditionById(<any>response_);
                } catch (e) {
                    return <Observable<TicketTagAndCategoryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketTagAndCategoryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketUseConditionById(response: HttpResponseBase): Observable<TicketTagAndCategoryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketTagAndCategoryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketTagAndCategoryOutput>(<any>null);
    }

    /**
     * 无用,但暂时保留
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTicketsForOrder(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, body: GetTicketsForOrderInput | undefined): Observable<SkuTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForOrder(<any>response_);
                } catch (e) {
                    return <Observable<SkuTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForOrder(response: HttpResponseBase): Observable<SkuTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuTicketDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTickets(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, body: GetTicketsInput | undefined): Observable<SimpleTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTickets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<SimpleTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<SimpleTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleTicketDto[]>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    getTicketsForActivity(actionId: number | undefined, securityKey: string | undefined): Observable<SimpleTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsForActivity?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsForActivity(<any>response_);
                } catch (e) {
                    return <Observable<SimpleTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsForActivity(response: HttpResponseBase): Observable<SimpleTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleTicketDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    takeTicketForActivity(body: TakeTicketForActivityInput | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicketForActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicketForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicketForActivity(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicketForActivity(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    takeTicketForActivity_Jingmei(body: TakeTicketForActivityInput | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicketForActivity_Jingmei";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicketForActivity_Jingmei(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicketForActivity_Jingmei(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicketForActivity_Jingmei(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param memberTicketId (optional) 
     * @return Success
     */
    getTakedTicketByMemberIdAndTicketId(memberTicketId: number | undefined): Observable<GetTakedTicketInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakedTicketByMemberIdAndTicketId?";
        if (memberTicketId === null)
            throw new Error("The parameter 'memberTicketId' cannot be null.");
        else if (memberTicketId !== undefined)
            url_ += "memberTicketId=" + encodeURIComponent("" + memberTicketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakedTicketByMemberIdAndTicketId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakedTicketByMemberIdAndTicketId(<any>response_);
                } catch (e) {
                    return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakedTicketByMemberIdAndTicketId(response: HttpResponseBase): Observable<GetTakedTicketInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTakedTicketInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTakedTicketInfoDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    getTakedTicketByActionId(actionId: number | undefined): Observable<GetTakedTicketInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakedTicketByActionId?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakedTicketByActionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakedTicketByActionId(<any>response_);
                } catch (e) {
                    return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTakedTicketInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakedTicketByActionId(response: HttpResponseBase): Observable<GetTakedTicketInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTakedTicketInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTakedTicketInfoDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getPointPreOrder(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, body: GetPointPreOrderInput | undefined): Observable<SimplePointOrderDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetPointPreOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPointPreOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPointPreOrder(<any>response_);
                } catch (e) {
                    return <Observable<SimplePointOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimplePointOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPointPreOrder(response: HttpResponseBase): Observable<SimplePointOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimplePointOrderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePointOrderDto[]>(<any>null);
    }

    /**
     * 会员中心查看有哪些券
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    getTicketsByMemberId(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketsByMemberId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketsByMemberId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketsByMemberId(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketsByMemberId(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * 领取优惠券
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketId (optional) 
     * @param actionId (optional) 
     * @param sendMessage (optional) 
     * @return Success
     */
    takeTicket(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, ticketId: number | undefined, actionId: number | undefined, sendMessage: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/TakeTicket?";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (sendMessage === null)
            throw new Error("The parameter 'sendMessage' cannot be null.");
        else if (sendMessage !== undefined)
            url_ += "SendMessage=" + encodeURIComponent("" + sendMessage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTakeTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTakeTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTakeTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ticketNo (optional) 
     * @param securityKey (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    useTicketByTicketNo(ticketNo: string | undefined, securityKey: string | undefined, subKey: string | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/UseTicketByTicketNo?";
        if (ticketNo === null)
            throw new Error("The parameter 'ticketNo' cannot be null.");
        else if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseTicketByTicketNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseTicketByTicketNo(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUseTicketByTicketNo(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param ticketIds (optional) 
     * @return Success
     */
    getTicketInfosByIds(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, ticketIds: number[] | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketInfosByIds?";
        if (ticketIds === null)
            throw new Error("The parameter 'ticketIds' cannot be null.");
        else if (ticketIds !== undefined)
            ticketIds && ticketIds.forEach(item => { url_ += "ticketIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInfosByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInfosByIds(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInfosByIds(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param productId (optional) 
     * @return Success
     */
    getTicketCenter(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, productId: number | undefined): Observable<GetTicketDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTicketCenter?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketCenter(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketCenter(response: HttpResponseBase): Observable<GetTicketDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTicketDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @param skuId (optional) 
     * @return Success
     */
    getOtherTickets(tenantId: number | undefined, memberId: number | undefined, storeId: number | undefined, skuId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetOtherTickets?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "storeId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOtherTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOtherTickets(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetOtherTickets(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 雪花秀派样机流程
     * @param body (optional) 
     * @return Success
     */
    getPickNobyUser(body: TaketicketForUserInput | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetPickNobyUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickNobyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickNobyUser(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickNobyUser(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * 跨服查询
     * @param body (optional) 
     * @return Success
     */
    getAwardsByUser(body: TakeTicketRepInput | undefined): Observable<TakeTicketRepDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAwardsByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByUser(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketRepDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketRepDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByUser(response: HttpResponseBase): Observable<TakeTicketRepDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketRepDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketRepDtoPagedResultDto>(<any>null);
    }

    /**
     * 检查券码是否符合
     * @param ticketNo (optional) 
     * @param securityKey (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    checkTicketNo(ticketNo: string | undefined, securityKey: string | undefined, subKey: string | undefined): Observable<CheckTicketDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/CheckTicketNo?";
        if (ticketNo === null)
            throw new Error("The parameter 'ticketNo' cannot be null.");
        else if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTicketNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTicketNo(<any>response_);
                } catch (e) {
                    return <Observable<CheckTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTicketNo(response: HttpResponseBase): Observable<CheckTicketDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckTicketDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckTicketDto>(<any>null);
    }

    /**
     * 使用券码
     * @param subKey (optional) 
     * @param ticketNo (optional) 
     * @param isSuccess (optional) 
     * @param operationTime (optional) 
     * @param cargoRoadId (optional) 
     * @param thingId (optional) 
     * @param thingname (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    useTicketAfterCheck(subKey: string | undefined, ticketNo: string | undefined, isSuccess: boolean | undefined, operationTime: number | undefined, cargoRoadId: number | undefined, thingId: number | undefined, thingname: string | undefined, tenantId: number | undefined): Observable<TakeTicketResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/UseTicketAfterCheck?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (ticketNo === null)
            throw new Error("The parameter 'ticketNo' cannot be null.");
        else if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&";
        if (isSuccess === null)
            throw new Error("The parameter 'isSuccess' cannot be null.");
        else if (isSuccess !== undefined)
            url_ += "IsSuccess=" + encodeURIComponent("" + isSuccess) + "&";
        if (operationTime === null)
            throw new Error("The parameter 'operationTime' cannot be null.");
        else if (operationTime !== undefined)
            url_ += "OperationTime=" + encodeURIComponent("" + operationTime) + "&";
        if (cargoRoadId === null)
            throw new Error("The parameter 'cargoRoadId' cannot be null.");
        else if (cargoRoadId !== undefined)
            url_ += "CargoRoadId=" + encodeURIComponent("" + cargoRoadId) + "&";
        if (thingId === null)
            throw new Error("The parameter 'thingId' cannot be null.");
        else if (thingId !== undefined)
            url_ += "thingId=" + encodeURIComponent("" + thingId) + "&";
        if (thingname === null)
            throw new Error("The parameter 'thingname' cannot be null.");
        else if (thingname !== undefined)
            url_ += "thingname=" + encodeURIComponent("" + thingname) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseTicketAfterCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseTicketAfterCheck(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUseTicketAfterCheck(response: HttpResponseBase): Observable<TakeTicketResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TakeTicketResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketResultDto>(<any>null);
    }

    /**
     * 根据Subkey获取设备操作的平均时间
     * @param subKey (optional) 
     * @return Success
     */
    getAvgOperationTime(subKey: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAvgOperationTime?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvgOperationTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvgOperationTime(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvgOperationTime(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAwardsUserRep(): Observable<TakeTicketRepDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetAwardsUserRep";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsUserRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsUserRep(<any>response_);
                } catch (e) {
                    return <Observable<TakeTicketRepDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeTicketRepDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsUserRep(response: HttpResponseBase): Observable<TakeTicketRepDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TakeTicketRepDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeTicketRepDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTakeTicketRep(): Observable<TicketRep[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakeTicketRep";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakeTicketRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakeTicketRep(<any>response_);
                } catch (e) {
                    return <Observable<TicketRep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketRep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakeTicketRep(response: HttpResponseBase): Observable<TicketRep[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TicketRep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketRep[]>(<any>null);
    }

    /**
     * 导出Excel
     * @return Success
     */
    getTakeTicketListToExcel(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/GetTakeTicketListToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakeTicketListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakeTicketListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakeTicketListToExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加附件
     * @param name (optional) 
     * @param body (optional) 网络附件，上传Stream流
     * @return Success
     */
    addAttachments(name: string | undefined, body: Stream | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/AddAttachments?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAttachments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    sendMail(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingTicket/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: OrderTagType | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteTag(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class TicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ONLINE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ticketStatus (optional) 
     * @param ticketType (optional) 
     * @param takeType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTickets(ticketStatus: AuditStatus | undefined, ticketType: TicketType | undefined, takeType: TakeType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetTicketDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetTickets?";
        if (ticketStatus === null)
            throw new Error("The parameter 'ticketStatus' cannot be null.");
        else if (ticketStatus !== undefined)
            url_ += "TicketStatus=" + encodeURIComponent("" + ticketStatus) + "&";
        if (ticketType === null)
            throw new Error("The parameter 'ticketType' cannot be null.");
        else if (ticketType !== undefined)
            url_ += "TicketType=" + encodeURIComponent("" + ticketType) + "&";
        if (takeType === null)
            throw new Error("The parameter 'takeType' cannot be null.");
        else if (takeType !== undefined)
            url_ += "TakeType=" + encodeURIComponent("" + takeType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<GetTicketDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateTicket(body: AddOrUpdateTicketInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/AddOrUpdateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteTickets(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/DeleteTickets?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTickets(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTickets(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    grantTicketByTags(body: GrantTicketByTagsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GrantTicketByTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantTicketByTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantTicketByTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantTicketByTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    grantTicketByMemberLevels(body: GrantTicketByMemberLevelsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GrantTicketByMemberLevels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantTicketByMemberLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantTicketByMemberLevels(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantTicketByMemberLevels(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ticketId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTicketMembers(ticketId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetTicketMemberDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetTicketMembers?";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "TicketId=" + encodeURIComponent("" + ticketId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketMembers(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketMemberDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketMemberDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketMembers(response: HttpResponseBase): Observable<GetTicketMemberDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTicketMemberDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketMemberDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTicketStatus(body: SetTicketStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/SetTicketStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTicketStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTicketStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTicketStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class AddCustomerMemberFromOnlineInput implements IAddCustomerMemberFromOnlineInput {
    subkey!: string | undefined;
    tenantId!: number | undefined;
    openId!: string | undefined;
    name!: string | undefined;
    tel!: string | undefined;
    company!: string | undefined;
    interest!: string | undefined;
    type!: string | undefined;
    from!: string | undefined;
    informManager!: boolean;

    constructor(data?: IAddCustomerMemberFromOnlineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.tenantId = _data["tenantId"];
            this.openId = _data["openId"];
            this.name = _data["name"];
            this.tel = _data["tel"];
            this.company = _data["company"];
            this.interest = _data["interest"];
            this.type = _data["type"];
            this.from = _data["from"];
            this.informManager = _data["informManager"];
        }
    }

    static fromJS(data: any): AddCustomerMemberFromOnlineInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddCustomerMemberFromOnlineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["tenantId"] = this.tenantId;
        data["openId"] = this.openId;
        data["name"] = this.name;
        data["tel"] = this.tel;
        data["company"] = this.company;
        data["interest"] = this.interest;
        data["type"] = this.type;
        data["from"] = this.from;
        data["informManager"] = this.informManager;
        return data; 
    }
}

export interface IAddCustomerMemberFromOnlineInput {
    subkey: string | undefined;
    tenantId: number | undefined;
    openId: string | undefined;
    name: string | undefined;
    tel: string | undefined;
    company: string | undefined;
    interest: string | undefined;
    type: string | undefined;
    from: string | undefined;
    informManager: boolean;
}

export class AddGroupToOvoParkInput implements IAddGroupToOvoParkInput {
    groupname!: string | undefined;
    orgid!: number;

    constructor(data?: IAddGroupToOvoParkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupname = _data["groupname"];
            this.orgid = _data["orgid"];
        }
    }

    static fromJS(data: any): AddGroupToOvoParkInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupToOvoParkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupname"] = this.groupname;
        data["orgid"] = this.orgid;
        return data; 
    }
}

export interface IAddGroupToOvoParkInput {
    groupname: string | undefined;
    orgid: number;
}

export class AddMemberToCustomerInput implements IAddMemberToCustomerInput {
    memberIds!: number[] | undefined;
    customerId!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IAddMemberToCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of _data["memberIds"])
                    this.memberIds!.push(item);
            }
            if (Array.isArray(_data["customerId"])) {
                this.customerId = [] as any;
                for (let item of _data["customerId"])
                    this.customerId!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): AddMemberToCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddMemberToCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        if (Array.isArray(this.customerId)) {
            data["customerId"] = [];
            for (let item of this.customerId)
                data["customerId"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IAddMemberToCustomerInput {
    memberIds: number[] | undefined;
    customerId: number[] | undefined;
    action: string | undefined;
}

export class AddOrUpdateAddressInput implements IAddOrUpdateAddressInput {
    id!: number | undefined;
    phone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    zipcode!: string | undefined;
    normalizeName!: string | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    isDefault!: boolean;

    constructor(data?: IAddOrUpdateAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phone = _data["phone"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.address = _data["address"];
            this.zipcode = _data["zipcode"];
            this.normalizeName = _data["normalizeName"];
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): AddOrUpdateAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipcode"] = this.zipcode;
        data["normalizeName"] = this.normalizeName;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IAddOrUpdateAddressInput {
    id: number | undefined;
    phone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    zipcode: string | undefined;
    normalizeName: string | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    isDefault: boolean;
}

export class AddOrUpdateBigScreenOrderForConfirmDto implements IAddOrUpdateBigScreenOrderForConfirmDto {
    orderId!: number;
    orderNO!: string | undefined;

    constructor(data?: IAddOrUpdateBigScreenOrderForConfirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNO = _data["orderNO"];
        }
    }

    static fromJS(data: any): AddOrUpdateBigScreenOrderForConfirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateBigScreenOrderForConfirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNO"] = this.orderNO;
        return data; 
    }
}

export interface IAddOrUpdateBigScreenOrderForConfirmDto {
    orderId: number;
    orderNO: string | undefined;
}

export class AddOrUpdateCustomerInput implements IAddOrUpdateCustomerInput {
    id!: number | undefined;
    name!: string | undefined;
    legalPerson!: string | undefined;
    registeredCapital!: string | undefined;
    businessCode!: string | undefined;
    address!: string | undefined;
    description!: string | undefined;
    interest!: string | undefined;

    constructor(data?: IAddOrUpdateCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.legalPerson = _data["legalPerson"];
            this.registeredCapital = _data["registeredCapital"];
            this.businessCode = _data["businessCode"];
            this.address = _data["address"];
            this.description = _data["description"];
            this.interest = _data["interest"];
        }
    }

    static fromJS(data: any): AddOrUpdateCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["legalPerson"] = this.legalPerson;
        data["registeredCapital"] = this.registeredCapital;
        data["businessCode"] = this.businessCode;
        data["address"] = this.address;
        data["description"] = this.description;
        data["interest"] = this.interest;
        return data; 
    }
}

export interface IAddOrUpdateCustomerInput {
    id: number | undefined;
    name: string | undefined;
    legalPerson: string | undefined;
    registeredCapital: string | undefined;
    businessCode: string | undefined;
    address: string | undefined;
    description: string | undefined;
    interest: string | undefined;
}

export class AddOrUpdateExtensionOrderInput implements IAddOrUpdateExtensionOrderInput {
    subKey!: string;
    orderId!: number;
    memberId!: number | undefined;
    skuId!: number | undefined;
    mediaId!: string | undefined;
    printStateDescription!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    from!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;
    gcodeFileUrl!: string | undefined;

    constructor(data?: IAddOrUpdateExtensionOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.orderId = _data["orderId"];
            this.memberId = _data["memberId"];
            this.skuId = _data["skuId"];
            this.mediaId = _data["mediaId"];
            this.printStateDescription = _data["printStateDescription"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.from = _data["from"];
            this.startPrintDataTime = _data["startPrintDataTime"] ? moment(_data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = _data["endPrintDateTime"] ? moment(_data["endPrintDateTime"].toString()) : <any>undefined;
            this.gcodeFileUrl = _data["gcodeFileUrl"];
        }
    }

    static fromJS(data: any): AddOrUpdateExtensionOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateExtensionOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["orderId"] = this.orderId;
        data["memberId"] = this.memberId;
        data["skuId"] = this.skuId;
        data["mediaId"] = this.mediaId;
        data["printStateDescription"] = this.printStateDescription;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["from"] = this.from;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        return data; 
    }
}

export interface IAddOrUpdateExtensionOrderInput {
    subKey: string;
    orderId: number;
    memberId: number | undefined;
    skuId: number | undefined;
    mediaId: string | undefined;
    printStateDescription: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    from: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
    gcodeFileUrl: string | undefined;
}

export class AddOrUpdateHaierOrderInput implements IAddOrUpdateHaierOrderInput {
    id!: number | undefined;
    /** 所属OU */
    organizationUnitId!: number | undefined;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    number!: string | undefined;
    /** 店铺外部编号 */
    storeId!: string | undefined;
    note!: string | undefined;
    /** 会员名称 */
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    orderItems!: AddOrUpdateHaierOrderItemOuterInput[] | undefined;
    ticketId!: number | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateHaierOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.taxFee = _data["taxFee"];
            this.postFee = _data["postFee"];
            this.payment = _data["payment"];
            this.number = _data["number"];
            this.storeId = _data["storeId"];
            this.note = _data["note"];
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(AddOrUpdateHaierOrderItemOuterInput.fromJS(item));
            }
            this.ticketId = _data["ticketId"];
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateHaierOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateHaierOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationUnitId"] = this.organizationUnitId;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["number"] = this.number;
        data["storeId"] = this.storeId;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["ticketId"] = this.ticketId;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateHaierOrderInput {
    id: number | undefined;
    /** 所属OU */
    organizationUnitId: number | undefined;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    number: string | undefined;
    /** 店铺外部编号 */
    storeId: string | undefined;
    note: string | undefined;
    /** 会员名称 */
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    orderItems: AddOrUpdateHaierOrderItemOuterInput[] | undefined;
    ticketId: number | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateHaierOrderItemOuterInput implements IAddOrUpdateHaierOrderItemOuterInput {
    /** Sku 编号 */
    skuId!: string;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    /** 数量 */
    number!: number;
    /** 总价 */
    totalFee!: number;
    /** 税金 */
    taxFee!: number;
    /** 实付金额 */
    payment!: number;
    /** Sku状态 */
    status!: string | undefined;
    /** 商品品牌 */
    brandName!: string | undefined;
    /** 商品类别 */
    category!: string | undefined;
    /** 活动标签 */
    activityTag!: string | undefined;
    /** 会员折扣 */
    discount!: string | undefined;
    /** 是否是套装 */
    isSuite!: boolean;
    rfidCode!: string | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateHaierOrderItemOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.payment = _data["payment"];
            this.status = _data["status"];
            this.brandName = _data["brandName"];
            this.category = _data["category"];
            this.activityTag = _data["activityTag"];
            this.discount = _data["discount"];
            this.isSuite = _data["isSuite"];
            this.rfidCode = _data["rfidCode"];
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateHaierOrderItemOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateHaierOrderItemOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["rfidCode"] = this.rfidCode;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateHaierOrderItemOuterInput {
    /** Sku 编号 */
    skuId: string;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    /** 数量 */
    number: number;
    /** 总价 */
    totalFee: number;
    /** 税金 */
    taxFee: number;
    /** 实付金额 */
    payment: number;
    /** Sku状态 */
    status: string | undefined;
    /** 商品品牌 */
    brandName: string | undefined;
    /** 商品类别 */
    category: string | undefined;
    /** 活动标签 */
    activityTag: string | undefined;
    /** 会员折扣 */
    discount: string | undefined;
    /** 是否是套装 */
    isSuite: boolean;
    rfidCode: string | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateMemberLevelInput implements IAddOrUpdateMemberLevelInput {
    id!: number | undefined;
    name!: string | undefined;
    levelKey!: string | undefined;
    condition!: number;
    discount!: number;

    constructor(data?: IAddOrUpdateMemberLevelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.levelKey = _data["levelKey"];
            this.condition = _data["condition"];
            this.discount = _data["discount"];
        }
    }

    static fromJS(data: any): AddOrUpdateMemberLevelInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMemberLevelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["levelKey"] = this.levelKey;
        data["condition"] = this.condition;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IAddOrUpdateMemberLevelInput {
    id: number | undefined;
    name: string | undefined;
    levelKey: string | undefined;
    condition: number;
    discount: number;
}

export class AddOrUpdateMemberOuterInput implements IAddOrUpdateMemberOuterInput {
    id!: string;
    /** 会员类型 */
    type!: string;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    /** 所属店铺名称 */
    storeName!: string | undefined;
    /** 注册时间 */
    registerdTime!: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime!: moment.Moment | undefined;
    /** 会员积分 */
    point!: number | undefined;
    /** 会员积分倍率 */
    pointRate!: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts!: boolean | undefined;
    /** 会员OpenId */
    openId!: string | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string;
    /** 职业 */
    career!: string | undefined;
    /** 收入 */
    income!: string | undefined;
    /** 收获地址集合 */
    address!: ShippingAddressOuterDto[] | undefined;
    /** 数据来源 */
    from!: string | undefined;
    source!: string | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;

    constructor(data?: IAddOrUpdateMemberOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.registerdTime = _data["registerdTime"] ? moment(_data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.openId = _data["openId"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(ShippingAddressOuterDto.fromJS(item));
            }
            this.from = _data["from"];
            this.source = _data["source"];
            this.extraInfo1 = _data["extraInfo1"];
            this.extraInfo2 = _data["extraInfo2"];
            this.extraInfo3 = _data["extraInfo3"];
            this.extraInfoX = _data["extraInfoX"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AddOrUpdateMemberOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMemberOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["openId"] = this.openId;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["source"] = this.source;
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        return data; 
    }
}

export interface IAddOrUpdateMemberOuterInput {
    id: string;
    /** 会员类型 */
    type: string;
    /** 所属店铺编号 */
    storeId: string | undefined;
    /** 所属店铺名称 */
    storeName: string | undefined;
    /** 注册时间 */
    registerdTime: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime: moment.Moment | undefined;
    /** 会员积分 */
    point: number | undefined;
    /** 会员积分倍率 */
    pointRate: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts: boolean | undefined;
    /** 会员OpenId */
    openId: string | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    /** 注册手机号码 */
    regPhone: string;
    /** 职业 */
    career: string | undefined;
    /** 收入 */
    income: string | undefined;
    /** 收获地址集合 */
    address: ShippingAddressOuterDto[] | undefined;
    /** 数据来源 */
    from: string | undefined;
    source: string | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
}

export class AddOrUpdateOrderExtensionInput implements IAddOrUpdateOrderExtensionInput {
    orderId!: number;
    skuId!: number | undefined;
    mediaId!: string | undefined;
    printState!: PrintState;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IAddOrUpdateOrderExtensionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.skuId = _data["skuId"];
            this.mediaId = _data["mediaId"];
            this.printState = _data["printState"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderExtensionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderExtensionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["skuId"] = this.skuId;
        data["mediaId"] = this.mediaId;
        data["printState"] = this.printState;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IAddOrUpdateOrderExtensionInput {
    orderId: number;
    skuId: number | undefined;
    mediaId: string | undefined;
    printState: PrintState;
    description: string | undefined;
    extensionData: string | undefined;
}

export class AddOrUpdateOrderItemOuterInput implements IAddOrUpdateOrderItemOuterInput {
    /** Sku 编号 */
    skuId!: string;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    /** 数量 */
    number!: number;
    /** 总价 */
    totalFee!: number;
    /** 税金 */
    taxFee!: number;
    /** 实付金额 */
    payment!: number;
    /** Sku状态 */
    status!: string | undefined;
    /** 商品品牌 */
    brandName!: string | undefined;
    /** 商品类别 */
    category!: string | undefined;
    /** 商品小类 */
    subCategory!: string | undefined;
    /** 活动标签 */
    activityTag!: string | undefined;
    /** 会员折扣 */
    discount!: string | undefined;
    /** 是否是套装 */
    isSuite!: boolean;
    rfid!: string | undefined;
    activityId!: number | undefined;

    constructor(data?: IAddOrUpdateOrderItemOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.payment = _data["payment"];
            this.status = _data["status"];
            this.brandName = _data["brandName"];
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.activityTag = _data["activityTag"];
            this.discount = _data["discount"];
            this.isSuite = _data["isSuite"];
            this.rfid = _data["rfid"];
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderItemOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderItemOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["rfid"] = this.rfid;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IAddOrUpdateOrderItemOuterInput {
    /** Sku 编号 */
    skuId: string;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    /** 数量 */
    number: number;
    /** 总价 */
    totalFee: number;
    /** 税金 */
    taxFee: number;
    /** 实付金额 */
    payment: number;
    /** Sku状态 */
    status: string | undefined;
    /** 商品品牌 */
    brandName: string | undefined;
    /** 商品类别 */
    category: string | undefined;
    /** 商品小类 */
    subCategory: string | undefined;
    /** 活动标签 */
    activityTag: string | undefined;
    /** 会员折扣 */
    discount: string | undefined;
    /** 是否是套装 */
    isSuite: boolean;
    rfid: string | undefined;
    activityId: number | undefined;
}

export class AddOrUpdateOrderOuterInput implements IAddOrUpdateOrderOuterInput {
    id!: string;
    orderDateTime!: moment.Moment;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    status!: string;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    /** 所属店铺名称 */
    storeName!: string | undefined;
    /** 订单数据来源 */
    from!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    buyer!: Buyer;
    source!: string | undefined;

    constructor(data?: IAddOrUpdateOrderOuterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.taxFee = _data["taxFee"];
            this.postFee = _data["postFee"];
            this.payment = _data["payment"];
            this.payType = _data["payType"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.refundTime = _data["refundTime"] ? moment(_data["refundTime"].toString()) : <any>undefined;
            this.consignTime = _data["consignTime"] ? moment(_data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = _data["returnsTime"] ? moment(_data["returnsTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.from = _data["from"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.buyer = _data["buyer"] ? Buyer.fromJS(_data["buyer"]) : <any>undefined;
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): AddOrUpdateOrderOuterInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOrderOuterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["buyer"] = this.buyer ? this.buyer.toJSON() : <any>undefined;
        data["source"] = this.source;
        return data; 
    }
}

export interface IAddOrUpdateOrderOuterInput {
    id: string;
    orderDateTime: moment.Moment;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    status: string;
    /** 所属店铺编号 */
    storeId: string | undefined;
    /** 所属店铺名称 */
    storeName: string | undefined;
    /** 订单数据来源 */
    from: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    buyer: Buyer;
    source: string | undefined;
}

export class AddOrUpdatePayAccountInput implements IAddOrUpdatePayAccountInput {
    id!: number | undefined;
    appID!: string | undefined;
    from!: string | undefined;
    parameters!: any | undefined;
    name!: string | undefined;
    description!: string | undefined;
    auditStatus!: boolean;

    constructor(data?: IAddOrUpdatePayAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appID = _data["appID"];
            this.from = _data["from"];
            this.parameters = _data["parameters"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.auditStatus = _data["auditStatus"];
        }
    }

    static fromJS(data: any): AddOrUpdatePayAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdatePayAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appID"] = this.appID;
        data["from"] = this.from;
        data["parameters"] = this.parameters;
        data["name"] = this.name;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        return data; 
    }
}

export interface IAddOrUpdatePayAccountInput {
    id: number | undefined;
    appID: string | undefined;
    from: string | undefined;
    parameters: any | undefined;
    name: string | undefined;
    description: string | undefined;
    auditStatus: boolean;
}

export class AddOrUpdateTicketInput implements IAddOrUpdateTicketInput {
    id!: number | undefined;
    storeId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    ticketType!: TicketType;
    takeType!: TakeType;
    value!: number;
    useCondition!: TicketUseCondition;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;
    ticketStatus!: AuditStatus;

    constructor(data?: IAddOrUpdateTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.ticketType = _data["ticketType"];
            this.takeType = _data["takeType"];
            this.value = _data["value"];
            this.useCondition = _data["useCondition"] ? TicketUseCondition.fromJS(_data["useCondition"]) : <any>undefined;
            if (Array.isArray(_data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of _data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
            this.ticketStatus = _data["ticketStatus"];
        }
    }

    static fromJS(data: any): AddOrUpdateTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface IAddOrUpdateTicketInput {
    id: number | undefined;
    storeId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    ticketType: TicketType;
    takeType: TakeType;
    value: number;
    useCondition: TicketUseCondition;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
    ticketStatus: AuditStatus;
}

export class AddOrUpdateWeishopOrderInput implements IAddOrUpdateWeishopOrderInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    /** 所属OU */
    organizationUnitId!: number | undefined;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    number!: string | undefined;
    /** 店铺外部编号 */
    storeId!: string | undefined;
    note!: string | undefined;
    /** 会员名称 */
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    ticketId!: number | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;
    activityId!: number | undefined;
    status!: string | undefined;

    constructor(data?: IAddOrUpdateWeishopOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.taxFee = _data["taxFee"];
            this.postFee = _data["postFee"];
            this.payment = _data["payment"];
            this.number = _data["number"];
            this.storeId = _data["storeId"];
            this.note = _data["note"];
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.ticketId = _data["ticketId"];
            this.pointReduction = _data["pointReduction"];
            this.deductionAmount = _data["deductionAmount"];
            this.activityId = _data["activityId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AddOrUpdateWeishopOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateWeishopOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["number"] = this.number;
        data["storeId"] = this.storeId;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["ticketId"] = this.ticketId;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        data["activityId"] = this.activityId;
        data["status"] = this.status;
        return data; 
    }
}

export interface IAddOrUpdateWeishopOrderInput {
    id: number | undefined;
    tenantId: number | undefined;
    /** 所属OU */
    organizationUnitId: number | undefined;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    number: string | undefined;
    /** 店铺外部编号 */
    storeId: string | undefined;
    note: string | undefined;
    /** 会员名称 */
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    ticketId: number | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
    activityId: number | undefined;
    status: string | undefined;
}

export class AddPointLogByMemberIdInput implements IAddPointLogByMemberIdInput {
    tenantId!: number | undefined;
    dispatchPointToMemberInput!: DispatchPointToMemberInput1;

    constructor(data?: IAddPointLogByMemberIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.dispatchPointToMemberInput = _data["dispatchPointToMemberInput"] ? DispatchPointToMemberInput1.fromJS(_data["dispatchPointToMemberInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddPointLogByMemberIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddPointLogByMemberIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["dispatchPointToMemberInput"] = this.dispatchPointToMemberInput ? this.dispatchPointToMemberInput.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddPointLogByMemberIdInput {
    tenantId: number | undefined;
    dispatchPointToMemberInput: DispatchPointToMemberInput1;
}

export class AddSalesToCustomerInput implements IAddSalesToCustomerInput {
    sales!: IdNameDto[] | undefined;
    customerId!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IAddSalesToCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sales"])) {
                this.sales = [] as any;
                for (let item of _data["sales"])
                    this.sales!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["customerId"])) {
                this.customerId = [] as any;
                for (let item of _data["customerId"])
                    this.customerId!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): AddSalesToCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSalesToCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        if (Array.isArray(this.customerId)) {
            data["customerId"] = [];
            for (let item of this.customerId)
                data["customerId"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IAddSalesToCustomerInput {
    sales: IdNameDto[] | undefined;
    customerId: number[] | undefined;
    action: string | undefined;
}

export class AddUserDto implements IAddUserDto {
    success!: boolean;
    errorMessage!: string | undefined;

    constructor(data?: IAddUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): AddUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface IAddUserDto {
    success: boolean;
    errorMessage: string | undefined;
}

export class AddUserInput implements IAddUserInput {
    useid!: string | undefined;
    userid!: string | undefined;
    orgid!: number | undefined;
    depid!: number;
    thirdpicurl!: string | undefined;
    faceid!: string | undefined;
    version!: string | undefined;

    constructor(data?: IAddUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useid = _data["useid"];
            this.userid = _data["userid"];
            this.orgid = _data["orgid"];
            this.depid = _data["depid"];
            this.thirdpicurl = _data["thirdpicurl"];
            this.faceid = _data["faceid"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): AddUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useid"] = this.useid;
        data["userid"] = this.userid;
        data["orgid"] = this.orgid;
        data["depid"] = this.depid;
        data["thirdpicurl"] = this.thirdpicurl;
        data["faceid"] = this.faceid;
        data["version"] = this.version;
        return data; 
    }
}

export interface IAddUserInput {
    useid: string | undefined;
    userid: string | undefined;
    orgid: number | undefined;
    depid: number;
    thirdpicurl: string | undefined;
    faceid: string | undefined;
    version: string | undefined;
}

export class AddUserResultDto implements IAddUserResultDto {
    data!: Data;
    result!: string | undefined;

    constructor(data?: IAddUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Data.fromJS(_data["data"]) : <any>undefined;
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): AddUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["result"] = this.result;
        return data; 
    }
}

export interface IAddUserResultDto {
    data: Data;
    result: string | undefined;
}

export class AddUserToOvoParkInput implements IAddUserToOvoParkInput {
    deviceId!: number;
    securityKey!: string | undefined;
    username!: string | undefined;
    gender!: string | undefined;
    from!: string | undefined;
    thirdpicurl!: string | undefined;
    mobilephone!: string | undefined;
    openId!: string | undefined;
    birthTime!: moment.Moment;
    faceId!: string | undefined;

    constructor(data?: IAddUserToOvoParkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.securityKey = _data["securityKey"];
            this.username = _data["username"];
            this.gender = _data["gender"];
            this.from = _data["from"];
            this.thirdpicurl = _data["thirdpicurl"];
            this.mobilephone = _data["mobilephone"];
            this.openId = _data["openId"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.faceId = _data["faceId"];
        }
    }

    static fromJS(data: any): AddUserToOvoParkInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToOvoParkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["securityKey"] = this.securityKey;
        data["username"] = this.username;
        data["gender"] = this.gender;
        data["from"] = this.from;
        data["thirdpicurl"] = this.thirdpicurl;
        data["mobilephone"] = this.mobilephone;
        data["openId"] = this.openId;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["faceId"] = this.faceId;
        return data; 
    }
}

export interface IAddUserToOvoParkInput {
    deviceId: number;
    securityKey: string | undefined;
    username: string | undefined;
    gender: string | undefined;
    from: string | undefined;
    thirdpicurl: string | undefined;
    mobilephone: string | undefined;
    openId: string | undefined;
    birthTime: moment.Moment;
    faceId: string | undefined;
}

export class AgeChartDto implements IAgeChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IAgeChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): AgeChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgeChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IAgeChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
}

export class AlipayNotifyInput implements IAlipayNotifyInput {
    trade_no!: string | undefined;
    order_no!: string | undefined;
    total_fee!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    buyer_email!: string | undefined;
    trade_status!: string | undefined;

    constructor(data?: IAlipayNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trade_no = _data["trade_no"];
            this.order_no = _data["order_no"];
            this.total_fee = _data["total_fee"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.buyer_email = _data["buyer_email"];
            this.trade_status = _data["trade_status"];
        }
    }

    static fromJS(data: any): AlipayNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new AlipayNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trade_no"] = this.trade_no;
        data["order_no"] = this.order_no;
        data["total_fee"] = this.total_fee;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["buyer_email"] = this.buyer_email;
        data["trade_status"] = this.trade_status;
        return data; 
    }
}

export interface IAlipayNotifyInput {
    trade_no: string | undefined;
    order_no: string | undefined;
    total_fee: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    buyer_email: string | undefined;
    trade_status: string | undefined;
}

export class AliPayParameters implements IAliPayParameters {
    apP_PRIVATE_KEY!: string | undefined;
    alipaY_PUBLIC_KEY!: string | undefined;

    constructor(data?: IAliPayParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apP_PRIVATE_KEY = _data["apP_PRIVATE_KEY"];
            this.alipaY_PUBLIC_KEY = _data["alipaY_PUBLIC_KEY"];
        }
    }

    static fromJS(data: any): AliPayParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AliPayParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apP_PRIVATE_KEY"] = this.apP_PRIVATE_KEY;
        data["alipaY_PUBLIC_KEY"] = this.alipaY_PUBLIC_KEY;
        return data; 
    }
}

export interface IAliPayParameters {
    apP_PRIVATE_KEY: string | undefined;
    alipaY_PUBLIC_KEY: string | undefined;
}

export enum AuditStatus {
    Offline = 0,
    Online = 1,
}

export class BehaviorDto implements IBehaviorDto {
    templateChartDtos!: TemplateChartDto[] | undefined;

    constructor(data?: IBehaviorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["templateChartDtos"])) {
                this.templateChartDtos = [] as any;
                for (let item of _data["templateChartDtos"])
                    this.templateChartDtos!.push(TemplateChartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BehaviorDto {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.templateChartDtos)) {
            data["templateChartDtos"] = [];
            for (let item of this.templateChartDtos)
                data["templateChartDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBehaviorDto {
    templateChartDtos: TemplateChartDto[] | undefined;
}

export class BigChart implements IBigChart {
    orderChart!: OrderChartDto;
    ageChart!: AgeChartDto;
    sexChart!: ValueNameDto[] | undefined;
    payChart!: ValueNameDto[] | undefined;
    guestChart!: GuestChartDto;
    perHourOrderChart!: PerHourOrderChartDto;
    mainChart!: MainChartDto;
    memberChart!: MemberChartDto;
    productChart!: ProductChartDto;
    orderSalesChart!: OrderSalesChartDto;
    lastSalesChart!: LastSalesChartDto;
    categorySalesChart!: CategorySalesChartDto[] | undefined;
    dailyGuestChart!: GuestChartDto1;
    dailyOrderSalesChart!: OrderSalesChartDto;
    dailyOrderCountChart!: OrderCountChartDto;
    dailyBuyerCountChart!: BuyerCountChartDto;

    constructor(data?: IBigChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderChart = _data["orderChart"] ? OrderChartDto.fromJS(_data["orderChart"]) : <any>undefined;
            this.ageChart = _data["ageChart"] ? AgeChartDto.fromJS(_data["ageChart"]) : <any>undefined;
            if (Array.isArray(_data["sexChart"])) {
                this.sexChart = [] as any;
                for (let item of _data["sexChart"])
                    this.sexChart!.push(ValueNameDto.fromJS(item));
            }
            if (Array.isArray(_data["payChart"])) {
                this.payChart = [] as any;
                for (let item of _data["payChart"])
                    this.payChart!.push(ValueNameDto.fromJS(item));
            }
            this.guestChart = _data["guestChart"] ? GuestChartDto.fromJS(_data["guestChart"]) : <any>undefined;
            this.perHourOrderChart = _data["perHourOrderChart"] ? PerHourOrderChartDto.fromJS(_data["perHourOrderChart"]) : <any>undefined;
            this.mainChart = _data["mainChart"] ? MainChartDto.fromJS(_data["mainChart"]) : <any>undefined;
            this.memberChart = _data["memberChart"] ? MemberChartDto.fromJS(_data["memberChart"]) : <any>undefined;
            this.productChart = _data["productChart"] ? ProductChartDto.fromJS(_data["productChart"]) : <any>undefined;
            this.orderSalesChart = _data["orderSalesChart"] ? OrderSalesChartDto.fromJS(_data["orderSalesChart"]) : <any>undefined;
            this.lastSalesChart = _data["lastSalesChart"] ? LastSalesChartDto.fromJS(_data["lastSalesChart"]) : <any>undefined;
            if (Array.isArray(_data["categorySalesChart"])) {
                this.categorySalesChart = [] as any;
                for (let item of _data["categorySalesChart"])
                    this.categorySalesChart!.push(CategorySalesChartDto.fromJS(item));
            }
            this.dailyGuestChart = _data["dailyGuestChart"] ? GuestChartDto1.fromJS(_data["dailyGuestChart"]) : <any>undefined;
            this.dailyOrderSalesChart = _data["dailyOrderSalesChart"] ? OrderSalesChartDto.fromJS(_data["dailyOrderSalesChart"]) : <any>undefined;
            this.dailyOrderCountChart = _data["dailyOrderCountChart"] ? OrderCountChartDto.fromJS(_data["dailyOrderCountChart"]) : <any>undefined;
            this.dailyBuyerCountChart = _data["dailyBuyerCountChart"] ? BuyerCountChartDto.fromJS(_data["dailyBuyerCountChart"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BigChart {
        data = typeof data === 'object' ? data : {};
        let result = new BigChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderChart"] = this.orderChart ? this.orderChart.toJSON() : <any>undefined;
        data["ageChart"] = this.ageChart ? this.ageChart.toJSON() : <any>undefined;
        if (Array.isArray(this.sexChart)) {
            data["sexChart"] = [];
            for (let item of this.sexChart)
                data["sexChart"].push(item.toJSON());
        }
        if (Array.isArray(this.payChart)) {
            data["payChart"] = [];
            for (let item of this.payChart)
                data["payChart"].push(item.toJSON());
        }
        data["guestChart"] = this.guestChart ? this.guestChart.toJSON() : <any>undefined;
        data["perHourOrderChart"] = this.perHourOrderChart ? this.perHourOrderChart.toJSON() : <any>undefined;
        data["mainChart"] = this.mainChart ? this.mainChart.toJSON() : <any>undefined;
        data["memberChart"] = this.memberChart ? this.memberChart.toJSON() : <any>undefined;
        data["productChart"] = this.productChart ? this.productChart.toJSON() : <any>undefined;
        data["orderSalesChart"] = this.orderSalesChart ? this.orderSalesChart.toJSON() : <any>undefined;
        data["lastSalesChart"] = this.lastSalesChart ? this.lastSalesChart.toJSON() : <any>undefined;
        if (Array.isArray(this.categorySalesChart)) {
            data["categorySalesChart"] = [];
            for (let item of this.categorySalesChart)
                data["categorySalesChart"].push(item.toJSON());
        }
        data["dailyGuestChart"] = this.dailyGuestChart ? this.dailyGuestChart.toJSON() : <any>undefined;
        data["dailyOrderSalesChart"] = this.dailyOrderSalesChart ? this.dailyOrderSalesChart.toJSON() : <any>undefined;
        data["dailyOrderCountChart"] = this.dailyOrderCountChart ? this.dailyOrderCountChart.toJSON() : <any>undefined;
        data["dailyBuyerCountChart"] = this.dailyBuyerCountChart ? this.dailyBuyerCountChart.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBigChart {
    orderChart: OrderChartDto;
    ageChart: AgeChartDto;
    sexChart: ValueNameDto[] | undefined;
    payChart: ValueNameDto[] | undefined;
    guestChart: GuestChartDto;
    perHourOrderChart: PerHourOrderChartDto;
    mainChart: MainChartDto;
    memberChart: MemberChartDto;
    productChart: ProductChartDto;
    orderSalesChart: OrderSalesChartDto;
    lastSalesChart: LastSalesChartDto;
    categorySalesChart: CategorySalesChartDto[] | undefined;
    dailyGuestChart: GuestChartDto1;
    dailyOrderSalesChart: OrderSalesChartDto;
    dailyOrderCountChart: OrderCountChartDto;
    dailyBuyerCountChart: BuyerCountChartDto;
}

export class Buyer implements IBuyer {
    /** 会员编码 */
    memberId!: string | undefined;
    /** 会员名称 */
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;

    constructor(data?: IBuyer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
        }
    }

    static fromJS(data: any): Buyer {
        data = typeof data === 'object' ? data : {};
        let result = new Buyer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        return data; 
    }
}

export interface IBuyer {
    /** 会员编码 */
    memberId: string | undefined;
    /** 会员名称 */
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
}

export class BuyerCountChartDto implements IBuyerCountChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalBuyerCount!: number;

    constructor(data?: IBuyerCountChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.totalBuyerCount = _data["totalBuyerCount"];
        }
    }

    static fromJS(data: any): BuyerCountChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuyerCountChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalBuyerCount"] = this.totalBuyerCount;
        return data; 
    }
}

export interface IBuyerCountChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalBuyerCount: number;
}

export class BuyerCountInput implements IBuyerCountInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IBuyerCountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuyerCountInput {
        data = typeof data === 'object' ? data : {};
        let result = new BuyerCountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuyerCountInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class CategorySalesChartDto implements ICategorySalesChartDto {
    date!: string | undefined;
    todaySales!: number;
    categorySales!: ValueNameDto[] | undefined;

    constructor(data?: ICategorySalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.todaySales = _data["todaySales"];
            if (Array.isArray(_data["categorySales"])) {
                this.categorySales = [] as any;
                for (let item of _data["categorySales"])
                    this.categorySales!.push(ValueNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategorySalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["todaySales"] = this.todaySales;
        if (Array.isArray(this.categorySales)) {
            data["categorySales"] = [];
            for (let item of this.categorySales)
                data["categorySales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategorySalesChartDto {
    date: string | undefined;
    todaySales: number;
    categorySales: ValueNameDto[] | undefined;
}

export class CheckTicketDto implements ICheckTicketDto {
    actionId!: number | undefined;
    cargoRoadId!: number;
    thingName!: string | undefined;
    thingId!: number;
    success!: boolean;
    errorMessage!: string | undefined;
    outerId!: string | undefined;
    ticketNo!: string | undefined;
    memberNo!: string | undefined;
    openId!: string | undefined;

    constructor(data?: ICheckTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionId = _data["actionId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.thingName = _data["thingName"];
            this.thingId = _data["thingId"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.outerId = _data["outerId"];
            this.ticketNo = _data["ticketNo"];
            this.memberNo = _data["memberNo"];
            this.openId = _data["openId"];
        }
    }

    static fromJS(data: any): CheckTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["thingName"] = this.thingName;
        data["thingId"] = this.thingId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["outerId"] = this.outerId;
        data["ticketNo"] = this.ticketNo;
        data["memberNo"] = this.memberNo;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface ICheckTicketDto {
    actionId: number | undefined;
    cargoRoadId: number;
    thingName: string | undefined;
    thingId: number;
    success: boolean;
    errorMessage: string | undefined;
    outerId: string | undefined;
    ticketNo: string | undefined;
    memberNo: string | undefined;
    openId: string | undefined;
}

export class CreateMemberInput implements ICreateMemberInput {
    storeOuterId!: string | undefined;
    /** 会员内部编号 */
    memberNo!: string | undefined;
    name!: string;
    /** 出生年月日 */
    birthTime!: moment.Moment | undefined;
    /** 性别 */
    gender!: string | undefined;
    /** 身份证号 */
    idNumber!: string | undefined;
    /** 会员类型 */
    type!: string | undefined;
    /** 首次购买日期 */
    firstBuyTime!: moment.Moment | undefined;
    /** 会员积分 */
    point!: number | undefined;
    /** 会员积分倍率 */
    pointRate!: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts!: boolean | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string | undefined;
    /** 职业 */
    career!: string | undefined;
    /** 收入 */
    income!: string | undefined;
    /** 收获地址集合 */
    shippingAddresses!: ShippingAddressDto[] | undefined;
    /** 数据来源 */
    from!: string | undefined;
    /** 状态 */
    status!: string | undefined;

    constructor(data?: ICreateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeOuterId = _data["storeOuterId"];
            this.memberNo = _data["memberNo"];
            this.name = _data["name"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.type = _data["type"];
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of _data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
            this.from = _data["from"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["memberNo"] = this.memberNo;
        data["name"] = this.name;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["status"] = this.status;
        return data; 
    }
}

export interface ICreateMemberInput {
    storeOuterId: string | undefined;
    /** 会员内部编号 */
    memberNo: string | undefined;
    name: string;
    /** 出生年月日 */
    birthTime: moment.Moment | undefined;
    /** 性别 */
    gender: string | undefined;
    /** 身份证号 */
    idNumber: string | undefined;
    /** 会员类型 */
    type: string | undefined;
    /** 首次购买日期 */
    firstBuyTime: moment.Moment | undefined;
    /** 会员积分 */
    point: number | undefined;
    /** 会员积分倍率 */
    pointRate: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts: boolean | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    /** 注册手机号码 */
    regPhone: string | undefined;
    /** 职业 */
    career: string | undefined;
    /** 收入 */
    income: string | undefined;
    /** 收获地址集合 */
    shippingAddresses: ShippingAddressDto[] | undefined;
    /** 数据来源 */
    from: string | undefined;
    /** 状态 */
    status: string | undefined;
}

export class CreateOrderInput implements ICreateOrderInput {
    orderNO!: string;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    number!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    status!: string | undefined;
    payment!: number;
    totalFee!: number;
    discountFee!: number;
    postFee!: number;
    taxFee!: number | undefined;
    payTime!: moment.Moment | undefined;
    payType!: string | undefined;
    /** 收货地址 */
    addressId!: number | undefined;
    orderItems!: OrderItemDto[] | undefined;

    constructor(data?: ICreateOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNO = _data["orderNO"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.number = _data["number"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.payment = _data["payment"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.postFee = _data["postFee"];
            this.taxFee = _data["taxFee"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.payType = _data["payType"];
            this.addressId = _data["addressId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNO"] = this.orderNO;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["number"] = this.number;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["postFee"] = this.postFee;
        data["taxFee"] = this.taxFee;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["addressId"] = this.addressId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrderInput {
    orderNO: string;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    number: string | undefined;
    orderDateTime: moment.Moment | undefined;
    status: string | undefined;
    payment: number;
    totalFee: number;
    discountFee: number;
    postFee: number;
    taxFee: number | undefined;
    payTime: moment.Moment | undefined;
    payType: string | undefined;
    /** 收货地址 */
    addressId: number | undefined;
    orderItems: OrderItemDto[] | undefined;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: OrderTagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: OrderTagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class CustomerDto implements ICustomerDto {
    id!: number;
    creationTime!: moment.Moment;
    name!: string | undefined;
    legalPerson!: string | undefined;
    registeredCapital!: string | undefined;
    businessCode!: string | undefined;
    address!: string | undefined;
    description!: string | undefined;
    interest!: string | undefined;
    customerTags!: IdNameDto[] | undefined;
    customerSales!: IdNameDto[] | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.legalPerson = _data["legalPerson"];
            this.registeredCapital = _data["registeredCapital"];
            this.businessCode = _data["businessCode"];
            this.address = _data["address"];
            this.description = _data["description"];
            this.interest = _data["interest"];
            if (Array.isArray(_data["customerTags"])) {
                this.customerTags = [] as any;
                for (let item of _data["customerTags"])
                    this.customerTags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["customerSales"])) {
                this.customerSales = [] as any;
                for (let item of _data["customerSales"])
                    this.customerSales!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["legalPerson"] = this.legalPerson;
        data["registeredCapital"] = this.registeredCapital;
        data["businessCode"] = this.businessCode;
        data["address"] = this.address;
        data["description"] = this.description;
        data["interest"] = this.interest;
        if (Array.isArray(this.customerTags)) {
            data["customerTags"] = [];
            for (let item of this.customerTags)
                data["customerTags"].push(item.toJSON());
        }
        if (Array.isArray(this.customerSales)) {
            data["customerSales"] = [];
            for (let item of this.customerSales)
                data["customerSales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerDto {
    id: number;
    creationTime: moment.Moment;
    name: string | undefined;
    legalPerson: string | undefined;
    registeredCapital: string | undefined;
    businessCode: string | undefined;
    address: string | undefined;
    description: string | undefined;
    interest: string | undefined;
    customerTags: IdNameDto[] | undefined;
    customerSales: IdNameDto[] | undefined;
}

export class CustomerDtoPagedResultDto implements ICustomerDtoPagedResultDto {
    totalCount!: number;
    items!: CustomerDto[] | undefined;

    constructor(data?: ICustomerDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerDtoPagedResultDto {
    totalCount: number;
    items: CustomerDto[] | undefined;
}

export class Data implements IData {
    order_sn!: string | undefined;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order_sn = _data["order_sn"];
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order_sn"] = this.order_sn;
        return data; 
    }
}

export interface IData {
    order_sn: string | undefined;
}

export class DeliverOrderInput implements IDeliverOrderInput {
    orderId!: number;
    expressCompanyId!: number;
    expressNumber!: string | undefined;

    constructor(data?: IDeliverOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.expressCompanyId = _data["expressCompanyId"];
            this.expressNumber = _data["expressNumber"];
        }
    }

    static fromJS(data: any): DeliverOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeliverOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["expressCompanyId"] = this.expressCompanyId;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IDeliverOrderInput {
    orderId: number;
    expressCompanyId: number;
    expressNumber: string | undefined;
}

export class DispatchPointToMemberInput implements IDispatchPointToMemberInput {
    memberIds!: number[] | undefined;
    openIds!: string[] | undefined;
    dispatchAmount!: number;
    pointFromType!: EnumPointFromType;
    inOrOutType!: EnumInOrOutType;
    thingId!: string | undefined;
    from!: string | undefined;
    description!: string | undefined;

    constructor(data?: IDispatchPointToMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of _data["memberIds"])
                    this.memberIds!.push(item);
            }
            if (Array.isArray(_data["openIds"])) {
                this.openIds = [] as any;
                for (let item of _data["openIds"])
                    this.openIds!.push(item);
            }
            this.dispatchAmount = _data["dispatchAmount"];
            this.pointFromType = _data["pointFromType"];
            this.inOrOutType = _data["inOrOutType"];
            this.thingId = _data["thingId"];
            this.from = _data["from"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DispatchPointToMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchPointToMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        if (Array.isArray(this.openIds)) {
            data["openIds"] = [];
            for (let item of this.openIds)
                data["openIds"].push(item);
        }
        data["dispatchAmount"] = this.dispatchAmount;
        data["pointFromType"] = this.pointFromType;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["from"] = this.from;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDispatchPointToMemberInput {
    memberIds: number[] | undefined;
    openIds: string[] | undefined;
    dispatchAmount: number;
    pointFromType: EnumPointFromType;
    inOrOutType: EnumInOrOutType;
    thingId: string | undefined;
    from: string | undefined;
    description: string | undefined;
}

export class DispatchPointToMemberInput1 implements IDispatchPointToMemberInput1 {
    openId!: string | undefined;
    dispatchAmount!: number;
    pointFromType!: EnumPointFromType;
    inOrOutType!: EnumInOrOutType;
    thingId!: string | undefined;
    from!: string | undefined;
    description!: string | undefined;

    constructor(data?: IDispatchPointToMemberInput1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.dispatchAmount = _data["dispatchAmount"];
            this.pointFromType = _data["pointFromType"];
            this.inOrOutType = _data["inOrOutType"];
            this.thingId = _data["thingId"];
            this.from = _data["from"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DispatchPointToMemberInput1 {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchPointToMemberInput1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["dispatchAmount"] = this.dispatchAmount;
        data["pointFromType"] = this.pointFromType;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["from"] = this.from;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDispatchPointToMemberInput1 {
    openId: string | undefined;
    dispatchAmount: number;
    pointFromType: EnumPointFromType;
    inOrOutType: EnumInOrOutType;
    thingId: string | undefined;
    from: string | undefined;
    description: string | undefined;
}

export class DollMachine implements IDollMachine {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IDollMachine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): DollMachine {
        data = typeof data === 'object' ? data : {};
        let result = new DollMachine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IDollMachine {
    key: string[] | undefined;
    value: number[] | undefined;
}

export enum EnumInOrOutType {
    In = 0,
    Out = 1,
}

export enum EnumPointFromType {
    CashPayment = 0,
    Exchange = 1,
    Activity = 2,
    Dispatch = 3,
    ThirdParty = 4,
}

export enum EnumSnsType {
    Taobao = 0,
    WeChat = 1,
    Others = 2,
}

export class ExpressTrackingDto implements IExpressTrackingDto {
    logisticCode!: string | undefined;
    shipperCode!: string | undefined;
    companyName!: string | undefined;
    traces!: Traces[] | undefined;

    constructor(data?: IExpressTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logisticCode = _data["logisticCode"];
            this.shipperCode = _data["shipperCode"];
            this.companyName = _data["companyName"];
            if (Array.isArray(_data["traces"])) {
                this.traces = [] as any;
                for (let item of _data["traces"])
                    this.traces!.push(Traces.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExpressTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpressTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logisticCode"] = this.logisticCode;
        data["shipperCode"] = this.shipperCode;
        data["companyName"] = this.companyName;
        if (Array.isArray(this.traces)) {
            data["traces"] = [];
            for (let item of this.traces)
                data["traces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExpressTrackingDto {
    logisticCode: string | undefined;
    shipperCode: string | undefined;
    companyName: string | undefined;
    traces: Traces[] | undefined;
}

export class ExtensionOrdersDto implements IExtensionOrdersDto {
    id!: number;
    creationTime!: moment.Moment | undefined;
    from!: string | undefined;
    orderId!: number;
    printPicUrl!: string | undefined;
    /** 原始图片地址 */
    picUrl!: string | undefined;
    /** Gcode文件地址 */
    gcodeFileUrl!: string | undefined;
    printStateDescription!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;
    memberId!: number | undefined;
    memberName!: string | undefined;

    constructor(data?: IExtensionOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.from = _data["from"];
            this.orderId = _data["orderId"];
            this.printPicUrl = _data["printPicUrl"];
            this.picUrl = _data["picUrl"];
            this.gcodeFileUrl = _data["gcodeFileUrl"];
            this.printStateDescription = _data["printStateDescription"];
            this.startPrintDataTime = _data["startPrintDataTime"] ? moment(_data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = _data["endPrintDateTime"] ? moment(_data["endPrintDateTime"].toString()) : <any>undefined;
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
        }
    }

    static fromJS(data: any): ExtensionOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["from"] = this.from;
        data["orderId"] = this.orderId;
        data["printPicUrl"] = this.printPicUrl;
        data["picUrl"] = this.picUrl;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        data["printStateDescription"] = this.printStateDescription;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        return data; 
    }
}

export interface IExtensionOrdersDto {
    id: number;
    creationTime: moment.Moment | undefined;
    from: string | undefined;
    orderId: number;
    printPicUrl: string | undefined;
    /** 原始图片地址 */
    picUrl: string | undefined;
    /** Gcode文件地址 */
    gcodeFileUrl: string | undefined;
    printStateDescription: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
    memberId: number | undefined;
    memberName: string | undefined;
}

export class ExtensionOrdersDtoPagedResultDto implements IExtensionOrdersDtoPagedResultDto {
    totalCount!: number;
    items!: ExtensionOrdersDto[] | undefined;

    constructor(data?: IExtensionOrdersDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExtensionOrdersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtensionOrdersDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionOrdersDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExtensionOrdersDtoPagedResultDto {
    totalCount: number;
    items: ExtensionOrdersDto[] | undefined;
}

export class FanDto implements IFanDto {
    fanCount!: number;
    activityName!: string | undefined;

    constructor(data?: IFanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fanCount = _data["fanCount"];
            this.activityName = _data["activityName"];
        }
    }

    static fromJS(data: any): FanDto {
        data = typeof data === 'object' ? data : {};
        let result = new FanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fanCount"] = this.fanCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IFanDto {
    fanCount: number;
    activityName: string | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class GameActionEffectDto implements IGameActionEffectDto {
    cargo!: DollMachine;
    doll!: DollMachine;
    others!: DollMachine;

    constructor(data?: IGameActionEffectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cargo = _data["cargo"] ? DollMachine.fromJS(_data["cargo"]) : <any>undefined;
            this.doll = _data["doll"] ? DollMachine.fromJS(_data["doll"]) : <any>undefined;
            this.others = _data["others"] ? DollMachine.fromJS(_data["others"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GameActionEffectDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameActionEffectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargo"] = this.cargo ? this.cargo.toJSON() : <any>undefined;
        data["doll"] = this.doll ? this.doll.toJSON() : <any>undefined;
        data["others"] = this.others ? this.others.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGameActionEffectDto {
    cargo: DollMachine;
    doll: DollMachine;
    others: DollMachine;
}

export class GameRank implements IGameRank {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    score!: number;

    constructor(data?: IGameRank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headImgUrl = _data["headImgUrl"];
            this.nickName = _data["nickName"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): GameRank {
        data = typeof data === 'object' ? data : {};
        let result = new GameRank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IGameRank {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    score: number;
}

export class GameRanks implements IGameRanks {
    gameRank!: GameRank[] | undefined;
    gameName!: string | undefined;

    constructor(data?: IGameRanks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["gameRank"])) {
                this.gameRank = [] as any;
                for (let item of _data["gameRank"])
                    this.gameRank!.push(GameRank.fromJS(item));
            }
            this.gameName = _data["gameName"];
        }
    }

    static fromJS(data: any): GameRanks {
        data = typeof data === 'object' ? data : {};
        let result = new GameRanks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gameRank)) {
            data["gameRank"] = [];
            for (let item of this.gameRank)
                data["gameRank"].push(item.toJSON());
        }
        data["gameName"] = this.gameName;
        return data; 
    }
}

export interface IGameRanks {
    gameRank: GameRank[] | undefined;
    gameName: string | undefined;
}

export class GameScoreDto implements IGameScoreDto {
    gameRanks!: GameRanks[] | undefined;

    constructor(data?: IGameScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["gameRanks"])) {
                this.gameRanks = [] as any;
                for (let item of _data["gameRanks"])
                    this.gameRanks!.push(GameRanks.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gameRanks)) {
            data["gameRanks"] = [];
            for (let item of this.gameRanks)
                data["gameRanks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGameScoreDto {
    gameRanks: GameRanks[] | undefined;
}

export class GetAliPaySettingDto implements IGetAliPaySettingDto {
    appID!: string | undefined;
    parameters!: AliPayParameters;

    constructor(data?: IGetAliPaySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appID = _data["appID"];
            this.parameters = _data["parameters"] ? AliPayParameters.fromJS(_data["parameters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAliPaySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAliPaySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appID"] = this.appID;
        data["parameters"] = this.parameters ? this.parameters.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAliPaySettingDto {
    appID: string | undefined;
    parameters: AliPayParameters;
}

export class GetExpressCompaniesDto implements IGetExpressCompaniesDto {
    id!: number;
    companyName!: string | undefined;

    constructor(data?: IGetExpressCompaniesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): GetExpressCompaniesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpressCompaniesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IGetExpressCompaniesDto {
    id: number;
    companyName: string | undefined;
}

export class GetExpressCompaniesDtoPagedResultDto implements IGetExpressCompaniesDtoPagedResultDto {
    totalCount!: number;
    items!: GetExpressCompaniesDto[] | undefined;

    constructor(data?: IGetExpressCompaniesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetExpressCompaniesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetExpressCompaniesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpressCompaniesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetExpressCompaniesDtoPagedResultDto {
    totalCount: number;
    items: GetExpressCompaniesDto[] | undefined;
}

export class GetItemSalesBySkuIdInput implements IGetItemSalesBySkuIdInput {
    skuIds!: string[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IGetItemSalesBySkuIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetItemSalesBySkuIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemSalesBySkuIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetItemSalesBySkuIdInput {
    skuIds: string[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class GetItemSalesDto implements IGetItemSalesDto {
    skuId!: string | undefined;
    saleNumber!: number;
    saleAmount!: number;

    constructor(data?: IGetItemSalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.saleNumber = _data["saleNumber"];
            this.saleAmount = _data["saleAmount"];
        }
    }

    static fromJS(data: any): GetItemSalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemSalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["saleNumber"] = this.saleNumber;
        data["saleAmount"] = this.saleAmount;
        return data; 
    }
}

export interface IGetItemSalesDto {
    skuId: string | undefined;
    saleNumber: number;
    saleAmount: number;
}

export class GetMemberLevelDto implements IGetMemberLevelDto {
    id!: number;
    name!: string | undefined;
    levelKey!: string | undefined;
    condition!: number;
    discount!: number;

    constructor(data?: IGetMemberLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.levelKey = _data["levelKey"];
            this.condition = _data["condition"];
            this.discount = _data["discount"];
        }
    }

    static fromJS(data: any): GetMemberLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["levelKey"] = this.levelKey;
        data["condition"] = this.condition;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IGetMemberLevelDto {
    id: number;
    name: string | undefined;
    levelKey: string | undefined;
    condition: number;
    discount: number;
}

export class GetMemberLevelDtoPagedResultDto implements IGetMemberLevelDtoPagedResultDto {
    totalCount!: number;
    items!: GetMemberLevelDto[] | undefined;

    constructor(data?: IGetMemberLevelDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMemberLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberLevelDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberLevelDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberLevelDtoPagedResultDto {
    totalCount: number;
    items: GetMemberLevelDto[] | undefined;
}

export class GetMemberPointLogInput implements IGetMemberPointLogInput {
    inOrOutType!: EnumInOrOutType;
    pointFromType!: EnumPointFromType[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetMemberPointLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inOrOutType = _data["inOrOutType"];
            if (Array.isArray(_data["pointFromType"])) {
                this.pointFromType = [] as any;
                for (let item of _data["pointFromType"])
                    this.pointFromType!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetMemberPointLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberPointLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inOrOutType"] = this.inOrOutType;
        if (Array.isArray(this.pointFromType)) {
            data["pointFromType"] = [];
            for (let item of this.pointFromType)
                data["pointFromType"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetMemberPointLogInput {
    inOrOutType: EnumInOrOutType;
    pointFromType: EnumPointFromType[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetPayAccountDto implements IGetPayAccountDto {
    id!: number;
    appID!: string | undefined;
    from!: string | undefined;
    parameters!: any | undefined;
    name!: string | undefined;
    description!: string | undefined;
    auditStatus!: boolean;

    constructor(data?: IGetPayAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appID = _data["appID"];
            this.from = _data["from"];
            this.parameters = _data["parameters"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.auditStatus = _data["auditStatus"];
        }
    }

    static fromJS(data: any): GetPayAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appID"] = this.appID;
        data["from"] = this.from;
        data["parameters"] = this.parameters;
        data["name"] = this.name;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        return data; 
    }
}

export interface IGetPayAccountDto {
    id: number;
    appID: string | undefined;
    from: string | undefined;
    parameters: any | undefined;
    name: string | undefined;
    description: string | undefined;
    auditStatus: boolean;
}

export class GetPayAccountDtoPagedResultDto implements IGetPayAccountDtoPagedResultDto {
    totalCount!: number;
    items!: GetPayAccountDto[] | undefined;

    constructor(data?: IGetPayAccountDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPayAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPayAccountDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayAccountDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPayAccountDtoPagedResultDto {
    totalCount: number;
    items: GetPayAccountDto[] | undefined;
}

export class GetPayRecordDto implements IGetPayRecordDto {
    id!: number;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    memberId!: number | undefined;
    orderNo!: string | undefined;
    orderId!: number;
    orderFrom!: string | undefined;
    payFrom!: string | undefined;
    tradNumber!: string | undefined;
    payAccount!: string | undefined;
    payTime!: moment.Moment;
    payAmount!: number;
    payType!: PayType;

    constructor(data?: IGetPayRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.memberId = _data["memberId"];
            this.orderNo = _data["orderNo"];
            this.orderId = _data["orderId"];
            this.orderFrom = _data["orderFrom"];
            this.payFrom = _data["payFrom"];
            this.tradNumber = _data["tradNumber"];
            this.payAccount = _data["payAccount"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.payAmount = _data["payAmount"];
            this.payType = _data["payType"];
        }
    }

    static fromJS(data: any): GetPayRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["memberId"] = this.memberId;
        data["orderNo"] = this.orderNo;
        data["orderId"] = this.orderId;
        data["orderFrom"] = this.orderFrom;
        data["payFrom"] = this.payFrom;
        data["tradNumber"] = this.tradNumber;
        data["payAccount"] = this.payAccount;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["payAmount"] = this.payAmount;
        data["payType"] = this.payType;
        return data; 
    }
}

export interface IGetPayRecordDto {
    id: number;
    storeId: number | undefined;
    storeOuterId: string | undefined;
    memberId: number | undefined;
    orderNo: string | undefined;
    orderId: number;
    orderFrom: string | undefined;
    payFrom: string | undefined;
    tradNumber: string | undefined;
    payAccount: string | undefined;
    payTime: moment.Moment;
    payAmount: number;
    payType: PayType;
}

export class GetPayRecordDtoPagedResultDto implements IGetPayRecordDtoPagedResultDto {
    totalCount!: number;
    items!: GetPayRecordDto[] | undefined;

    constructor(data?: IGetPayRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPayRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPayRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPayRecordDtoPagedResultDto {
    totalCount: number;
    items: GetPayRecordDto[] | undefined;
}

export class GetPointPreOrderInput implements IGetPointPreOrderInput {
    pointOrderInfos!: SkuIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetPointPreOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pointOrderInfos"])) {
                this.pointOrderInfos = [] as any;
                for (let item of _data["pointOrderInfos"])
                    this.pointOrderInfos!.push(SkuIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPointPreOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPointPreOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pointOrderInfos)) {
            data["pointOrderInfos"] = [];
            for (let item of this.pointOrderInfos)
                data["pointOrderInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPointPreOrderInput {
    pointOrderInfos: SkuIdAndTicketIdDto[] | undefined;
}

export class GetRefundDetailDto implements IGetRefundDetailDto {
    order!: OrderDto;
    refundWay!: RefundWay;
    refundReason!: string | undefined;
    description!: string | undefined;
    creationTime!: moment.Moment;
    refundAmount!: number;
    companyName!: string | undefined;
    expressNumber!: string | undefined;
    imageUrls!: string[] | undefined;
    status!: RefundStatus;
    lastModificationTime!: moment.Moment | undefined;

    constructor(data?: IGetRefundDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"] ? OrderDto.fromJS(_data["order"]) : <any>undefined;
            this.refundWay = _data["refundWay"];
            this.refundReason = _data["refundReason"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.refundAmount = _data["refundAmount"];
            this.companyName = _data["companyName"];
            this.expressNumber = _data["expressNumber"];
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            this.status = _data["status"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRefundDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRefundDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["refundWay"] = this.refundWay;
        data["refundReason"] = this.refundReason;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["refundAmount"] = this.refundAmount;
        data["companyName"] = this.companyName;
        data["expressNumber"] = this.expressNumber;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        data["status"] = this.status;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRefundDetailDto {
    order: OrderDto;
    refundWay: RefundWay;
    refundReason: string | undefined;
    description: string | undefined;
    creationTime: moment.Moment;
    refundAmount: number;
    companyName: string | undefined;
    expressNumber: string | undefined;
    imageUrls: string[] | undefined;
    status: RefundStatus;
    lastModificationTime: moment.Moment | undefined;
}

export class GetSaleItemDetailInput implements IGetSaleItemDetailInput {
    storeIds!: number[] | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    activtyTags!: string[] | undefined;
    brandNames!: string[] | undefined;
    discounts!: string[] | undefined;
    categorys!: string[] | undefined;
    subCategorys!: string[] | undefined;
    skuId!: string | undefined;
    groupByStore!: string | undefined;
    groupByProduct!: string | undefined;
    groupByMember!: string | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetSaleItemDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["activtyTags"])) {
                this.activtyTags = [] as any;
                for (let item of _data["activtyTags"])
                    this.activtyTags!.push(item);
            }
            if (Array.isArray(_data["brandNames"])) {
                this.brandNames = [] as any;
                for (let item of _data["brandNames"])
                    this.brandNames!.push(item);
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(item);
            }
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
            if (Array.isArray(_data["subCategorys"])) {
                this.subCategorys = [] as any;
                for (let item of _data["subCategorys"])
                    this.subCategorys!.push(item);
            }
            this.skuId = _data["skuId"];
            this.groupByStore = _data["groupByStore"];
            this.groupByProduct = _data["groupByProduct"];
            this.groupByMember = _data["groupByMember"];
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetSaleItemDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSaleItemDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.activtyTags)) {
            data["activtyTags"] = [];
            for (let item of this.activtyTags)
                data["activtyTags"].push(item);
        }
        if (Array.isArray(this.brandNames)) {
            data["brandNames"] = [];
            for (let item of this.brandNames)
                data["brandNames"].push(item);
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item);
        }
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        if (Array.isArray(this.subCategorys)) {
            data["subCategorys"] = [];
            for (let item of this.subCategorys)
                data["subCategorys"].push(item);
        }
        data["skuId"] = this.skuId;
        data["groupByStore"] = this.groupByStore;
        data["groupByProduct"] = this.groupByProduct;
        data["groupByMember"] = this.groupByMember;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetSaleItemDetailInput {
    storeIds: number[] | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    activtyTags: string[] | undefined;
    brandNames: string[] | undefined;
    discounts: string[] | undefined;
    categorys: string[] | undefined;
    subCategorys: string[] | undefined;
    skuId: string | undefined;
    groupByStore: string | undefined;
    groupByProduct: string | undefined;
    groupByMember: string | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetShippingAddressDto implements IGetShippingAddressDto {
    id!: number;
    phone!: string | undefined;
    normalizeName!: string | undefined;
    zipcode!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    isDefault!: boolean;

    constructor(data?: IGetShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.phone = _data["phone"];
            this.normalizeName = _data["normalizeName"];
            this.zipcode = _data["zipcode"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.address = _data["address"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): GetShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["normalizeName"] = this.normalizeName;
        data["zipcode"] = this.zipcode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IGetShippingAddressDto {
    id: number;
    phone: string | undefined;
    normalizeName: string | undefined;
    zipcode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    isDefault: boolean;
}

export class GetShippingAddressDtoPagedResultDto implements IGetShippingAddressDtoPagedResultDto {
    totalCount!: number;
    items!: GetShippingAddressDto[] | undefined;

    constructor(data?: IGetShippingAddressDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetShippingAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetShippingAddressDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetShippingAddressDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetShippingAddressDtoPagedResultDto {
    totalCount: number;
    items: GetShippingAddressDto[] | undefined;
}

export class GetTakedTicketInfoDto implements IGetTakedTicketInfoDto {
    memberId!: number;
    ticketId!: number;
    used!: boolean;
    useTime!: moment.Moment | undefined;
    ticketNo!: string | undefined;
    actionId!: number | undefined;
    ticketInfo!: Ticket;

    constructor(data?: IGetTakedTicketInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.ticketId = _data["ticketId"];
            this.used = _data["used"];
            this.useTime = _data["useTime"] ? moment(_data["useTime"].toString()) : <any>undefined;
            this.ticketNo = _data["ticketNo"];
            this.actionId = _data["actionId"];
            this.ticketInfo = _data["ticketInfo"] ? Ticket.fromJS(_data["ticketInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTakedTicketInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTakedTicketInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["ticketId"] = this.ticketId;
        data["used"] = this.used;
        data["useTime"] = this.useTime ? this.useTime.toISOString() : <any>undefined;
        data["ticketNo"] = this.ticketNo;
        data["actionId"] = this.actionId;
        data["ticketInfo"] = this.ticketInfo ? this.ticketInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTakedTicketInfoDto {
    memberId: number;
    ticketId: number;
    used: boolean;
    useTime: moment.Moment | undefined;
    ticketNo: string | undefined;
    actionId: number | undefined;
    ticketInfo: Ticket;
}

export class GetTicketDto implements IGetTicketDto {
    id!: number;
    creationTime!: moment.Moment;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    expireTime!: moment.Moment | undefined;
    isTaked!: boolean;
    canTake!: boolean;
    description!: string | undefined;
    ticketType!: TicketType;
    takeType!: TakeType;
    value!: number;
    useCondition!: TicketUseCondition;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;
    ticketStatus!: AuditStatus;
    storeId!: number | undefined;

    constructor(data?: IGetTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.expireTime = _data["expireTime"] ? moment(_data["expireTime"].toString()) : <any>undefined;
            this.isTaked = _data["isTaked"];
            this.canTake = _data["canTake"];
            this.description = _data["description"];
            this.ticketType = _data["ticketType"];
            this.takeType = _data["takeType"];
            this.value = _data["value"];
            this.useCondition = _data["useCondition"] ? TicketUseCondition.fromJS(_data["useCondition"]) : <any>undefined;
            if (Array.isArray(_data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of _data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
            this.ticketStatus = _data["ticketStatus"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): GetTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["isTaked"] = this.isTaked;
        data["canTake"] = this.canTake;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IGetTicketDto {
    id: number;
    creationTime: moment.Moment;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    expireTime: moment.Moment | undefined;
    isTaked: boolean;
    canTake: boolean;
    description: string | undefined;
    ticketType: TicketType;
    takeType: TakeType;
    value: number;
    useCondition: TicketUseCondition;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
    ticketStatus: AuditStatus;
    storeId: number | undefined;
}

export class GetTicketDtoPagedResultDto implements IGetTicketDtoPagedResultDto {
    totalCount!: number;
    items!: GetTicketDto[] | undefined;

    constructor(data?: IGetTicketDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketDtoPagedResultDto {
    totalCount: number;
    items: GetTicketDto[] | undefined;
}

export class GetTicketMemberDto implements IGetTicketMemberDto {
    memberTicketId!: number;
    creationTime!: moment.Moment;
    used!: boolean;
    useTime!: moment.Moment | undefined;
    memberId!: number;
    wechatNickName!: string | undefined;
    openId!: string | undefined;
    storeName!: string | undefined;
    deviceId!: number | undefined;

    constructor(data?: IGetTicketMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberTicketId = _data["memberTicketId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.used = _data["used"];
            this.useTime = _data["useTime"] ? moment(_data["useTime"].toString()) : <any>undefined;
            this.memberId = _data["memberId"];
            this.wechatNickName = _data["wechatNickName"];
            this.openId = _data["openId"];
            this.storeName = _data["storeName"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): GetTicketMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberTicketId"] = this.memberTicketId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["used"] = this.used;
        data["useTime"] = this.useTime ? this.useTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["wechatNickName"] = this.wechatNickName;
        data["openId"] = this.openId;
        data["storeName"] = this.storeName;
        data["deviceId"] = this.deviceId;
        return data; 
    }
}

export interface IGetTicketMemberDto {
    memberTicketId: number;
    creationTime: moment.Moment;
    used: boolean;
    useTime: moment.Moment | undefined;
    memberId: number;
    wechatNickName: string | undefined;
    openId: string | undefined;
    storeName: string | undefined;
    deviceId: number | undefined;
}

export class GetTicketMemberDtoPagedResultDto implements IGetTicketMemberDtoPagedResultDto {
    totalCount!: number;
    items!: GetTicketMemberDto[] | undefined;

    constructor(data?: IGetTicketMemberDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTicketMemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketMemberDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketMemberDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketMemberDtoPagedResultDto {
    totalCount: number;
    items: GetTicketMemberDto[] | undefined;
}

export class GetTicketsByTagAndCategoryInput implements IGetTicketsByTagAndCategoryInput {
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: IGetTicketsByTagAndCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTicketsByTagAndCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsByTagAndCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface IGetTicketsByTagAndCategoryInput {
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class GetTicketsForOrderInput implements IGetTicketsForOrderInput {
    ticketInfos!: ProductIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetTicketsForOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketInfos"])) {
                this.ticketInfos = [] as any;
                for (let item of _data["ticketInfos"])
                    this.ticketInfos!.push(ProductIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketsForOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsForOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketInfos)) {
            data["ticketInfos"] = [];
            for (let item of this.ticketInfos)
                data["ticketInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketsForOrderInput {
    ticketInfos: ProductIdAndTicketIdDto[] | undefined;
}

export class GetTicketsInput implements IGetTicketsInput {
    ticketInfos!: SkuIdAndTicketIdDto[] | undefined;

    constructor(data?: IGetTicketsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketInfos"])) {
                this.ticketInfos = [] as any;
                for (let item of _data["ticketInfos"])
                    this.ticketInfos!.push(SkuIdAndTicketIdDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketInfos)) {
            data["ticketInfos"] = [];
            for (let item of this.ticketInfos)
                data["ticketInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTicketsInput {
    ticketInfos: SkuIdAndTicketIdDto[] | undefined;
}

export class GrantTicketByMemberLevelsInput implements IGrantTicketByMemberLevelsInput {
    ticketIds!: number[] | undefined;
    memberLevels!: string[] | undefined;

    constructor(data?: IGrantTicketByMemberLevelsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of _data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            if (Array.isArray(_data["memberLevels"])) {
                this.memberLevels = [] as any;
                for (let item of _data["memberLevels"])
                    this.memberLevels!.push(item);
            }
        }
    }

    static fromJS(data: any): GrantTicketByMemberLevelsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantTicketByMemberLevelsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        if (Array.isArray(this.memberLevels)) {
            data["memberLevels"] = [];
            for (let item of this.memberLevels)
                data["memberLevels"].push(item);
        }
        return data; 
    }
}

export interface IGrantTicketByMemberLevelsInput {
    ticketIds: number[] | undefined;
    memberLevels: string[] | undefined;
}

export class GrantTicketByTagsInput implements IGrantTicketByTagsInput {
    ticketIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IGrantTicketByTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of _data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GrantTicketByTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantTicketByTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IGrantTicketByTagsInput {
    ticketIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class GuestChartDto implements IGuestChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number;
    yesterday!: number;

    constructor(data?: IGuestChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.today = _data["today"];
            this.yesterday = _data["yesterday"];
        }
    }

    static fromJS(data: any): GuestChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuestChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

export interface IGuestChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number;
    yesterday: number;
}

export class GuestChartDto1 implements IGuestChartDto1 {
    key!: string[] | undefined;
    value!: number[] | undefined;
    total!: number;

    constructor(data?: IGuestChartDto1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GuestChartDto1 {
        data = typeof data === 'object' ? data : {};
        let result = new GuestChartDto1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IGuestChartDto1 {
    key: string[] | undefined;
    value: number[] | undefined;
    total: number;
}

export class IdNameDto implements IIdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class InteractiveDto implements IInteractiveDto {
    interactiveCount!: number;
    activityName!: string | undefined;

    constructor(data?: IInteractiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interactiveCount = _data["interactiveCount"];
            this.activityName = _data["activityName"];
        }
    }

    static fromJS(data: any): InteractiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interactiveCount"] = this.interactiveCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IInteractiveDto {
    interactiveCount: number;
    activityName: string | undefined;
}

export class InteractiveShareAndFansDto implements IInteractiveShareAndFansDto {
    interactives!: InteractiveDto[] | undefined;
    totalInteractives!: number;
    shares!: ShareDto[] | undefined;
    totalShares!: number;
    fans!: FanDto[] | undefined;
    totalFans!: number;

    constructor(data?: IInteractiveShareAndFansDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["interactives"])) {
                this.interactives = [] as any;
                for (let item of _data["interactives"])
                    this.interactives!.push(InteractiveDto.fromJS(item));
            }
            this.totalInteractives = _data["totalInteractives"];
            if (Array.isArray(_data["shares"])) {
                this.shares = [] as any;
                for (let item of _data["shares"])
                    this.shares!.push(ShareDto.fromJS(item));
            }
            this.totalShares = _data["totalShares"];
            if (Array.isArray(_data["fans"])) {
                this.fans = [] as any;
                for (let item of _data["fans"])
                    this.fans!.push(FanDto.fromJS(item));
            }
            this.totalFans = _data["totalFans"];
        }
    }

    static fromJS(data: any): InteractiveShareAndFansDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveShareAndFansDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.interactives)) {
            data["interactives"] = [];
            for (let item of this.interactives)
                data["interactives"].push(item.toJSON());
        }
        data["totalInteractives"] = this.totalInteractives;
        if (Array.isArray(this.shares)) {
            data["shares"] = [];
            for (let item of this.shares)
                data["shares"].push(item.toJSON());
        }
        data["totalShares"] = this.totalShares;
        if (Array.isArray(this.fans)) {
            data["fans"] = [];
            for (let item of this.fans)
                data["fans"].push(item.toJSON());
        }
        data["totalFans"] = this.totalFans;
        return data; 
    }
}

export interface IInteractiveShareAndFansDto {
    interactives: InteractiveDto[] | undefined;
    totalInteractives: number;
    shares: ShareDto[] | undefined;
    totalShares: number;
    fans: FanDto[] | undefined;
    totalFans: number;
}

export class IntValueNameDto implements IIntValueNameDto {
    value!: number;
    name!: string | undefined;

    constructor(data?: IIntValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IntValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIntValueNameDto {
    value: number;
    name: string | undefined;
}

export class LastSalesChartDto implements ILastSalesChartDto {
    sales!: ValueNamePicUrlDto[] | undefined;

    constructor(data?: ILastSalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sales"])) {
                this.sales = [] as any;
                for (let item of _data["sales"])
                    this.sales!.push(ValueNamePicUrlDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LastSalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new LastSalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILastSalesChartDto {
    sales: ValueNamePicUrlDto[] | undefined;
}

export class MainChartDto implements IMainChartDto {
    order!: number;
    ticket!: GuestChartDto1;
    voucher!: number;
    today!: number;
    yesterday!: number;
    week!: number;
    lastWeek!: number;
    month!: number;
    lastMonth!: number;

    constructor(data?: IMainChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            this.ticket = _data["ticket"] ? GuestChartDto1.fromJS(_data["ticket"]) : <any>undefined;
            this.voucher = _data["voucher"];
            this.today = _data["today"];
            this.yesterday = _data["yesterday"];
            this.week = _data["week"];
            this.lastWeek = _data["lastWeek"];
            this.month = _data["month"];
            this.lastMonth = _data["lastMonth"];
        }
    }

    static fromJS(data: any): MainChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["voucher"] = this.voucher;
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        data["week"] = this.week;
        data["lastWeek"] = this.lastWeek;
        data["month"] = this.month;
        data["lastMonth"] = this.lastMonth;
        return data; 
    }
}

export interface IMainChartDto {
    order: number;
    ticket: GuestChartDto1;
    voucher: number;
    today: number;
    yesterday: number;
    week: number;
    lastWeek: number;
    month: number;
    lastMonth: number;
}

export class Member implements IMember {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    memberNo!: string | undefined;
    outerId!: string | undefined;
    openId!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;
    storeId!: number | undefined;
    deviceId!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    registerdTime!: moment.Moment;
    firstBuyTime!: moment.Moment | undefined;
    point!: number;
    pointRate!: string | undefined;
    canExchangeGifts!: boolean | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    snsNickName!: string | undefined;
    snsPlatformType!: string | undefined;
    faceUrl!: string | undefined;
    weChatNickName!: string | undefined;
    regPhone!: string;
    career!: string | undefined;
    income!: string | undefined;
    shippingAddresses!: ShippingAddress[] | undefined;
    from!: string | undefined;
    orders!: Order[] | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.memberNo = _data["memberNo"];
            this.outerId = _data["outerId"];
            this.openId = _data["openId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.registerdTime = _data["registerdTime"] ? moment(_data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.snsNickName = _data["snsNickName"];
            this.snsPlatformType = _data["snsPlatformType"];
            this.faceUrl = _data["faceUrl"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of _data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddress.fromJS(item));
            }
            this.from = _data["from"];
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            this.extraInfo1 = _data["extraInfo1"];
            this.extraInfo2 = _data["extraInfo2"];
            this.extraInfo3 = _data["extraInfo3"];
            this.extraInfoX = _data["extraInfoX"];
            this.status = _data["status"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["memberNo"] = this.memberNo;
        data["outerId"] = this.outerId;
        data["openId"] = this.openId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["snsNickName"] = this.snsNickName;
        data["snsPlatformType"] = this.snsPlatformType;
        data["faceUrl"] = this.faceUrl;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMember {
    tenantId: number;
    organizationUnitId: number | undefined;
    memberNo: string | undefined;
    outerId: string | undefined;
    openId: string | undefined;
    name: string | undefined;
    type: string | undefined;
    storeId: number | undefined;
    deviceId: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    registerdTime: moment.Moment;
    firstBuyTime: moment.Moment | undefined;
    point: number;
    pointRate: string | undefined;
    canExchangeGifts: boolean | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    snsNickName: string | undefined;
    snsPlatformType: string | undefined;
    faceUrl: string | undefined;
    weChatNickName: string | undefined;
    regPhone: string;
    career: string | undefined;
    income: string | undefined;
    shippingAddresses: ShippingAddress[] | undefined;
    from: string | undefined;
    orders: Order[] | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MemberChartDto implements IMemberChartDto {
    actionNumber!: number[] | undefined;
    newNumber!: number[] | undefined;
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IMemberChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actionNumber"])) {
                this.actionNumber = [] as any;
                for (let item of _data["actionNumber"])
                    this.actionNumber!.push(item);
            }
            if (Array.isArray(_data["newNumber"])) {
                this.newNumber = [] as any;
                for (let item of _data["newNumber"])
                    this.newNumber!.push(item);
            }
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): MemberChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actionNumber)) {
            data["actionNumber"] = [];
            for (let item of this.actionNumber)
                data["actionNumber"].push(item);
        }
        if (Array.isArray(this.newNumber)) {
            data["newNumber"] = [];
            for (let item of this.newNumber)
                data["newNumber"].push(item);
        }
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IMemberChartDto {
    actionNumber: number[] | undefined;
    newNumber: number[] | undefined;
    key: string[] | undefined;
    value: number[] | undefined;
}

export class MemberCostInput implements IMemberCostInput {
    memberName!: string | undefined;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    type!: string | undefined;
    storeId!: number | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IMemberCostInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberName = _data["memberName"];
            this.orderDateTimeStart = _data["orderDateTimeStart"] ? moment(_data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = _data["orderDateTimeEnd"] ? moment(_data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.storeId = _data["storeId"];
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): MemberCostInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCostInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberName"] = this.memberName;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IMemberCostInput {
    memberName: string | undefined;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    type: string | undefined;
    storeId: number | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class MemberCostListDto implements IMemberCostListDto {
    memberId!: number;
    amount!: number;
    memberNo!: string | undefined;
    registerdTime!: moment.Moment;
    type!: string | undefined;
    snsNickName!: string | undefined;
    name!: string | undefined;
    gender!: string | undefined;
    regPhone!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;

    constructor(data?: IMemberCostListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.amount = _data["amount"];
            this.memberNo = _data["memberNo"];
            this.registerdTime = _data["registerdTime"] ? moment(_data["registerdTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.snsNickName = _data["snsNickName"];
            this.name = _data["name"];
            this.gender = _data["gender"];
            this.regPhone = _data["regPhone"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): MemberCostListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCostListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["amount"] = this.amount;
        data["memberNo"] = this.memberNo;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["snsNickName"] = this.snsNickName;
        data["name"] = this.name;
        data["gender"] = this.gender;
        data["regPhone"] = this.regPhone;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        return data; 
    }
}

export interface IMemberCostListDto {
    memberId: number;
    amount: number;
    memberNo: string | undefined;
    registerdTime: moment.Moment;
    type: string | undefined;
    snsNickName: string | undefined;
    name: string | undefined;
    gender: string | undefined;
    regPhone: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
}

export class MemberCostListDtoPagedResultDto implements IMemberCostListDtoPagedResultDto {
    totalCount!: number;
    items!: MemberCostListDto[] | undefined;

    constructor(data?: IMemberCostListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberCostListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberCostListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCostListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberCostListDtoPagedResultDto {
    totalCount: number;
    items: MemberCostListDto[] | undefined;
}

export class MemberDaySkusDto implements IMemberDaySkusDto {
    memberId!: number;
    date!: moment.Moment;
    skuId!: string | undefined;
    skuName!: string | undefined;
    number!: number;

    constructor(data?: IMemberDaySkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.skuId = _data["skuId"];
            this.skuName = _data["skuName"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): MemberDaySkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDaySkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["skuId"] = this.skuId;
        data["skuName"] = this.skuName;
        data["number"] = this.number;
        return data; 
    }
}

export interface IMemberDaySkusDto {
    memberId: number;
    date: moment.Moment;
    skuId: string | undefined;
    skuName: string | undefined;
    number: number;
}

export class MemberDaySkusDtoPagedResultDto implements IMemberDaySkusDtoPagedResultDto {
    totalCount!: number;
    items!: MemberDaySkusDto[] | undefined;

    constructor(data?: IMemberDaySkusDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberDaySkusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberDaySkusDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDaySkusDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberDaySkusDtoPagedResultDto {
    totalCount: number;
    items: MemberDaySkusDto[] | undefined;
}

export class MemberDaySkusInput implements IMemberDaySkusInput {
    memberId!: number;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IMemberDaySkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.orderDateTimeStart = _data["orderDateTimeStart"] ? moment(_data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = _data["orderDateTimeEnd"] ? moment(_data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): MemberDaySkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDaySkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IMemberDaySkusInput {
    memberId: number;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class MemberDto implements IMemberDto {
    /** 会员内部编号 */
    memberNo!: string | undefined;
    /** 出生年月日 */
    birthTime!: moment.Moment | undefined;
    /** 性别 */
    gender!: string | undefined;
    /** 身份证号 */
    idNumber!: string | undefined;
    id!: number;
    /** 所属Tenant. */
    tenantId!: number;
    /** 所属OU */
    organizationUnitId!: number | undefined;
    /** 外部会员编码 */
    outerId!: string | undefined;
    name!: string | undefined;
    /** 会员类型 */
    type!: string | undefined;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    /** 所属店铺编号 */
    storeOuterId!: string | undefined;
    /** 所属店铺名称 */
    storeName!: string | undefined;
    /** 注册时间 */
    registerdTime!: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime!: moment.Moment | undefined;
    /** 会员积分 */
    point!: number;
    /** 会员积分倍率 */
    pointRate!: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts!: boolean | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string | undefined;
    /** 职业 */
    career!: string | undefined;
    /** 收入 */
    income!: string | undefined;
    /** 收获地址集合 */
    shippingAddresses!: ShippingAddressDto[] | undefined;
    /** 数据来源 */
    from!: string | undefined;
    orders!: OrderDto[] | undefined;
    memberTags!: IdNameDto[] | undefined;
    /** 状态 */
    status!: string | undefined;
    canCreditPay!: boolean;
    snsUserInfo!: SnsUserInfoDto;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.registerdTime = _data["registerdTime"] ? moment(_data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of _data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
            this.from = _data["from"];
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
            if (Array.isArray(_data["memberTags"])) {
                this.memberTags = [] as any;
                for (let item of _data["memberTags"])
                    this.memberTags!.push(IdNameDto.fromJS(item));
            }
            this.status = _data["status"];
            this.canCreditPay = _data["canCreditPay"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoDto.fromJS(_data["snsUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        data["from"] = this.from;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.memberTags)) {
            data["memberTags"] = [];
            for (let item of this.memberTags)
                data["memberTags"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["canCreditPay"] = this.canCreditPay;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberDto {
    /** 会员内部编号 */
    memberNo: string | undefined;
    /** 出生年月日 */
    birthTime: moment.Moment | undefined;
    /** 性别 */
    gender: string | undefined;
    /** 身份证号 */
    idNumber: string | undefined;
    id: number;
    /** 所属Tenant. */
    tenantId: number;
    /** 所属OU */
    organizationUnitId: number | undefined;
    /** 外部会员编码 */
    outerId: string | undefined;
    name: string | undefined;
    /** 会员类型 */
    type: string | undefined;
    /** 所属店铺编号 */
    storeId: string | undefined;
    /** 所属店铺编号 */
    storeOuterId: string | undefined;
    /** 所属店铺名称 */
    storeName: string | undefined;
    /** 注册时间 */
    registerdTime: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime: moment.Moment | undefined;
    /** 会员积分 */
    point: number;
    /** 会员积分倍率 */
    pointRate: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts: boolean | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    /** 注册手机号码 */
    regPhone: string | undefined;
    /** 职业 */
    career: string | undefined;
    /** 收入 */
    income: string | undefined;
    /** 收获地址集合 */
    shippingAddresses: ShippingAddressDto[] | undefined;
    /** 数据来源 */
    from: string | undefined;
    orders: OrderDto[] | undefined;
    memberTags: IdNameDto[] | undefined;
    /** 状态 */
    status: string | undefined;
    canCreditPay: boolean;
    snsUserInfo: SnsUserInfoDto;
}

export class MemberDtoPagedResultDto implements IMemberDtoPagedResultDto {
    totalCount!: number;
    items!: MemberDto[] | undefined;

    constructor(data?: IMemberDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberDtoPagedResultDto {
    totalCount: number;
    items: MemberDto[] | undefined;
}

export class MemberInput implements IMemberInput {
    tenantId!: number;
    openId!: string | undefined;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    deviceId!: number | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    name!: string | undefined;
    age!: number;
    gender!: string | undefined;
    birthTime!: moment.Moment | undefined;
    regPhone!: string | undefined;
    faceUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.openId = _data["openId"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.weChatNickName = _data["weChatNickName"];
            this.name = _data["name"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.regPhone = _data["regPhone"];
            this.faceUrl = _data["faceUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): MemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["openId"] = this.openId;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["weChatNickName"] = this.weChatNickName;
        data["name"] = this.name;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["regPhone"] = this.regPhone;
        data["faceUrl"] = this.faceUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IMemberInput {
    tenantId: number;
    openId: string | undefined;
    /** 所属店铺编号 */
    storeId: string | undefined;
    deviceId: number | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    name: string | undefined;
    age: number;
    gender: string | undefined;
    birthTime: moment.Moment | undefined;
    regPhone: string | undefined;
    faceUrl: string | undefined;
    from: string | undefined;
}

export class MemberOuterDto implements IMemberOuterDto {
    id!: string | undefined;
    /** 会员类型 */
    type!: string | undefined;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    /** 所属店铺名称 */
    storeName!: string | undefined;
    /** 注册时间 */
    registerdTime!: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime!: moment.Moment | undefined;
    /** 会员积分 */
    point!: number;
    /** 会员积分倍率 */
    pointRate!: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts!: boolean | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string | undefined;
    /** 职业 */
    career!: string | undefined;
    /** 收入 */
    income!: string | undefined;
    /** 收获地址集合 */
    address!: ShippingAddressOuterDto[] | undefined;
    /** 数据来源 */
    from!: string | undefined;
    extraInfo1!: string | undefined;
    extraInfo2!: string | undefined;
    extraInfo3!: string | undefined;
    extraInfoX!: string | undefined;
    status!: string | undefined;

    constructor(data?: IMemberOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.registerdTime = _data["registerdTime"] ? moment(_data["registerdTime"].toString()) : <any>undefined;
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(ShippingAddressOuterDto.fromJS(item));
            }
            this.from = _data["from"];
            this.extraInfo1 = _data["extraInfo1"];
            this.extraInfo2 = _data["extraInfo2"];
            this.extraInfo3 = _data["extraInfo3"];
            this.extraInfoX = _data["extraInfoX"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MemberOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["registerdTime"] = this.registerdTime ? this.registerdTime.toISOString() : <any>undefined;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["extraInfo1"] = this.extraInfo1;
        data["extraInfo2"] = this.extraInfo2;
        data["extraInfo3"] = this.extraInfo3;
        data["extraInfoX"] = this.extraInfoX;
        data["status"] = this.status;
        return data; 
    }
}

export interface IMemberOuterDto {
    id: string | undefined;
    /** 会员类型 */
    type: string | undefined;
    /** 所属店铺编号 */
    storeId: string | undefined;
    /** 所属店铺名称 */
    storeName: string | undefined;
    /** 注册时间 */
    registerdTime: moment.Moment;
    /** 首次购买日期 */
    firstBuyTime: moment.Moment | undefined;
    /** 会员积分 */
    point: number;
    /** 会员积分倍率 */
    pointRate: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts: boolean | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    /** 注册手机号码 */
    regPhone: string | undefined;
    /** 职业 */
    career: string | undefined;
    /** 收入 */
    income: string | undefined;
    /** 收获地址集合 */
    address: ShippingAddressOuterDto[] | undefined;
    /** 数据来源 */
    from: string | undefined;
    extraInfo1: string | undefined;
    extraInfo2: string | undefined;
    extraInfo3: string | undefined;
    extraInfoX: string | undefined;
    status: string | undefined;
}

export class MemberOuterDtoPagedResultDto implements IMemberOuterDtoPagedResultDto {
    totalCount!: number;
    items!: MemberOuterDto[] | undefined;

    constructor(data?: IMemberOuterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberOuterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberOuterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberOuterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberOuterDtoPagedResultDto {
    totalCount: number;
    items: MemberOuterDto[] | undefined;
}

export class MemberPointLogDto implements IMemberPointLogDto {
    id!: number;
    creationTime!: moment.Moment;
    openId!: string | undefined;
    from!: string | undefined;
    inOrOutType!: EnumInOrOutType;
    thingId!: string | undefined;
    description!: string | undefined;
    amount!: number;
    amountBefore!: number;
    amountAfter!: number;

    constructor(data?: IMemberPointLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.openId = _data["openId"];
            this.from = _data["from"];
            this.inOrOutType = _data["inOrOutType"];
            this.thingId = _data["thingId"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.amountBefore = _data["amountBefore"];
            this.amountAfter = _data["amountAfter"];
        }
    }

    static fromJS(data: any): MemberPointLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPointLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["openId"] = this.openId;
        data["from"] = this.from;
        data["inOrOutType"] = this.inOrOutType;
        data["thingId"] = this.thingId;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["amountBefore"] = this.amountBefore;
        data["amountAfter"] = this.amountAfter;
        return data; 
    }
}

export interface IMemberPointLogDto {
    id: number;
    creationTime: moment.Moment;
    openId: string | undefined;
    from: string | undefined;
    inOrOutType: EnumInOrOutType;
    thingId: string | undefined;
    description: string | undefined;
    amount: number;
    amountBefore: number;
    amountAfter: number;
}

export class MemberPointLogDtoPagedResultDto implements IMemberPointLogDtoPagedResultDto {
    totalCount!: number;
    items!: MemberPointLogDto[] | undefined;

    constructor(data?: IMemberPointLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberPointLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberPointLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPointLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberPointLogDtoPagedResultDto {
    totalCount: number;
    items: MemberPointLogDto[] | undefined;
}

export class MembersCountInput implements IMembersCountInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IMembersCountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MembersCountInput {
        data = typeof data === 'object' ? data : {};
        let result = new MembersCountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMembersCountInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueTimeDto implements INameValueTimeDto {
    seconds!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seconds = _data["seconds"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seconds"] = this.seconds;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueTimeDto {
    seconds: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class Order implements IOrder {
    orderNO!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    outerId!: string | undefined;
    orderDateTime!: moment.Moment;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    pointPayment!: number;
    deductionAmount!: number;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    number!: string | undefined;
    status!: string | undefined;
    note!: string | undefined;
    storeId!: number | undefined;
    deviceId!: number | undefined;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    memberId!: number | undefined;
    memberOuterId!: string | undefined;
    member!: Member;
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    from!: string | undefined;
    orderItems!: OrderItem[] | undefined;
    activityId!: number | undefined;
    pickNo!: string | undefined;
    isuse!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNO = _data["orderNO"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outerId = _data["outerId"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.taxFee = _data["taxFee"];
            this.postFee = _data["postFee"];
            this.payment = _data["payment"];
            this.pointPayment = _data["pointPayment"];
            this.deductionAmount = _data["deductionAmount"];
            this.payType = _data["payType"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.refundTime = _data["refundTime"] ? moment(_data["refundTime"].toString()) : <any>undefined;
            this.consignTime = _data["consignTime"] ? moment(_data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = _data["returnsTime"] ? moment(_data["returnsTime"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.status = _data["status"];
            this.note = _data["note"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.memberId = _data["memberId"];
            this.memberOuterId = _data["memberOuterId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
            this.from = _data["from"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItem.fromJS(item));
            }
            this.activityId = _data["activityId"];
            this.pickNo = _data["pickNo"];
            this.isuse = _data["isuse"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNO"] = this.orderNO;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outerId"] = this.outerId;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["pointPayment"] = this.pointPayment;
        data["deductionAmount"] = this.deductionAmount;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["status"] = this.status;
        data["note"] = this.note;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["memberId"] = this.memberId;
        data["memberOuterId"] = this.memberOuterId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["activityId"] = this.activityId;
        data["pickNo"] = this.pickNo;
        data["isuse"] = this.isuse;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrder {
    orderNO: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    outerId: string | undefined;
    orderDateTime: moment.Moment;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    pointPayment: number;
    deductionAmount: number;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    number: string | undefined;
    status: string | undefined;
    note: string | undefined;
    storeId: number | undefined;
    deviceId: number | undefined;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    memberId: number | undefined;
    memberOuterId: string | undefined;
    member: Member;
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    from: string | undefined;
    orderItems: OrderItem[] | undefined;
    activityId: number | undefined;
    pickNo: string | undefined;
    isuse: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OrderCategoryDto implements IOrderCategoryDto {
    category!: string | undefined;
    subCategory!: string[] | undefined;

    constructor(data?: IOrderCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            if (Array.isArray(_data["subCategory"])) {
                this.subCategory = [] as any;
                for (let item of _data["subCategory"])
                    this.subCategory!.push(item);
            }
        }
    }

    static fromJS(data: any): OrderCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        if (Array.isArray(this.subCategory)) {
            data["subCategory"] = [];
            for (let item of this.subCategory)
                data["subCategory"].push(item);
        }
        return data; 
    }
}

export interface IOrderCategoryDto {
    category: string | undefined;
    subCategory: string[] | undefined;
}

export class OrderChartDto implements IOrderChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalOrderCount!: number;

    constructor(data?: IOrderChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.totalOrderCount = _data["totalOrderCount"];
        }
    }

    static fromJS(data: any): OrderChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalOrderCount"] = this.totalOrderCount;
        return data; 
    }
}

export interface IOrderChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalOrderCount: number;
}

export class OrderCountAndSalesInput implements IOrderCountAndSalesInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IOrderCountAndSalesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderCountAndSalesInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCountAndSalesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderCountAndSalesInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class OrderCountChartDto implements IOrderCountChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalOrderCount!: number;

    constructor(data?: IOrderCountChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.totalOrderCount = _data["totalOrderCount"];
        }
    }

    static fromJS(data: any): OrderCountChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCountChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalOrderCount"] = this.totalOrderCount;
        return data; 
    }
}

export interface IOrderCountChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalOrderCount: number;
}

export class OrderDeliverInfoDto implements IOrderDeliverInfoDto {
    id!: number;
    expressCompanyId!: number;
    companyName!: string | undefined;
    expressNumber!: string | undefined;

    constructor(data?: IOrderDeliverInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expressCompanyId = _data["expressCompanyId"];
            this.companyName = _data["companyName"];
            this.expressNumber = _data["expressNumber"];
        }
    }

    static fromJS(data: any): OrderDeliverInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDeliverInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expressCompanyId"] = this.expressCompanyId;
        data["companyName"] = this.companyName;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IOrderDeliverInfoDto {
    id: number;
    expressCompanyId: number;
    companyName: string | undefined;
    expressNumber: string | undefined;
}

export class OrderDto implements IOrderDto {
    id!: number;
    orderNO!: string | undefined;
    /** 所属Tenant. */
    tenantId!: number;
    organizationUnitId!: number | undefined;
    /** 店铺编号 */
    storeId!: number | undefined;
    /** 店铺外部编号 */
    storeOuterId!: string | undefined;
    /** 店铺名称 */
    storeName!: string | undefined;
    number!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    status!: string | undefined;
    payment!: number;
    totalFee!: number;
    discountFee!: number;
    postFee!: number;
    taxFee!: number;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    payType!: string | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    /** 收货地址 */
    addressId!: number | undefined;
    orderItems!: OrderItemDto[] | undefined;
    from!: string | undefined;
    note!: string | undefined;
    /** 会员名称 */
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;
    isCanPay!: boolean;
    expirePayTime!: moment.Moment | undefined;
    isCanRefund!: boolean;
    creationTime!: moment.Moment;
    memberId!: number | undefined;
    member!: MemberDto;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNO = _data["orderNO"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.number = _data["number"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.payment = _data["payment"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.postFee = _data["postFee"];
            this.taxFee = _data["taxFee"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.refundTime = _data["refundTime"] ? moment(_data["refundTime"].toString()) : <any>undefined;
            this.payType = _data["payType"];
            this.consignTime = _data["consignTime"] ? moment(_data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = _data["returnsTime"] ? moment(_data["returnsTime"].toString()) : <any>undefined;
            this.addressId = _data["addressId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemDto.fromJS(item));
            }
            this.from = _data["from"];
            this.note = _data["note"];
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
            this.isCanPay = _data["isCanPay"];
            this.expirePayTime = _data["expirePayTime"] ? moment(_data["expirePayTime"].toString()) : <any>undefined;
            this.isCanRefund = _data["isCanRefund"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? MemberDto.fromJS(_data["member"]) : <any>undefined;
            this.pointReduction = _data["pointReduction"];
            this.deductionAmount = _data["deductionAmount"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNO"] = this.orderNO;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["number"] = this.number;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["postFee"] = this.postFee;
        data["taxFee"] = this.taxFee;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["from"] = this.from;
        data["note"] = this.note;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        data["isCanPay"] = this.isCanPay;
        data["expirePayTime"] = this.expirePayTime ? this.expirePayTime.toISOString() : <any>undefined;
        data["isCanRefund"] = this.isCanRefund;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface IOrderDto {
    id: number;
    orderNO: string | undefined;
    /** 所属Tenant. */
    tenantId: number;
    organizationUnitId: number | undefined;
    /** 店铺编号 */
    storeId: number | undefined;
    /** 店铺外部编号 */
    storeOuterId: string | undefined;
    /** 店铺名称 */
    storeName: string | undefined;
    number: string | undefined;
    orderDateTime: moment.Moment | undefined;
    status: string | undefined;
    payment: number;
    totalFee: number;
    discountFee: number;
    postFee: number;
    taxFee: number;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    payType: string | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    /** 收货地址 */
    addressId: number | undefined;
    orderItems: OrderItemDto[] | undefined;
    from: string | undefined;
    note: string | undefined;
    /** 会员名称 */
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
    isCanPay: boolean;
    expirePayTime: moment.Moment | undefined;
    isCanRefund: boolean;
    creationTime: moment.Moment;
    memberId: number | undefined;
    member: MemberDto;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class OrderDtoPagedResultDto implements IOrderDtoPagedResultDto {
    totalCount!: number;
    items!: OrderDto[] | undefined;

    constructor(data?: IOrderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderDtoPagedResultDto {
    totalCount: number;
    items: OrderDto[] | undefined;
}

export class OrderDtoPagedTotalResultDto implements IOrderDtoPagedTotalResultDto {
    totalSale!: number;
    totalCount!: number;
    items!: OrderDto[] | undefined;

    constructor(data?: IOrderDtoPagedTotalResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSale = _data["totalSale"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDtoPagedTotalResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDtoPagedTotalResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderDtoPagedTotalResultDto {
    totalSale: number;
    totalCount: number;
    items: OrderDto[] | undefined;
}

export class OrderInformationDto implements IOrderInformationDto {
    memberId!: number | undefined;
    memberName!: string | undefined;
    memberNo!: string | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    orderDateTime!: moment.Moment;

    constructor(data?: IOrderInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.memberNo = _data["memberNo"];
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["memberNo"] = this.memberNo;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderInformationDto {
    memberId: number | undefined;
    memberName: string | undefined;
    memberNo: string | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    orderDateTime: moment.Moment;
}

export class OrderInformationDtoPagedResultDto implements IOrderInformationDtoPagedResultDto {
    totalCount!: number;
    items!: OrderInformationDto[] | undefined;

    constructor(data?: IOrderInformationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderInformationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderInformationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInformationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderInformationDtoPagedResultDto {
    totalCount: number;
    items: OrderInformationDto[] | undefined;
}

export class OrderInformationInput implements IOrderInformationInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IOrderInformationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): OrderInformationInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInformationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IOrderInformationInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class OrderItem implements IOrderItem {
    outerId!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    number!: number;
    totalFee!: number;
    taxFee!: number;
    discountFee!: number;
    payment!: number;
    pointPayment!: number;
    deductionAmount!: number;
    status!: string | undefined;
    orderId!: number;
    propertyValues!: string | undefined;
    productId!: number | undefined;
    order!: Order;
    brandName!: string | undefined;
    category!: string | undefined;
    subCategory!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    activityId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.discountFee = _data["discountFee"];
            this.payment = _data["payment"];
            this.pointPayment = _data["pointPayment"];
            this.deductionAmount = _data["deductionAmount"];
            this.status = _data["status"];
            this.orderId = _data["orderId"];
            this.propertyValues = _data["propertyValues"];
            this.productId = _data["productId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.brandName = _data["brandName"];
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.activityTag = _data["activityTag"];
            this.discount = _data["discount"];
            this.isSuite = _data["isSuite"];
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.activityId = _data["activityId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["discountFee"] = this.discountFee;
        data["payment"] = this.payment;
        data["pointPayment"] = this.pointPayment;
        data["deductionAmount"] = this.deductionAmount;
        data["status"] = this.status;
        data["orderId"] = this.orderId;
        data["propertyValues"] = this.propertyValues;
        data["productId"] = this.productId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["brandName"] = this.brandName;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["activityId"] = this.activityId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderItem {
    outerId: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    skuId: string | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    number: number;
    totalFee: number;
    taxFee: number;
    discountFee: number;
    payment: number;
    pointPayment: number;
    deductionAmount: number;
    status: string | undefined;
    orderId: number;
    propertyValues: string | undefined;
    productId: number | undefined;
    order: Order;
    brandName: string | undefined;
    category: string | undefined;
    subCategory: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean;
    storeId: number | undefined;
    storeOuterId: string | undefined;
    activityId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OrderItemDto implements IOrderItemDto {
    id!: number;
    /** 所属Tenant. */
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderId!: number;
    /** Sku 编号 */
    skuId!: string | undefined;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    /** 数量 */
    number!: number;
    /** 总价 */
    totalFee!: number;
    /** 税金 */
    taxFee!: number;
    /** 实付金额 */
    payment!: number;
    /** Sku状态 */
    status!: string | undefined;
    outerId!: string | undefined;
    currentSkuPropertyValues!: SkuPropertyValues[] | undefined;
    productId!: number | undefined;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderId = _data["orderId"];
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.payment = _data["payment"];
            this.status = _data["status"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(SkuPropertyValues.fromJS(item));
            }
            this.productId = _data["productId"];
            this.pointReduction = _data["pointReduction"];
            this.deductionAmount = _data["deductionAmount"];
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderId"] = this.orderId;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface IOrderItemDto {
    id: number;
    /** 所属Tenant. */
    tenantId: number;
    organizationUnitId: number | undefined;
    orderId: number;
    /** Sku 编号 */
    skuId: string | undefined;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    /** 数量 */
    number: number;
    /** 总价 */
    totalFee: number;
    /** 税金 */
    taxFee: number;
    /** 实付金额 */
    payment: number;
    /** Sku状态 */
    status: string | undefined;
    outerId: string | undefined;
    currentSkuPropertyValues: SkuPropertyValues[] | undefined;
    productId: number | undefined;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class OrderItemPagedTotalResultDto implements IOrderItemPagedTotalResultDto {
    totalSale!: number;
    totalCount!: number;
    items!: OrderItem[] | undefined;

    constructor(data?: IOrderItemPagedTotalResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSale = _data["totalSale"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderItemPagedTotalResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemPagedTotalResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderItemPagedTotalResultDto {
    totalSale: number;
    totalCount: number;
    items: OrderItem[] | undefined;
}

export class OrderOuterDto implements IOrderOuterDto {
    id!: string | undefined;
    orderDateTime!: string | undefined;
    totalFee!: number;
    discountFee!: number;
    taxFee!: number;
    postFee!: number;
    payment!: number;
    payType!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    status!: string | undefined;
    /** 所属店铺编号 */
    storeId!: string | undefined;
    /** 所属店铺名称 */
    storeName!: string | undefined;
    /** 订单数据来源 */
    from!: string | undefined;
    orderItems!: AddOrUpdateOrderItemOuterInput[] | undefined;
    /** 会员编码 */
    memberId!: number | undefined;
    /** 会员名称 */
    memberName!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    postPhone!: string | undefined;

    constructor(data?: IOrderOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderDateTime = _data["orderDateTime"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.taxFee = _data["taxFee"];
            this.postFee = _data["postFee"];
            this.payment = _data["payment"];
            this.payType = _data["payType"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.refundTime = _data["refundTime"] ? moment(_data["refundTime"].toString()) : <any>undefined;
            this.consignTime = _data["consignTime"] ? moment(_data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = _data["returnsTime"] ? moment(_data["returnsTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.from = _data["from"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(AddOrUpdateOrderItemOuterInput.fromJS(item));
            }
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.postPhone = _data["postPhone"];
        }
    }

    static fromJS(data: any): OrderOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderDateTime"] = this.orderDateTime;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["taxFee"] = this.taxFee;
        data["postFee"] = this.postFee;
        data["payment"] = this.payment;
        data["payType"] = this.payType;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["from"] = this.from;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["postPhone"] = this.postPhone;
        return data; 
    }
}

export interface IOrderOuterDto {
    id: string | undefined;
    orderDateTime: string | undefined;
    totalFee: number;
    discountFee: number;
    taxFee: number;
    postFee: number;
    payment: number;
    payType: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    status: string | undefined;
    /** 所属店铺编号 */
    storeId: string | undefined;
    /** 所属店铺名称 */
    storeName: string | undefined;
    /** 订单数据来源 */
    from: string | undefined;
    orderItems: AddOrUpdateOrderItemOuterInput[] | undefined;
    /** 会员编码 */
    memberId: number | undefined;
    /** 会员名称 */
    memberName: string | undefined;
    province: string | undefined;
    city: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    postPhone: string | undefined;
}

export class OrderOuterDtoPagedResultDto implements IOrderOuterDtoPagedResultDto {
    totalCount!: number;
    items!: OrderOuterDto[] | undefined;

    constructor(data?: IOrderOuterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderOuterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderOuterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOuterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderOuterDtoPagedResultDto {
    totalCount: number;
    items: OrderOuterDto[] | undefined;
}

export class OrderReportByActivityDto implements IOrderReportByActivityDto {
    orderItemCount!: number;
    orderItemPayment!: number;
    verificatedCount!: number;
    verificatedPayment!: number;

    constructor(data?: IOrderReportByActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderItemCount = _data["orderItemCount"];
            this.orderItemPayment = _data["orderItemPayment"];
            this.verificatedCount = _data["verificatedCount"];
            this.verificatedPayment = _data["verificatedPayment"];
        }
    }

    static fromJS(data: any): OrderReportByActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderReportByActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemCount"] = this.orderItemCount;
        data["orderItemPayment"] = this.orderItemPayment;
        data["verificatedCount"] = this.verificatedCount;
        data["verificatedPayment"] = this.verificatedPayment;
        return data; 
    }
}

export interface IOrderReportByActivityDto {
    orderItemCount: number;
    orderItemPayment: number;
    verificatedCount: number;
    verificatedPayment: number;
}

export class OrderSalesChartDto implements IOrderSalesChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    totalSale!: number;

    constructor(data?: IOrderSalesChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.totalSale = _data["totalSale"];
        }
    }

    static fromJS(data: any): OrderSalesChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSalesChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["totalSale"] = this.totalSale;
        return data; 
    }
}

export interface IOrderSalesChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    totalSale: number;
}

export class OrderSkuDto implements IOrderSkuDto {
    orderDateTime!: moment.Moment | undefined;
    /** Sku 编号 */
    skuId!: string | undefined;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    /** 数量 */
    number!: number;
    /** 总价 */
    totalFee!: number;
    /** 税金 */
    taxFee!: number;
    /** 优惠金额 */
    discountFee!: number;
    /** 实付金额 */
    payment!: number;

    constructor(data?: IOrderSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.discountFee = _data["discountFee"];
            this.payment = _data["payment"];
        }
    }

    static fromJS(data: any): OrderSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["discountFee"] = this.discountFee;
        data["payment"] = this.payment;
        return data; 
    }
}

export interface IOrderSkuDto {
    orderDateTime: moment.Moment | undefined;
    /** Sku 编号 */
    skuId: string | undefined;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    /** 数量 */
    number: number;
    /** 总价 */
    totalFee: number;
    /** 税金 */
    taxFee: number;
    /** 优惠金额 */
    discountFee: number;
    /** 实付金额 */
    payment: number;
}

export class OrderSkuDtoPagedResultDto implements IOrderSkuDtoPagedResultDto {
    totalCount!: number;
    items!: OrderSkuDto[] | undefined;

    constructor(data?: IOrderSkuDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderSkuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderSkuDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSkuDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderSkuDtoPagedResultDto {
    totalCount: number;
    items: OrderSkuDto[] | undefined;
}

export class OrderSkuInput implements IOrderSkuInput {
    memberId!: number;
    orderDateTimeStart!: moment.Moment | undefined;
    orderDateTimeEnd!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IOrderSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.orderDateTimeStart = _data["orderDateTimeStart"] ? moment(_data["orderDateTimeStart"].toString()) : <any>undefined;
            this.orderDateTimeEnd = _data["orderDateTimeEnd"] ? moment(_data["orderDateTimeEnd"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): OrderSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["orderDateTimeStart"] = this.orderDateTimeStart ? this.orderDateTimeStart.toISOString() : <any>undefined;
        data["orderDateTimeEnd"] = this.orderDateTimeEnd ? this.orderDateTimeEnd.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IOrderSkuInput {
    memberId: number;
    orderDateTimeStart: moment.Moment | undefined;
    orderDateTimeEnd: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export enum OrderTagType {
    Member = 0,
    Customer = 1,
}

export class OrderWithTotalSaleDto implements IOrderWithTotalSaleDto {
    amount!: number;
    orders!: OrderDtoPagedResultDto;

    constructor(data?: IOrderWithTotalSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.orders = _data["orders"] ? OrderDtoPagedResultDto.fromJS(_data["orders"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderWithTotalSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderWithTotalSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["orders"] = this.orders ? this.orders.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOrderWithTotalSaleDto {
    amount: number;
    orders: OrderDtoPagedResultDto;
}

export class OvoParkUserInfo implements IOvoParkUserInfo {
    data!: UserData;
    result!: string | undefined;

    constructor(data?: IOvoParkUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserData.fromJS(_data["data"]) : <any>undefined;
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): OvoParkUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OvoParkUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOvoParkUserInfo {
    data: UserData;
    result: string | undefined;
}

export enum PayType {
    Pay = 0,
    Refund = 1,
}

export class PerHourOrderChartDto implements IPerHourOrderChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number;
    yesterday!: number;

    constructor(data?: IPerHourOrderChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.today = _data["today"];
            this.yesterday = _data["yesterday"];
        }
    }

    static fromJS(data: any): PerHourOrderChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerHourOrderChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

export interface IPerHourOrderChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number;
    yesterday: number;
}

export class PointF implements IPointF {
    readonly isEmpty!: boolean;
    x!: number;
    y!: number;

    constructor(data?: IPointF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isEmpty = _data["isEmpty"];
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): PointF {
        data = typeof data === 'object' ? data : {};
        let result = new PointF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmpty"] = this.isEmpty;
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }
}

export interface IPointF {
    isEmpty: boolean;
    x: number;
    y: number;
}

export class PointLevelRegPhoneDto implements IPointLevelRegPhoneDto {
    point!: number;
    memberLevel!: string | undefined;
    regPhone!: string | undefined;
    name!: string | undefined;

    constructor(data?: IPointLevelRegPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.point = _data["point"];
            this.memberLevel = _data["memberLevel"];
            this.regPhone = _data["regPhone"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PointLevelRegPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new PointLevelRegPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["point"] = this.point;
        data["memberLevel"] = this.memberLevel;
        data["regPhone"] = this.regPhone;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPointLevelRegPhoneDto {
    point: number;
    memberLevel: string | undefined;
    regPhone: string | undefined;
    name: string | undefined;
}

export class PostSignatureTextDataInput implements IPostSignatureTextDataInput {
    text!: string | undefined;
    signatureImage!: string | undefined;
    layoutWidth!: number;
    layoutHeight!: number;
    fontSize!: number;
    drawOutline!: boolean;
    maxWidth!: number;
    maxHeight!: number;
    offsetX!: number;
    offsetY!: number;
    borderSpeed!: number;

    constructor(data?: IPostSignatureTextDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.signatureImage = _data["signatureImage"];
            this.layoutWidth = _data["layoutWidth"];
            this.layoutHeight = _data["layoutHeight"];
            this.fontSize = _data["fontSize"];
            this.drawOutline = _data["drawOutline"];
            this.maxWidth = _data["maxWidth"];
            this.maxHeight = _data["maxHeight"];
            this.offsetX = _data["offsetX"];
            this.offsetY = _data["offsetY"];
            this.borderSpeed = _data["borderSpeed"];
        }
    }

    static fromJS(data: any): PostSignatureTextDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostSignatureTextDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["signatureImage"] = this.signatureImage;
        data["layoutWidth"] = this.layoutWidth;
        data["layoutHeight"] = this.layoutHeight;
        data["fontSize"] = this.fontSize;
        data["drawOutline"] = this.drawOutline;
        data["maxWidth"] = this.maxWidth;
        data["maxHeight"] = this.maxHeight;
        data["offsetX"] = this.offsetX;
        data["offsetY"] = this.offsetY;
        data["borderSpeed"] = this.borderSpeed;
        return data; 
    }
}

export interface IPostSignatureTextDataInput {
    text: string | undefined;
    signatureImage: string | undefined;
    layoutWidth: number;
    layoutHeight: number;
    fontSize: number;
    drawOutline: boolean;
    maxWidth: number;
    maxHeight: number;
    offsetX: number;
    offsetY: number;
    borderSpeed: number;
}

export class PrintOrderAction implements IPrintOrderAction {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    dateTime!: moment.Moment | undefined;
    printState!: PrintState;

    constructor(data?: IPrintOrderAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headImgUrl = _data["headImgUrl"];
            this.nickName = _data["nickName"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
            this.printState = _data["printState"];
        }
    }

    static fromJS(data: any): PrintOrderAction {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["printState"] = this.printState;
        return data; 
    }
}

export interface IPrintOrderAction {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    dateTime: moment.Moment | undefined;
    printState: PrintState;
}

export class PrintOrderCountDto implements IPrintOrderCountDto {
    totalOrderCount!: number;
    completeOrderCount!: number;
    incompleteOrderCount!: number;
    totalPrintOrderActions!: PrintOrderAction[] | undefined;
    completePrintOrderActions!: PrintOrderAction[] | undefined;
    incompletePrintOrderActions!: PrintOrderAction[] | undefined;

    constructor(data?: IPrintOrderCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrderCount = _data["totalOrderCount"];
            this.completeOrderCount = _data["completeOrderCount"];
            this.incompleteOrderCount = _data["incompleteOrderCount"];
            if (Array.isArray(_data["totalPrintOrderActions"])) {
                this.totalPrintOrderActions = [] as any;
                for (let item of _data["totalPrintOrderActions"])
                    this.totalPrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
            if (Array.isArray(_data["completePrintOrderActions"])) {
                this.completePrintOrderActions = [] as any;
                for (let item of _data["completePrintOrderActions"])
                    this.completePrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
            if (Array.isArray(_data["incompletePrintOrderActions"])) {
                this.incompletePrintOrderActions = [] as any;
                for (let item of _data["incompletePrintOrderActions"])
                    this.incompletePrintOrderActions!.push(PrintOrderAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrintOrderCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderCount"] = this.totalOrderCount;
        data["completeOrderCount"] = this.completeOrderCount;
        data["incompleteOrderCount"] = this.incompleteOrderCount;
        if (Array.isArray(this.totalPrintOrderActions)) {
            data["totalPrintOrderActions"] = [];
            for (let item of this.totalPrintOrderActions)
                data["totalPrintOrderActions"].push(item.toJSON());
        }
        if (Array.isArray(this.completePrintOrderActions)) {
            data["completePrintOrderActions"] = [];
            for (let item of this.completePrintOrderActions)
                data["completePrintOrderActions"].push(item.toJSON());
        }
        if (Array.isArray(this.incompletePrintOrderActions)) {
            data["incompletePrintOrderActions"] = [];
            for (let item of this.incompletePrintOrderActions)
                data["incompletePrintOrderActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPrintOrderCountDto {
    totalOrderCount: number;
    completeOrderCount: number;
    incompleteOrderCount: number;
    totalPrintOrderActions: PrintOrderAction[] | undefined;
    completePrintOrderActions: PrintOrderAction[] | undefined;
    incompletePrintOrderActions: PrintOrderAction[] | undefined;
}

export class PrintOrderDto implements IPrintOrderDto {
    orderId!: number;
    printPicUrl!: string | undefined;
    /** 原始图片地址 */
    picUrl!: string | undefined;
    /** Gcode文件地址 */
    gcodeFileUrl!: string | undefined;
    printState!: PrintState;
    printStateDescription!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;

    constructor(data?: IPrintOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.printPicUrl = _data["printPicUrl"];
            this.picUrl = _data["picUrl"];
            this.gcodeFileUrl = _data["gcodeFileUrl"];
            this.printState = _data["printState"];
            this.printStateDescription = _data["printStateDescription"];
            this.startPrintDataTime = _data["startPrintDataTime"] ? moment(_data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = _data["endPrintDateTime"] ? moment(_data["endPrintDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrintOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["printPicUrl"] = this.printPicUrl;
        data["picUrl"] = this.picUrl;
        data["gcodeFileUrl"] = this.gcodeFileUrl;
        data["printState"] = this.printState;
        data["printStateDescription"] = this.printStateDescription;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPrintOrderDto {
    orderId: number;
    printPicUrl: string | undefined;
    /** 原始图片地址 */
    picUrl: string | undefined;
    /** Gcode文件地址 */
    gcodeFileUrl: string | undefined;
    printState: PrintState;
    printStateDescription: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
}

export enum PrintState {
    None = 0,
    WaitingForPrint = 1,
    Printing = 2,
    Printed = 3,
    Failed = 4,
}

export class ProductChartDto implements IProductChartDto {
    sales!: SalesDto[] | undefined;
    storage!: StorageDto[] | undefined;
    totalCount!: number;
    skuCount!: number;
    totalSkuCount!: number;

    constructor(data?: IProductChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sales"])) {
                this.sales = [] as any;
                for (let item of _data["sales"])
                    this.sales!.push(SalesDto.fromJS(item));
            }
            if (Array.isArray(_data["storage"])) {
                this.storage = [] as any;
                for (let item of _data["storage"])
                    this.storage!.push(StorageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.skuCount = _data["skuCount"];
            this.totalSkuCount = _data["totalSkuCount"];
        }
    }

    static fromJS(data: any): ProductChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        if (Array.isArray(this.storage)) {
            data["storage"] = [];
            for (let item of this.storage)
                data["storage"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["skuCount"] = this.skuCount;
        data["totalSkuCount"] = this.totalSkuCount;
        return data; 
    }
}

export interface IProductChartDto {
    sales: SalesDto[] | undefined;
    storage: StorageDto[] | undefined;
    totalCount: number;
    skuCount: number;
    totalSkuCount: number;
}

export class ProductIdAndTicketIdDto implements IProductIdAndTicketIdDto {
    skuId!: number | undefined;
    number!: number | undefined;
    ticketId!: number | undefined;

    constructor(data?: IProductIdAndTicketIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.number = _data["number"];
            this.ticketId = _data["ticketId"];
        }
    }

    static fromJS(data: any): ProductIdAndTicketIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIdAndTicketIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        data["ticketId"] = this.ticketId;
        return data; 
    }
}

export interface IProductIdAndTicketIdDto {
    skuId: number | undefined;
    number: number | undefined;
    ticketId: number | undefined;
}

export class ProductSaleChartDto implements IProductSaleChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;

    constructor(data?: IProductSaleChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductSaleChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSaleChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data; 
    }
}

export interface IProductSaleChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
}

export class QueryUserByFaceDto implements IQueryUserByFaceDto {
    snsUserInfoId!: number;
    snsUserInfo!: SnsUserInfo;
    imageUrl!: string | undefined;
    vendor!: string | undefined;
    tenantId!: number;
    extensionData!: string | undefined;
    gender!: string | undefined;
    age!: number;
    happiness!: string | undefined;
    emotion!: string | undefined;
    score!: string | undefined;
    parentUserId!: number;
    groupName!: string | undefined;
    name!: string | undefined;

    constructor(data?: IQueryUserByFaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfo.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.imageUrl = _data["imageUrl"];
            this.vendor = _data["vendor"];
            this.tenantId = _data["tenantId"];
            this.extensionData = _data["extensionData"];
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.happiness = _data["happiness"];
            this.emotion = _data["emotion"];
            this.score = _data["score"];
            this.parentUserId = _data["parentUserId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): QueryUserByFaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryUserByFaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["vendor"] = this.vendor;
        data["tenantId"] = this.tenantId;
        data["extensionData"] = this.extensionData;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["happiness"] = this.happiness;
        data["emotion"] = this.emotion;
        data["score"] = this.score;
        data["parentUserId"] = this.parentUserId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        return data; 
    }
}

export interface IQueryUserByFaceDto {
    snsUserInfoId: number;
    snsUserInfo: SnsUserInfo;
    imageUrl: string | undefined;
    vendor: string | undefined;
    tenantId: number;
    extensionData: string | undefined;
    gender: string | undefined;
    age: number;
    happiness: string | undefined;
    emotion: string | undefined;
    score: string | undefined;
    parentUserId: number;
    groupName: string | undefined;
    name: string | undefined;
}

export class QueryUserByFaceInput implements IQueryUserByFaceInput {
    faceBytes!: string | undefined;
    faceUrl!: string | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;

    constructor(data?: IQueryUserByFaceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.faceBytes = _data["faceBytes"];
            this.faceUrl = _data["faceUrl"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): QueryUserByFaceInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryUserByFaceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceBytes"] = this.faceBytes;
        data["faceUrl"] = this.faceUrl;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IQueryUserByFaceInput {
    faceBytes: string | undefined;
    faceUrl: string | undefined;
    securityKey: string | undefined;
    params: string | undefined;
}

export class RefundOrderInput implements IRefundOrderInput {
    orderId!: number;
    refundWay!: RefundWay;
    refundReason!: string | undefined;
    description!: string | undefined;
    imageUrls!: string[] | undefined;
    refundAmount!: number;

    constructor(data?: IRefundOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.refundWay = _data["refundWay"];
            this.refundReason = _data["refundReason"];
            this.description = _data["description"];
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            this.refundAmount = _data["refundAmount"];
        }
    }

    static fromJS(data: any): RefundOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new RefundOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["refundWay"] = this.refundWay;
        data["refundReason"] = this.refundReason;
        data["description"] = this.description;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        data["refundAmount"] = this.refundAmount;
        return data; 
    }
}

export interface IRefundOrderInput {
    orderId: number;
    refundWay: RefundWay;
    refundReason: string | undefined;
    description: string | undefined;
    imageUrls: string[] | undefined;
    refundAmount: number;
}

export enum RefundStatus {
    Submitted = 0,
    CheckPassed = 1,
    Returned = 2,
    Delivered = 3,
    CheckRefused = 4,
}

export enum RefundWay {
    Refund = 0,
    Return = 1,
    Exchange = 2,
}

export class RefuseRefundApplyInput implements IRefuseRefundApplyInput {
    id!: number;
    refundReason!: string | undefined;

    constructor(data?: IRefuseRefundApplyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.refundReason = _data["refundReason"];
        }
    }

    static fromJS(data: any): RefuseRefundApplyInput {
        data = typeof data === 'object' ? data : {};
        let result = new RefuseRefundApplyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refundReason"] = this.refundReason;
        return data; 
    }
}

export interface IRefuseRefundApplyInput {
    id: number;
    refundReason: string | undefined;
}

export class RegisterFaceByUserDto implements IRegisterFaceByUserDto {
    gender!: string | undefined;
    age!: number;

    constructor(data?: IRegisterFaceByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): RegisterFaceByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterFaceByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["age"] = this.age;
        return data; 
    }
}

export interface IRegisterFaceByUserDto {
    gender: string | undefined;
    age: number;
}

export class RegisterFaceByUserInput implements IRegisterFaceByUserInput {
    openId!: string | undefined;
    snsType!: EnumSnsType;
    faceBytes!: string | undefined;
    faceUrl!: string | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;

    constructor(data?: IRegisterFaceByUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.snsType = _data["snsType"];
            this.faceBytes = _data["faceBytes"];
            this.faceUrl = _data["faceUrl"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): RegisterFaceByUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterFaceByUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["faceBytes"] = this.faceBytes;
        data["faceUrl"] = this.faceUrl;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IRegisterFaceByUserInput {
    openId: string | undefined;
    snsType: EnumSnsType;
    faceBytes: string | undefined;
    faceUrl: string | undefined;
    securityKey: string | undefined;
    params: string | undefined;
}

export class RegisterUserToWeiShopInput implements IRegisterUserToWeiShopInput {
    userName!: string | undefined;
    mobilephone!: string | undefined;

    constructor(data?: IRegisterUserToWeiShopInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.mobilephone = _data["mobilephone"];
        }
    }

    static fromJS(data: any): RegisterUserToWeiShopInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserToWeiShopInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["mobilephone"] = this.mobilephone;
        return data; 
    }
}

export interface IRegisterUserToWeiShopInput {
    userName: string | undefined;
    mobilephone: string | undefined;
}

export class ReportInput implements IReportInput {
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: IReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IReportInput {
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class RetailingReportDto implements IRetailingReportDto {
    totalOrderAndSaleDto!: TotalOrderAndSaleDto;
    orderSalesChartDto!: OrderSalesChartDto;
    productSaleChartDto!: ProductSaleChartDto;
    userActionsDto!: UserActionsDto;
    behaviorDto!: BehaviorDto;
    interactiveAndShareDto!: InteractiveShareAndFansDto;
    gameActionEffectDto!: GameActionEffectDto;
    gameScoreDto!: GameScoreDto;

    constructor(data?: IRetailingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrderAndSaleDto = _data["totalOrderAndSaleDto"] ? TotalOrderAndSaleDto.fromJS(_data["totalOrderAndSaleDto"]) : <any>undefined;
            this.orderSalesChartDto = _data["orderSalesChartDto"] ? OrderSalesChartDto.fromJS(_data["orderSalesChartDto"]) : <any>undefined;
            this.productSaleChartDto = _data["productSaleChartDto"] ? ProductSaleChartDto.fromJS(_data["productSaleChartDto"]) : <any>undefined;
            this.userActionsDto = _data["userActionsDto"] ? UserActionsDto.fromJS(_data["userActionsDto"]) : <any>undefined;
            this.behaviorDto = _data["behaviorDto"] ? BehaviorDto.fromJS(_data["behaviorDto"]) : <any>undefined;
            this.interactiveAndShareDto = _data["interactiveAndShareDto"] ? InteractiveShareAndFansDto.fromJS(_data["interactiveAndShareDto"]) : <any>undefined;
            this.gameActionEffectDto = _data["gameActionEffectDto"] ? GameActionEffectDto.fromJS(_data["gameActionEffectDto"]) : <any>undefined;
            this.gameScoreDto = _data["gameScoreDto"] ? GameScoreDto.fromJS(_data["gameScoreDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetailingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderAndSaleDto"] = this.totalOrderAndSaleDto ? this.totalOrderAndSaleDto.toJSON() : <any>undefined;
        data["orderSalesChartDto"] = this.orderSalesChartDto ? this.orderSalesChartDto.toJSON() : <any>undefined;
        data["productSaleChartDto"] = this.productSaleChartDto ? this.productSaleChartDto.toJSON() : <any>undefined;
        data["userActionsDto"] = this.userActionsDto ? this.userActionsDto.toJSON() : <any>undefined;
        data["behaviorDto"] = this.behaviorDto ? this.behaviorDto.toJSON() : <any>undefined;
        data["interactiveAndShareDto"] = this.interactiveAndShareDto ? this.interactiveAndShareDto.toJSON() : <any>undefined;
        data["gameActionEffectDto"] = this.gameActionEffectDto ? this.gameActionEffectDto.toJSON() : <any>undefined;
        data["gameScoreDto"] = this.gameScoreDto ? this.gameScoreDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRetailingReportDto {
    totalOrderAndSaleDto: TotalOrderAndSaleDto;
    orderSalesChartDto: OrderSalesChartDto;
    productSaleChartDto: ProductSaleChartDto;
    userActionsDto: UserActionsDto;
    behaviorDto: BehaviorDto;
    interactiveAndShareDto: InteractiveShareAndFansDto;
    gameActionEffectDto: GameActionEffectDto;
    gameScoreDto: GameScoreDto;
}

export class SaleReportInput implements ISaleReportInput {
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    storeIds!: number[] | undefined;
    /** mm,dd */
    type!: string | undefined;
    storeDeviceInfo!: string | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISaleReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.type = _data["type"];
            this.storeDeviceInfo = _data["storeDeviceInfo"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SaleReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["type"] = this.type;
        data["storeDeviceInfo"] = this.storeDeviceInfo;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISaleReportInput {
    startTime: moment.Moment;
    endTime: moment.Moment;
    storeIds: number[] | undefined;
    /** mm,dd */
    type: string | undefined;
    storeDeviceInfo: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class SalesCurrentDayReportDto implements ISalesCurrentDayReportDto {
    areaName!: string | undefined;
    provinceName!: string | undefined;
    cityName!: string | undefined;
    outerId!: string | undefined;
    storeName!: string | undefined;
    storeType!: string | undefined;
    deviceType!: string | undefined;
    storeStatus!: string | undefined;
    registMemberCount!: number;
    orderCount!: number;
    orderItemsCount!: number;
    sumPayment!: number;
    totalCount!: number;

    constructor(data?: ISalesCurrentDayReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaName = _data["areaName"];
            this.provinceName = _data["provinceName"];
            this.cityName = _data["cityName"];
            this.outerId = _data["outerId"];
            this.storeName = _data["storeName"];
            this.storeType = _data["storeType"];
            this.deviceType = _data["deviceType"];
            this.storeStatus = _data["storeStatus"];
            this.registMemberCount = _data["registMemberCount"];
            this.orderCount = _data["orderCount"];
            this.orderItemsCount = _data["orderItemsCount"];
            this.sumPayment = _data["sumPayment"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SalesCurrentDayReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesCurrentDayReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaName"] = this.areaName;
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["storeType"] = this.storeType;
        data["deviceType"] = this.deviceType;
        data["storeStatus"] = this.storeStatus;
        data["registMemberCount"] = this.registMemberCount;
        data["orderCount"] = this.orderCount;
        data["orderItemsCount"] = this.orderItemsCount;
        data["sumPayment"] = this.sumPayment;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface ISalesCurrentDayReportDto {
    areaName: string | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    outerId: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    deviceType: string | undefined;
    storeStatus: string | undefined;
    registMemberCount: number;
    orderCount: number;
    orderItemsCount: number;
    sumPayment: number;
    totalCount: number;
}

export class SalesCurrentDayReportDtoPagedResultDto implements ISalesCurrentDayReportDtoPagedResultDto {
    totalCount!: number;
    items!: SalesCurrentDayReportDto[] | undefined;

    constructor(data?: ISalesCurrentDayReportDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SalesCurrentDayReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesCurrentDayReportDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesCurrentDayReportDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISalesCurrentDayReportDtoPagedResultDto {
    totalCount: number;
    items: SalesCurrentDayReportDto[] | undefined;
}

export class SalesDto implements ISalesDto {
    value!: number;
    name!: string | undefined;
    picUrl!: string | undefined;
    price!: string | undefined;
    quantity!: string | undefined;
    saleCount!: number;

    constructor(data?: ISalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.saleCount = _data["saleCount"];
        }
    }

    static fromJS(data: any): SalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["saleCount"] = this.saleCount;
        return data; 
    }
}

export interface ISalesDto {
    value: number;
    name: string | undefined;
    picUrl: string | undefined;
    price: string | undefined;
    quantity: string | undefined;
    saleCount: number;
}

export class SalesItemDetailReportDto implements ISalesItemDetailReportDto {
    areaName!: string | undefined;
    provinceName!: string | undefined;
    cityName!: string | undefined;
    outerId!: string | undefined;
    storeName!: string | undefined;
    storeType!: string | undefined;
    deviceType!: string | undefined;
    storeStatus!: string | undefined;
    memberNo!: string | undefined;
    memberLevel!: string | undefined;
    orderDateTime!: moment.Moment | undefined;
    orderNO!: string | undefined;
    brandName!: string | undefined;
    skuId!: string | undefined;
    title!: string | undefined;
    category!: string | undefined;
    subCategory!: string | undefined;
    payTime!: moment.Moment | undefined;
    orderStatus!: string | undefined;
    activityTag!: string | undefined;
    discount!: string | undefined;
    isSuite!: boolean | undefined;
    number!: number;
    payment!: number;
    nullValue!: any | undefined;

    constructor(data?: ISalesItemDetailReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaName = _data["areaName"];
            this.provinceName = _data["provinceName"];
            this.cityName = _data["cityName"];
            this.outerId = _data["outerId"];
            this.storeName = _data["storeName"];
            this.storeType = _data["storeType"];
            this.deviceType = _data["deviceType"];
            this.storeStatus = _data["storeStatus"];
            this.memberNo = _data["memberNo"];
            this.memberLevel = _data["memberLevel"];
            this.orderDateTime = _data["orderDateTime"] ? moment(_data["orderDateTime"].toString()) : <any>undefined;
            this.orderNO = _data["orderNO"];
            this.brandName = _data["brandName"];
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.orderStatus = _data["orderStatus"];
            this.activityTag = _data["activityTag"];
            this.discount = _data["discount"];
            this.isSuite = _data["isSuite"];
            this.number = _data["number"];
            this.payment = _data["payment"];
            this.nullValue = _data["nullValue"];
        }
    }

    static fromJS(data: any): SalesItemDetailReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesItemDetailReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaName"] = this.areaName;
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["storeType"] = this.storeType;
        data["deviceType"] = this.deviceType;
        data["storeStatus"] = this.storeStatus;
        data["memberNo"] = this.memberNo;
        data["memberLevel"] = this.memberLevel;
        data["orderDateTime"] = this.orderDateTime ? this.orderDateTime.toISOString() : <any>undefined;
        data["orderNO"] = this.orderNO;
        data["brandName"] = this.brandName;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["orderStatus"] = this.orderStatus;
        data["activityTag"] = this.activityTag;
        data["discount"] = this.discount;
        data["isSuite"] = this.isSuite;
        data["number"] = this.number;
        data["payment"] = this.payment;
        data["nullValue"] = this.nullValue;
        return data; 
    }
}

export interface ISalesItemDetailReportDto {
    areaName: string | undefined;
    provinceName: string | undefined;
    cityName: string | undefined;
    outerId: string | undefined;
    storeName: string | undefined;
    storeType: string | undefined;
    deviceType: string | undefined;
    storeStatus: string | undefined;
    memberNo: string | undefined;
    memberLevel: string | undefined;
    orderDateTime: moment.Moment | undefined;
    orderNO: string | undefined;
    brandName: string | undefined;
    skuId: string | undefined;
    title: string | undefined;
    category: string | undefined;
    subCategory: string | undefined;
    payTime: moment.Moment | undefined;
    orderStatus: string | undefined;
    activityTag: string | undefined;
    discount: string | undefined;
    isSuite: boolean | undefined;
    number: number;
    payment: number;
    nullValue: any | undefined;
}

export class SalesItemDetailReportDtoPagedResultDto implements ISalesItemDetailReportDtoPagedResultDto {
    totalCount!: number;
    items!: SalesItemDetailReportDto[] | undefined;

    constructor(data?: ISalesItemDetailReportDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SalesItemDetailReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesItemDetailReportDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesItemDetailReportDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISalesItemDetailReportDtoPagedResultDto {
    totalCount: number;
    items: SalesItemDetailReportDto[] | undefined;
}

export class SetShopPayInput implements ISetShopPayInput {
    payAccountId!: number[] | undefined;

    constructor(data?: ISetShopPayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["payAccountId"])) {
                this.payAccountId = [] as any;
                for (let item of _data["payAccountId"])
                    this.payAccountId!.push(item);
            }
        }
    }

    static fromJS(data: any): SetShopPayInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetShopPayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.payAccountId)) {
            data["payAccountId"] = [];
            for (let item of this.payAccountId)
                data["payAccountId"].push(item);
        }
        return data; 
    }
}

export interface ISetShopPayInput {
    payAccountId: number[] | undefined;
}

export class SetTicketStatusInput implements ISetTicketStatusInput {
    ticketIds!: number[] | undefined;
    ticketStatus!: AuditStatus;

    constructor(data?: ISetTicketStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketIds"])) {
                this.ticketIds = [] as any;
                for (let item of _data["ticketIds"])
                    this.ticketIds!.push(item);
            }
            this.ticketStatus = _data["ticketStatus"];
        }
    }

    static fromJS(data: any): SetTicketStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetTicketStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketIds)) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface ISetTicketStatusInput {
    ticketIds: number[] | undefined;
    ticketStatus: AuditStatus;
}

export class ShareDto implements IShareDto {
    shareCount!: number;
    activityName!: string | undefined;

    constructor(data?: IShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shareCount = _data["shareCount"];
            this.activityName = _data["activityName"];
        }
    }

    static fromJS(data: any): ShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareCount"] = this.shareCount;
        data["activityName"] = this.activityName;
        return data; 
    }
}

export interface IShareDto {
    shareCount: number;
    activityName: string | undefined;
}

export class ShippingAddress implements IShippingAddress {
    outerId!: string | undefined;
    memberId!: number;
    member!: Member;
    phone!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    zipcode!: string | undefined;
    normalizeName!: string | undefined;
    birthTime!: moment.Moment | undefined;
    gender!: string | undefined;
    idNumber!: string | undefined;
    isDefault!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IShippingAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.memberId = _data["memberId"];
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
            this.phone = _data["phone"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.address = _data["address"];
            this.zipcode = _data["zipcode"];
            this.normalizeName = _data["normalizeName"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.isDefault = _data["isDefault"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShippingAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["memberId"] = this.memberId;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipcode"] = this.zipcode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IShippingAddress {
    outerId: string | undefined;
    memberId: number;
    member: Member;
    phone: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    zipcode: string | undefined;
    normalizeName: string | undefined;
    birthTime: moment.Moment | undefined;
    gender: string | undefined;
    idNumber: string | undefined;
    isDefault: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ShippingAddressDto implements IShippingAddressDto {
    id!: number;
    outerId!: string | undefined;
    /** 收货人手机 */
    postPhone!: string | undefined;
    /** 省 */
    province!: string | undefined;
    /** 市 */
    city!: string | undefined;
    /** 区 */
    area!: string | undefined;
    /** 详细地址 */
    adress!: string | undefined;
    /** 邮编 */
    zipCode!: string | undefined;
    /** 姓名 */
    normalizeName!: string | undefined;
    /** 出生年月日 */
    birthTime!: moment.Moment | undefined;
    /** 性别 */
    gender!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string | undefined;
    /** 身份证号 */
    idNumber!: string | undefined;
    /** 是否为默认地址 */
    isDefault!: boolean;

    constructor(data?: IShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.postPhone = _data["postPhone"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.adress = _data["adress"];
            this.zipCode = _data["zipCode"];
            this.normalizeName = _data["normalizeName"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.regPhone = _data["regPhone"];
            this.idNumber = _data["idNumber"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["postPhone"] = this.postPhone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["adress"] = this.adress;
        data["zipCode"] = this.zipCode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["regPhone"] = this.regPhone;
        data["idNumber"] = this.idNumber;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IShippingAddressDto {
    id: number;
    outerId: string | undefined;
    /** 收货人手机 */
    postPhone: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 区 */
    area: string | undefined;
    /** 详细地址 */
    adress: string | undefined;
    /** 邮编 */
    zipCode: string | undefined;
    /** 姓名 */
    normalizeName: string | undefined;
    /** 出生年月日 */
    birthTime: moment.Moment | undefined;
    /** 性别 */
    gender: string | undefined;
    /** 注册手机号码 */
    regPhone: string | undefined;
    /** 身份证号 */
    idNumber: string | undefined;
    /** 是否为默认地址 */
    isDefault: boolean;
}

export class ShippingAddressOuterDto implements IShippingAddressOuterDto {
    code!: string | undefined;
    /** 收货人手机 */
    phone!: string | undefined;
    /** 省 */
    province!: string | undefined;
    /** 市 */
    city!: string | undefined;
    /** 区 */
    area!: string | undefined;
    /** 详细地址 */
    address!: string | undefined;
    /** 邮编 */
    zipCode!: string | undefined;
    /** 姓名 */
    normalizeName!: string | undefined;
    /** 出生年月日 */
    birthTime!: moment.Moment | undefined;
    /** 性别 */
    gender!: string | undefined;
    /** 身份证号 */
    idNumber!: string | undefined;

    constructor(data?: IShippingAddressOuterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.normalizeName = _data["normalizeName"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
        }
    }

    static fromJS(data: any): ShippingAddressOuterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddressOuterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["normalizeName"] = this.normalizeName;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        return data; 
    }
}

export interface IShippingAddressOuterDto {
    code: string | undefined;
    /** 收货人手机 */
    phone: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 区 */
    area: string | undefined;
    /** 详细地址 */
    address: string | undefined;
    /** 邮编 */
    zipCode: string | undefined;
    /** 姓名 */
    normalizeName: string | undefined;
    /** 出生年月日 */
    birthTime: moment.Moment | undefined;
    /** 性别 */
    gender: string | undefined;
    /** 身份证号 */
    idNumber: string | undefined;
}

export class SimplePointOrderDto implements ISimplePointOrderDto {
    canPointPurchase!: boolean | undefined;
    reason!: string | undefined;
    totalFee!: number;
    takePoint!: number;

    constructor(data?: ISimplePointOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canPointPurchase = _data["canPointPurchase"];
            this.reason = _data["reason"];
            this.totalFee = _data["totalFee"];
            this.takePoint = _data["takePoint"];
        }
    }

    static fromJS(data: any): SimplePointOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePointOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canPointPurchase"] = this.canPointPurchase;
        data["reason"] = this.reason;
        data["totalFee"] = this.totalFee;
        data["takePoint"] = this.takePoint;
        return data; 
    }
}

export interface ISimplePointOrderDto {
    canPointPurchase: boolean | undefined;
    reason: string | undefined;
    totalFee: number;
    takePoint: number;
}

export class SimpleTicketDto implements ISimpleTicketDto {
    id!: number;
    ticketType!: TicketType;
    useCondition!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    value!: number;
    totalFee!: number | undefined;
    discountFee!: number | undefined;
    isRecommend!: boolean;
    pointReduction!: number | undefined;
    deductionAmount!: number | undefined;

    constructor(data?: ISimpleTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketType = _data["ticketType"];
            this.useCondition = _data["useCondition"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
            this.isRecommend = _data["isRecommend"];
            this.pointReduction = _data["pointReduction"];
            this.deductionAmount = _data["deductionAmount"];
        }
    }

    static fromJS(data: any): SimpleTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketType"] = this.ticketType;
        data["useCondition"] = this.useCondition;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["value"] = this.value;
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        data["isRecommend"] = this.isRecommend;
        data["pointReduction"] = this.pointReduction;
        data["deductionAmount"] = this.deductionAmount;
        return data; 
    }
}

export interface ISimpleTicketDto {
    id: number;
    ticketType: TicketType;
    useCondition: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    value: number;
    totalFee: number | undefined;
    discountFee: number | undefined;
    isRecommend: boolean;
    pointReduction: number | undefined;
    deductionAmount: number | undefined;
}

export class SimpleUserAction implements ISimpleUserAction {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    interactiveCount!: number;

    constructor(data?: ISimpleUserAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headImgUrl = _data["headImgUrl"];
            this.nickName = _data["nickName"];
            this.interactiveCount = _data["interactiveCount"];
        }
    }

    static fromJS(data: any): SimpleUserAction {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUserAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["interactiveCount"] = this.interactiveCount;
        return data; 
    }
}

export interface ISimpleUserAction {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    interactiveCount: number;
}

export class SkuDaySaleDto implements ISkuDaySaleDto {
    /** Sku 编号 */
    skuId!: string | undefined;
    date!: moment.Moment;
    saleNumber!: number;
    saleAmout!: number;

    constructor(data?: ISkuDaySaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.saleNumber = _data["saleNumber"];
            this.saleAmout = _data["saleAmout"];
        }
    }

    static fromJS(data: any): SkuDaySaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDaySaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["saleNumber"] = this.saleNumber;
        data["saleAmout"] = this.saleAmout;
        return data; 
    }
}

export interface ISkuDaySaleDto {
    /** Sku 编号 */
    skuId: string | undefined;
    date: moment.Moment;
    saleNumber: number;
    saleAmout: number;
}

export class SkuDaySaleDtoPagedResultDto implements ISkuDaySaleDtoPagedResultDto {
    totalCount!: number;
    items!: SkuDaySaleDto[] | undefined;

    constructor(data?: ISkuDaySaleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuDaySaleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuDaySaleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDaySaleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuDaySaleDtoPagedResultDto {
    totalCount: number;
    items: SkuDaySaleDto[] | undefined;
}

export class SkuDaySaleInput implements ISkuDaySaleInput {
    skuId!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    sorting!: string | undefined;
    filter!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISkuDaySaleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SkuDaySaleInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDaySaleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISkuDaySaleInput {
    skuId: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    sorting: string | undefined;
    filter: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class SkuFromBuyerInput implements ISkuFromBuyerInput {
    memberId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ISkuFromBuyerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuFromBuyerInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuFromBuyerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuFromBuyerInput {
    memberId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class SkuIdAndTicketIdDto implements ISkuIdAndTicketIdDto {
    skuId!: number | undefined;
    number!: number | undefined;

    constructor(data?: ISkuIdAndTicketIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): SkuIdAndTicketIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuIdAndTicketIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        return data; 
    }
}

export interface ISkuIdAndTicketIdDto {
    skuId: number | undefined;
    number: number | undefined;
}

export class SkuPropertyValues implements ISkuPropertyValues {
    propertyId!: number;
    propertyValueId!: number;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISkuPropertyValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyValueId = _data["propertyValueId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SkuPropertyValues {
        data = typeof data === 'object' ? data : {};
        let result = new SkuPropertyValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyValueId"] = this.propertyValueId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISkuPropertyValues {
    propertyId: number;
    propertyValueId: number;
    name: string | undefined;
    value: string | undefined;
}

export class SkuSaleListDto implements ISkuSaleListDto {
    /** Sku 编号 */
    skuId!: string | undefined;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    number!: number;
    saleAmout!: number;
    creationTime!: moment.Moment | undefined;

    constructor(data?: ISkuSaleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.saleAmout = _data["saleAmout"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuSaleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSaleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["saleAmout"] = this.saleAmout;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuSaleListDto {
    /** Sku 编号 */
    skuId: string | undefined;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    number: number;
    saleAmout: number;
    creationTime: moment.Moment | undefined;
}

export class SkuSaleListDtoPagedTotalResultDto implements ISkuSaleListDtoPagedTotalResultDto {
    totalSale!: number;
    totalCount!: number;
    items!: SkuSaleListDto[] | undefined;

    constructor(data?: ISkuSaleListDtoPagedTotalResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSale = _data["totalSale"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuSaleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuSaleListDtoPagedTotalResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSaleListDtoPagedTotalResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSale"] = this.totalSale;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuSaleListDtoPagedTotalResultDto {
    totalSale: number;
    totalCount: number;
    items: SkuSaleListDto[] | undefined;
}

export class SkuSaleListInput implements ISkuSaleListInput {
    filter!: string | undefined;
    skuName!: string | undefined;
    skuId!: string | undefined;
    storeIds!: number[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISkuSaleListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.skuName = _data["skuName"];
            this.skuId = _data["skuId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SkuSaleListInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSaleListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["skuName"] = this.skuName;
        data["skuId"] = this.skuId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISkuSaleListInput {
    filter: string | undefined;
    skuName: string | undefined;
    skuId: string | undefined;
    storeIds: number[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class SkuTicket implements ISkuTicket {
    skuId!: number;
    tickets!: GetTicketDto[] | undefined;

    constructor(data?: ISkuTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(GetTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuTicket {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuTicket {
    skuId: number;
    tickets: GetTicketDto[] | undefined;
}

export class SkuTicketDto implements ISkuTicketDto {
    skuTickets!: SkuTicket[] | undefined;
    tickets!: GetTicketDto[] | undefined;
    totalFee!: number;
    discountFee!: number;

    constructor(data?: ISkuTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuTickets"])) {
                this.skuTickets = [] as any;
                for (let item of _data["skuTickets"])
                    this.skuTickets!.push(SkuTicket.fromJS(item));
            }
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(GetTicketDto.fromJS(item));
            }
            this.totalFee = _data["totalFee"];
            this.discountFee = _data["discountFee"];
        }
    }

    static fromJS(data: any): SkuTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuTickets)) {
            data["skuTickets"] = [];
            for (let item of this.skuTickets)
                data["skuTickets"].push(item.toJSON());
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        data["totalFee"] = this.totalFee;
        data["discountFee"] = this.discountFee;
        return data; 
    }
}

export interface ISkuTicketDto {
    skuTickets: SkuTicket[] | undefined;
    tickets: GetTicketDto[] | undefined;
    totalFee: number;
    discountFee: number;
}

export class SkuTotalSalesInput implements ISkuTotalSalesInput {
    skuId!: string | undefined;
    storeId!: number | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ISkuTotalSalesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuTotalSalesInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTotalSalesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuTotalSalesInput {
    skuId: string | undefined;
    storeId: number | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class SnsUserInfo implements ISnsUserInfo {
    id!: number | undefined;
    tenantId!: number;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: EnumSnsType;
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;

    constructor(data?: ISnsUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.weixinGroupid = _data["weixinGroupid"];
            this.memberId = _data["memberId"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
        }
    }

    static fromJS(data: any): SnsUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        return data; 
    }
}

export interface ISnsUserInfo {
    id: number | undefined;
    tenantId: number;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: EnumSnsType;
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
}

export class SnsUserInfoDto implements ISnsUserInfoDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    isBecomeFans!: boolean;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: EnumSnsType;
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.isBecomeFans = _data["isBecomeFans"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
            this.memberId = _data["memberId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    isBecomeFans: boolean;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: EnumSnsType;
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number;
}

export class StorageDto implements IStorageDto {
    value!: number;
    name!: string | undefined;
    picUrl!: string | undefined;
    price!: string | undefined;
    saleCount!: number;

    constructor(data?: IStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
            this.price = _data["price"];
            this.saleCount = _data["saleCount"];
        }
    }

    static fromJS(data: any): StorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["price"] = this.price;
        data["saleCount"] = this.saleCount;
        return data; 
    }
}

export interface IStorageDto {
    value: number;
    name: string | undefined;
    picUrl: string | undefined;
    price: string | undefined;
    saleCount: number;
}

export class Stream implements IStream {
    readonly canRead!: boolean;
    readonly canSeek!: boolean;
    readonly canTimeout!: boolean;
    readonly canWrite!: boolean;
    readonly length!: number;
    position!: number;
    readTimeout!: number;
    writeTimeout!: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canTimeout = _data["canTimeout"];
            (<any>this).canWrite = _data["canWrite"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }
}

export interface IStream {
    canRead: boolean;
    canSeek: boolean;
    canTimeout: boolean;
    canWrite: boolean;
    length: number;
    position: number;
    readTimeout: number;
    writeTimeout: number;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDtoPagedResultDto implements ITagDtoPagedResultDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: ITagDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export enum TagType {
    Resource = 0,
    Device = 1,
    Product = 2,
    Ads = 3,
    Other = 4,
    Brand = 5,
    Question = 6,
    Counter = 7,
    WechatPublicMessage = 8,
}

export class TakeTicketForActivityInput implements ITakeTicketForActivityInput {
    ticket!: number;
    actionId!: number;
    securityKey!: string | undefined;
    sendMessage!: boolean | undefined;

    constructor(data?: ITakeTicketForActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticket = _data["ticket"];
            this.actionId = _data["actionId"];
            this.securityKey = _data["securityKey"];
            this.sendMessage = _data["sendMessage"];
        }
    }

    static fromJS(data: any): TakeTicketForActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketForActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["sendMessage"] = this.sendMessage;
        return data; 
    }
}

export interface ITakeTicketForActivityInput {
    ticket: number;
    actionId: number;
    securityKey: string | undefined;
    sendMessage: boolean | undefined;
}

export class TaketicketForUserInput implements ITaketicketForUserInput {
    openId!: string | undefined;
    appId!: string | undefined;
    securityKey!: string | undefined;
    memberNo!: string | undefined;
    memberType!: string | undefined;
    ticketId!: number;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;

    constructor(data?: ITaketicketForUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.appId = _data["appId"];
            this.securityKey = _data["securityKey"];
            this.memberNo = _data["memberNo"];
            this.memberType = _data["memberType"];
            this.ticketId = _data["ticketId"];
            this.nickName = _data["nickName"];
            this.headImgUrl = _data["headImgUrl"];
        }
    }

    static fromJS(data: any): TaketicketForUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new TaketicketForUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["appId"] = this.appId;
        data["securityKey"] = this.securityKey;
        data["memberNo"] = this.memberNo;
        data["memberType"] = this.memberType;
        data["ticketId"] = this.ticketId;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        return data; 
    }
}

export interface ITaketicketForUserInput {
    openId: string | undefined;
    appId: string | undefined;
    securityKey: string | undefined;
    memberNo: string | undefined;
    memberType: string | undefined;
    ticketId: number;
    nickName: string | undefined;
    headImgUrl: string | undefined;
}

export class TakeTicketRepDto implements ITakeTicketRepDto {
    id!: number;
    isSuccess!: boolean;
    memberNo!: string | undefined;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;
    operationTime!: string | undefined;
    openId!: string | undefined;
    storeId!: string | undefined;
    storename!: string | undefined;
    pickDate!: moment.Moment;
    deviceId!: number;
    deviceName!: string | undefined;
    activityId!: number;
    activityName!: string | undefined;
    activityNote!: string | undefined;
    awardName!: string | undefined;
    memberType!: string | undefined;

    constructor(data?: ITakeTicketRepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSuccess = _data["isSuccess"];
            this.memberNo = _data["memberNo"];
            this.nickName = _data["nickName"];
            this.headImgUrl = _data["headImgUrl"];
            this.operationTime = _data["operationTime"];
            this.openId = _data["openId"];
            this.storeId = _data["storeId"];
            this.storename = _data["storename"];
            this.pickDate = _data["pickDate"] ? moment(_data["pickDate"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.activityNote = _data["activityNote"];
            this.awardName = _data["awardName"];
            this.memberType = _data["memberType"];
        }
    }

    static fromJS(data: any): TakeTicketRepDto {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketRepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSuccess"] = this.isSuccess;
        data["memberNo"] = this.memberNo;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        data["operationTime"] = this.operationTime;
        data["openId"] = this.openId;
        data["storeId"] = this.storeId;
        data["storename"] = this.storename;
        data["pickDate"] = this.pickDate ? this.pickDate.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["activityNote"] = this.activityNote;
        data["awardName"] = this.awardName;
        data["memberType"] = this.memberType;
        return data; 
    }
}

export interface ITakeTicketRepDto {
    id: number;
    isSuccess: boolean;
    memberNo: string | undefined;
    nickName: string | undefined;
    headImgUrl: string | undefined;
    operationTime: string | undefined;
    openId: string | undefined;
    storeId: string | undefined;
    storename: string | undefined;
    pickDate: moment.Moment;
    deviceId: number;
    deviceName: string | undefined;
    activityId: number;
    activityName: string | undefined;
    activityNote: string | undefined;
    awardName: string | undefined;
    memberType: string | undefined;
}

export class TakeTicketRepDtoPagedResultDto implements ITakeTicketRepDtoPagedResultDto {
    totalCount!: number;
    items!: TakeTicketRepDto[] | undefined;

    constructor(data?: ITakeTicketRepDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TakeTicketRepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TakeTicketRepDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketRepDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITakeTicketRepDtoPagedResultDto {
    totalCount: number;
    items: TakeTicketRepDto[] | undefined;
}

export class TakeTicketRepInput implements ITakeTicketRepInput {
    openId!: string | undefined;
    appId!: string | undefined;
    endTime!: moment.Moment | undefined;
    startTime!: moment.Moment | undefined;
    ticktId!: number | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    isUsed!: number | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: ITakeTicketRepInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.appId = _data["appId"];
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.ticktId = _data["ticktId"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.isUsed = _data["isUsed"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TakeTicketRepInput {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketRepInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["appId"] = this.appId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["ticktId"] = this.ticktId;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["isUsed"] = this.isUsed;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface ITakeTicketRepInput {
    openId: string | undefined;
    appId: string | undefined;
    endTime: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    ticktId: number | undefined;
    deviceId: number;
    deviceName: string | undefined;
    isUsed: number | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class TakeTicketResultDto implements ITakeTicketResultDto {
    success!: boolean;
    errorMessage!: string | undefined;
    outerId!: string | undefined;
    ticketNo!: string | undefined;
    memberNo!: string | undefined;
    openId!: string | undefined;

    constructor(data?: ITakeTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.outerId = _data["outerId"];
            this.ticketNo = _data["ticketNo"];
            this.memberNo = _data["memberNo"];
            this.openId = _data["openId"];
        }
    }

    static fromJS(data: any): TakeTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TakeTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["outerId"] = this.outerId;
        data["ticketNo"] = this.ticketNo;
        data["memberNo"] = this.memberNo;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface ITakeTicketResultDto {
    success: boolean;
    errorMessage: string | undefined;
    outerId: string | undefined;
    ticketNo: string | undefined;
    memberNo: string | undefined;
    openId: string | undefined;
}

export enum TakeType {
    UserTake = 0,
    ManagerGrant = 1,
    RegisterAutoGrant = 2,
    GameAutoGrant = 3,
}

export class TemplateChartDto implements ITemplateChartDto {
    templates!: IntValueNameDto[] | undefined;
    totalCount!: number | undefined;
    title!: string | undefined;

    constructor(data?: ITemplateChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(IntValueNameDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): TemplateChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["title"] = this.title;
        return data; 
    }
}

export interface ITemplateChartDto {
    templates: IntValueNameDto[] | undefined;
    totalCount: number | undefined;
    title: string | undefined;
}

export class Ticket implements ITicket {
    tenantId!: number;
    storeId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    description!: string | undefined;
    ticketType!: TicketType;
    takeType!: TakeType;
    value!: number;
    useCondition!: string | undefined;
    takeCondition!: string | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;
    ticketStatus!: AuditStatus;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.description = _data["description"];
            this.ticketType = _data["ticketType"];
            this.takeType = _data["takeType"];
            this.value = _data["value"];
            this.useCondition = _data["useCondition"];
            this.takeCondition = _data["takeCondition"];
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
            this.ticketStatus = _data["ticketStatus"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition;
        data["takeCondition"] = this.takeCondition;
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITicket {
    tenantId: number;
    storeId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    description: string | undefined;
    ticketType: TicketType;
    takeType: TakeType;
    value: number;
    useCondition: string | undefined;
    takeCondition: string | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
    ticketStatus: AuditStatus;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TicketRep implements ITicketRep {
    area!: string | undefined;
    storeNo!: string | undefined;
    storeName!: string | undefined;
    deviceName!: string | undefined;
    schedule!: string | undefined;
    totalLeft!: string | undefined;
    newMemberToday!: number;
    oldMemberToday!: number;
    todayCount!: number;
    newMember!: number;
    oldMember!: number;
    totalCount!: number;
    avgNum!: number;

    constructor(data?: ITicketRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.storeNo = _data["storeNo"];
            this.storeName = _data["storeName"];
            this.deviceName = _data["deviceName"];
            this.schedule = _data["schedule"];
            this.totalLeft = _data["totalLeft"];
            this.newMemberToday = _data["newMemberToday"];
            this.oldMemberToday = _data["oldMemberToday"];
            this.todayCount = _data["todayCount"];
            this.newMember = _data["newMember"];
            this.oldMember = _data["oldMember"];
            this.totalCount = _data["totalCount"];
            this.avgNum = _data["avgNum"];
        }
    }

    static fromJS(data: any): TicketRep {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["storeNo"] = this.storeNo;
        data["storeName"] = this.storeName;
        data["deviceName"] = this.deviceName;
        data["schedule"] = this.schedule;
        data["totalLeft"] = this.totalLeft;
        data["newMemberToday"] = this.newMemberToday;
        data["oldMemberToday"] = this.oldMemberToday;
        data["todayCount"] = this.todayCount;
        data["newMember"] = this.newMember;
        data["oldMember"] = this.oldMember;
        data["totalCount"] = this.totalCount;
        data["avgNum"] = this.avgNum;
        return data; 
    }
}

export interface ITicketRep {
    area: string | undefined;
    storeNo: string | undefined;
    storeName: string | undefined;
    deviceName: string | undefined;
    schedule: string | undefined;
    totalLeft: string | undefined;
    newMemberToday: number;
    oldMemberToday: number;
    todayCount: number;
    newMember: number;
    oldMember: number;
    totalCount: number;
    avgNum: number;
}

export class TicketTagAndCategoryOutput implements ITicketTagAndCategoryOutput {
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketTagAndCategoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketTagAndCategoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TicketTagAndCategoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketTagAndCategoryOutput {
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export enum TicketType {
    Voucher = 0,
    Discount = 1,
}

export class TicketUseCondition implements ITicketUseCondition {
    amount!: number | undefined;
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketUseCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketUseCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUseCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketUseCondition {
    amount: number | undefined;
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class TinyFileOutput implements ITinyFileOutput {
    /** 资源创建完成后产生的 Id */
    resourceId!: number | undefined;
    fileUri!: string | undefined;
    thumbnailUri!: string | undefined;
    code!: number;
    message!: string | undefined;
    details!: string | undefined;
    validationErrors!: ValidationErrorInfo[] | undefined;

    constructor(data?: ITinyFileOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.fileUri = _data["fileUri"];
            this.thumbnailUri = _data["thumbnailUri"];
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TinyFileOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TinyFileOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["fileUri"] = this.fileUri;
        data["thumbnailUri"] = this.thumbnailUri;
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITinyFileOutput {
    /** 资源创建完成后产生的 Id */
    resourceId: number | undefined;
    fileUri: string | undefined;
    thumbnailUri: string | undefined;
    code: number;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class TopSkusInput implements ITopSkusInput {
    top!: number | undefined;
    brandId!: number | undefined;
    ouOrStoreList!: IdTypeDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;

    constructor(data?: ITopSkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.top = _data["top"];
            this.brandId = _data["brandId"];
            if (Array.isArray(_data["ouOrStoreList"])) {
                this.ouOrStoreList = [] as any;
                for (let item of _data["ouOrStoreList"])
                    this.ouOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TopSkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new TopSkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["top"] = this.top;
        data["brandId"] = this.brandId;
        if (Array.isArray(this.ouOrStoreList)) {
            data["ouOrStoreList"] = [];
            for (let item of this.ouOrStoreList)
                data["ouOrStoreList"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITopSkusInput {
    top: number | undefined;
    brandId: number | undefined;
    ouOrStoreList: IdTypeDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class TotalOrderAndSaleDto implements ITotalOrderAndSaleDto {
    orderCount!: number;
    consumerCount!: number;
    orderSales!: number;

    constructor(data?: ITotalOrderAndSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderCount = _data["orderCount"];
            this.consumerCount = _data["consumerCount"];
            this.orderSales = _data["orderSales"];
        }
    }

    static fromJS(data: any): TotalOrderAndSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalOrderAndSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCount"] = this.orderCount;
        data["consumerCount"] = this.consumerCount;
        data["orderSales"] = this.orderSales;
        return data; 
    }
}

export interface ITotalOrderAndSaleDto {
    orderCount: number;
    consumerCount: number;
    orderSales: number;
}

export class Traces implements ITraces {
    acceptTime!: moment.Moment;
    acceptStation!: string | undefined;

    constructor(data?: ITraces) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.acceptTime = _data["acceptTime"] ? moment(_data["acceptTime"].toString()) : <any>undefined;
            this.acceptStation = _data["acceptStation"];
        }
    }

    static fromJS(data: any): Traces {
        data = typeof data === 'object' ? data : {};
        let result = new Traces();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptTime"] = this.acceptTime ? this.acceptTime.toISOString() : <any>undefined;
        data["acceptStation"] = this.acceptStation;
        return data; 
    }
}

export interface ITraces {
    acceptTime: moment.Moment;
    acceptStation: string | undefined;
}

export class TrackKeyInfoDto implements ITrackKeyInfoDto {
    key!: string | undefined;
    secret!: string | undefined;
    from!: string | undefined;

    constructor(data?: ITrackKeyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.secret = _data["secret"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): TrackKeyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackKeyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["secret"] = this.secret;
        data["from"] = this.from;
        return data; 
    }
}

export interface ITrackKeyInfoDto {
    key: string | undefined;
    secret: string | undefined;
    from: string | undefined;
}

export class UpdateMemberInput implements IUpdateMemberInput {
    storeOuterId!: string | undefined;
    id!: number;
    /** 会员内部编号 */
    memberNo!: string | undefined;
    name!: string | undefined;
    /** 出生年月日 */
    birthTime!: moment.Moment | undefined;
    /** 性别 */
    gender!: string | undefined;
    /** 身份证号 */
    idNumber!: string | undefined;
    /** 会员类型 */
    type!: string | undefined;
    /** 首次购买日期 */
    firstBuyTime!: moment.Moment | undefined;
    /** 会员积分 */
    point!: number | undefined;
    /** 会员积分倍率 */
    pointRate!: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts!: boolean | undefined;
    /** 微信昵称 */
    weChatNickName!: string | undefined;
    /** 注册手机号码 */
    regPhone!: string | undefined;
    /** 职业 */
    career!: string | undefined;
    /** 收入 */
    income!: string | undefined;
    /** 收获地址集合 */
    shippingAddresses!: ShippingAddressDto[] | undefined;

    constructor(data?: IUpdateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeOuterId = _data["storeOuterId"];
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.name = _data["name"];
            this.birthTime = _data["birthTime"] ? moment(_data["birthTime"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.idNumber = _data["idNumber"];
            this.type = _data["type"];
            this.firstBuyTime = _data["firstBuyTime"] ? moment(_data["firstBuyTime"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.pointRate = _data["pointRate"];
            this.canExchangeGifts = _data["canExchangeGifts"];
            this.weChatNickName = _data["weChatNickName"];
            this.regPhone = _data["regPhone"];
            this.career = _data["career"];
            this.income = _data["income"];
            if (Array.isArray(_data["shippingAddresses"])) {
                this.shippingAddresses = [] as any;
                for (let item of _data["shippingAddresses"])
                    this.shippingAddresses!.push(ShippingAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["name"] = this.name;
        data["birthTime"] = this.birthTime ? this.birthTime.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["idNumber"] = this.idNumber;
        data["type"] = this.type;
        data["firstBuyTime"] = this.firstBuyTime ? this.firstBuyTime.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["pointRate"] = this.pointRate;
        data["canExchangeGifts"] = this.canExchangeGifts;
        data["weChatNickName"] = this.weChatNickName;
        data["regPhone"] = this.regPhone;
        data["career"] = this.career;
        data["income"] = this.income;
        if (Array.isArray(this.shippingAddresses)) {
            data["shippingAddresses"] = [];
            for (let item of this.shippingAddresses)
                data["shippingAddresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateMemberInput {
    storeOuterId: string | undefined;
    id: number;
    /** 会员内部编号 */
    memberNo: string | undefined;
    name: string | undefined;
    /** 出生年月日 */
    birthTime: moment.Moment | undefined;
    /** 性别 */
    gender: string | undefined;
    /** 身份证号 */
    idNumber: string | undefined;
    /** 会员类型 */
    type: string | undefined;
    /** 首次购买日期 */
    firstBuyTime: moment.Moment | undefined;
    /** 会员积分 */
    point: number | undefined;
    /** 会员积分倍率 */
    pointRate: string | undefined;
    /** 会员积分兑换礼活动 */
    canExchangeGifts: boolean | undefined;
    /** 微信昵称 */
    weChatNickName: string | undefined;
    /** 注册手机号码 */
    regPhone: string | undefined;
    /** 职业 */
    career: string | undefined;
    /** 收入 */
    income: string | undefined;
    /** 收获地址集合 */
    shippingAddresses: ShippingAddressDto[] | undefined;
}

export class UpdateOrderInput implements IUpdateOrderInput {
    id!: number;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    status!: string | undefined;
    payTime!: moment.Moment | undefined;
    refundTime!: moment.Moment | undefined;
    payType!: string | undefined;
    consignTime!: moment.Moment | undefined;
    returnsTime!: moment.Moment | undefined;
    /** 收货地址 */
    addressId!: number | undefined;

    constructor(data?: IUpdateOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.status = _data["status"];
            this.payTime = _data["payTime"] ? moment(_data["payTime"].toString()) : <any>undefined;
            this.refundTime = _data["refundTime"] ? moment(_data["refundTime"].toString()) : <any>undefined;
            this.payType = _data["payType"];
            this.consignTime = _data["consignTime"] ? moment(_data["consignTime"].toString()) : <any>undefined;
            this.returnsTime = _data["returnsTime"] ? moment(_data["returnsTime"].toString()) : <any>undefined;
            this.addressId = _data["addressId"];
        }
    }

    static fromJS(data: any): UpdateOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["status"] = this.status;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        data["consignTime"] = this.consignTime ? this.consignTime.toISOString() : <any>undefined;
        data["returnsTime"] = this.returnsTime ? this.returnsTime.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        return data; 
    }
}

export interface IUpdateOrderInput {
    id: number;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    status: string | undefined;
    payTime: moment.Moment | undefined;
    refundTime: moment.Moment | undefined;
    payType: string | undefined;
    consignTime: moment.Moment | undefined;
    returnsTime: moment.Moment | undefined;
    /** 收货地址 */
    addressId: number | undefined;
}

export class UpdateOrderItemInput implements IUpdateOrderItemInput {
    id!: number;
    /** Sku 编号 */
    skuId!: string | undefined;
    /** Sku名称 */
    title!: string | undefined;
    /** Sku图片地址 */
    picUrl!: string | undefined;
    /** 数量 */
    number!: number;
    /** 总价 */
    totalFee!: number | undefined;
    /** 税金 */
    taxFee!: number | undefined;
    /** 实付金额 */
    payment!: number | undefined;
    /** Sku状态 */
    status!: string | undefined;

    constructor(data?: IUpdateOrderItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.number = _data["number"];
            this.totalFee = _data["totalFee"];
            this.taxFee = _data["taxFee"];
            this.payment = _data["payment"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateOrderItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["number"] = this.number;
        data["totalFee"] = this.totalFee;
        data["taxFee"] = this.taxFee;
        data["payment"] = this.payment;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateOrderItemInput {
    id: number;
    /** Sku 编号 */
    skuId: string | undefined;
    /** Sku名称 */
    title: string | undefined;
    /** Sku图片地址 */
    picUrl: string | undefined;
    /** 数量 */
    number: number;
    /** 总价 */
    totalFee: number | undefined;
    /** 税金 */
    taxFee: number | undefined;
    /** 实付金额 */
    payment: number | undefined;
    /** Sku状态 */
    status: string | undefined;
}

export class UpdateOrderMakingInfoInput implements IUpdateOrderMakingInfoInput {
    subKey!: string;
    orderId!: number;
    printStateDescription!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    startPrintDataTime!: moment.Moment | undefined;
    endPrintDateTime!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderMakingInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.orderId = _data["orderId"];
            this.printStateDescription = _data["printStateDescription"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.startPrintDataTime = _data["startPrintDataTime"] ? moment(_data["startPrintDataTime"].toString()) : <any>undefined;
            this.endPrintDateTime = _data["endPrintDateTime"] ? moment(_data["endPrintDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderMakingInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderMakingInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["orderId"] = this.orderId;
        data["printStateDescription"] = this.printStateDescription;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["startPrintDataTime"] = this.startPrintDataTime ? this.startPrintDataTime.toISOString() : <any>undefined;
        data["endPrintDateTime"] = this.endPrintDateTime ? this.endPrintDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateOrderMakingInfoInput {
    subKey: string;
    orderId: number;
    printStateDescription: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    startPrintDataTime: moment.Moment | undefined;
    endPrintDateTime: moment.Moment | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: OrderTagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: OrderTagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class UploadExpressInput implements IUploadExpressInput {
    orderId!: number;
    expressCompanyId!: number;
    expressNumber!: string | undefined;

    constructor(data?: IUploadExpressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.expressCompanyId = _data["expressCompanyId"];
            this.expressNumber = _data["expressNumber"];
        }
    }

    static fromJS(data: any): UploadExpressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExpressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["expressCompanyId"] = this.expressCompanyId;
        data["expressNumber"] = this.expressNumber;
        return data; 
    }
}

export interface IUploadExpressInput {
    orderId: number;
    expressCompanyId: number;
    expressNumber: string | undefined;
}

export class UserActionsDto implements IUserActionsDto {
    userActions!: SimpleUserAction[] | undefined;

    constructor(data?: IUserActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userActions"])) {
                this.userActions = [] as any;
                for (let item of _data["userActions"])
                    this.userActions!.push(SimpleUserAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserActionsDto {
    userActions: SimpleUserAction[] | undefined;
}

export class UserData implements IUserData {
    useid!: string | undefined;
    username!: string | undefined;
    age!: string | undefined;
    deviceMac!: string | undefined;
    mobilephone!: string | undefined;
    gender!: string | undefined;
    memberUrl!: string | undefined;
    arriveUrl!: string | undefined;
    arriveTime!: string | undefined;
    cardNumber!: string | undefined;
    memberType!: string | undefined;
    repeatedArrivalTimes!: string | undefined;
    faceId!: string | undefined;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useid = _data["useid"];
            this.username = _data["username"];
            this.age = _data["age"];
            this.deviceMac = _data["deviceMac"];
            this.mobilephone = _data["mobilephone"];
            this.gender = _data["gender"];
            this.memberUrl = _data["memberUrl"];
            this.arriveUrl = _data["arriveUrl"];
            this.arriveTime = _data["arriveTime"];
            this.cardNumber = _data["cardNumber"];
            this.memberType = _data["memberType"];
            this.repeatedArrivalTimes = _data["repeatedArrivalTimes"];
            this.faceId = _data["faceId"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useid"] = this.useid;
        data["username"] = this.username;
        data["age"] = this.age;
        data["deviceMac"] = this.deviceMac;
        data["mobilephone"] = this.mobilephone;
        data["gender"] = this.gender;
        data["memberUrl"] = this.memberUrl;
        data["arriveUrl"] = this.arriveUrl;
        data["arriveTime"] = this.arriveTime;
        data["cardNumber"] = this.cardNumber;
        data["memberType"] = this.memberType;
        data["repeatedArrivalTimes"] = this.repeatedArrivalTimes;
        data["faceId"] = this.faceId;
        return data; 
    }
}

export interface IUserData {
    useid: string | undefined;
    username: string | undefined;
    age: string | undefined;
    deviceMac: string | undefined;
    mobilephone: string | undefined;
    gender: string | undefined;
    memberUrl: string | undefined;
    arriveUrl: string | undefined;
    arriveTime: string | undefined;
    cardNumber: string | undefined;
    memberType: string | undefined;
    repeatedArrivalTimes: string | undefined;
    faceId: string | undefined;
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class ValueNameDto implements IValueNameDto {
    value!: number;
    name!: string | undefined;

    constructor(data?: IValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IValueNameDto {
    value: number;
    name: string | undefined;
}

export class ValueNamePicUrlDto implements IValueNamePicUrlDto {
    value!: number;
    name!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IValueNamePicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): ValueNamePicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueNamePicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IValueNamePicUrlDto {
    value: number;
    name: string | undefined;
    picUrl: string | undefined;
}

export class VerificatOrderItemInput implements IVerificatOrderItemInput {
    orderId!: number;
    orderItemId!: number | undefined;
    storeId!: number;
    activityId!: number;

    constructor(data?: IVerificatOrderItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderItemId = _data["orderItemId"];
            this.storeId = _data["storeId"];
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): VerificatOrderItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerificatOrderItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderItemId"] = this.orderItemId;
        data["storeId"] = this.storeId;
        data["activityId"] = this.activityId;
        return data; 
    }
}

export interface IVerificatOrderItemInput {
    orderId: number;
    orderItemId: number | undefined;
    storeId: number;
    activityId: number;
}

export class WeishopOrderCountDto implements IWeishopOrderCountDto {
    toPay!: number;
    toDeliver!: number;
    toReceive!: number;
    toRefund!: number;

    constructor(data?: IWeishopOrderCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.toPay = _data["toPay"];
            this.toDeliver = _data["toDeliver"];
            this.toReceive = _data["toReceive"];
            this.toRefund = _data["toRefund"];
        }
    }

    static fromJS(data: any): WeishopOrderCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeishopOrderCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toPay"] = this.toPay;
        data["toDeliver"] = this.toDeliver;
        data["toReceive"] = this.toReceive;
        data["toRefund"] = this.toRefund;
        return data; 
    }
}

export interface IWeishopOrderCountDto {
    toPay: number;
    toDeliver: number;
    toReceive: number;
    toRefund: number;
}

export class WxPayDataDto implements IWxPayDataDto {
    appId!: string | undefined;
    timeStamp!: string | undefined;
    nonceStr!: string | undefined;
    package!: string | undefined;
    signType!: string | undefined;
    paySign!: string | undefined;

    constructor(data?: IWxPayDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.timeStamp = _data["timeStamp"];
            this.nonceStr = _data["nonceStr"];
            this.package = _data["package"];
            this.signType = _data["signType"];
            this.paySign = _data["paySign"];
        }
    }

    static fromJS(data: any): WxPayDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WxPayDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["timeStamp"] = this.timeStamp;
        data["nonceStr"] = this.nonceStr;
        data["package"] = this.package;
        data["signType"] = this.signType;
        data["paySign"] = this.paySign;
        return data; 
    }
}

export interface IWxPayDataDto {
    appId: string | undefined;
    timeStamp: string | undefined;
    nonceStr: string | undefined;
    package: string | undefined;
    signType: string | undefined;
    paySign: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}