/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_FLOOR_URL = new InjectionToken<string>('API_FLOOR_URL');

@Injectable()
export class BuildingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBuilding(body: CreateBuildingInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Building/CreateBuilding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBuilding(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBuilding(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBuilding(body: UpdateBuildingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Building/UpdateBuilding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBuilding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBuilding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBuilding(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Building/DeleteBuilding?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBuilding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBuilding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteBuildings(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Building/BatchDeleteBuildings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteBuildings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteBuildings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteBuildings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBuildings(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BuildingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Building/GetBuildings?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildings(<any>response_);
                } catch (e) {
                    return <Observable<BuildingDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildings(response: HttpResponseBase): Observable<BuildingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuildingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getBuildingsForSelect(): Observable<GuidNameAndNODto[]> {
        let url_ = this.baseUrl + "/api/services/app/Building/GetBuildingsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildingsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildingsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<GuidNameAndNODto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GuidNameAndNODto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildingsForSelect(response: HttpResponseBase): Observable<GuidNameAndNODto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameAndNODto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GuidNameAndNODto[]>(<any>null);
    }
}

@Injectable()
export class FloorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFloor(body: CreateFloorInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Floor/CreateFloor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFloor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFloor(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFloor(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFloor(body: UpdateFloorInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Floor/UpdateFloor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFloor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFloor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFloor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteFloor(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Floor/DeleteFloor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFloor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFloor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFloor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteFloors(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Floor/BatchDeleteFloors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteFloors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteFloors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteFloors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param buildingId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFloors(buildingId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FloorDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Floor/GetFloors?";
        if (buildingId !== undefined)
            url_ += "BuildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloors(<any>response_);
                } catch (e) {
                    return <Observable<FloorDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloors(response: HttpResponseBase): Observable<FloorDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FloorDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorDtoPagedResultDto>(<any>null);
    }

    /**
     * @param buildingId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFloorsNew(buildingId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FloorListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Floor/GetFloorsNew?";
        if (buildingId !== undefined)
            url_ += "BuildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorsNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorsNew(<any>response_);
                } catch (e) {
                    return <Observable<FloorListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloorsNew(response: HttpResponseBase): Observable<FloorListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FloorListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param buildingId (optional) 
     * @return Success
     */
    getFloors4Select(buildingId: string | null | undefined): Observable<GuidNameAndNODto[]> {
        let url_ = this.baseUrl + "/api/services/app/Floor/GetFloors4Select?";
        if (buildingId !== undefined)
            url_ += "buildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloors4Select(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloors4Select(<any>response_);
                } catch (e) {
                    return <Observable<GuidNameAndNODto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GuidNameAndNODto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloors4Select(response: HttpResponseBase): Observable<GuidNameAndNODto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameAndNODto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GuidNameAndNODto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateAngleResourcesToFloor(body: FloorAngleResourceInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Floor/AddOrUpdateAngleResourcesToFloor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateAngleResourcesToFloor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateAngleResourcesToFloor(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateAngleResourcesToFloor(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFloorAngleResources(floorId: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FloorAngleResourceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Floor/GetFloorAngleResources?";
        if (floorId === undefined || floorId === null)
            throw new Error("The parameter 'floorId' must be defined and cannot be null.");
        else
            url_ += "FloorId=" + encodeURIComponent("" + floorId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorAngleResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorAngleResources(<any>response_);
                } catch (e) {
                    return <Observable<FloorAngleResourceDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorAngleResourceDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloorAngleResources(response: HttpResponseBase): Observable<FloorAngleResourceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FloorAngleResourceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorAngleResourceDtoPagedResultDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteFloorAngleResouces(ids: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Floor/DeleteFloorAngleResouces?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFloorAngleResouces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFloorAngleResouces(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFloorAngleResouces(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param floorId (optional) 
     * @return Success
     */
    getFloorDetail4Edit(floorId: string | null | undefined): Observable<FloorDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Floor/GetFloorDetail4Edit?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorDetail4Edit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorDetail4Edit(<any>response_);
                } catch (e) {
                    return <Observable<FloorDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloorDetail4Edit(response: HttpResponseBase): Observable<FloorDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FloorDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorDetailDto>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAbpClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetAbpClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAbpClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAbpClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAbpClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class NavigationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNavigation(body: CreateNavigationInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/CreateNavigation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNavigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNavigation(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNavigation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNavigation(body: UpdateNavigationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/UpdateNavigation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNavigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNavigation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNavigation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNavigation(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/DeleteNavigation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNavigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNavigation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNavigation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    batchDeleteNavigations(ids: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/BatchDeleteNavigations?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteNavigations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteNavigations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteNavigations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param lastRoomId (optional) 
     * @param nextRoomId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getNavigationsByRoomId(lastRoomId: string | null | undefined, nextRoomId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<NavigationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/GetNavigationsByRoomId?";
        if (lastRoomId !== undefined)
            url_ += "LastRoomId=" + encodeURIComponent("" + lastRoomId) + "&"; 
        if (nextRoomId !== undefined)
            url_ += "NextRoomId=" + encodeURIComponent("" + nextRoomId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigationsByRoomId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigationsByRoomId(<any>response_);
                } catch (e) {
                    return <Observable<NavigationDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NavigationDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNavigationsByRoomId(response: HttpResponseBase): Observable<NavigationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NavigationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NavigationDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateNavigations(body: AddOrUpdateNavigationsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Navigation/AddOrUpdateNavigations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateNavigations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateNavigations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateNavigations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RobotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadRobotMapData(body: RobotMapInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Robot/UploadRobotMapData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadRobotMapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadRobotMapData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadRobotMapData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getDeviceNavigateLines(deviceId: number | undefined): Observable<NavigateLineDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Robot/GetDeviceNavigateLines?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceNavigateLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceNavigateLines(<any>response_);
                } catch (e) {
                    return <Observable<NavigateLineDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NavigateLineDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceNavigateLines(response: HttpResponseBase): Observable<NavigateLineDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NavigateLineDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NavigateLineDto[]>(<any>null);
    }

    /**
     * @param lineId (optional) 
     * @return Success
     */
    getDeviceNavigateLinePoints(lineId: string | undefined): Observable<NavigatePointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Robot/GetDeviceNavigateLinePoints?";
        if (lineId === null)
            throw new Error("The parameter 'lineId' cannot be null.");
        else if (lineId !== undefined)
            url_ += "lineId=" + encodeURIComponent("" + lineId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceNavigateLinePoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceNavigateLinePoints(<any>response_);
                } catch (e) {
                    return <Observable<NavigatePointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NavigatePointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceNavigateLinePoints(response: HttpResponseBase): Observable<NavigatePointDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NavigatePointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NavigatePointDto[]>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param patrolName (optional) 
     * @return Success
     */
    getDeviceNavigateLinePointsByName(deviceId: number | undefined, patrolName: string | null | undefined): Observable<NavigatePointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Robot/GetDeviceNavigateLinePointsByName?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (patrolName !== undefined)
            url_ += "patrolName=" + encodeURIComponent("" + patrolName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceNavigateLinePointsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceNavigateLinePointsByName(<any>response_);
                } catch (e) {
                    return <Observable<NavigatePointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NavigatePointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceNavigateLinePointsByName(response: HttpResponseBase): Observable<NavigatePointDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NavigatePointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NavigatePointDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMaps(): Observable<RobotMapDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Robot/GetMaps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaps(<any>response_);
                } catch (e) {
                    return <Observable<RobotMapDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RobotMapDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaps(response: HttpResponseBase): Observable<RobotMapDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RobotMapDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RobotMapDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMapPoints(id: string | undefined): Observable<NavigatePointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Robot/GetMapPoints?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapPoints(<any>response_);
                } catch (e) {
                    return <Observable<NavigatePointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NavigatePointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMapPoints(response: HttpResponseBase): Observable<NavigatePointDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NavigatePointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NavigatePointDto[]>(<any>null);
    }
}

@Injectable()
export class RoomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRoom(body: CreateRoomInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Room/CreateRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRoom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRoom(body: UpdateRoomInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Room/UpdateRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRoom(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRoom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRoom(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Room/DeleteRoom?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRoom(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRoom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteRooms(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Room/BatchDeleteRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteRooms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteRooms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param floorId (optional) 
     * @param buildingId (optional) 
     * @param roomType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getRooms(floorId: string | null | undefined, buildingId: string | null | undefined, roomType: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<RoomDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRooms?";
        if (floorId !== undefined)
            url_ += "FloorId=" + encodeURIComponent("" + floorId) + "&"; 
        if (buildingId !== undefined)
            url_ += "BuildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (roomType !== undefined)
            url_ += "RoomType=" + encodeURIComponent("" + roomType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRooms(<any>response_);
                } catch (e) {
                    return <Observable<RoomDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoomDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRooms(response: HttpResponseBase): Observable<RoomDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoomDtoPagedResultDto>(<any>null);
    }

    /**
     * @param floorId (optional) 
     * @param buildingId (optional) 
     * @param roomType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getRoomsNew(floorId: string | null | undefined, buildingId: string | null | undefined, roomType: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<RoomListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRoomsNew?";
        if (floorId !== undefined)
            url_ += "FloorId=" + encodeURIComponent("" + floorId) + "&"; 
        if (buildingId !== undefined)
            url_ += "BuildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (roomType !== undefined)
            url_ += "RoomType=" + encodeURIComponent("" + roomType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoomsNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoomsNew(<any>response_);
                } catch (e) {
                    return <Observable<RoomListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoomListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoomsNew(response: HttpResponseBase): Observable<RoomListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoomListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateAngleLocationResourcesToRoom(body: RoomAngleLocationResourceInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Room/AddOrUpdateAngleLocationResourcesToRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateAngleLocationResourcesToRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateAngleLocationResourcesToRoom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateAngleLocationResourcesToRoom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getRoomAngleLocationResources(roomId: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<RoomAngleLocationResourcesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRoomAngleLocationResources?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined and cannot be null.");
        else
            url_ += "RoomId=" + encodeURIComponent("" + roomId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoomAngleLocationResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoomAngleLocationResources(<any>response_);
                } catch (e) {
                    return <Observable<RoomAngleLocationResourcesDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoomAngleLocationResourcesDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoomAngleLocationResources(response: HttpResponseBase): Observable<RoomAngleLocationResourcesDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomAngleLocationResourcesDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoomAngleLocationResourcesDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteRoomAngleLocationResouces(body: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Room/BatchDeleteRoomAngleLocationResouces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteRoomAngleLocationResouces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteRoomAngleLocationResouces(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteRoomAngleLocationResouces(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param buildingId (optional) 
     * @param floorId (optional) 
     * @param roomType (optional) 
     * @param name (optional) 
     * @return Success
     */
    getRooms4Select(buildingId: string | null | undefined, floorId: string | null | undefined, roomType: string | null | undefined, name: string | null | undefined): Observable<GuidNameAndNODto[]> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRooms4Select?";
        if (buildingId !== undefined)
            url_ += "buildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        if (roomType !== undefined)
            url_ += "roomType=" + encodeURIComponent("" + roomType) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRooms4Select(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRooms4Select(<any>response_);
                } catch (e) {
                    return <Observable<GuidNameAndNODto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GuidNameAndNODto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRooms4Select(response: HttpResponseBase): Observable<GuidNameAndNODto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameAndNODto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GuidNameAndNODto[]>(<any>null);
    }

    /**
     * @param roomId (optional) 
     * @return Success
     */
    getRoomDetailsById(roomId: string | undefined): Observable<RoomDto> {
        let url_ = this.baseUrl + "/api/services/app/Room/GetRoomDetailsById?";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoomDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoomDetailsById(<any>response_);
                } catch (e) {
                    return <Observable<RoomDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoomDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoomDetailsById(response: HttpResponseBase): Observable<RoomDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoomDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateRooms(body: AddOrUpdateRoomsInput | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Room/AddOrUpdateRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateRooms(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateRooms(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRoomList(body: UpdateRoomListInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Room/UpdateRoomList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRoomList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRoomList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRoomList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subkey (optional) 
     * @param buildingId (optional) 
     * @param floorId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFloorsDetails(subkey: string | null | undefined, buildingId: string | undefined, floorId: string | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SensingFloorDetailsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetFloorsDetails?";
        if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (buildingId === null)
            throw new Error("The parameter 'buildingId' cannot be null.");
        else if (buildingId !== undefined)
            url_ += "BuildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        if (floorId === null)
            throw new Error("The parameter 'floorId' cannot be null.");
        else if (floorId !== undefined)
            url_ += "FloorId=" + encodeURIComponent("" + floorId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorsDetails(<any>response_);
                } catch (e) {
                    return <Observable<SensingFloorDetailsDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensingFloorDetailsDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFloorsDetails(response: HttpResponseBase): Observable<SensingFloorDetailsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensingFloorDetailsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensingFloorDetailsDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class WeatherServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_FLOOR_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param cityId (optional) 
     * @param date (optional) 
     * @return Success
     */
    getWeatherByDate(cityId: number | undefined, date: moment.Moment | undefined): Observable<WeatherDto> {
        let url_ = this.baseUrl + "/api/services/app/Weather/GetWeatherByDate?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&"; 
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherByDate(<any>response_);
                } catch (e) {
                    return <Observable<WeatherDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeatherByDate(response: HttpResponseBase): Observable<WeatherDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherDto>(<any>null);
    }
}

export class CreateBuildingInput implements ICreateBuildingInput {
    name!: string;
    no!: string | undefined;
    /** 大楼的图片地址 */
    imageUrl!: string | undefined;
    country!: string | undefined;
    stateOrProvince!: string | undefined;
    cityOrTown!: string | undefined;
    longitude!: number;
    latitude!: number;
    description!: string | undefined;

    constructor(data?: ICreateBuildingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.no = data["no"];
            this.imageUrl = data["imageUrl"];
            this.country = data["country"];
            this.stateOrProvince = data["stateOrProvince"];
            this.cityOrTown = data["cityOrTown"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateBuildingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBuildingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["no"] = this.no;
        data["imageUrl"] = this.imageUrl;
        data["country"] = this.country;
        data["stateOrProvince"] = this.stateOrProvince;
        data["cityOrTown"] = this.cityOrTown;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateBuildingInput {
    name: string;
    no: string | undefined;
    /** 大楼的图片地址 */
    imageUrl: string | undefined;
    country: string | undefined;
    stateOrProvince: string | undefined;
    cityOrTown: string | undefined;
    longitude: number;
    latitude: number;
    description: string | undefined;
}

export class UpdateBuildingInput implements IUpdateBuildingInput {
    id!: string;
    name!: string;
    no!: string | undefined;
    /** 大楼的图片地址 */
    imageUrl!: string | undefined;
    country!: string | undefined;
    stateOrProvince!: string | undefined;
    cityOrTown!: string | undefined;
    longitude!: number;
    latitude!: number;
    description!: string | undefined;

    constructor(data?: IUpdateBuildingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.no = data["no"];
            this.imageUrl = data["imageUrl"];
            this.country = data["country"];
            this.stateOrProvince = data["stateOrProvince"];
            this.cityOrTown = data["cityOrTown"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UpdateBuildingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBuildingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["no"] = this.no;
        data["imageUrl"] = this.imageUrl;
        data["country"] = this.country;
        data["stateOrProvince"] = this.stateOrProvince;
        data["cityOrTown"] = this.cityOrTown;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateBuildingInput {
    id: string;
    name: string;
    no: string | undefined;
    /** 大楼的图片地址 */
    imageUrl: string | undefined;
    country: string | undefined;
    stateOrProvince: string | undefined;
    cityOrTown: string | undefined;
    longitude: number;
    latitude: number;
    description: string | undefined;
}

export class BuildingWithoutFloorDto implements IBuildingWithoutFloorDto {
    id!: string;
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    imageUrl!: string | undefined;
    country!: string | undefined;
    stateOrProvince!: string | undefined;
    cityOrTown!: string | undefined;
    longitude!: number;
    latitude!: number;
    description!: string | undefined;

    constructor(data?: IBuildingWithoutFloorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.imageUrl = data["imageUrl"];
            this.country = data["country"];
            this.stateOrProvince = data["stateOrProvince"];
            this.cityOrTown = data["cityOrTown"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): BuildingWithoutFloorDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingWithoutFloorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["imageUrl"] = this.imageUrl;
        data["country"] = this.country;
        data["stateOrProvince"] = this.stateOrProvince;
        data["cityOrTown"] = this.cityOrTown;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["description"] = this.description;
        return data; 
    }
}

export interface IBuildingWithoutFloorDto {
    id: string;
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    imageUrl: string | undefined;
    country: string | undefined;
    stateOrProvince: string | undefined;
    cityOrTown: string | undefined;
    longitude: number;
    latitude: number;
    description: string | undefined;
}

export class FloorWithoutRoomDto implements IFloorWithoutRoomDto {
    id!: string;
    tenantId!: number;
    buildingId!: string;
    buildingName!: string | undefined;
    building!: BuildingWithoutFloorDto;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl!: string | undefined;

    constructor(data?: IFloorWithoutRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.buildingName = data["buildingName"];
            this.building = data["building"] ? BuildingWithoutFloorDto.fromJS(data["building"]) : <any>undefined;
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
        }
    }

    static fromJS(data: any): FloorWithoutRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorWithoutRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["buildingName"] = this.buildingName;
        data["building"] = this.building ? this.building.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        return data; 
    }
}

export interface IFloorWithoutRoomDto {
    id: string;
    tenantId: number;
    buildingId: string;
    buildingName: string | undefined;
    building: BuildingWithoutFloorDto;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl: string | undefined;
}

export class Building implements IBuilding {
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    imageUrl!: string | undefined;
    country!: string | undefined;
    stateOrProvince!: string | undefined;
    cityOrTown!: string | undefined;
    longitude!: number;
    latitude!: number;
    address!: string | undefined;
    floors!: Floor[] | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IBuilding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.imageUrl = data["imageUrl"];
            this.country = data["country"];
            this.stateOrProvince = data["stateOrProvince"];
            this.cityOrTown = data["cityOrTown"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.address = data["address"];
            if (Array.isArray(data["floors"])) {
                this.floors = [] as any;
                for (let item of data["floors"])
                    this.floors!.push(Floor.fromJS(item));
            }
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Building {
        data = typeof data === 'object' ? data : {};
        let result = new Building();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["imageUrl"] = this.imageUrl;
        data["country"] = this.country;
        data["stateOrProvince"] = this.stateOrProvince;
        data["cityOrTown"] = this.cityOrTown;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["address"] = this.address;
        if (Array.isArray(this.floors)) {
            data["floors"] = [];
            for (let item of this.floors)
                data["floors"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBuilding {
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    imageUrl: string | undefined;
    country: string | undefined;
    stateOrProvince: string | undefined;
    cityOrTown: string | undefined;
    longitude: number;
    latitude: number;
    address: string | undefined;
    floors: Floor[] | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class FloorAngleResource implements IFloorAngleResource {
    floorId!: string;
    floor!: Floor;
    imageUrl!: string | undefined;
    angle!: number;
    displayName!: string | undefined;
    isDefault!: boolean;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IFloorAngleResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            this.floor = data["floor"] ? Floor.fromJS(data["floor"]) : <any>undefined;
            this.imageUrl = data["imageUrl"];
            this.angle = data["angle"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FloorAngleResource {
        data = typeof data === 'object' ? data : {};
        let result = new FloorAngleResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        data["floor"] = this.floor ? this.floor.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["angle"] = this.angle;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFloorAngleResource {
    floorId: string;
    floor: Floor;
    imageUrl: string | undefined;
    angle: number;
    displayName: string | undefined;
    isDefault: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class Floor implements IFloor {
    tenantId!: number;
    buildingId!: string;
    building!: Building;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    thumbnailImageUrl!: string | undefined;
    rooms!: Room[] | undefined;
    floorResources!: FloorAngleResource[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IFloor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.building = data["building"] ? Building.fromJS(data["building"]) : <any>undefined;
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            if (Array.isArray(data["rooms"])) {
                this.rooms = [] as any;
                for (let item of data["rooms"])
                    this.rooms!.push(Room.fromJS(item));
            }
            if (Array.isArray(data["floorResources"])) {
                this.floorResources = [] as any;
                for (let item of data["floorResources"])
                    this.floorResources!.push(FloorAngleResource.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Floor {
        data = typeof data === 'object' ? data : {};
        let result = new Floor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["building"] = this.building ? this.building.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        if (Array.isArray(this.floorResources)) {
            data["floorResources"] = [];
            for (let item of this.floorResources)
                data["floorResources"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFloor {
    tenantId: number;
    buildingId: string;
    building: Building;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    thumbnailImageUrl: string | undefined;
    rooms: Room[] | undefined;
    floorResources: FloorAngleResource[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class Room implements IRoom {
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    floorId!: string;
    floor!: Floor;
    pathLocations!: RoomAngleLocationResource[] | undefined;
    areaWidth!: number;
    areaHeight!: number;
    roomType!: string | undefined;
    threeDPath!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.floorId = data["floorId"];
            this.floor = data["floor"] ? Floor.fromJS(data["floor"]) : <any>undefined;
            if (Array.isArray(data["pathLocations"])) {
                this.pathLocations = [] as any;
                for (let item of data["pathLocations"])
                    this.pathLocations!.push(RoomAngleLocationResource.fromJS(item));
            }
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.roomType = data["roomType"];
            this.threeDPath = data["threeDPath"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Room {
        data = typeof data === 'object' ? data : {};
        let result = new Room();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["floorId"] = this.floorId;
        data["floor"] = this.floor ? this.floor.toJSON() : <any>undefined;
        if (Array.isArray(this.pathLocations)) {
            data["pathLocations"] = [];
            for (let item of this.pathLocations)
                data["pathLocations"].push(item.toJSON());
        }
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["roomType"] = this.roomType;
        data["threeDPath"] = this.threeDPath;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoom {
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    floorId: string;
    floor: Floor;
    pathLocations: RoomAngleLocationResource[] | undefined;
    areaWidth: number;
    areaHeight: number;
    roomType: string | undefined;
    threeDPath: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class RoomAngleLocationResource implements IRoomAngleLocationResource {
    pathLocationX!: number;
    pathLocationY!: number;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    roomId!: string;
    room!: Room;
    angle!: number;
    usage!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IRoomAngleLocationResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pathLocationX = data["pathLocationX"];
            this.pathLocationY = data["pathLocationY"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.roomId = data["roomId"];
            this.room = data["room"] ? Room.fromJS(data["room"]) : <any>undefined;
            this.angle = data["angle"];
            this.usage = data["usage"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoomAngleLocationResource {
        data = typeof data === 'object' ? data : {};
        let result = new RoomAngleLocationResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathLocationX"] = this.pathLocationX;
        data["pathLocationY"] = this.pathLocationY;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["roomId"] = this.roomId;
        data["room"] = this.room ? this.room.toJSON() : <any>undefined;
        data["angle"] = this.angle;
        data["usage"] = this.usage;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoomAngleLocationResource {
    pathLocationX: number;
    pathLocationY: number;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    roomId: string;
    room: Room;
    angle: number;
    usage: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class RoomDto implements IRoomDto {
    floor!: FloorWithoutRoomDto;
    storeDisplayName!: string | undefined;
    id!: string;
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    floorId!: string;
    pathLocations!: RoomAngleLocationResource[] | undefined;
    areaWidth!: number;
    areaHeight!: number;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;

    constructor(data?: IRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floor = data["floor"] ? FloorWithoutRoomDto.fromJS(data["floor"]) : <any>undefined;
            this.storeDisplayName = data["storeDisplayName"];
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.floorId = data["floorId"];
            if (Array.isArray(data["pathLocations"])) {
                this.pathLocations = [] as any;
                for (let item of data["pathLocations"])
                    this.pathLocations!.push(RoomAngleLocationResource.fromJS(item));
            }
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
        }
    }

    static fromJS(data: any): RoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor"] = this.floor ? this.floor.toJSON() : <any>undefined;
        data["storeDisplayName"] = this.storeDisplayName;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["floorId"] = this.floorId;
        if (Array.isArray(this.pathLocations)) {
            data["pathLocations"] = [];
            for (let item of this.pathLocations)
                data["pathLocations"].push(item.toJSON());
        }
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        return data; 
    }
}

export interface IRoomDto {
    floor: FloorWithoutRoomDto;
    storeDisplayName: string | undefined;
    id: string;
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    floorId: string;
    pathLocations: RoomAngleLocationResource[] | undefined;
    areaWidth: number;
    areaHeight: number;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
}

export class FloorDto implements IFloorDto {
    rooms!: RoomDto[] | undefined;
    id!: string;
    tenantId!: number;
    buildingId!: string;
    buildingName!: string | undefined;
    building!: BuildingWithoutFloorDto;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl!: string | undefined;

    constructor(data?: IFloorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["rooms"])) {
                this.rooms = [] as any;
                for (let item of data["rooms"])
                    this.rooms!.push(RoomDto.fromJS(item));
            }
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.buildingName = data["buildingName"];
            this.building = data["building"] ? BuildingWithoutFloorDto.fromJS(data["building"]) : <any>undefined;
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
        }
    }

    static fromJS(data: any): FloorDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["buildingName"] = this.buildingName;
        data["building"] = this.building ? this.building.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        return data; 
    }
}

export interface IFloorDto {
    rooms: RoomDto[] | undefined;
    id: string;
    tenantId: number;
    buildingId: string;
    buildingName: string | undefined;
    building: BuildingWithoutFloorDto;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl: string | undefined;
}

export class BuildingDto implements IBuildingDto {
    floors!: FloorDto[] | undefined;
    id!: string;
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    imageUrl!: string | undefined;
    country!: string | undefined;
    stateOrProvince!: string | undefined;
    cityOrTown!: string | undefined;
    longitude!: number;
    latitude!: number;
    description!: string | undefined;

    constructor(data?: IBuildingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["floors"])) {
                this.floors = [] as any;
                for (let item of data["floors"])
                    this.floors!.push(FloorDto.fromJS(item));
            }
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.imageUrl = data["imageUrl"];
            this.country = data["country"];
            this.stateOrProvince = data["stateOrProvince"];
            this.cityOrTown = data["cityOrTown"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): BuildingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.floors)) {
            data["floors"] = [];
            for (let item of this.floors)
                data["floors"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["imageUrl"] = this.imageUrl;
        data["country"] = this.country;
        data["stateOrProvince"] = this.stateOrProvince;
        data["cityOrTown"] = this.cityOrTown;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["description"] = this.description;
        return data; 
    }
}

export interface IBuildingDto {
    floors: FloorDto[] | undefined;
    id: string;
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    imageUrl: string | undefined;
    country: string | undefined;
    stateOrProvince: string | undefined;
    cityOrTown: string | undefined;
    longitude: number;
    latitude: number;
    description: string | undefined;
}

export class BuildingDtoPagedResultDto implements IBuildingDtoPagedResultDto {
    totalCount!: number;
    items!: BuildingDto[] | undefined;

    constructor(data?: IBuildingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BuildingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BuildingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBuildingDtoPagedResultDto {
    totalCount: number;
    items: BuildingDto[] | undefined;
}

export class GuidNameAndNODto implements IGuidNameAndNODto {
    id!: string;
    name!: string | undefined;
    no!: string | undefined;

    constructor(data?: IGuidNameAndNODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.no = data["no"];
        }
    }

    static fromJS(data: any): GuidNameAndNODto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidNameAndNODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["no"] = this.no;
        return data; 
    }
}

export interface IGuidNameAndNODto {
    id: string;
    name: string | undefined;
    no: string | undefined;
}

export class CreateFloorInput implements ICreateFloorInput {
    buildingId!: string;
    name!: string | undefined;
    no!: string | undefined;
    thumbnailImageUrl!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICreateFloorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildingId = data["buildingId"];
            this.name = data["name"];
            this.no = data["no"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateFloorInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFloorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildingId"] = this.buildingId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateFloorInput {
    buildingId: string;
    name: string | undefined;
    no: string | undefined;
    thumbnailImageUrl: string | undefined;
    description: string | undefined;
}

export class UpdateFloorInput implements IUpdateFloorInput {
    id!: string;
    buildingId!: string;
    name!: string | undefined;
    no!: string | undefined;
    thumbnailImageUrl!: string | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateFloorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.buildingId = data["buildingId"];
            this.name = data["name"];
            this.no = data["no"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UpdateFloorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFloorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["buildingId"] = this.buildingId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateFloorInput {
    id: string;
    buildingId: string;
    name: string | undefined;
    no: string | undefined;
    thumbnailImageUrl: string | undefined;
    description: string | undefined;
}

export class FloorDtoPagedResultDto implements IFloorDtoPagedResultDto {
    totalCount!: number;
    items!: FloorDto[] | undefined;

    constructor(data?: IFloorDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FloorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFloorDtoPagedResultDto {
    totalCount: number;
    items: FloorDto[] | undefined;
}

export class FloorListDto implements IFloorListDto {
    id!: string;
    tenantId!: number;
    buildingId!: string;
    buildingName!: string | undefined;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    thumbnailImageUrl!: string | undefined;
    roomcount!: number;

    constructor(data?: IFloorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.buildingName = data["buildingName"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            this.roomcount = data["roomcount"];
        }
    }

    static fromJS(data: any): FloorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["buildingName"] = this.buildingName;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        data["roomcount"] = this.roomcount;
        return data; 
    }
}

export interface IFloorListDto {
    id: string;
    tenantId: number;
    buildingId: string;
    buildingName: string | undefined;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    thumbnailImageUrl: string | undefined;
    roomcount: number;
}

export class FloorListDtoPagedResultDto implements IFloorListDtoPagedResultDto {
    totalCount!: number;
    items!: FloorListDto[] | undefined;

    constructor(data?: IFloorListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FloorListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFloorListDtoPagedResultDto {
    totalCount: number;
    items: FloorListDto[] | undefined;
}

export class FloorAngleResourceInput implements IFloorAngleResourceInput {
    floorId!: string;
    id!: string;
    /** 图片地址 */
    imageUrl!: string | undefined;
    /** 图片对应的角度 */
    angle!: number;
    /** 名称 */
    displayName!: string | undefined;
    /** 是否为默认  进入楼层默认高亮等等 */
    isDefault!: boolean;

    constructor(data?: IFloorAngleResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            this.id = data["id"];
            this.imageUrl = data["imageUrl"];
            this.angle = data["angle"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): FloorAngleResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new FloorAngleResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["angle"] = this.angle;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IFloorAngleResourceInput {
    floorId: string;
    id: string;
    /** 图片地址 */
    imageUrl: string | undefined;
    /** 图片对应的角度 */
    angle: number;
    /** 名称 */
    displayName: string | undefined;
    /** 是否为默认  进入楼层默认高亮等等 */
    isDefault: boolean;
}

export class FloorAngleResourceDto implements IFloorAngleResourceDto {
    floorId!: string;
    /** 图片地址 */
    imageUrl!: string | undefined;
    /** 图片对应的角度 */
    angle!: number;
    /** 名称 */
    displayName!: string | undefined;
    /** 是否为默认  进入楼层默认高亮等等 */
    isDefault!: boolean;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IFloorAngleResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            this.imageUrl = data["imageUrl"];
            this.angle = data["angle"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FloorAngleResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorAngleResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        data["imageUrl"] = this.imageUrl;
        data["angle"] = this.angle;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFloorAngleResourceDto {
    floorId: string;
    /** 图片地址 */
    imageUrl: string | undefined;
    /** 图片对应的角度 */
    angle: number;
    /** 名称 */
    displayName: string | undefined;
    /** 是否为默认  进入楼层默认高亮等等 */
    isDefault: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class FloorAngleResourceDtoPagedResultDto implements IFloorAngleResourceDtoPagedResultDto {
    totalCount!: number;
    items!: FloorAngleResourceDto[] | undefined;

    constructor(data?: IFloorAngleResourceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FloorAngleResourceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorAngleResourceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorAngleResourceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFloorAngleResourceDtoPagedResultDto {
    totalCount: number;
    items: FloorAngleResourceDto[] | undefined;
}

export class RoomAngleLocationResourcesDto implements IRoomAngleLocationResourcesDto {
    pathLocationX!: number;
    pathLocationY!: number;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    roomId!: string;
    /** 二维的方向. */
    angle!: number;
    /** 用途, 在当前的使用中,Usage和Angle相同的情况下，只允许有一条记录. */
    usage!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IRoomAngleLocationResourcesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pathLocationX = data["pathLocationX"];
            this.pathLocationY = data["pathLocationY"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.roomId = data["roomId"];
            this.angle = data["angle"];
            this.usage = data["usage"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoomAngleLocationResourcesDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomAngleLocationResourcesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathLocationX"] = this.pathLocationX;
        data["pathLocationY"] = this.pathLocationY;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["roomId"] = this.roomId;
        data["angle"] = this.angle;
        data["usage"] = this.usage;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoomAngleLocationResourcesDto {
    pathLocationX: number;
    pathLocationY: number;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    roomId: string;
    /** 二维的方向. */
    angle: number;
    /** 用途, 在当前的使用中,Usage和Angle相同的情况下，只允许有一条记录. */
    usage: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class RoomInfoDto implements IRoomInfoDto {
    id!: string | undefined;
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    floorId!: string;
    pathLocations!: RoomAngleLocationResourcesDto[] | undefined;
    areaWidth!: number;
    areaHeight!: number;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;

    constructor(data?: IRoomInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.floorId = data["floorId"];
            if (Array.isArray(data["pathLocations"])) {
                this.pathLocations = [] as any;
                for (let item of data["pathLocations"])
                    this.pathLocations!.push(RoomAngleLocationResourcesDto.fromJS(item));
            }
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
        }
    }

    static fromJS(data: any): RoomInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["floorId"] = this.floorId;
        if (Array.isArray(this.pathLocations)) {
            data["pathLocations"] = [];
            for (let item of this.pathLocations)
                data["pathLocations"].push(item.toJSON());
        }
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        return data; 
    }
}

export interface IRoomInfoDto {
    id: string | undefined;
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    floorId: string;
    pathLocations: RoomAngleLocationResourcesDto[] | undefined;
    areaWidth: number;
    areaHeight: number;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
}

export class FloorInfoDto implements IFloorInfoDto {
    id!: string;
    tenantId!: number;
    buildingId!: string;
    buildingName!: string | undefined;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl!: string | undefined;
    floorAngleResource!: FloorAngleResourceDto[] | undefined;
    roomInfos!: RoomInfoDto[] | undefined;

    constructor(data?: IFloorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.buildingName = data["buildingName"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            if (Array.isArray(data["floorAngleResource"])) {
                this.floorAngleResource = [] as any;
                for (let item of data["floorAngleResource"])
                    this.floorAngleResource!.push(FloorAngleResourceDto.fromJS(item));
            }
            if (Array.isArray(data["roomInfos"])) {
                this.roomInfos = [] as any;
                for (let item of data["roomInfos"])
                    this.roomInfos!.push(RoomInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["buildingName"] = this.buildingName;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        if (Array.isArray(this.floorAngleResource)) {
            data["floorAngleResource"] = [];
            for (let item of this.floorAngleResource)
                data["floorAngleResource"].push(item.toJSON());
        }
        if (Array.isArray(this.roomInfos)) {
            data["roomInfos"] = [];
            for (let item of this.roomInfos)
                data["roomInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFloorInfoDto {
    id: string;
    tenantId: number;
    buildingId: string;
    buildingName: string | undefined;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    /** 缩略图 示意图 */
    thumbnailImageUrl: string | undefined;
    floorAngleResource: FloorAngleResourceDto[] | undefined;
    roomInfos: RoomInfoDto[] | undefined;
}

export class NavigationDto implements INavigationDto {
    id!: string;
    description!: string | undefined;
    lastRoomId!: string | undefined;
    nextRoomId!: string | undefined;

    constructor(data?: INavigationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.description = data["description"];
            this.lastRoomId = data["lastRoomId"];
            this.nextRoomId = data["nextRoomId"];
        }
    }

    static fromJS(data: any): NavigationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NavigationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["lastRoomId"] = this.lastRoomId;
        data["nextRoomId"] = this.nextRoomId;
        return data; 
    }
}

export interface INavigationDto {
    id: string;
    description: string | undefined;
    lastRoomId: string | undefined;
    nextRoomId: string | undefined;
}

export class FloorDetailDto implements IFloorDetailDto {
    floorInfoDto!: FloorInfoDto;
    navigations!: NavigationDto[] | undefined;

    constructor(data?: IFloorDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorInfoDto = data["floorInfoDto"] ? FloorInfoDto.fromJS(data["floorInfoDto"]) : <any>undefined;
            if (Array.isArray(data["navigations"])) {
                this.navigations = [] as any;
                for (let item of data["navigations"])
                    this.navigations!.push(NavigationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorInfoDto"] = this.floorInfoDto ? this.floorInfoDto.toJSON() : <any>undefined;
        if (Array.isArray(this.navigations)) {
            data["navigations"] = [];
            for (let item of this.navigations)
                data["navigations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFloorDetailDto {
    floorInfoDto: FloorInfoDto;
    navigations: NavigationDto[] | undefined;
}

export class CreateNavigationInput implements ICreateNavigationInput {
    description!: string | undefined;
    lastRoomId!: string | undefined;
    nextRoomId!: string | undefined;

    constructor(data?: ICreateNavigationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.lastRoomId = data["lastRoomId"];
            this.nextRoomId = data["nextRoomId"];
        }
    }

    static fromJS(data: any): CreateNavigationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNavigationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["lastRoomId"] = this.lastRoomId;
        data["nextRoomId"] = this.nextRoomId;
        return data; 
    }
}

export interface ICreateNavigationInput {
    description: string | undefined;
    lastRoomId: string | undefined;
    nextRoomId: string | undefined;
}

export class UpdateNavigationInput implements IUpdateNavigationInput {
    id!: string;
    lastRoomId!: string | undefined;
    nextRoomId!: string | undefined;

    constructor(data?: IUpdateNavigationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.lastRoomId = data["lastRoomId"];
            this.nextRoomId = data["nextRoomId"];
        }
    }

    static fromJS(data: any): UpdateNavigationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNavigationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lastRoomId"] = this.lastRoomId;
        data["nextRoomId"] = this.nextRoomId;
        return data; 
    }
}

export interface IUpdateNavigationInput {
    id: string;
    lastRoomId: string | undefined;
    nextRoomId: string | undefined;
}

export class NavigationDtoPagedResultDto implements INavigationDtoPagedResultDto {
    totalCount!: number;
    items!: NavigationDto[] | undefined;

    constructor(data?: INavigationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NavigationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NavigationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NavigationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INavigationDtoPagedResultDto {
    totalCount: number;
    items: NavigationDto[] | undefined;
}

export class NavigationInput implements INavigationInput {
    lastRoomId!: string;
    nextRoomId!: string;

    constructor(data?: INavigationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastRoomId = data["lastRoomId"];
            this.nextRoomId = data["nextRoomId"];
        }
    }

    static fromJS(data: any): NavigationInput {
        data = typeof data === 'object' ? data : {};
        let result = new NavigationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastRoomId"] = this.lastRoomId;
        data["nextRoomId"] = this.nextRoomId;
        return data; 
    }
}

export interface INavigationInput {
    lastRoomId: string;
    nextRoomId: string;
}

export class AddOrUpdateNavigationsInput implements IAddOrUpdateNavigationsInput {
    floorId!: string;
    navigationInputs!: NavigationInput[] | undefined;

    constructor(data?: IAddOrUpdateNavigationsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            if (Array.isArray(data["navigationInputs"])) {
                this.navigationInputs = [] as any;
                for (let item of data["navigationInputs"])
                    this.navigationInputs!.push(NavigationInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateNavigationsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateNavigationsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        if (Array.isArray(this.navigationInputs)) {
            data["navigationInputs"] = [];
            for (let item of this.navigationInputs)
                data["navigationInputs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateNavigationsInput {
    floorId: string;
    navigationInputs: NavigationInput[] | undefined;
}

export class Pointxy implements IPointxy {
    x!: number;
    y!: number;

    constructor(data?: IPointxy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x = data["x"];
            this.y = data["y"];
        }
    }

    static fromJS(data: any): Pointxy {
        data = typeof data === 'object' ? data : {};
        let result = new Pointxy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }
}

export interface IPointxy {
    x: number;
    y: number;
}

export class MapPointDto implements IMapPointDto {
    icon!: string | undefined;
    imgPath!: string | undefined;
    positionAction!: string | undefined;
    resourceList!: any[] | undefined;
    degree!: number;
    isReachable!: boolean;
    pointId!: number;
    pointName!: string | undefined;
    pointXY!: Pointxy;

    constructor(data?: IMapPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.icon = data["icon"];
            this.imgPath = data["imgPath"];
            this.positionAction = data["positionAction"];
            if (Array.isArray(data["resourceList"])) {
                this.resourceList = [] as any;
                for (let item of data["resourceList"])
                    this.resourceList!.push(item);
            }
            this.degree = data["degree"];
            this.isReachable = data["isReachable"];
            this.pointId = data["pointId"];
            this.pointName = data["pointName"];
            this.pointXY = data["pointXY"] ? Pointxy.fromJS(data["pointXY"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["icon"] = this.icon;
        data["imgPath"] = this.imgPath;
        data["positionAction"] = this.positionAction;
        if (Array.isArray(this.resourceList)) {
            data["resourceList"] = [];
            for (let item of this.resourceList)
                data["resourceList"].push(item);
        }
        data["degree"] = this.degree;
        data["isReachable"] = this.isReachable;
        data["pointId"] = this.pointId;
        data["pointName"] = this.pointName;
        data["pointXY"] = this.pointXY ? this.pointXY.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMapPointDto {
    icon: string | undefined;
    imgPath: string | undefined;
    positionAction: string | undefined;
    resourceList: any[] | undefined;
    degree: number;
    isReachable: boolean;
    pointId: number;
    pointName: string | undefined;
    pointXY: Pointxy;
}

export class Deffinishreslist implements IDeffinishreslist {
    resId!: number;
    resPath!: string | undefined;
    tts!: string | undefined;

    constructor(data?: IDeffinishreslist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resId = data["resId"];
            this.resPath = data["resPath"];
            this.tts = data["tts"];
        }
    }

    static fromJS(data: any): Deffinishreslist {
        data = typeof data === 'object' ? data : {};
        let result = new Deffinishreslist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resId"] = this.resId;
        data["resPath"] = this.resPath;
        data["tts"] = this.tts;
        return data; 
    }
}

export interface IDeffinishreslist {
    resId: number;
    resPath: string | undefined;
    tts: string | undefined;
}

export class Defstartreslist implements IDefstartreslist {
    resId!: number;
    resPath!: string | undefined;
    tts!: string | undefined;

    constructor(data?: IDefstartreslist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resId = data["resId"];
            this.resPath = data["resPath"];
            this.tts = data["tts"];
        }
    }

    static fromJS(data: any): Defstartreslist {
        data = typeof data === 'object' ? data : {};
        let result = new Defstartreslist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resId"] = this.resId;
        data["resPath"] = this.resPath;
        data["tts"] = this.tts;
        return data; 
    }
}

export interface IDefstartreslist {
    resId: number;
    resPath: string | undefined;
    tts: string | undefined;
}

export class Finishreslist implements IFinishreslist {
    resId!: number;
    resPath!: string | undefined;
    tts!: string | undefined;

    constructor(data?: IFinishreslist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resId = data["resId"];
            this.resPath = data["resPath"];
            this.tts = data["tts"];
        }
    }

    static fromJS(data: any): Finishreslist {
        data = typeof data === 'object' ? data : {};
        let result = new Finishreslist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resId"] = this.resId;
        data["resPath"] = this.resPath;
        data["tts"] = this.tts;
        return data; 
    }
}

export interface IFinishreslist {
    resId: number;
    resPath: string | undefined;
    tts: string | undefined;
}

export class Position implements IPosition {
    x!: number;
    y!: number;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x = data["x"];
            this.y = data["y"];
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }
}

export interface IPosition {
    x: number;
    y: number;
}

export class Pointlist implements IPointlist {
    degree!: number;
    finishResList!: Finishreslist[] | undefined;
    id!: number;
    naviPosId!: number;
    pointName!: string | undefined;
    position!: Position;
    startResList!: any[] | undefined;
    stayTime!: number;

    constructor(data?: IPointlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.degree = data["degree"];
            if (Array.isArray(data["finishResList"])) {
                this.finishResList = [] as any;
                for (let item of data["finishResList"])
                    this.finishResList!.push(Finishreslist.fromJS(item));
            }
            this.id = data["id"];
            this.naviPosId = data["naviPosId"];
            this.pointName = data["pointName"];
            this.position = data["position"] ? Position.fromJS(data["position"]) : <any>undefined;
            if (Array.isArray(data["startResList"])) {
                this.startResList = [] as any;
                for (let item of data["startResList"])
                    this.startResList!.push(item);
            }
            this.stayTime = data["stayTime"];
        }
    }

    static fromJS(data: any): Pointlist {
        data = typeof data === 'object' ? data : {};
        let result = new Pointlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["degree"] = this.degree;
        if (Array.isArray(this.finishResList)) {
            data["finishResList"] = [];
            for (let item of this.finishResList)
                data["finishResList"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["naviPosId"] = this.naviPosId;
        data["pointName"] = this.pointName;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        if (Array.isArray(this.startResList)) {
            data["startResList"] = [];
            for (let item of this.startResList)
                data["startResList"].push(item);
        }
        data["stayTime"] = this.stayTime;
        return data; 
    }
}

export interface IPointlist {
    degree: number;
    finishResList: Finishreslist[] | undefined;
    id: number;
    naviPosId: number;
    pointName: string | undefined;
    position: Position;
    startResList: any[] | undefined;
    stayTime: number;
}

export class MapLineDto implements IMapLineDto {
    defFinishResList!: Deffinishreslist[] | undefined;
    defStartResList!: Defstartreslist[] | undefined;
    isChecked!: boolean;
    lineId!: number;
    lineName!: string | undefined;
    patrolResList!: any[] | undefined;
    pointList!: Pointlist[] | undefined;
    type!: number;

    constructor(data?: IMapLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["defFinishResList"])) {
                this.defFinishResList = [] as any;
                for (let item of data["defFinishResList"])
                    this.defFinishResList!.push(Deffinishreslist.fromJS(item));
            }
            if (Array.isArray(data["defStartResList"])) {
                this.defStartResList = [] as any;
                for (let item of data["defStartResList"])
                    this.defStartResList!.push(Defstartreslist.fromJS(item));
            }
            this.isChecked = data["isChecked"];
            this.lineId = data["lineId"];
            this.lineName = data["lineName"];
            if (Array.isArray(data["patrolResList"])) {
                this.patrolResList = [] as any;
                for (let item of data["patrolResList"])
                    this.patrolResList!.push(item);
            }
            if (Array.isArray(data["pointList"])) {
                this.pointList = [] as any;
                for (let item of data["pointList"])
                    this.pointList!.push(Pointlist.fromJS(item));
            }
            this.type = data["type"];
        }
    }

    static fromJS(data: any): MapLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.defFinishResList)) {
            data["defFinishResList"] = [];
            for (let item of this.defFinishResList)
                data["defFinishResList"].push(item.toJSON());
        }
        if (Array.isArray(this.defStartResList)) {
            data["defStartResList"] = [];
            for (let item of this.defStartResList)
                data["defStartResList"].push(item.toJSON());
        }
        data["isChecked"] = this.isChecked;
        data["lineId"] = this.lineId;
        data["lineName"] = this.lineName;
        if (Array.isArray(this.patrolResList)) {
            data["patrolResList"] = [];
            for (let item of this.patrolResList)
                data["patrolResList"].push(item);
        }
        if (Array.isArray(this.pointList)) {
            data["pointList"] = [];
            for (let item of this.pointList)
                data["pointList"].push(item.toJSON());
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IMapLineDto {
    defFinishResList: Deffinishreslist[] | undefined;
    defStartResList: Defstartreslist[] | undefined;
    isChecked: boolean;
    lineId: number;
    lineName: string | undefined;
    patrolResList: any[] | undefined;
    pointList: Pointlist[] | undefined;
    type: number;
}

export class RobotMapInput implements IRobotMapInput {
    sn!: string | undefined;
    name!: string | undefined;
    points!: MapPointDto[] | undefined;
    paths!: MapLineDto[] | undefined;

    constructor(data?: IRobotMapInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sn = data["sn"];
            this.name = data["name"];
            if (Array.isArray(data["points"])) {
                this.points = [] as any;
                for (let item of data["points"])
                    this.points!.push(MapPointDto.fromJS(item));
            }
            if (Array.isArray(data["paths"])) {
                this.paths = [] as any;
                for (let item of data["paths"])
                    this.paths!.push(MapLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RobotMapInput {
        data = typeof data === 'object' ? data : {};
        let result = new RobotMapInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["name"] = this.name;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        if (Array.isArray(this.paths)) {
            data["paths"] = [];
            for (let item of this.paths)
                data["paths"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRobotMapInput {
    sn: string | undefined;
    name: string | undefined;
    points: MapPointDto[] | undefined;
    paths: MapLineDto[] | undefined;
}

export class NavigateLineDto implements INavigateLineDto {
    name!: string | undefined;
    id!: string;

    constructor(data?: INavigateLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NavigateLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new NavigateLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface INavigateLineDto {
    name: string | undefined;
    id: string;
}

export class NavigatePointDto implements INavigatePointDto {
    name!: string | undefined;
    id!: string;

    constructor(data?: INavigatePointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NavigatePointDto {
        data = typeof data === 'object' ? data : {};
        let result = new NavigatePointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface INavigatePointDto {
    name: string | undefined;
    id: string;
}

export class RobotMapDto implements IRobotMapDto {
    name!: string | undefined;
    id!: string;

    constructor(data?: IRobotMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RobotMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new RobotMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRobotMapDto {
    name: string | undefined;
    id: string;
}

export class CreateRoomInput implements ICreateRoomInput {
    floorId!: string;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    areaWidth!: number;
    areaHeight!: number;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;

    constructor(data?: ICreateRoomInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
        }
    }

    static fromJS(data: any): CreateRoomInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoomInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        return data; 
    }
}

export interface ICreateRoomInput {
    floorId: string;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    areaWidth: number;
    areaHeight: number;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
}

export class UpdateRoomInput implements IUpdateRoomInput {
    id!: string;
    floorId!: string;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    areaWidth!: number;
    areaHeight!: number;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;

    constructor(data?: IUpdateRoomInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.floorId = data["floorId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
        }
    }

    static fromJS(data: any): UpdateRoomInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoomInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["floorId"] = this.floorId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        return data; 
    }
}

export interface IUpdateRoomInput {
    id: string;
    floorId: string;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    areaWidth: number;
    areaHeight: number;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
}

export class RoomDtoPagedResultDto implements IRoomDtoPagedResultDto {
    totalCount!: number;
    items!: RoomDto[] | undefined;

    constructor(data?: IRoomDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoomDtoPagedResultDto {
    totalCount: number;
    items: RoomDto[] | undefined;
}

export class RoomListDto implements IRoomListDto {
    id!: string;
    tenantId!: number;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    floorId!: string;
    floorNo!: string | undefined;
    buildingName!: string | undefined;
    buildingID!: string;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;
    areaWidth!: number;
    areaHeight!: number;

    constructor(data?: IRoomListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.floorId = data["floorId"];
            this.floorNo = data["floorNo"];
            this.buildingName = data["buildingName"];
            this.buildingID = data["buildingID"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
        }
    }

    static fromJS(data: any): RoomListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["floorId"] = this.floorId;
        data["floorNo"] = this.floorNo;
        data["buildingName"] = this.buildingName;
        data["buildingID"] = this.buildingID;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        return data; 
    }
}

export interface IRoomListDto {
    id: string;
    tenantId: number;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    floorId: string;
    floorNo: string | undefined;
    buildingName: string | undefined;
    buildingID: string;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
    areaWidth: number;
    areaHeight: number;
}

export class RoomListDtoPagedResultDto implements IRoomListDtoPagedResultDto {
    totalCount!: number;
    items!: RoomListDto[] | undefined;

    constructor(data?: IRoomListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoomListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoomListDtoPagedResultDto {
    totalCount: number;
    items: RoomListDto[] | undefined;
}

export class RoomAngleLocationResourceInput implements IRoomAngleLocationResourceInput {
    pathLocationX!: number;
    pathLocationY!: number;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    roomId!: string;
    /** 二维的方向. */
    angle!: number;
    /** 用途, 在当前的使用中,Usage和Angle相同的情况下，只允许有一条记录. */
    usage!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: IRoomAngleLocationResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pathLocationX = data["pathLocationX"];
            this.pathLocationY = data["pathLocationY"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.roomId = data["roomId"];
            this.angle = data["angle"];
            this.usage = data["usage"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoomAngleLocationResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoomAngleLocationResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathLocationX"] = this.pathLocationX;
        data["pathLocationY"] = this.pathLocationY;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["roomId"] = this.roomId;
        data["angle"] = this.angle;
        data["usage"] = this.usage;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoomAngleLocationResourceInput {
    pathLocationX: number;
    pathLocationY: number;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    roomId: string;
    /** 二维的方向. */
    angle: number;
    /** 用途, 在当前的使用中,Usage和Angle相同的情况下，只允许有一条记录. */
    usage: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class RoomAngleLocationResourcesDtoPagedResultDto implements IRoomAngleLocationResourcesDtoPagedResultDto {
    totalCount!: number;
    items!: RoomAngleLocationResourcesDto[] | undefined;

    constructor(data?: IRoomAngleLocationResourcesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoomAngleLocationResourcesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoomAngleLocationResourcesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomAngleLocationResourcesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoomAngleLocationResourcesDtoPagedResultDto {
    totalCount: number;
    items: RoomAngleLocationResourcesDto[] | undefined;
}

export class RoomInput implements IRoomInput {
    id!: string;
    name!: string | undefined;
    no!: string | undefined;
    roomType!: string | undefined;
    pathLocationX!: number;
    pathLocationY!: number;

    constructor(data?: IRoomInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.no = data["no"];
            this.roomType = data["roomType"];
            this.pathLocationX = data["pathLocationX"];
            this.pathLocationY = data["pathLocationY"];
        }
    }

    static fromJS(data: any): RoomInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoomInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["no"] = this.no;
        data["roomType"] = this.roomType;
        data["pathLocationX"] = this.pathLocationX;
        data["pathLocationY"] = this.pathLocationY;
        return data; 
    }
}

export interface IRoomInput {
    id: string;
    name: string | undefined;
    no: string | undefined;
    roomType: string | undefined;
    pathLocationX: number;
    pathLocationY: number;
}

export class AddOrUpdateRoomsInput implements IAddOrUpdateRoomsInput {
    floorId!: string;
    angle!: number;
    roomInputs!: RoomInput[] | undefined;

    constructor(data?: IAddOrUpdateRoomsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorId = data["floorId"];
            this.angle = data["angle"];
            if (Array.isArray(data["roomInputs"])) {
                this.roomInputs = [] as any;
                for (let item of data["roomInputs"])
                    this.roomInputs!.push(RoomInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateRoomsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateRoomsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorId"] = this.floorId;
        data["angle"] = this.angle;
        if (Array.isArray(this.roomInputs)) {
            data["roomInputs"] = [];
            for (let item of this.roomInputs)
                data["roomInputs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateRoomsInput {
    floorId: string;
    angle: number;
    roomInputs: RoomInput[] | undefined;
}

export class UpdateRoomDto implements IUpdateRoomDto {
    id!: string;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;

    constructor(data?: IUpdateRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
        }
    }

    static fromJS(data: any): UpdateRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        return data; 
    }
}

export interface IUpdateRoomDto {
    id: string;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
}

export class UpdateRoomListInput implements IUpdateRoomListInput {
    updateRoomDtos!: UpdateRoomDto[] | undefined;

    constructor(data?: IUpdateRoomListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["updateRoomDtos"])) {
                this.updateRoomDtos = [] as any;
                for (let item of data["updateRoomDtos"])
                    this.updateRoomDtos!.push(UpdateRoomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateRoomListInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoomListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updateRoomDtos)) {
            data["updateRoomDtos"] = [];
            for (let item of this.updateRoomDtos)
                data["updateRoomDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateRoomListInput {
    updateRoomDtos: UpdateRoomDto[] | undefined;
}

export class SensingRoomAngleLocationResourcesDto implements ISensingRoomAngleLocationResourcesDto {
    pathLocationX!: number;
    pathLocationY!: number;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    angle!: number;
    usage!: string | undefined;

    constructor(data?: ISensingRoomAngleLocationResourcesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pathLocationX = data["pathLocationX"];
            this.pathLocationY = data["pathLocationY"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.angle = data["angle"];
            this.usage = data["usage"];
        }
    }

    static fromJS(data: any): SensingRoomAngleLocationResourcesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingRoomAngleLocationResourcesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathLocationX"] = this.pathLocationX;
        data["pathLocationY"] = this.pathLocationY;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["angle"] = this.angle;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface ISensingRoomAngleLocationResourcesDto {
    pathLocationX: number;
    pathLocationY: number;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    angle: number;
    usage: string | undefined;
}

export class SensingRoomDto implements ISensingRoomDto {
    id!: string | undefined;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    pathLocations!: SensingRoomAngleLocationResourcesDto[] | undefined;
    areaWidth!: number;
    areaHeight!: number;
    storeId!: number | undefined;
    storeName!: string | undefined;
    brandName!: string | undefined;
    brandLogo!: string | undefined;
    roomType!: string | undefined;

    constructor(data?: ISensingRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            if (Array.isArray(data["pathLocations"])) {
                this.pathLocations = [] as any;
                for (let item of data["pathLocations"])
                    this.pathLocations!.push(SensingRoomAngleLocationResourcesDto.fromJS(item));
            }
            this.areaWidth = data["areaWidth"];
            this.areaHeight = data["areaHeight"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.brandName = data["brandName"];
            this.brandLogo = data["brandLogo"];
            this.roomType = data["roomType"];
        }
    }

    static fromJS(data: any): SensingRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        if (Array.isArray(this.pathLocations)) {
            data["pathLocations"] = [];
            for (let item of this.pathLocations)
                data["pathLocations"].push(item.toJSON());
        }
        data["areaWidth"] = this.areaWidth;
        data["areaHeight"] = this.areaHeight;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["brandName"] = this.brandName;
        data["brandLogo"] = this.brandLogo;
        data["roomType"] = this.roomType;
        return data; 
    }
}

export interface ISensingRoomDto {
    id: string | undefined;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    pathLocations: SensingRoomAngleLocationResourcesDto[] | undefined;
    areaWidth: number;
    areaHeight: number;
    storeId: number | undefined;
    storeName: string | undefined;
    brandName: string | undefined;
    brandLogo: string | undefined;
    roomType: string | undefined;
}

export class SensingFloorDetailsDto implements ISensingFloorDetailsDto {
    navigations!: NavigationDto[] | undefined;
    id!: string;
    tenantId!: number;
    buildingId!: string;
    buildingName!: string | undefined;
    name!: string | undefined;
    no!: string | undefined;
    description!: string | undefined;
    thumbnailImageUrl!: string | undefined;
    floorResources!: FloorAngleResourceDto[] | undefined;
    rooms!: SensingRoomDto[] | undefined;

    constructor(data?: ISensingFloorDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["navigations"])) {
                this.navigations = [] as any;
                for (let item of data["navigations"])
                    this.navigations!.push(NavigationDto.fromJS(item));
            }
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.buildingId = data["buildingId"];
            this.buildingName = data["buildingName"];
            this.name = data["name"];
            this.no = data["no"];
            this.description = data["description"];
            this.thumbnailImageUrl = data["thumbnailImageUrl"];
            if (Array.isArray(data["floorResources"])) {
                this.floorResources = [] as any;
                for (let item of data["floorResources"])
                    this.floorResources!.push(FloorAngleResourceDto.fromJS(item));
            }
            if (Array.isArray(data["rooms"])) {
                this.rooms = [] as any;
                for (let item of data["rooms"])
                    this.rooms!.push(SensingRoomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingFloorDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingFloorDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.navigations)) {
            data["navigations"] = [];
            for (let item of this.navigations)
                data["navigations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["buildingId"] = this.buildingId;
        data["buildingName"] = this.buildingName;
        data["name"] = this.name;
        data["no"] = this.no;
        data["description"] = this.description;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        if (Array.isArray(this.floorResources)) {
            data["floorResources"] = [];
            for (let item of this.floorResources)
                data["floorResources"].push(item.toJSON());
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingFloorDetailsDto {
    navigations: NavigationDto[] | undefined;
    id: string;
    tenantId: number;
    buildingId: string;
    buildingName: string | undefined;
    name: string | undefined;
    no: string | undefined;
    description: string | undefined;
    thumbnailImageUrl: string | undefined;
    floorResources: FloorAngleResourceDto[] | undefined;
    rooms: SensingRoomDto[] | undefined;
}

export class SensingFloorDetailsDtoPagedResultDto implements ISensingFloorDetailsDtoPagedResultDto {
    totalCount!: number;
    items!: SensingFloorDetailsDto[] | undefined;

    constructor(data?: ISensingFloorDetailsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SensingFloorDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingFloorDetailsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingFloorDetailsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingFloorDetailsDtoPagedResultDto {
    totalCount: number;
    items: SensingFloorDetailsDto[] | undefined;
}

export class WeatherDto implements IWeatherDto {
    cityId!: number;
    condition!: string | undefined;
    icon!: string | undefined;
    temp!: string | undefined;
    updatetime!: string | undefined;

    constructor(data?: IWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityId = data["cityId"];
            this.condition = data["condition"];
            this.icon = data["icon"];
            this.temp = data["temp"];
            this.updatetime = data["updatetime"];
        }
    }

    static fromJS(data: any): WeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId;
        data["condition"] = this.condition;
        data["icon"] = this.icon;
        data["temp"] = this.temp;
        data["updatetime"] = this.updatetime;
        return data; 
    }
}

export interface IWeatherDto {
    cityId: number;
    condition: string | undefined;
    icon: string | undefined;
    temp: string | undefined;
    updatetime: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}