/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_ACTIVITY_URL = new InjectionToken<string>('API_ACTIVITY_URL');

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getActivityById(input: number | null | undefined): Observable<ActivityBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityById(response: HttpResponseBase): Observable<ActivityBasicDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityBasicDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearUserActivityData(input: ClearActivityUserDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ClearUserActivityData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserActivityData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearUserActivityData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param isTemplate (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivities(auditStatus: AuditStatus | null | undefined, startTime: moment.Moment | null | undefined, isTemplate: boolean | null | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivities?";
        if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (isTemplate !== undefined)
            url_ += "IsTemplate=" + encodeURIComponent("" + isTemplate) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivities(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivities(response: HttpResponseBase): Observable<PagedResultDtoOfActivityBasicDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityBasicDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createActivity(input: CreateBasicActivityInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivity(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createActivityFromTemplate(input: ActivityFromTemplateInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivityFromTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivityFromTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivityFromTemplate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivityFromTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteActivity(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivity?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateActivity(input: UpdateBasicActivityInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/UpdateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    publishToOrganizationOrStoreOrDevices(input: PublishEntitiesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/PublishToOrganizationOrStoreOrDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrStoreOrDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrStoreOrDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrStoreOrDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    publishAllToOrganizationOrStoreOrDevices(input: PublishEntitiesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/PublishAllToOrganizationOrStoreOrDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrStoreOrDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrStoreOrDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrStoreOrDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activityAudit(input: ActivityAuditInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivityAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param flowType (optional) 
     * @return Success
     */
    getActivityFlow(activityId: number | null | undefined, flowType: FlowType | null | undefined): Observable<ActivityFlowDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityFlow?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (flowType !== undefined)
            url_ += "FlowType=" + encodeURIComponent("" + flowType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityFlow(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFlowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFlowDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityFlow(response: HttpResponseBase): Observable<ActivityFlowDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFlowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFlowDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activityFlowSettings(input: ActivityFlowSettingsInput | null | undefined): Observable<ActivityFlowDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityFlowSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityFlowSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityFlowSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFlowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFlowDto>><any>_observableThrow(response_);
        }));
    }

    protected processActivityFlowSettings(response: HttpResponseBase): Observable<ActivityFlowDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFlowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFlowDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByActivityId(activityId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGamesByActivityId?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByActivityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByActivityId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByActivityId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGameForSelectByActivityId(activityId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGameForSelectByActivityId?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGameForSelectByActivityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGameForSelectByActivityId(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGameForSelectByActivityId(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getActivityGameById(id: number | null | undefined): Observable<ActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGameById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGameById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGameById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGameById(response: HttpResponseBase): Observable<ActivityGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateActivityGame(input: ActivityGameSettingsInput | null | undefined): Observable<ActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateOrUpdateActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateActivityGame(response: HttpResponseBase): Observable<ActivityGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param activityGameIds (optional) 
     * @return Success
     */
    deleteActivityGame(activityId: number | null | undefined, activityGameIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivityGame?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (activityGameIds !== undefined)
            activityGameIds && activityGameIds.forEach(item => { url_ += "ActivityGameIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getAwardSettings(activityId: number | null | undefined): Observable<AwardSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetAwardSettings?";
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardSettings(response: HttpResponseBase): Observable<AwardSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardSettingsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    awardSettings(input: AwardSettingsDto | null | undefined): Observable<AwardSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/AwardSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAwardSettings(response: HttpResponseBase): Observable<AwardSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardSettingsDto>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityAward(deviceId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetDeviceActivityAward?";
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityAward(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityAward(response: HttpResponseBase): Observable<PagedResultDtoOfActivityAwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityAwardDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteActivityAward(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivityAward?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivityAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityAwardUser(activityId: number | null | undefined, deviceId: number | null | undefined, activityGameId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityAwardUser?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityAwardUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityAwardUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityAwardUser(response: HttpResponseBase): Observable<PagedResultDtoOfUserAwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserAwardDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserAwardExpressInfo(input: UpdateSnsUserAwardExpressInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/UpdateUserAwardExpressInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserAwardExpressInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserAwardExpressInfo(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserAwardExpressInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param awardId (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    doLotteryAction2Award(awardId: number | null | undefined, actionId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DoLotteryAction2Award?";
        if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&"; 
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAction2Award(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAction2Award(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAction2Award(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getAwardMessageSettings(activityId: number | null | undefined): Observable<AwardMessageSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetAwardMessageSettings?";
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardMessageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardMessageSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardMessageSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardMessageSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardMessageSettings(response: HttpResponseBase): Observable<AwardMessageSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardMessageSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardMessageSettingsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    awardMessageSettings(input: AwardMessageSettingsInput | null | undefined): Observable<AwardMessageSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/AwardMessageSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardMessageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardMessageSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardMessageSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardMessageSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAwardMessageSettings(response: HttpResponseBase): Observable<AwardMessageSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardMessageSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardMessageSettingsDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getActivityShareSettings(activityId: number | null | undefined): Observable<ActivityShareSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityShareSettings?";
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityShareSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityShareSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityShareSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityShareSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityShareSettings(response: HttpResponseBase): Observable<ActivityShareSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityShareSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityShareSettingsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activityShareSettings(input: ActivityShareSettingsInput | null | undefined): Observable<ActivityShareSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityShareSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityShareSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityShareSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityShareSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityShareSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processActivityShareSettings(response: HttpResponseBase): Observable<ActivityShareSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityShareSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityShareSettingsDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityUserDatas(activityId: number | null | undefined, deviceId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityUserDataDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityUserDatas?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityUserDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityUserDatas(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityUserDatas(response: HttpResponseBase): Observable<PagedResultDtoOfActivityUserDataDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityUserDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityUserDataDto>(<any>null);
    }

    /**
     * @param activityUserDataIds (optional) 
     * @param isValidate (optional) 
     * @return Success
     */
    validateActivityUserDatas(activityUserDataIds: number[] | null | undefined, isValidate: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ValidateActivityUserDatas?";
        if (isValidate !== undefined)
            url_ += "isValidate=" + encodeURIComponent("" + isValidate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activityUserDataIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateActivityUserDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateActivityUserDatas(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateActivityUserDatas(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearActivityData(input: DoClearActivityDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ClearActivityData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActivityData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActivityData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class AlipayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    alipayNotify(): Observable<void> {
        let url_ = this.baseUrl + "/Alipay/AlipayNotify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlipayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlipayNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAlipayNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param auth_code (optional) 
     * @param app_id (optional) 
     * @param scope (optional) 
     * @param source (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(auth_code: string | null | undefined, app_id: string | null | undefined, scope: string | null | undefined, source: string | null | undefined, state: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Alipay/CallBack?";
        if (auth_code !== undefined)
            url_ += "auth_code=" + encodeURIComponent("" + auth_code) + "&"; 
        if (app_id !== undefined)
            url_ += "app_id=" + encodeURIComponent("" + app_id) + "&"; 
        if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&"; 
        if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApplyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @param applyStatus (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyForms(type: Type | null | undefined, applyStatus: ApplyStatus | null | undefined, start: moment.Moment | null | undefined, end: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfApplyFormDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyForms?";
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (applyStatus !== undefined)
            url_ += "ApplyStatus=" + encodeURIComponent("" + applyStatus) + "&"; 
        if (start !== undefined)
            url_ += "Start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end !== undefined)
            url_ += "End=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyForms(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyForms(response: HttpResponseBase): Observable<PagedResultDtoOfApplyFormDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApplyFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApplyFormDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createApplyForm(input: CreateApplyFormInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/CreateApplyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    audit(input: AuditApplyFormInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AwardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param activityGameId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwards(activityId: number | null | undefined, activityGameId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/GetAwards?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwards(response: HttpResponseBase): Observable<PagedResultDtoOfAwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAwardDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAward(input: CreateAwardInput | null | undefined): Observable<AwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/CreateAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAward(<any>response_);
                } catch (e) {
                    return <Observable<AwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAward(response: HttpResponseBase): Observable<AwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAward(input: UpdateAwardInput | null | undefined): Observable<AwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/UpdateAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAward(<any>response_);
                } catch (e) {
                    return <Observable<AwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAward(response: HttpResponseBase): Observable<AwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param ids (optional) 
     * @return Success
     */
    deleteAward(activityId: number | null | undefined, ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Award/DeleteAward?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    activityTemplateSelect(): Observable<KeyValueDtoOfInt64[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/ActivityTemplateSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityTemplateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityTemplateSelect(<any>response_);
                } catch (e) {
                    return <Observable<KeyValueDtoOfInt64[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyValueDtoOfInt64[]>><any>_observableThrow(response_);
        }));
    }

    protected processActivityTemplateSelect(response: HttpResponseBase): Observable<KeyValueDtoOfInt64[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValueDtoOfInt64.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValueDtoOfInt64[]>(<any>null);
    }

    /**
     * @return Success
     */
    flowTypeSelect(): Observable<KeyValueDtoOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/FlowTypeSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlowTypeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlowTypeSelect(<any>response_);
                } catch (e) {
                    return <Observable<KeyValueDtoOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyValueDtoOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processFlowTypeSelect(response: HttpResponseBase): Observable<KeyValueDtoOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValueDtoOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValueDtoOfString[]>(<any>null);
    }

    /**
     * @param text (optional) 
     * @return Success
     */
    textCensor(text: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Common/TextCensor?";
        if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTextCensor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTextCensor(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processTextCensor(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createCourse(input: CreateCourseInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Course/CreateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCourse(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCourse(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCourse(input: UpdateCourseInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/UpdateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCourse(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/DeleteCourse?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    batchDeleteCourses(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/BatchDeleteCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteCourses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteCourses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param courseNo (optional) 
     * @param name (optional) 
     * @param tagId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCourses(id: number | null | undefined, courseNo: string | null | undefined, name: string | null | undefined, tagId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCourseDto> {
        let url_ = this.baseUrl + "/api/services/app/Course/GetCourses?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (courseNo !== undefined)
            url_ += "CourseNo=" + encodeURIComponent("" + courseNo) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourses(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCourseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCourseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourses(response: HttpResponseBase): Observable<PagedResultDtoOfCourseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCourseDto>(<any>null);
    }
}

@Injectable()
export class DeviceActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivitiesById(deviceId: number, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetDeviceActivitiesById?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivitiesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivitiesById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivitiesById(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceActivityDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByIdAndDeviceId(deviceId: number, activityId: number, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetActivityGamesByIdAndDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByIdAndDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByIdAndDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByIdAndDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createDeviceActivityGame(input: CreateDeviceActivityGameInput | null | undefined): Observable<DeviceActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/CreateDeviceActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceActivityGame(response: HttpResponseBase): Observable<DeviceActivityGame> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGame>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateDeviceActivityGame(input: UpdateDeviceActivityGameInput | null | undefined): Observable<DeviceActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/UpdateDeviceActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceActivityGame(response: HttpResponseBase): Observable<DeviceActivityGame> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGame>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceActivityGame(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/DeleteDeviceActivityGame?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getActivityChat(input: GetActivityChatInput | null | undefined): Observable<SummaryReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetActivityChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityChat(<any>response_);
                } catch (e) {
                    return <Observable<SummaryReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SummaryReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityChat(response: HttpResponseBase): Observable<SummaryReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SummaryReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    mirrorPublishActivityToDevices(input: MirrorPublishActivityToDevicesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/MirrorPublishActivityToDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMirrorPublishActivityToDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMirrorPublishActivityToDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMirrorPublishActivityToDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DouyinServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(code: string | null | undefined, state: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/CallBack?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    authCallBack(code: string | null | undefined, state: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/AuthCallBack?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuthCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDouyinMediaAuthorizeUrl(): Observable<string> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinMediaAuthorizeUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinMediaAuthorizeUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinMediaAuthorizeUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinMediaAuthorizeUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @return Success
     */
    getDouyinUserData(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinUserData?";
        if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinUserData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinUserData(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinUserData(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDouyinMedia(subkey: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDouyinMedia> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinMedia?";
        if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinMedia(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDouyinMedia>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDouyinMedia>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinMedia(response: HttpResponseBase): Observable<PagedResultDtoOfDouyinMedia> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDouyinMedia.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDouyinMedia>(<any>null);
    }

    /**
     * @return Success
     */
    syncDouyinMedia(): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/SyncDouyinMedia";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncDouyinMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncDouyinMedia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncDouyinMedia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HtmlTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param templateEnum (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getHtmlTemplates(templateEnum: TemplateEnum | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfHtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/GetHtmlTemplates?";
        if (templateEnum !== undefined)
            url_ += "TemplateEnum=" + encodeURIComponent("" + templateEnum) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHtmlTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHtmlTemplates(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHtmlTemplates(response: HttpResponseBase): Observable<PagedResultDtoOfHtmlTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfHtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHtmlTemplateDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createHtmlTemplate(input: CreateHtmlTemplateInput | null | undefined): Observable<HtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/CreateHtmlTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<HtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHtmlTemplate(response: HttpResponseBase): Observable<HtmlTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HtmlTemplateDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateHtmlTemplate(input: UpdateHtmlTemplateInput | null | undefined): Observable<HtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/UpdateHtmlTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<HtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHtmlTemplate(response: HttpResponseBase): Observable<HtmlTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HtmlTemplateDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteHtmlTemplate(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/DeleteHtmlTemplate?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHtmlTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ImportQuestionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param excel (optional) 
     * @return Success
     */
    importQuestionByExcel(excel: FileParameter | null | undefined): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportQuestions/ImportQuestionByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excel !== null && excel !== undefined)
            content_.append("excel", excel.data, excel.fileName ? excel.fileName : "excel");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportQuestionByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportQuestionByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportQuestionByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class ImportTrainingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importTrainingsByExcel(): Observable<string> {
        let url_ = this.baseUrl + "/ImportTrainings/ImportTrainingsByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTrainingsByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTrainingsByExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportTrainingsByExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param excel (optional) 
     * @return Success
     */
    importQuestionByExcel(excel: FileParameter | null | undefined): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportTrainings/ImportQuestionByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excel !== null && excel !== undefined)
            content_.append("excel", excel.data, excel.fileName ? excel.fileName : "excel");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportQuestionByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportQuestionByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportQuestionByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class PaperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPaper(input: CreatePaperInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/CreatePaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePaper(input: UpdatePaperInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/UpdatePaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapers(organizationUnitId: number | null | undefined, tagIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetPapers?";
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param dispatchedSoftwareId (optional) 
     * @param organizationUnitId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDispatchedPapers(dispatchedSoftwareId: number | null | undefined, organizationUnitId: number | null | undefined, tagIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetDispatchedPapers?";
        if (dispatchedSoftwareId !== undefined)
            url_ += "DispatchedSoftwareId=" + encodeURIComponent("" + dispatchedSoftwareId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispatchedPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispatchedPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispatchedPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaper(id: number | null | undefined): Observable<PaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetPaper?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaper(<any>response_);
                } catch (e) {
                    return <Observable<PaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaper(response: HttpResponseBase): Observable<PaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaperDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionsByPaperId(paperId: number | null | undefined, tagIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetQuestionsByPaperId?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getNoUsedQuestionsByPaperId(paperId: number | null | undefined, tagIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetNoUsedQuestionsByPaperId?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoUsedQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoUsedQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNoUsedQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePaper(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/DeletePaper?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePapers(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/DeletePapers?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePapers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePapers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateQuestionScoreAndOrder(input: UpdateQuestionScoreAndOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/UpdateQuestionScoreAndOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionScoreAndOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionScoreAndOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionScoreAndOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @return Success
     */
    addRandomQuestionsToPaper(paperId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/AddRandomQuestionsToPaper?";
        if (paperId !== undefined)
            url_ += "paperId=" + encodeURIComponent("" + paperId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRandomQuestionsToPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRandomQuestionsToPaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRandomQuestionsToPaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    publishPapersToSoftwares(input: PublishPapersToSoftwares | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/PublishPapersToSoftwares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishPapersToSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishPapersToSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishPapersToSoftwares(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PublicAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    createPublicAccountMenu(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PublicAccount/CreatePublicAccountMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePublicAccountMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePublicAccountMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePublicAccountMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param qrcodeId (optional) 
     * @return Success
     */
    showqrcode(qrcodeId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/showqrcode?";
        if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowqrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowqrcode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShowqrcode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuestionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createQuestion(input: CreateQuestionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/CreateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQuestion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateQuestion(input: UpdateQuestionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/UpdateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param tagIds (optional) 
     * @param questionScoreType (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestions(type: Type2 | null | undefined, tagIds: number[] | null | undefined, questionScoreType: QuestionScoreType | null | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetQuestions?";
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (questionScoreType !== undefined)
            url_ += "QuestionScoreType=" + encodeURIComponent("" + questionScoreType) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestions(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuestion(id: number | null | undefined): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetQuestion?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestion(<any>response_);
                } catch (e) {
                    return <Observable<QuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestion(response: HttpResponseBase): Observable<QuestionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteQuestion(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/DeleteQuestion?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteQuestions(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/DeleteQuestions?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateQuestionStatus(input: UpdateQuestionStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/UpdateQuestionStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    publishQuestionsToPapers(input: PublishQuestionsToPapersInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/PublishQuestionsToPapers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishQuestionsToPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishQuestionsToPapers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishQuestionsToPapers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReleaseApiTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    releaseApiTest(): Observable<NameValueTimeDto[]> {
        let url_ = this.baseUrl + "/api/ReleaseApiTest/ReleaseApiTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseApiTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseApiTest(<any>response_);
                } catch (e) {
                    return <Observable<NameValueTimeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueTimeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseApiTest(response: HttpResponseBase): Observable<NameValueTimeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueTimeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueTimeDto[]>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param softwareId (optional) 
     * @param activityGameId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getTotal(startTime: moment.Moment, endTime: moment.Moment, activityId: number | null | undefined, deviceId: number | null | undefined, softwareId: number | null | undefined, activityGameId: number | null | undefined, tenantId: number | null | undefined): Observable<SummaryReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetTotal?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotal(<any>response_);
                } catch (e) {
                    return <Observable<SummaryReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SummaryReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotal(response: HttpResponseBase): Observable<SummaryReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SummaryReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryReportDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param softwareId (optional) 
     * @param activityGameId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getActivityLabelChartReport(labels: string, type: string, startTime: moment.Moment, endTime: moment.Moment, activityId: number | null | undefined, deviceId: number | null | undefined, softwareId: number | null | undefined, activityGameId: number | null | undefined, tenantId: number | null | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetActivityLabelChartReport?";
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "Labels=" + encodeURIComponent("" + labels) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLabelChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLabelChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLabelChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getUserAwardReportByActivity(activityId: number | null | undefined): Observable<UserAwardByActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetUserAwardReportByActivity?";
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAwardReportByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAwardReportByActivity(<any>response_);
                } catch (e) {
                    return <Observable<UserAwardByActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAwardByActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAwardReportByActivity(response: HttpResponseBase): Observable<UserAwardByActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAwardByActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAwardByActivityDto>(<any>null);
    }
}

@Injectable()
export class SengsingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivities(subkey: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSensingDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetActivities?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivities(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivities(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceActivityDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGames(subkey: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<ActivityGameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetActivityGames?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGames(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGames(response: HttpResponseBase): Observable<ActivityGameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityGameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwards(subkey: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetAwards?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwards(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceAwardDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwardsBySecurityKey(securityKey: string, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetAwardsBySecurityKey?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsBySecurityKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsBySecurityKey(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsBySecurityKey(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceAwardDto>(<any>null);
    }

    /**
     * @param softwareId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapers(subkey: string, softwareId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPapers?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param tags (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapersByTags(subkey: string, tags: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPapersByTags?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (tags !== undefined)
            tags && tags.forEach(item => { url_ += "Tags=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapersByTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapersByTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapersByTags(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionsByPaperId(subkey: string, paperId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetQuestionsByPaperId?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUserPaper(input: AddUserPaperInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/AddUserPaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserPaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserPaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userActionId (optional) 
     * @return Success
     */
    getUserPaper(subKey: string | null | undefined, paperId: number | null | undefined, trainingId: number | null | undefined, userActionId: number | null | undefined): Observable<SingleUserPaperDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetUserPaper?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userActionId !== undefined)
            url_ += "UserActionId=" + encodeURIComponent("" + userActionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaper(<any>response_);
                } catch (e) {
                    return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaper(response: HttpResponseBase): Observable<SingleUserPaperDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserPaperDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleUserPaperDetailDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUserPaper4WeChat(input: AddUserPaperInput4Wechat | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/AddUserPaper4WeChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserPaper4WeChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserPaper4WeChat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserPaper4WeChat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReport(subkey: string, paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPaperAnswerReport?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&"; 
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerReportDto>(<any>null);
    }

    /**
     * @param securityKey (optional) 
     * @return Success
     */
    getDeviceInfoBySecurityKey(securityKey: string | null | undefined): Observable<SensingDeviceStoreInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetDeviceInfoBySecurityKey?";
        if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceInfoBySecurityKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceInfoBySecurityKey(<any>response_);
                } catch (e) {
                    return <Observable<SensingDeviceStoreInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensingDeviceStoreInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceInfoBySecurityKey(response: HttpResponseBase): Observable<SensingDeviceStoreInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensingDeviceStoreInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensingDeviceStoreInfoDto>(<any>null);
    }
}

@Injectable()
export class SensingDeviceActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWinUserAwards(isGameLevel: boolean | null | undefined, securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetWinUserAwards?";
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWinUserAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWinUserAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWinUserAwards(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserAwardOuput>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getSnsUserAwardById(userAwardId: number, securityKey: string, params: string | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetSnsUserAwardById?";
        if (userAwardId === undefined || userAwardId === null)
            throw new Error("The parameter 'userAwardId' must be defined and cannot be null.");
        else
            url_ += "UserAwardId=" + encodeURIComponent("" + userAwardId) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSnsUserAwardById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSnsUserAwardById(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSnsUserAwardById(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryAwardBySnsUserInfo(input: SnsDataInput | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardBySnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardBySnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardBySnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardBySnsUserInfo(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryForCargoBySnsUserInfo(input: DoLotteryAwardForCargoBySnsInput | null | undefined): Observable<LotteryCargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryForCargoBySnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryForCargoBySnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryForCargoBySnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<LotteryCargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LotteryCargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryForCargoBySnsUserInfo(response: HttpResponseBase): Observable<LotteryCargoResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LotteryCargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LotteryCargoResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryAwardByAction(input: LotteryActionDataInput | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardByAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardByAction(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryAwardForCargoByAction(input: DoLotteryAwardForCargoByActionInput | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardForCargoByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardForCargoByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardForCargoByAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardForCargoByAction(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryForCargoByAction(input: DoLotteryAwardForCargoByActionInput | null | undefined): Observable<LotteryCargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryForCargoByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryForCargoByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryForCargoByAction(<any>response_);
                } catch (e) {
                    return <Observable<LotteryCargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LotteryCargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryForCargoByAction(response: HttpResponseBase): Observable<LotteryCargoResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LotteryCargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LotteryCargoResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryAwardByActionWithScore(input: LotteryActionDataInput | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardByActionWithScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardByActionWithScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardByActionWithScore(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardByActionWithScore(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryUserByAwardId(input: AwardDataInput | null | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryUserByAwardId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryUserByAwardId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryUserByAwardId(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryUserByAwardId(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAwardNotify(input: UserAwardDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/SendAwardNotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAwardNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAwardNotify(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendAwardNotify(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearActivityDatas(input: ClearActivityDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ClearActivityDatas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActivityDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActivityDatas(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActivityDatas(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doLotteryForCargo(input: DoLotteryAwardForCargoBySnsInput | null | undefined): Observable<CargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryForCargo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryForCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryForCargo(<any>response_);
                } catch (e) {
                    return <Observable<CargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryForCargo(response: HttpResponseBase): Observable<CargoResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dropCagoByInput(input: DropCargoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DropCagoByInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCagoByInput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCagoByInput(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCagoByInput(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getDeviceActivityGameInfo(securityKey: string, params: string | null | undefined): Observable<DeviceActivityGameOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameInfo?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameInfo(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameInfo(response: HttpResponseBase): Observable<DeviceActivityGameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGameOutput>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getActivityInfo(subKey: string | null | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityInfo?";
        if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityInfo(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityInfo(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getDeviceActivityGames(securityKey: string, params: string | null | undefined): Observable<DeviceActivityGameSimpleOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGames?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGames(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGameSimpleOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGameSimpleOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGames(response: HttpResponseBase): Observable<DeviceActivityGameSimpleOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceActivityGameSimpleOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGameSimpleOutput[]>(<any>null);
    }

    /**
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwardsByActivity(securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAwardOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetAwardsByActivity?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAwardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAwardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfAwardOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAwardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAwardOutput>(<any>null);
    }

    /**
     * @param memberIds (optional) 
     * @return Success
     */
    getUserInfosByMemberIds(subKey: string, memberIds: number[] | null | undefined): Observable<SnsUserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserInfosByMemberIds?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (memberIds !== undefined)
            memberIds && memberIds.forEach(item => { url_ += "MemberIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfosByMemberIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfosByMemberIds(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfosByMemberIds(response: HttpResponseBase): Observable<SnsUserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SnsUserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    queryUserInfosByMemberIds(input: SensingDeviceUserInfoInput | null | undefined): Observable<SnsUserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/QueryUserInfosByMemberIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUserInfosByMemberIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUserInfosByMemberIds(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryUserInfosByMemberIds(response: HttpResponseBase): Observable<SnsUserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SnsUserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoDto[]>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param activityId (optional) 
     * @return Success
     */
    getUserInteractive(subKey: string | null | undefined, activityId: number[] | null | undefined): Observable<UserInteractiveDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserInteractive?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (activityId !== undefined)
            activityId && activityId.forEach(item => { url_ += "ActivityId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInteractive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInteractive(<any>response_);
                } catch (e) {
                    return <Observable<UserInteractiveDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInteractiveDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInteractive(response: HttpResponseBase): Observable<UserInteractiveDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInteractiveDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInteractiveDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateActivityAwards(input: UpdateActivityAwardsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/UpdateActivityAwards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActivityAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActivityAwards(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActivityAwards(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param snsType (optional) 
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPlayGamesByUser(openId: string, snsType: SnsType | null | undefined, securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPlayGameOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetPlayGamesByUser?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlayGamesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlayGamesByUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPlayGameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPlayGameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlayGamesByUser(response: HttpResponseBase): Observable<PagedResultDtoOfPlayGameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPlayGameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPlayGameOutput>(<any>null);
    }

    /**
     * @param minScore (optional) 
     * @param isGameLevel (optional) 
     * @param snsType (optional) 
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyActionsInActivity(minScore: number | null | undefined, isGameLevel: boolean | null | undefined, openId: string, snsType: SnsType2 | null | undefined, securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserActionPlayInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyActionsInActivity?";
        if (minScore !== undefined)
            url_ += "MinScore=" + encodeURIComponent("" + minScore) + "&"; 
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyActionsInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyActionsInActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionPlayInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionPlayInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyActionsInActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionPlayInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionPlayInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionPlayInfoOutput>(<any>null);
    }

    /**
     * @param rankColumn (optional) 
     * @param rank (optional) 
     * @param isGameLevel (optional) 
     * @param actionId (optional) 
     * @param snsType (optional) 
     * @param params (optional) 
     * @return Success
     */
    getMyRankInActivity(rankColumn: string | null | undefined, rank: number | null | undefined, isGameLevel: boolean | null | undefined, actionId: number | null | undefined, openId: string, snsType: SnsType3 | null | undefined, securityKey: string, params: string | null | undefined): Observable<RankUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyRankInActivity?";
        if (rankColumn !== undefined)
            url_ += "RankColumn=" + encodeURIComponent("" + rankColumn) + "&"; 
        if (rank !== undefined)
            url_ += "Rank=" + encodeURIComponent("" + rank) + "&"; 
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyRankInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyRankInActivity(<any>response_);
                } catch (e) {
                    return <Observable<RankUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RankUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyRankInActivity(response: HttpResponseBase): Observable<RankUserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RankUserActionInfoOutput>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param deviceActivityGameId (optional) 
     * @return Success
     */
    getUserPlayGameScoreRank(subKey: string | null | undefined, deviceActivityGameId: number | null | undefined): Observable<UserGameRank[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserPlayGameScoreRank?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (deviceActivityGameId !== undefined)
            url_ += "deviceActivityGameId=" + encodeURIComponent("" + deviceActivityGameId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPlayGameScoreRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPlayGameScoreRank(<any>response_);
                } catch (e) {
                    return <Observable<UserGameRank[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGameRank[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPlayGameScoreRank(response: HttpResponseBase): Observable<UserGameRank[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserGameRank.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserGameRank[]>(<any>null);
    }

    /**
     * @param securityKeys (optional) 
     * @param openId (optional) 
     * @return Success
     */
    getActivityActionsForNextGame(securityKeys: string[] | null | undefined, openId: string | null | undefined): Observable<GetActivityActionsForNextGameDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityActionsForNextGame?";
        if (securityKeys !== undefined)
            securityKeys && securityKeys.forEach(item => { url_ += "securityKeys=" + encodeURIComponent("" + item) + "&"; });
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityActionsForNextGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityActionsForNextGame(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityActionsForNextGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityActionsForNextGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityActionsForNextGame(response: HttpResponseBase): Observable<GetActivityActionsForNextGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetActivityActionsForNextGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityActionsForNextGameDto>(<any>null);
    }

    /**
     * @param securityKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityGameUserActions(securityKey: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameUserActions?";
        if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionDto>(<any>null);
    }

    /**
     * @param securityKeys (optional) 
     * @return Success
     */
    getLastPlayedUserInfos(securityKeys: string[] | null | undefined): Observable<GetLastPlayedUserInfosDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetLastPlayedUserInfos?";
        if (securityKeys !== undefined)
            securityKeys && securityKeys.forEach(item => { url_ += "securityKeys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastPlayedUserInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastPlayedUserInfos(<any>response_);
                } catch (e) {
                    return <Observable<GetLastPlayedUserInfosDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLastPlayedUserInfosDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastPlayedUserInfos(response: HttpResponseBase): Observable<GetLastPlayedUserInfosDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetLastPlayedUserInfosDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLastPlayedUserInfosDto[]>(<any>null);
    }

    /**
     * @param snsType (optional) 
     * @param params (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    getMyPersonDataInActivity(openId: string, snsType: SnsType4 | null | undefined, securityKey: string, params: string | null | undefined, actionId: number | null | undefined): Observable<ActivityUserDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyPersonDataInActivity?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPersonDataInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPersonDataInActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityUserDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityUserDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyPersonDataInActivity(response: HttpResponseBase): Observable<ActivityUserDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityUserDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityUserDataOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateMyPersonData(input: AddOrUpdateActivityUserInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/AddOrUpdateMyPersonData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMyPersonData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMyPersonData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMyPersonData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    mySignInActivity(input: SnsUserSimpleDataInput | null | undefined): Observable<ActivityUserDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/MySignInActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMySignInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMySignInActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityUserDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityUserDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processMySignInActivity(response: HttpResponseBase): Observable<ActivityUserDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityUserDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityUserDataOutput>(<any>null);
    }

    /**
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityChattingRecords(securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityChattingRecords?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityChattingRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityChattingRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityChattingRecords(response: HttpResponseBase): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserRoomMessageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserRoomMessageOutput>(<any>null);
    }

    /**
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityGameChattingRecords(securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameChattingRecords?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameChattingRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameChattingRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameChattingRecords(response: HttpResponseBase): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserRoomMessageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserRoomMessageOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTextMessageByUser(input: SnsUserTextDataInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/SendTextMessageByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTextMessageByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTextMessageByUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSendTextMessageByUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getFaceRecognizeResult(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetFaceRecognizeResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceRecognizeResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceRecognizeResult(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetFaceRecognizeResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateSnsUserInfo(input: AddOrUpdateSnsUserInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/AddOrUpdateSnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateSnsUserInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createQrCode4Login(input: Qrcode4LoginInput | null | undefined): Observable<QrcodeOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/CreateQrCode4Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQrCode4Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQrCode4Login(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQrCode4Login(response: HttpResponseBase): Observable<QrcodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeOutput>(<any>null);
    }

    /**
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getScanQrCodeUsers(qrcodeId: number, securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetScanQrCodeUsers?";
        if (qrcodeId === undefined || qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' must be defined and cannot be null.");
        else
            url_ += "QrcodeId=" + encodeURIComponent("" + qrcodeId) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScanQrCodeUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScanQrCodeUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetScanQrCodeUsers(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserInfoOutput>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getUserActionById(actionId: number, securityKey: string, params: string | null | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionById?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionById(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getScanQrCodeUserActions(qrcodeId: number, securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetScanQrCodeUserActions?";
        if (qrcodeId === undefined || qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' must be defined and cannot be null.");
        else
            url_ += "QrcodeId=" + encodeURIComponent("" + qrcodeId) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScanQrCodeUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScanQrCodeUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetScanQrCodeUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getUserActionsByActivity(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionsByActivity?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getUserActionsByActivityGame(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionsByActivityGame?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsByActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsByActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsByActivityGame(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDataUsers(isGameLevel: boolean | null | undefined, securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityDataUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDataUsers?";
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityDataUserOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityDataUserOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataUsers(response: HttpResponseBase): Observable<PagedResultDtoOfActivityDataUserOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityDataUserOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityDataUserOutput>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getRankedUsersWithActionByActivity(rankColumn: string, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, isGameLevel: boolean | null | undefined, securityKey: string, softwareCode: string | null | undefined, clientId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetRankedUsersWithActionByActivity?";
        if (rankColumn === undefined || rankColumn === null)
            throw new Error("The parameter 'rankColumn' must be defined and cannot be null.");
        else
            url_ += "RankColumn=" + encodeURIComponent("" + rankColumn) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&"; 
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRankedUsersWithActionByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRankedUsersWithActionByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRankedUsersWithActionByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * @param isGameLevel (optional) 
     * @param snsType (optional) 
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyAwardsInActivity(isGameLevel: boolean | null | undefined, openId: string, snsType: SnsType5 | null | undefined, securityKey: string, params: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyAwardsInActivity?";
        if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&"; 
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAwardsInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAwardsInActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyAwardsInActivity(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserAwardOuput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    getAwardsByUserAndAction(openId: string, avatarUrl: string | null | undefined, actionId: number, score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType | null | undefined, snsType: SnsType6 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<SnsUserAwardsSimpleOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetAwardsByUserAndAction?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&"; 
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByUserAndAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByUserAndAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardsSimpleOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardsSimpleOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByUserAndAction(response: HttpResponseBase): Observable<SnsUserAwardsSimpleOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardsSimpleOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardsSimpleOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmUserAwardById(input: UserAwardDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ConfirmUserAwardById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUserAwardById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUserAwardById(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmUserAwardById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearActionAndAwardsByUser(input: ClearSnsUserDataInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ClearActionAndAwardsByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActionAndAwardsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActionAndAwardsByUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActionAndAwardsByUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param input (optional) 
     * @return Success
     */
    getWeChatLimitQrocdeTicket(token: string | null | undefined, input: GetLimitQrcodeByWechatInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetWeChatLimitQrocdeTicket?";
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeChatLimitQrocdeTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeChatLimitQrocdeTicket(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeChatLimitQrocdeTicket(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingWechatManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param weixinAppID (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param tagIds (optional) 
     * @param showTagResult (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMedias(subKey: string | null | undefined, weixinAppID: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, tagIds: number[] | null | undefined, showTagResult: boolean | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWechatMediaDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingWechatManage/GetWechatMedias?";
        if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&"; 
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (showTagResult !== undefined)
            url_ += "ShowTagResult=" + encodeURIComponent("" + showTagResult) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMedias(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMedias(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMediaDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMediaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMediaDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @return Success
     */
    getWeixinAccessToken(weixinAppID: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingWechatManage/GetWeixinAccessToken?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinAccessToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinAccessToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SnsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param weixinAccountId (optional) 
     * @return Success
     */
    setShopWeixinAccount(weixinAccountId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sns/SetShopWeixinAccount?";
        if (weixinAccountId !== undefined)
            url_ += "WeixinAccountId=" + encodeURIComponent("" + weixinAccountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetShopWeixinAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetShopWeixinAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetShopWeixinAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param from (optional) 
     * @return Success
     */
    getShopWSettings(from: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Sns/GetShopWSettings?";
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopWSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopWSettings(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopWSettings(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    mergeSnsUsers(input: MergeSnsUsersInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sns/MergeSnsUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeSnsUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeSnsUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeSnsUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SnsUserInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleSnsUserInfo(id: number | null | undefined): Observable<SnsUserInfoWithMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetSingleSnsUserInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSnsUserInfo(response: HttpResponseBase): Observable<SnsUserInfoWithMemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoWithMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoWithMemberDto>(<any>null);
    }

    /**
     * @param snsAppId (optional) 
     * @param memberId (optional) 
     * @param user (optional) 
     * @return Success
     */
    insertOrUpdateSnsUserInfo(snsAppId: string | null | undefined, memberId: number | null | undefined, user: OAuthUserInfo | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/InsertOrUpdateSnsUserInfo?";
        if (snsAppId !== undefined)
            url_ += "snsAppId=" + encodeURIComponent("" + snsAppId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateSnsUserInfo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getUserInfo(memberId: number | null | undefined, tenantId: number | null | undefined): Observable<SnsUserInfoWithMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetUserInfo?";
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<SnsUserInfoWithMemberDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoWithMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoWithMemberDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param openId (optional) 
     * @return Success
     */
    getUserInfoByOpenId(tenantId: number | null | undefined, openId: string | null | undefined): Observable<SnsUserInfo> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetUserInfoByOpenId?";
        if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfoByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfoByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfoByOpenId(response: HttpResponseBase): Observable<SnsUserInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfo>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    isManager(memberId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/IsManager?";
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsManager(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsManager(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class SpecialUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(activityId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetUsers?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfSpecailUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSpecailUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createUser(input: CreateSpecialUserInput | null | undefined): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUser(input: UpdateSpecialUserInput | null | undefined): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    deleteWhiteUser(activityId: number | null | undefined, ids: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/DeleteWhiteUser?";
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWhiteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWhiteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWhiteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWhiteInfoByUser(activityId: number, snsUserId: number): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetWhiteInfoByUser?";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (snsUserId === undefined || snsUserId === null)
            throw new Error("The parameter 'snsUserId' must be defined and cannot be null.");
        else
            url_ += "SnsUserId=" + encodeURIComponent("" + snsUserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWhiteInfoByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWhiteInfoByUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWhiteInfoByUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getBlackInfoByUser(activityId: number, snsUserId: number): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetBlackInfoByUser?";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (snsUserId === undefined || snsUserId === null)
            throw new Error("The parameter 'snsUserId' must be defined and cannot be null.");
        else
            url_ += "SnsUserId=" + encodeURIComponent("" + snsUserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlackInfoByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlackInfoByUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlackInfoByUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }
}

@Injectable()
export class StoreActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStoreActivitiesById(storeId: number, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/GetStoreActivitiesById?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined and cannot be null.");
        else
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreActivitiesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreActivitiesById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreActivitiesById(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceActivityDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByIdAndStoreId(deviceId: number, activityId: number, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/GetActivityGamesByIdAndStoreId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByIdAndStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByIdAndStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByIdAndStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createStoreActivityGame(input: CreateDeviceActivityGameInput | null | undefined): Observable<StoreActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/CreateStoreActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<StoreActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStoreActivityGame(response: HttpResponseBase): Observable<StoreActivityGame> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreActivityGame>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateStoreActivityGame(input: UpdateStoreActivityGameInput | null | undefined): Observable<StoreActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/UpdateStoreActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<StoreActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStoreActivityGame(response: HttpResponseBase): Observable<StoreActivityGame> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreActivityGame>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStoreActivityGame(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/DeleteStoreActivityGame?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStoreActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TemplateMessageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param weixinAppID (optional) 
     * @param openId (optional) 
     * @param orderId (optional) 
     * @param type (optional) 
     * @param templateData (optional) 
     * @return Success
     */
    sendTemplateMessage(tenantId: number | null | undefined, weixinAppID: string | null | undefined, openId: string | null | undefined, orderId: string | null | undefined, type: number | null | undefined, templateData: any | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TemplateMessage/SendTemplateMessage?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (weixinAppID !== undefined)
            url_ += "weixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(templateData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTemplateMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTemplateMessage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendTemplateMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTraining(input: CreateTrainingInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Training/CreateTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTraining(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTraining(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTraining(input: UpdateTrainingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/UpdateTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param trainingUserId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTrainings(id: number | null | undefined, auditStatus: AuditStatus2 | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, organizationUnitId: number | null | undefined, trainingCategory: TrainingCategory | null | undefined, trainingWay: TrainingWay | null | undefined, trainingStatus: TrainingStatus | null | undefined, trainingUserId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTrainingBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainings?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&"; 
        if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&"; 
        if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&"; 
        if (trainingUserId !== undefined)
            url_ += "TrainingUserId=" + encodeURIComponent("" + trainingUserId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainings(response: HttpResponseBase): Observable<PagedResultDtoOfTrainingBasicDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTrainingBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTrainingBasicDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyTrainings(id: number | null | undefined, auditStatus: AuditStatus3 | null | undefined, startTime: moment.Moment | null | undefined, organizationUnitId: number | null | undefined, trainingCategory: TrainingCategory2 | null | undefined, trainingWay: TrainingWay2 | null | undefined, trainingStatus: TrainingStatus2 | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTrainingBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetMyTrainings?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&"; 
        if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&"; 
        if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyTrainings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyTrainings(response: HttpResponseBase): Observable<PagedResultDtoOfTrainingBasicDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTrainingBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTrainingBasicDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartmentForSelect(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetDepartmentForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentForSelect(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentForSelect(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTraining(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/DeleteTraining?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    batchDeleteTraining(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/BatchDeleteTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    trainingAudit(input: TrainingAuditInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/TrainingAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrainingAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrainingAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTrainingAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param trainingUserId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTrainingsToExcel(id: number | null | undefined, auditStatus: AuditStatus4 | null | undefined, startTime: moment.Moment | null | undefined, organizationUnitId: number | null | undefined, trainingCategory: TrainingCategory3 | null | undefined, trainingWay: TrainingWay3 | null | undefined, trainingStatus: TrainingStatus3 | null | undefined, trainingUserId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainingsToExcel?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&"; 
        if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&"; 
        if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&"; 
        if (trainingUserId !== undefined)
            url_ += "TrainingUserId=" + encodeURIComponent("" + trainingUserId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    batchSetCourseTags(input: BatchSetCourseTagsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/BatchSetCourseTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchSetCourseTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchSetCourseTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchSetCourseTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    autoGenerateTrainingByTag(input: AutoGenerateTrainingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/AutoGenerateTrainingByTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoGenerateTrainingByTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoGenerateTrainingByTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAutoGenerateTrainingByTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkTraining(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/CheckTraining";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getTrainingBasicInfo(openId: string | null | undefined, tenantId: number | null | undefined): Observable<TrainingSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainingBasicInfo?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingBasicInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingBasicInfo(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingBasicInfo(response: HttpResponseBase): Observable<TrainingSimpleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSimpleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completeTraining(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/CompleteTraining?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getSingleTraining4Wechat(id: number | null | undefined, tenantId: number | null | undefined): Observable<SingleTrainingInfo> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetSingleTraining4Wechat?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleTraining4Wechat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleTraining4Wechat(<any>response_);
                } catch (e) {
                    return <Observable<SingleTrainingInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleTrainingInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleTraining4Wechat(response: HttpResponseBase): Observable<SingleTrainingInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleTrainingInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleTrainingInfo>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @return Success
     */
    getUserPapers4Wechat(openId: string | null | undefined, paperId: number | null | undefined, trainingId: number | null | undefined): Observable<GetUserPapers4WechatDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetUserPapers4Wechat?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (paperId !== undefined)
            url_ += "paperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPapers4Wechat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPapers4Wechat(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPapers4WechatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPapers4WechatDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPapers4Wechat(response: HttpResponseBase): Observable<GetUserPapers4WechatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPapers4WechatDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPapers4WechatDto>(<any>null);
    }
}

@Injectable()
export class TrainingListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param trainingListDtos (optional) 
     * @return Success
     */
    exportToFile(trainingListDtos: TrainingBasicDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingListExcelExporter/ExportToFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingListDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param qrcodeId (optional) 
     * @return Success
     */
    qrcode(qrcodeId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Qrcode?";
        if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQrcode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processQrcode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param gameId (optional) 
     * @param isShared (optional) 
     * @param openid (optional) 
     * @param needAuth (optional) 
     * @param isPostData (optional) 
     * @param weChatAuthorizationType (optional) 
     * @param from (optional) 
     * @return Success
     */
    action(actionId: number | null | undefined, gameId: number | null | undefined, isShared: boolean | null | undefined, openid: string | null | undefined, needAuth: boolean | null | undefined, isPostData: boolean | null | undefined, weChatAuthorizationType: WeChatAuthorizationType | null | undefined, from: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Action?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&"; 
        if (isShared !== undefined)
            url_ += "isShared=" + encodeURIComponent("" + isShared) + "&"; 
        if (openid !== undefined)
            url_ += "openid=" + encodeURIComponent("" + openid) + "&"; 
        if (needAuth !== undefined)
            url_ += "needAuth=" + encodeURIComponent("" + needAuth) + "&"; 
        if (isPostData !== undefined)
            url_ += "isPostData=" + encodeURIComponent("" + isPostData) + "&"; 
        if (weChatAuthorizationType !== undefined)
            url_ += "WeChatAuthorizationType=" + encodeURIComponent("" + weChatAuthorizationType) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param urlSource (optional) 
     * @param storeId (optional) 
     * @param deviceId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    weishop(tenantId: number | null | undefined, urlSource: string | null | undefined, storeId: string | null | undefined, deviceId: number | null | undefined, memberId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Weishop?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (urlSource !== undefined)
            url_ += "urlSource=" + encodeURIComponent("" + urlSource) + "&"; 
        if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&"; 
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeishop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeishop(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWeishop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param mediaIds (optional) 
     * @return Success
     */
    getWechatImg(tenantId: number | null | undefined, memberId: number | null | undefined, mediaIds: string[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/Transfer/GetWechatImg";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mediaIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatImg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatImg(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatImg(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    activity(): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Activity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param securitykey (optional) 
     * @param callBack (optional) 
     * @return Success
     */
    weChatAuthorize(securitykey: string | null | undefined, callBack: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/WeChatAuthorize?";
        if (securitykey !== undefined)
            url_ += "securitykey=" + encodeURIComponent("" + securitykey) + "&"; 
        if (callBack !== undefined)
            url_ += "callBack=" + encodeURIComponent("" + callBack) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeChatAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeChatAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWeChatAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserActionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param eventKey (optional) 
     * @return Success
     */
    getActionInfoGet(eventKey: string | null | undefined): Observable<ActionInfoDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfo?";
        if (eventKey !== undefined)
            url_ += "EventKey=" + encodeURIComponent("" + eventKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoGet(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoGet(response: HttpResponseBase): Observable<ActionInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoDto>(<any>null);
    }

    /**
     * @param eventKey (optional) 
     * @return Success
     */
    getActionInfoPost(eventKey: string | null | undefined): Observable<ActionInfoDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfo?";
        if (eventKey !== undefined)
            url_ += "EventKey=" + encodeURIComponent("" + eventKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoPost(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoPost(response: HttpResponseBase): Observable<ActionInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    getActionInfoById(actionId: number | null | undefined, securityKey: string | null | undefined): Observable<ActionInfoForOrderDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfoById?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoById(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoForOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoForOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoById(response: HttpResponseBase): Observable<ActionInfoForOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoForOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoForOrderDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateActivityPayRecord(input: ActivityPayRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserAction/AddOrUpdateActivityPayRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateActivityPayRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateActivityPayRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateActivityPayRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param payOrder (optional) 
     * @return Success
     */
    getActivityPayRecordByPayOrder(payOrder: string | null | undefined): Observable<ActivityPayRecord> {
        let url_ = this.baseUrl + "/api/UserAction/GetActivityPayRecordByPayOrder?";
        if (payOrder !== undefined)
            url_ += "payOrder=" + encodeURIComponent("" + payOrder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityPayRecordByPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityPayRecordByPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<ActivityPayRecord>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityPayRecord>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityPayRecordByPayOrder(response: HttpResponseBase): Observable<ActivityPayRecord> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityPayRecord.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityPayRecord>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcode(score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType2 | null | undefined, snsType: SnsType7 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcode?";
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcode(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcode(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param gameId (optional) 
     * @param targetUrl (optional) 
     * @return Success
     */
    createActionInform(gameId: number | null | undefined, targetUrl: string | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/CreateActionInform?";
        if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActionInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActionInform(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActionInform(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param openId (optional) 
     * @param gameId (optional) 
     * @return Success
     */
    snsConfirm(tenantId: number | null | undefined, openId: string | null | undefined, gameId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/UserAction/SnsConfirm?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSnsConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSnsConfirm(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSnsConfirm(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param gameID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSnsUserInform(gameID: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSnsUserQrcode> {
        let url_ = this.baseUrl + "/api/UserAction/GetSnsUserInform?";
        if (gameID !== undefined)
            url_ += "GameID=" + encodeURIComponent("" + gameID) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSnsUserInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSnsUserInform(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserQrcode>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserQrcode>><any>_observableThrow(response_);
        }));
    }

    protected processGetSnsUserInform(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserQrcode> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserQrcode.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserQrcode>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSnsUserInform(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserAction/DeleteSnsUserInform?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSnsUserInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSnsUserInform(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSnsUserInform(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeOnline(score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType3 | null | undefined, snsType: SnsType8 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeOnline?";
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeOnline(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeOnline(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeWithSeconds(score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType4 | null | undefined, snsType: SnsType9 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeWithSeconds?";
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeWithSeconds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeWithSeconds(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeWithSeconds(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeLimit(score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType5 | null | undefined, snsType: SnsType10 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeLimit?";
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeLimit(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeLimit(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param weChatAuthorizationType (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerDataWithAuthorizationType4ActionQrcode(score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, weChatAuthorizationType: WeChatAuthorizationType2 | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType6 | null | undefined, snsType: SnsType11 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerDataWithAuthorizationType4ActionQrcode?";
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (weChatAuthorizationType !== undefined)
            url_ += "WeChatAuthorizationType=" + encodeURIComponent("" + weChatAuthorizationType) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerDataWithAuthorizationType4ActionQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerDataWithAuthorizationType4ActionQrcode(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerDataWithAuthorizationType4ActionQrcode(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param extensionData (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    updateActionExtension(actionId: number, extensionData: string | null | undefined, securityKey: string | null | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/UpdateActionExtension?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActionExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActionExtension(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActionExtension(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerDataByAction(actionId: number, score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType7 | null | undefined, snsType: SnsType12 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerDataByAction?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerDataByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerDataByAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerDataByAction(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendCustomMessage(input: SendCustomMessageInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/SendCustomMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendCustomMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendCustomMessage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendCustomMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postDataByUser(openId: string, avatarUrl: string | null | undefined, actionId: number, score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType8 | null | undefined, snsType: SnsType13 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostDataByUser?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&"; 
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDataByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDataByUser(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostDataByUser(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postDataByUserForPoint(openId: string, avatarUrl: string | null | undefined, actionId: number, score: number | null | undefined, type: string | null | undefined, extensionData: string | null | undefined, fromType: string | null | undefined, snsUserInfoId: number | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType9 | null | undefined, snsType: SnsType14 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, playerImage: FileParameter | null | undefined, playingImage: FileParameter | null | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostDataByUserForPoint?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&"; 
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&"; 
        if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&"; 
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage !== null && playerImage !== undefined)
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage !== null && playingImage !== undefined)
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDataByUserForPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDataByUserForPoint(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostDataByUserForPoint(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param phone (optional) 
     * @param name (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param headerImage (optional) 
     * @return Success
     */
    registerFaceMemberWithForm(openId: string, avatarUrl: string | null | undefined, phone: string | null | undefined, name: string | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType10 | null | undefined, snsType: SnsType15 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined, headerImage: FileParameter | null | undefined): Observable<SnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/RegisterFaceMemberWithForm?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (headerImage !== null && headerImage !== undefined)
            content_.append("HeaderImage", headerImage.data, headerImage.fileName ? headerImage.fileName : "HeaderImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceMemberWithForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceMemberWithForm(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceMemberWithForm(response: HttpResponseBase): Observable<SnsUserInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param faceUrl (optional) 
     * @param phone (optional) 
     * @param name (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param qrType (optional) 
     * @param snsType (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @return Success
     */
    registerFaceMember(openId: string, avatarUrl: string | null | undefined, faceUrl: string | null | undefined, phone: string | null | undefined, name: string | null | undefined, isSendWeChatMsg: boolean | null | undefined, qrType: QrType11 | null | undefined, snsType: SnsType16 | null | undefined, targetUrl: string | null | undefined, isTransferred: boolean | null | undefined, securityKey: string, params: string | null | undefined): Observable<SnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/RegisterFaceMember?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&"; 
        if (faceUrl !== undefined)
            url_ += "FaceUrl=" + encodeURIComponent("" + faceUrl) + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&"; 
        if (qrType !== undefined)
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&"; 
        if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&"; 
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&"; 
        if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceMember(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceMember(response: HttpResponseBase): Observable<SnsUserInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoOutput>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    actionDataById(actionId: number | null | undefined): Observable<UserActionDataOutput> {
        let url_ = this.baseUrl + "/api/UserAction/ActionDataById?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActionDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActionDataById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processActionDataById(response: HttpResponseBase): Observable<UserActionDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDataOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGameImageBase64(input: GetGameImageBase64Input | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/UserAction/GetGameImageBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameImageBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameImageBase64(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetGameImageBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param neededData (optional) 
     * @return Success
     */
    queryNeededActionDataById(actionId: number | null | undefined, neededData: string[] | null | undefined): Observable<UserActionDataOutput> {
        let url_ = this.baseUrl + "/api/UserAction/QueryNeededActionDataById?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (neededData !== undefined)
            neededData && neededData.forEach(item => { url_ += "neededData=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryNeededActionDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryNeededActionDataById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processQueryNeededActionDataById(response: HttpResponseBase): Observable<UserActionDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDataOutput>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param openId (optional) 
     * @param snsType (optional) 
     * @return Success
     */
    likeAction(actionId: number | null | undefined, openId: string | null | undefined, snsType: SnsType17 | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/LikeAction?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "snsType=" + encodeURIComponent("" + snsType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLikeAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLikeAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processLikeAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param snsType (optional) 
     * @param shareType (optional) 
     * @return Success
     */
    shareAction(actionId: number, openId: string | null | undefined, snsType: SnsType18 | null | undefined, shareType: ShareType | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/ShareAction?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (shareType !== undefined)
            url_ += "ShareType=" + encodeURIComponent("" + shareType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShareAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShareAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processShareAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param openId (optional) 
     * @param snsType (optional) 
     * @return Success
     */
    viewAction(actionId: number | null | undefined, openId: string | null | undefined, snsType: SnsType19 | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/ViewAction?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (snsType !== undefined)
            url_ += "snsType=" + encodeURIComponent("" + snsType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processViewAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addSnsAndAction(input: AddSnsAndActionInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/UserAction/AddSnsAndAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSnsAndAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSnsAndAction(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddSnsAndAction(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserActions(snsUserInfoId: number | null | undefined, activityId: number | null | undefined, softwareId: number | null | undefined, deviceId: number | null | undefined, activityGameId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, snsType: SnsType20 | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUserActions?";
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionDto>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserActionsToExcel(snsUserInfoId: number | null | undefined, activityId: number | null | undefined, softwareId: number | null | undefined, deviceId: number | null | undefined, activityGameId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, snsType: SnsType21 | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUserActionsToExcel?";
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createUserAction(input: CreateUserActionInput | null | undefined): Observable<UserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/CreateUserAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserAction(response: HttpResponseBase): Observable<UserActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserAction(input: UpdateUserActionInput | null | undefined): Observable<UserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/UpdateUserAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserAction(response: HttpResponseBase): Observable<UserActionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDto>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsersAndActionsSum(snsUserInfoId: number | null | undefined, activityId: number | null | undefined, softwareId: number | null | undefined, deviceId: number | null | undefined, activityGameId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, snsType: SnsType22 | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSnsUserActionSumDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUsersAndActionsSum?";
        if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&"; 
        if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&"; 
        if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersAndActionsSum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersAndActionsSum(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserActionSumDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserActionSumDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersAndActionsSum(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserActionSumDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserActionSumDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserActionSumDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    makeUserToSpecial(input: MakeUserToSpecialInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/MakeUserToSpecial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeUserToSpecial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeUserToSpecial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeUserToSpecial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteUserAction(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/DeleteUserAction?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserAction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    getMemberInfoByActionId(actionId: number | null | undefined): Observable<SimpleMemberInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetMemberInfoByActionId?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfoByActionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfoByActionId(<any>response_);
                } catch (e) {
                    return <Observable<SimpleMemberInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleMemberInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfoByActionId(response: HttpResponseBase): Observable<SimpleMemberInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleMemberInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleMemberInfoDto>(<any>null);
    }
}

@Injectable()
export class UserPaperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param paperId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserPapers(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, paperId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetUserPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPapers?";
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPapers(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserPaperDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserPaperDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReport(paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerReport?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerReportDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperOpinionReport(paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPaperOpinionReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperOpinionReport?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperOpinionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperOpinionReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperOpinionReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperOpinionReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperOpinionReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperOpinionReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperOpinionReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperOpinionReportDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerCompetitionReport(paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerCompetitionReport?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerCompetitionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerCompetitionReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerCompetitionReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerCompetitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerCompetitionDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerInvestigateReport(paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerInvestigateReport?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerInvestigateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerInvestigateReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerInvestigateReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerInvestigateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerInvestigateDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReportToExcel(paperId: number | null | undefined, trainingId: number | null | undefined, userId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerReportToExcel?";
        if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&"; 
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleUserPaperDetail(id: number | null | undefined): Observable<SingleUserPaperDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetSingleUserPaperDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleUserPaperDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleUserPaperDetail(<any>response_);
                } catch (e) {
                    return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleUserPaperDetail(response: HttpResponseBase): Observable<SingleUserPaperDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserPaperDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleUserPaperDetailDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserPaperQuestionRep(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<UserPaperRep[]> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPaperQuestionRep?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaperQuestionRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaperQuestionRep(<any>response_);
                } catch (e) {
                    return <Observable<UserPaperRep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPaperRep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaperQuestionRep(response: HttpResponseBase): Observable<UserPaperRep[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPaperRep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPaperRep[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTakeAwardRep(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<TakeAwardRep[]> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetTakeAwardRep?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTakeAwardRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTakeAwardRep(<any>response_);
                } catch (e) {
                    return <Observable<TakeAwardRep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TakeAwardRep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTakeAwardRep(response: HttpResponseBase): Observable<TakeAwardRep[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TakeAwardRep.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TakeAwardRep[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserPaperListToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPaperListToExcel?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaperListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaperListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaperListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WechatManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMenus(weixinAppID: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWechatMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMenus?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMenus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMenus(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMenuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMenuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMenuDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatConditionalMenus(weixinAppID: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWechatMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatConditionalMenus?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatConditionalMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatConditionalMenus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatConditionalMenus(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMenuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMenuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMenuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWechatMenuDetail(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMenuDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMenuDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMenuDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMenuDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWechatConditionalMenuDetail(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatConditionalMenuDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatConditionalMenuDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatConditionalMenuDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatConditionalMenuDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateWechatMenu(input: AddOrUpdateMenuInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateWechatMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateWechatConditionalMenu(input: AddOrUpdateConditionalMenuInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateWechatConditionalMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWechatConditionalMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWechatConditionalMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWechatConditionalMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    activeWechatMenu(id: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ActiveWechatMenu?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processActiveWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    activeConditionalWechatMenu(id: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ActiveConditionalWechatMenu?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveConditionalWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveConditionalWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processActiveConditionalWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteWechatMenu(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteWechatMenu?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWechatMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteConditionalWechatMenu(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteConditionalWechatMenu?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteConditionalWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteConditionalWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteConditionalWechatMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMedias(weixinAppID: string, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, tagIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWechatMediaDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMedias?";
        if (weixinAppID === undefined || weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' must be defined and cannot be null.");
        else
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMedias(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMedias(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMediaDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMediaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMediaDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatTemplateMessages(weixinAppID: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWechatTemplateMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatTemplateMessages?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatTemplateMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatTemplateMessages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatTemplateMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatTemplateMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatTemplateMessages(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatTemplateMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatTemplateMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatTemplateMessageDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @return Success
     */
    syncWechatTemplateMessages(weixinAppID: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SyncWechatTemplateMessages?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncWechatTemplateMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncWechatTemplateMessages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncWechatTemplateMessages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param initial (optional) 
     * @return Success
     */
    syncMedias(weixinAppID: string | null | undefined, initial: boolean | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SyncMedias?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        if (initial !== undefined)
            url_ += "initial=" + encodeURIComponent("" + initial) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncMedias(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSyncMedias(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setMediaTags(input: SetMediaTagsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SetMediaTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMediaTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMediaTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetMediaTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMessageSeeds(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMessageSeedDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetMessageSeeds?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMessageSeedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMessageSeedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessageSeeds(response: HttpResponseBase): Observable<PagedResultDtoOfGetMessageSeedDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMessageSeedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMessageSeedDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateMessageSeed(input: AddOrUpdateMessageSeedInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateMessageSeed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMessageSeed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMessageSeed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMessageSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @return Success
     */
    applyMessageSeeds(weixinAppID: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ApplyMessageSeeds?";
        if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApplyMessageSeeds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    setWechatNotifier(memberId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SetWechatNotifier?";
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWechatNotifier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWechatNotifier(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetWechatNotifier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWechatNotifier(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatNotifier";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatNotifier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatNotifier(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatNotifier(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMessageSeeds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteMessageSeeds?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMessageSeeds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeiboServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(code: string | null | undefined, state: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weibo/CallBack?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param mediaId (optional) 
     * @param activityId (optional) 
     * @return Success
     */
    getMedia(mediaId: string | null | undefined, activityId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/GetMedia?";
        if (mediaId !== undefined)
            url_ += "mediaId=" + encodeURIComponent("" + mediaId) + "&"; 
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userAwardId (optional) 
     * @return Success
     */
    awardMessageNotify(userAwardId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/AwardMessageNotify?";
        if (userAwardId !== undefined)
            url_ += "userAwardId=" + encodeURIComponent("" + userAwardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardMessageNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardMessageNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAwardMessageNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param fisrt (optional) 
     * @param remark (optional) 
     * @return Success
     */
    signInTemplateMessageNotify(actionId: number | null | undefined, fisrt: string | null | undefined, remark: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/SignInTemplateMessageNotify?";
        if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&"; 
        if (fisrt !== undefined)
            url_ += "fisrt=" + encodeURIComponent("" + fisrt) + "&"; 
        if (remark !== undefined)
            url_ += "remark=" + encodeURIComponent("" + remark) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignInTemplateMessageNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignInTemplateMessageNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignInTemplateMessageNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinJSSDKServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param appid (optional) 
     * @param openId (optional) 
     * @return Success
     */
    index(appid: string | null | undefined, openId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinJSSDK/Index?";
        if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param appid (optional) 
     * @param openId (optional) 
     * @param url (optional) 
     * @return Success
     */
    getWeChatJsViewModel(tenantId: number | null | undefined, appid: string | null | undefined, openId: string | null | undefined, url: string | null | undefined): Observable<WeChatJSViewModel> {
        let url_ = this.baseUrl + "/WeixinJSSDK/GetWeChatJsViewModel?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&"; 
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeChatJsViewModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeChatJsViewModel(<any>response_);
                } catch (e) {
                    return <Observable<WeChatJSViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatJSViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeChatJsViewModel(response: HttpResponseBase): Observable<WeChatJSViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeChatJSViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatJSViewModel>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param url (optional) 
     * @return Success
     */
    getWeishopJsViewModel(tenantId: number | null | undefined, memberId: number | null | undefined, url: string | null | undefined): Observable<WeChatJSViewModel> {
        let url_ = this.baseUrl + "/WeixinJSSDK/GetWeishopJsViewModel?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&"; 
        if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopJsViewModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopJsViewModel(<any>response_);
                } catch (e) {
                    return <Observable<WeChatJSViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatJSViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopJsViewModel(response: HttpResponseBase): Observable<WeChatJSViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeChatJSViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatJSViewModel>(<any>null);
    }
}

@Injectable()
export class WeixinMpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeixinMps(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfWeixinMpDto> {
        let url_ = this.baseUrl + "/api/services/app/WeixinMp/GetWeixinMps?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinMps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinMps(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWeixinMpDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWeixinMpDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinMps(response: HttpResponseBase): Observable<PagedResultDtoOfWeixinMpDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWeixinMpDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWeixinMpDto>(<any>null);
    }

    /**
     * @param weixinOpenPlatformId (optional) 
     * @return Success
     */
    getMpAuthorzieUrl(weixinOpenPlatformId: number | null | undefined): Observable<MpAuthorzieUrlDto> {
        let url_ = this.baseUrl + "/api/services/app/WeixinMp/GetMpAuthorzieUrl?";
        if (weixinOpenPlatformId !== undefined)
            url_ += "weixinOpenPlatformId=" + encodeURIComponent("" + weixinOpenPlatformId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMpAuthorzieUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMpAuthorzieUrl(<any>response_);
                } catch (e) {
                    return <Observable<MpAuthorzieUrlDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MpAuthorzieUrlDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMpAuthorzieUrl(response: HttpResponseBase): Observable<MpAuthorzieUrlDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MpAuthorzieUrlDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MpAuthorzieUrlDto>(<any>null);
    }
}

@Injectable()
export class WeixinOAuth2ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userActionId (optional) 
     * @param returnUrl (optional) 
     * @return Success
     */
    index(userActionId: number | null | undefined, returnUrl: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/Index?";
        if (userActionId !== undefined)
            url_ += "userActionId=" + encodeURIComponent("" + userActionId) + "&"; 
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @param returnUrl (optional) 
     * @return Success
     */
    userInfoCallback(code: string | null | undefined, state: string | null | undefined, returnUrl: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/UserInfoCallback?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInfoCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInfoCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserInfoCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @param returnUrl (optional) 
     * @return Success
     */
    baseCallback(code: string | null | undefined, state: string | null | undefined, returnUrl: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/BaseCallback?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaseCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaseCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBaseCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    callBackTest(): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/CallBackTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBackTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBackTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBackTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @param appid (optional) 
     * @return Success
     */
    callBack(code: string | null | undefined, state: string | null | undefined, appid: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/CallBack?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @param from (optional) 
     * @return Success
     */
    getLoginResult(code: string | null | undefined, state: string | null | undefined, from: string | null | undefined): Observable<WechatLoginResultDto> {
        let url_ = this.baseUrl + "/WeixinOAuth2/GetLoginResult?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginResult(<any>response_);
                } catch (e) {
                    return <Observable<WechatLoginResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WechatLoginResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginResult(response: HttpResponseBase): Observable<WechatLoginResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WechatLoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WechatLoginResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getWechatLoginUrl(): Observable<string> {
        let url_ = this.baseUrl + "/WeixinOAuth2/GetWechatLoginUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatLoginUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatLoginUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatLoginUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    testReturnUrl(): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/TestReturnUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestReturnUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestReturnUrl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestReturnUrl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinOpenPlatformServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getWeixinOpenPlatformList(): Observable<WeixinOpenPlatformDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeixinOpenPlatform/GetWeixinOpenPlatformList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinOpenPlatformList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinOpenPlatformList(<any>response_);
                } catch (e) {
                    return <Observable<WeixinOpenPlatformDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeixinOpenPlatformDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinOpenPlatformList(response: HttpResponseBase): Observable<WeixinOpenPlatformDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeixinOpenPlatformDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeixinOpenPlatformDto[]>(<any>null);
    }
}

export class ActivityBasicDto implements IActivityBasicDto {
    id!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    weChatAppID!: string | undefined;
    weixinPublicAccountInfoId!: number | undefined;
    externalAccessTokenInfoId!: number | undefined;
    taobaoSellerID!: string | undefined;
    organizer!: string | undefined;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean | undefined;
    iconPath!: string | undefined;
    ownerName!: string | undefined;
    isPublic!: boolean | undefined;
    contactor!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: ActivityBasicDtoAuditStatus | undefined;
    isMine!: boolean | undefined;
    organizationUnitId!: number | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean | undefined;
    isNeedValidate!: boolean | undefined;

    constructor(data?: IActivityBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.imagePath = data["imagePath"];
            this.address = data["address"];
            this.activityUrl = data["activityUrl"];
            this.activityLogoPath = data["activityLogoPath"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = data["weChatAppID"];
            this.weixinPublicAccountInfoId = data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = data["externalAccessTokenInfoId"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.organizer = data["organizer"];
            this.rules = data["rules"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = data["isTemplate"];
            this.iconPath = data["iconPath"];
            this.ownerName = data["ownerName"];
            this.isPublic = data["isPublic"];
            this.contactor = data["contactor"];
            this.contactorPhone = data["contactorPhone"];
            this.auditStatus = data["auditStatus"];
            this.isMine = data["isMine"];
            this.organizationUnitId = data["organizationUnitId"];
            this.description = data["description"];
            this.isNeedRegister = data["isNeedRegister"];
            this.isNeedValidate = data["isNeedValidate"];
        }
    }

    static fromJS(data: any): ActivityBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["organizer"] = this.organizer;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        return data; 
    }
}

export interface IActivityBasicDto {
    id: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    weChatAppID: string | undefined;
    weixinPublicAccountInfoId: number | undefined;
    externalAccessTokenInfoId: number | undefined;
    taobaoSellerID: string | undefined;
    organizer: string | undefined;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean | undefined;
    iconPath: string | undefined;
    ownerName: string | undefined;
    isPublic: boolean | undefined;
    contactor: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: ActivityBasicDtoAuditStatus | undefined;
    isMine: boolean | undefined;
    organizationUnitId: number | undefined;
    description: string | undefined;
    isNeedRegister: boolean | undefined;
    isNeedValidate: boolean | undefined;
}

export class ClearActivityUserDataInput implements IClearActivityUserDataInput {
    activityId!: number;
    snsUserInfoId!: number;

    constructor(data?: IClearActivityUserDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.snsUserInfoId = data["snsUserInfoId"];
        }
    }

    static fromJS(data: any): ClearActivityUserDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearActivityUserDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        return data; 
    }
}

export interface IClearActivityUserDataInput {
    activityId: number;
    snsUserInfoId: number;
}

export class PagedResultDtoOfActivityBasicDto implements IPagedResultDtoOfActivityBasicDto {
    totalCount!: number | undefined;
    items!: ActivityBasicDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ActivityBasicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityBasicDto {
    totalCount: number | undefined;
    items: ActivityBasicDto[] | undefined;
}

export class CreateBasicActivityInput implements ICreateBasicActivityInput {
    name!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    organizer!: string | undefined;
    ownerName!: string | undefined;
    address!: string | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean | undefined;
    isNeedValidate!: boolean | undefined;
    isPublic!: boolean | undefined;
    weChatAppID!: string | undefined;
    weixinPublicAccountInfoId!: number | undefined;
    externalAccessTokenInfoId!: number | undefined;
    taobaoSellerID!: string | undefined;
    rules!: string | undefined;
    activityLogoPath!: string | undefined;
    imagePath!: string | undefined;
    isTemplate!: boolean | undefined;
    auditStatus!: CreateBasicActivityInputAuditStatus | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ICreateBasicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.organizer = data["organizer"];
            this.ownerName = data["ownerName"];
            this.address = data["address"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.isNeedRegister = data["isNeedRegister"];
            this.isNeedValidate = data["isNeedValidate"];
            this.isPublic = data["isPublic"];
            this.weChatAppID = data["weChatAppID"];
            this.weixinPublicAccountInfoId = data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = data["externalAccessTokenInfoId"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.rules = data["rules"];
            this.activityLogoPath = data["activityLogoPath"];
            this.imagePath = data["imagePath"];
            this.isTemplate = data["isTemplate"];
            this.auditStatus = data["auditStatus"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateBasicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBasicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["organizer"] = this.organizer;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["isPublic"] = this.isPublic;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["rules"] = this.rules;
        data["activityLogoPath"] = this.activityLogoPath;
        data["imagePath"] = this.imagePath;
        data["isTemplate"] = this.isTemplate;
        data["auditStatus"] = this.auditStatus;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateBasicActivityInput {
    name: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    organizer: string | undefined;
    ownerName: string | undefined;
    address: string | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    description: string | undefined;
    isNeedRegister: boolean | undefined;
    isNeedValidate: boolean | undefined;
    isPublic: boolean | undefined;
    weChatAppID: string | undefined;
    weixinPublicAccountInfoId: number | undefined;
    externalAccessTokenInfoId: number | undefined;
    taobaoSellerID: string | undefined;
    rules: string | undefined;
    activityLogoPath: string | undefined;
    imagePath: string | undefined;
    isTemplate: boolean | undefined;
    auditStatus: CreateBasicActivityInputAuditStatus | undefined;
    organizationUnitId: number | undefined;
}

export class ActivityFromTemplateInput implements IActivityFromTemplateInput {
    id!: number | undefined;
    name!: string | undefined;
    isPublic!: boolean | undefined;
    isTemplate!: boolean | undefined;

    constructor(data?: IActivityFromTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isPublic = data["isPublic"];
            this.isTemplate = data["isTemplate"];
        }
    }

    static fromJS(data: any): ActivityFromTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFromTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isPublic"] = this.isPublic;
        data["isTemplate"] = this.isTemplate;
        return data; 
    }
}

export interface IActivityFromTemplateInput {
    id: number | undefined;
    name: string | undefined;
    isPublic: boolean | undefined;
    isTemplate: boolean | undefined;
}

export class UpdateBasicActivityInput implements IUpdateBasicActivityInput {
    id!: number | undefined;
    name!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    organizer!: string | undefined;
    ownerName!: string | undefined;
    address!: string | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean | undefined;
    isNeedValidate!: boolean | undefined;
    isPublic!: boolean | undefined;
    weChatAppID!: string | undefined;
    weixinPublicAccountInfoId!: number | undefined;
    externalAccessTokenInfoId!: number | undefined;
    taobaoSellerID!: string | undefined;
    rules!: string | undefined;
    activityLogoPath!: string | undefined;
    imagePath!: string | undefined;
    isTemplate!: boolean | undefined;
    auditStatus!: UpdateBasicActivityInputAuditStatus | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUpdateBasicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.organizer = data["organizer"];
            this.ownerName = data["ownerName"];
            this.address = data["address"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.isNeedRegister = data["isNeedRegister"];
            this.isNeedValidate = data["isNeedValidate"];
            this.isPublic = data["isPublic"];
            this.weChatAppID = data["weChatAppID"];
            this.weixinPublicAccountInfoId = data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = data["externalAccessTokenInfoId"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.rules = data["rules"];
            this.activityLogoPath = data["activityLogoPath"];
            this.imagePath = data["imagePath"];
            this.isTemplate = data["isTemplate"];
            this.auditStatus = data["auditStatus"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateBasicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBasicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["organizer"] = this.organizer;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["isPublic"] = this.isPublic;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["rules"] = this.rules;
        data["activityLogoPath"] = this.activityLogoPath;
        data["imagePath"] = this.imagePath;
        data["isTemplate"] = this.isTemplate;
        data["auditStatus"] = this.auditStatus;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateBasicActivityInput {
    id: number | undefined;
    name: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    organizer: string | undefined;
    ownerName: string | undefined;
    address: string | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    description: string | undefined;
    isNeedRegister: boolean | undefined;
    isNeedValidate: boolean | undefined;
    isPublic: boolean | undefined;
    weChatAppID: string | undefined;
    weixinPublicAccountInfoId: number | undefined;
    externalAccessTokenInfoId: number | undefined;
    taobaoSellerID: string | undefined;
    rules: string | undefined;
    activityLogoPath: string | undefined;
    imagePath: string | undefined;
    isTemplate: boolean | undefined;
    auditStatus: UpdateBasicActivityInputAuditStatus | undefined;
    organizationUnitId: number | undefined;
}

export class PublishEntitiesInput implements IPublishEntitiesInput {
    entityIds!: number[] | undefined;
    ouOrStoreOrDeviceList!: IdTypeDto[] | undefined;
    action!: string | undefined;

    constructor(data?: IPublishEntitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(data["ouOrStoreOrDeviceList"])) {
                this.ouOrStoreOrDeviceList = [] as any;
                for (let item of data["ouOrStoreOrDeviceList"])
                    this.ouOrStoreOrDeviceList!.push(IdTypeDto.fromJS(item));
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): PublishEntitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishEntitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouOrStoreOrDeviceList)) {
            data["ouOrStoreOrDeviceList"] = [];
            for (let item of this.ouOrStoreOrDeviceList)
                data["ouOrStoreOrDeviceList"].push(item.toJSON());
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishEntitiesInput {
    entityIds: number[] | undefined;
    ouOrStoreOrDeviceList: IdTypeDto[] | undefined;
    action: string | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number | undefined;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number | undefined;
    type: string | undefined;
}

export class ActivityAuditInput implements IActivityAuditInput {
    activityIds!: number[] | undefined;
    currentAuditStatus!: ActivityAuditInputCurrentAuditStatus | undefined;
    targetAuditStatus!: ActivityAuditInputTargetAuditStatus | undefined;

    constructor(data?: IActivityAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["activityIds"])) {
                this.activityIds = [] as any;
                for (let item of data["activityIds"])
                    this.activityIds!.push(item);
            }
            this.currentAuditStatus = data["currentAuditStatus"];
            this.targetAuditStatus = data["targetAuditStatus"];
        }
    }

    static fromJS(data: any): ActivityAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityIds)) {
            data["activityIds"] = [];
            for (let item of this.activityIds)
                data["activityIds"].push(item);
        }
        data["currentAuditStatus"] = this.currentAuditStatus;
        data["targetAuditStatus"] = this.targetAuditStatus;
        return data; 
    }
}

export interface IActivityAuditInput {
    activityIds: number[] | undefined;
    currentAuditStatus: ActivityAuditInputCurrentAuditStatus | undefined;
    targetAuditStatus: ActivityAuditInputTargetAuditStatus | undefined;
}

export class ActivityFlowDto implements IActivityFlowDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    activityId!: number | undefined;
    flowUrl!: string | undefined;
    flowType!: ActivityFlowDtoFlowType | undefined;
    isUseOutside!: boolean | undefined;
    htmlTemplateId!: number | undefined;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean | undefined;
    isHasRegister!: boolean | undefined;
    isRegisterInCurrPage!: boolean | undefined;
    isHasGame!: boolean | undefined;
    isHasGameResult!: boolean | undefined;
    isHasReward!: boolean | undefined;
    isHasVote!: boolean | undefined;
    insideHtml!: string | undefined;

    constructor(data?: IActivityFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.flowUrl = data["flowUrl"];
            this.flowType = data["flowType"];
            this.isUseOutside = data["isUseOutside"];
            this.htmlTemplateId = data["htmlTemplateId"];
            this.outsideLink = data["outsideLink"];
            this.isHasIntroduce = data["isHasIntroduce"];
            this.isHasRegister = data["isHasRegister"];
            this.isRegisterInCurrPage = data["isRegisterInCurrPage"];
            this.isHasGame = data["isHasGame"];
            this.isHasGameResult = data["isHasGameResult"];
            this.isHasReward = data["isHasReward"];
            this.isHasVote = data["isHasVote"];
            this.insideHtml = data["insideHtml"];
        }
    }

    static fromJS(data: any): ActivityFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        return data; 
    }
}

export interface IActivityFlowDto {
    id: number | undefined;
    tenantId: number | undefined;
    activityId: number | undefined;
    flowUrl: string | undefined;
    flowType: ActivityFlowDtoFlowType | undefined;
    isUseOutside: boolean | undefined;
    htmlTemplateId: number | undefined;
    outsideLink: string | undefined;
    isHasIntroduce: boolean | undefined;
    isHasRegister: boolean | undefined;
    isRegisterInCurrPage: boolean | undefined;
    isHasGame: boolean | undefined;
    isHasGameResult: boolean | undefined;
    isHasReward: boolean | undefined;
    isHasVote: boolean | undefined;
    insideHtml: string | undefined;
}

export class ActivityFlowSettingsInput implements IActivityFlowSettingsInput {
    id!: number | undefined;
    activityId!: number | undefined;
    flowUrl!: string | undefined;
    flowType!: ActivityFlowSettingsInputFlowType | undefined;
    htmlTemplateId!: number | undefined;
    isUseOutside!: boolean | undefined;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean | undefined;
    isHasRegister!: boolean | undefined;
    isRegisterInCurrPage!: boolean | undefined;
    isHasGame!: boolean | undefined;
    isHasGameResult!: boolean | undefined;
    isHasReward!: boolean | undefined;
    isHasVote!: boolean | undefined;
    insideHtml!: string | undefined;

    constructor(data?: IActivityFlowSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.flowUrl = data["flowUrl"];
            this.flowType = data["flowType"];
            this.htmlTemplateId = data["htmlTemplateId"];
            this.isUseOutside = data["isUseOutside"];
            this.outsideLink = data["outsideLink"];
            this.isHasIntroduce = data["isHasIntroduce"];
            this.isHasRegister = data["isHasRegister"];
            this.isRegisterInCurrPage = data["isRegisterInCurrPage"];
            this.isHasGame = data["isHasGame"];
            this.isHasGameResult = data["isHasGameResult"];
            this.isHasReward = data["isHasReward"];
            this.isHasVote = data["isHasVote"];
            this.insideHtml = data["insideHtml"];
        }
    }

    static fromJS(data: any): ActivityFlowSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["isUseOutside"] = this.isUseOutside;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        return data; 
    }
}

export interface IActivityFlowSettingsInput {
    id: number | undefined;
    activityId: number | undefined;
    flowUrl: string | undefined;
    flowType: ActivityFlowSettingsInputFlowType | undefined;
    htmlTemplateId: number | undefined;
    isUseOutside: boolean | undefined;
    outsideLink: string | undefined;
    isHasIntroduce: boolean | undefined;
    isHasRegister: boolean | undefined;
    isRegisterInCurrPage: boolean | undefined;
    isHasGame: boolean | undefined;
    isHasGameResult: boolean | undefined;
    isHasReward: boolean | undefined;
    isHasVote: boolean | undefined;
    insideHtml: string | undefined;
}

export class PagedResultDtoOfActivityGameDto implements IPagedResultDtoOfActivityGameDto {
    totalCount!: number | undefined;
    items!: ActivityGameDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityGameDto {
    totalCount: number | undefined;
    items: ActivityGameDto[] | undefined;
}

export class ActivityGameDto implements IActivityGameDto {
    name!: string | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    supportedPlayersCount!: number | undefined;
    softwareName!: string | undefined;
    gameType!: number | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: ActivityGameDtoWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: ActivityGameDtoTaobaoAuthorizationType | undefined;
    isSendWechatBeforeGame!: boolean | undefined;
    isSendWechatAfterGame!: boolean | undefined;
    isShareAction!: boolean | undefined;
    tenantId!: number | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    activityId!: number | undefined;
    actionShareId!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    afterGameMessageId!: number | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMsgBeforeGameDto | undefined;
    afterGameMessage!: SnsMsgAfterGameDto | undefined;
    actionShare!: ActionShareDto | undefined;
    extensionData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.softwareName = data["softwareName"];
            this.gameType = data["gameType"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.isSendWechatBeforeGame = data["isSendWechatBeforeGame"];
            this.isSendWechatAfterGame = data["isSendWechatAfterGame"];
            this.isShareAction = data["isShareAction"];
            this.tenantId = data["tenantId"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.activityId = data["activityId"];
            this.actionShareId = data["actionShareId"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.afterGameMessageId = data["afterGameMessageId"];
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMsgBeforeGameDto.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessage = data["afterGameMessage"] ? SnsMsgAfterGameDto.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.actionShare = data["actionShare"] ? ActionShareDto.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["softwareName"] = this.softwareName;
        data["gameType"] = this.gameType;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["isShareAction"] = this.isShareAction;
        data["tenantId"] = this.tenantId;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["actionShareId"] = this.actionShareId;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityGameDto {
    name: string | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    supportedPlayersCount: number | undefined;
    softwareName: string | undefined;
    gameType: number | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: ActivityGameDtoWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: ActivityGameDtoTaobaoAuthorizationType | undefined;
    isSendWechatBeforeGame: boolean | undefined;
    isSendWechatAfterGame: boolean | undefined;
    isShareAction: boolean | undefined;
    tenantId: number | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    activityId: number | undefined;
    actionShareId: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    afterGameMessageId: number | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMsgBeforeGameDto | undefined;
    afterGameMessage: SnsMsgAfterGameDto | undefined;
    actionShare: ActionShareDto | undefined;
    extensionData: string | undefined;
    id: number | undefined;
}

export class SnsMsgBeforeGameDto implements ISnsMsgBeforeGameDto {
    id!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: SnsMsgBeforeGameDtoWeChatType | undefined;
    htmlTemplateID!: number | undefined;

    constructor(data?: ISnsMsgBeforeGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
            this.weChatType = data["weChatType"];
            this.htmlTemplateID = data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): SnsMsgBeforeGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMsgBeforeGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ISnsMsgBeforeGameDto {
    id: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: SnsMsgBeforeGameDtoWeChatType | undefined;
    htmlTemplateID: number | undefined;
}

export class SnsMsgAfterGameDto implements ISnsMsgAfterGameDto {
    id!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: SnsMsgAfterGameDtoWeChatType | undefined;
    htmlTemplateID!: number | undefined;

    constructor(data?: ISnsMsgAfterGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
            this.weChatType = data["weChatType"];
            this.htmlTemplateID = data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): SnsMsgAfterGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMsgAfterGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ISnsMsgAfterGameDto {
    id: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: SnsMsgAfterGameDtoWeChatType | undefined;
    htmlTemplateID: number | undefined;
}

export class ActionShareDto implements IActionShareDto {
    id!: number | undefined;
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: ActionShareDtoActivityShareType | undefined;

    constructor(data?: IActionShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
        }
    }

    static fromJS(data: any): ActionShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActionShareDto {
    id: number | undefined;
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: ActionShareDtoActivityShareType | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class ActivityGameSettingsInput implements IActivityGameSettingsInput {
    activityId!: number | undefined;
    id!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    supportedPlayersCount!: number | undefined;
    weChatAuthorizationType!: ActivityGameSettingsInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: ActivityGameSettingsInputTaobaoAuthorizationType | undefined;
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMsgBeforeGameDto | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMsgAfterGameDto | undefined;
    isShareAction!: boolean | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActionShareDto | undefined;
    extensionData!: string | undefined;

    constructor(data?: IActivityGameSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.id = data["id"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMsgBeforeGameDto.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMsgAfterGameDto.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActionShareDto.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): ActivityGameSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IActivityGameSettingsInput {
    activityId: number | undefined;
    id: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    supportedPlayersCount: number | undefined;
    weChatAuthorizationType: ActivityGameSettingsInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: ActivityGameSettingsInputTaobaoAuthorizationType | undefined;
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMsgBeforeGameDto | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMsgAfterGameDto | undefined;
    isShareAction: boolean | undefined;
    actionShareId: number | undefined;
    actionShare: ActionShareDto | undefined;
    extensionData: string | undefined;
}

export class AwardSettingsDto implements IAwardSettingsDto {
    id!: number | undefined;
    isEnableWhiteUser!: boolean | undefined;
    isEnableBlackUser!: boolean | undefined;
    isAllowedRepeatAward!: boolean | undefined;
    repeatAwardDurations!: number | undefined;
    repeatAwardTimes!: number | undefined;
    isAllowedShareGetLotteryTimes!: boolean | undefined;
    shareDurations!: number | undefined;
    shareLotteryTimes!: number | undefined;
    isNeedAwardInfo!: boolean | undefined;
    isAwardType!: boolean | undefined;

    constructor(data?: IAwardSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isEnableWhiteUser = data["isEnableWhiteUser"];
            this.isEnableBlackUser = data["isEnableBlackUser"];
            this.isAllowedRepeatAward = data["isAllowedRepeatAward"];
            this.repeatAwardDurations = data["repeatAwardDurations"];
            this.repeatAwardTimes = data["repeatAwardTimes"];
            this.isAllowedShareGetLotteryTimes = data["isAllowedShareGetLotteryTimes"];
            this.shareDurations = data["shareDurations"];
            this.shareLotteryTimes = data["shareLotteryTimes"];
            this.isNeedAwardInfo = data["isNeedAwardInfo"];
            this.isAwardType = data["isAwardType"];
        }
    }

    static fromJS(data: any): AwardSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["repeatAwardDurations"] = this.repeatAwardDurations;
        data["repeatAwardTimes"] = this.repeatAwardTimes;
        data["isAllowedShareGetLotteryTimes"] = this.isAllowedShareGetLotteryTimes;
        data["shareDurations"] = this.shareDurations;
        data["shareLotteryTimes"] = this.shareLotteryTimes;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isAwardType"] = this.isAwardType;
        return data; 
    }
}

export interface IAwardSettingsDto {
    id: number | undefined;
    isEnableWhiteUser: boolean | undefined;
    isEnableBlackUser: boolean | undefined;
    isAllowedRepeatAward: boolean | undefined;
    repeatAwardDurations: number | undefined;
    repeatAwardTimes: number | undefined;
    isAllowedShareGetLotteryTimes: boolean | undefined;
    shareDurations: number | undefined;
    shareLotteryTimes: number | undefined;
    isNeedAwardInfo: boolean | undefined;
    isAwardType: boolean | undefined;
}

export class PagedResultDtoOfActivityAwardDto implements IPagedResultDtoOfActivityAwardDto {
    totalCount!: number | undefined;
    items!: ActivityAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ActivityAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityAwardDto {
    totalCount: number | undefined;
    items: ActivityAwardDto[] | undefined;
}

export class ActivityAwardDto implements IActivityAwardDto {
    activityId!: number | undefined;
    awardId!: number | undefined;
    awardName!: string | undefined;
    activityName!: string | undefined;
    awardIcon!: string | undefined;
    awardPicUrl!: string | undefined;
    awardCouponUrl!: string | undefined;
    awardThingType!: ActivityAwardDtoAwardThingType | undefined;

    constructor(data?: IActivityAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.awardId = data["awardId"];
            this.awardName = data["awardName"];
            this.activityName = data["activityName"];
            this.awardIcon = data["awardIcon"];
            this.awardPicUrl = data["awardPicUrl"];
            this.awardCouponUrl = data["awardCouponUrl"];
            this.awardThingType = data["awardThingType"];
        }
    }

    static fromJS(data: any): ActivityAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["awardId"] = this.awardId;
        data["awardName"] = this.awardName;
        data["activityName"] = this.activityName;
        data["awardIcon"] = this.awardIcon;
        data["awardPicUrl"] = this.awardPicUrl;
        data["awardCouponUrl"] = this.awardCouponUrl;
        data["awardThingType"] = this.awardThingType;
        return data; 
    }
}

export interface IActivityAwardDto {
    activityId: number | undefined;
    awardId: number | undefined;
    awardName: string | undefined;
    activityName: string | undefined;
    awardIcon: string | undefined;
    awardPicUrl: string | undefined;
    awardCouponUrl: string | undefined;
    awardThingType: ActivityAwardDtoAwardThingType | undefined;
}

export class PagedResultDtoOfUserAwardDto implements IPagedResultDtoOfUserAwardDto {
    totalCount!: number | undefined;
    items!: UserAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserAwardDto {
    totalCount: number | undefined;
    items: UserAwardDto[] | undefined;
}

export class UserAwardDto implements IUserAwardDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    headimgurl!: string | undefined;
    nickname!: string | undefined;
    snsAppName!: string | undefined;
    securityCode!: string | undefined;
    awardSeq!: number | undefined;
    name!: string | undefined;
    isConfirmed!: boolean | undefined;
    isNotified!: boolean | undefined;
    isReceived!: boolean | undefined;
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    gameName!: string | undefined;

    constructor(data?: IUserAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.headimgurl = data["headimgurl"];
            this.nickname = data["nickname"];
            this.snsAppName = data["snsAppName"];
            this.securityCode = data["securityCode"];
            this.awardSeq = data["awardSeq"];
            this.name = data["name"];
            this.isConfirmed = data["isConfirmed"];
            this.isNotified = data["isNotified"];
            this.isReceived = data["isReceived"];
            this.expressNO = data["expressNO"];
            this.expressCompany = data["expressCompany"];
            this.gameName = data["gameName"];
        }
    }

    static fromJS(data: any): UserAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["headimgurl"] = this.headimgurl;
        data["nickname"] = this.nickname;
        data["snsAppName"] = this.snsAppName;
        data["securityCode"] = this.securityCode;
        data["awardSeq"] = this.awardSeq;
        data["name"] = this.name;
        data["isConfirmed"] = this.isConfirmed;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["gameName"] = this.gameName;
        return data; 
    }
}

export interface IUserAwardDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    headimgurl: string | undefined;
    nickname: string | undefined;
    snsAppName: string | undefined;
    securityCode: string | undefined;
    awardSeq: number | undefined;
    name: string | undefined;
    isConfirmed: boolean | undefined;
    isNotified: boolean | undefined;
    isReceived: boolean | undefined;
    expressNO: string | undefined;
    expressCompany: string | undefined;
    gameName: string | undefined;
}

export class UpdateSnsUserAwardExpressInput implements IUpdateSnsUserAwardExpressInput {
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUpdateSnsUserAwardExpressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expressNO = data["expressNO"];
            this.expressCompany = data["expressCompany"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UpdateSnsUserAwardExpressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSnsUserAwardExpressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateSnsUserAwardExpressInput {
    expressNO: string | undefined;
    expressCompany: string | undefined;
    id: number | undefined;
}

export class AwardMessageSettingsDto implements IAwardMessageSettingsDto {
    id!: number | undefined;
    htmlTemplateID!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;

    constructor(data?: IAwardMessageSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.htmlTemplateID = data["htmlTemplateID"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
        }
    }

    static fromJS(data: any): AwardMessageSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardMessageSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        return data; 
    }
}

export interface IAwardMessageSettingsDto {
    id: number | undefined;
    htmlTemplateID: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
}

export class AwardMessageSettingsInput implements IAwardMessageSettingsInput {
    activityId!: number | undefined;
    id!: number | undefined;
    htmlTemplateID!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;

    constructor(data?: IAwardMessageSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.id = data["id"];
            this.htmlTemplateID = data["htmlTemplateID"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
        }
    }

    static fromJS(data: any): AwardMessageSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardMessageSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["id"] = this.id;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        return data; 
    }
}

export interface IAwardMessageSettingsInput {
    activityId: number | undefined;
    id: number | undefined;
    htmlTemplateID: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
}

export class ActivityShareSettingsDto implements IActivityShareSettingsDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: ActivityShareSettingsDtoActivityShareType | undefined;

    constructor(data?: IActivityShareSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
        }
    }

    static fromJS(data: any): ActivityShareSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActivityShareSettingsDto {
    id: number | undefined;
    tenantId: number | undefined;
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: ActivityShareSettingsDtoActivityShareType | undefined;
}

export class ActivityShareSettingsInput implements IActivityShareSettingsInput {
    id!: number | undefined;
    activityId!: number | undefined;
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: ActivityShareSettingsInputActivityShareType | undefined;

    constructor(data?: IActivityShareSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
        }
    }

    static fromJS(data: any): ActivityShareSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActivityShareSettingsInput {
    id: number | undefined;
    activityId: number | undefined;
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: ActivityShareSettingsInputActivityShareType | undefined;
}

export class PagedResultDtoOfActivityUserDataDto implements IPagedResultDtoOfActivityUserDataDto {
    totalCount!: number | undefined;
    items!: ActivityUserDataDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityUserDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ActivityUserDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityUserDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityUserDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityUserDataDto {
    totalCount: number | undefined;
    items: ActivityUserDataDto[] | undefined;
}

export class ActivityUserDataDto implements IActivityUserDataDto {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoDto | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    isSigned!: boolean | undefined;
    isValidated!: boolean | undefined;
    isRegistered!: boolean | undefined;
    isGamed!: boolean | undefined;
    deviceActivityId!: number | undefined;
    dispatchedActivityId!: number | undefined;
    userActionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivityUserDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoDto.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.name = data["name"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.isSigned = data["isSigned"];
            this.isValidated = data["isValidated"];
            this.isRegistered = data["isRegistered"];
            this.isGamed = data["isGamed"];
            this.deviceActivityId = data["deviceActivityId"];
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.userActionId = data["userActionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityUserDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityUserDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["isSigned"] = this.isSigned;
        data["isValidated"] = this.isValidated;
        data["isRegistered"] = this.isRegistered;
        data["isGamed"] = this.isGamed;
        data["deviceActivityId"] = this.deviceActivityId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["userActionId"] = this.userActionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityUserDataDto {
    tenantId: number | undefined;
    activityId: number | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoDto | undefined;
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    isSigned: boolean | undefined;
    isValidated: boolean | undefined;
    isRegistered: boolean | undefined;
    isGamed: boolean | undefined;
    deviceActivityId: number | undefined;
    dispatchedActivityId: number | undefined;
    userActionId: number | undefined;
    id: number | undefined;
}

export class SnsUserInfoDto implements ISnsUserInfoDto {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    isBecomeFans!: boolean | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoDtoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.isBecomeFans = data["isBecomeFans"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
            this.memberId = data["memberId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoDto {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    isBecomeFans: boolean | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoDtoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number | undefined;
}

export class DoClearActivityDataInput implements IDoClearActivityDataInput {
    activityId!: number;
    isClearAction!: boolean | undefined;
    isClearUserData!: boolean | undefined;
    isClearAward!: boolean | undefined;

    constructor(data?: IDoClearActivityDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.isClearAction = data["isClearAction"];
            this.isClearUserData = data["isClearUserData"];
            this.isClearAward = data["isClearAward"];
        }
    }

    static fromJS(data: any): DoClearActivityDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoClearActivityDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        return data; 
    }
}

export interface IDoClearActivityDataInput {
    activityId: number;
    isClearAction: boolean | undefined;
    isClearUserData: boolean | undefined;
    isClearAward: boolean | undefined;
}

export class PagedResultDtoOfApplyFormDto implements IPagedResultDtoOfApplyFormDto {
    totalCount!: number | undefined;
    items!: ApplyFormDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplyFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApplyFormDto {
    totalCount: number | undefined;
    items: ApplyFormDto[] | undefined;
}

export class ApplyFormDto implements IApplyFormDto {
    reason!: string | undefined;
    applyStatus!: string | undefined;
    applyType!: string | undefined;
    wanted!: string | undefined;
    resultMessage!: string | undefined;
    applyUserName!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
            this.applyStatus = data["applyStatus"];
            this.applyType = data["applyType"];
            this.wanted = data["wanted"];
            this.resultMessage = data["resultMessage"];
            this.applyUserName = data["applyUserName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyStatus"] = this.applyStatus;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        data["resultMessage"] = this.resultMessage;
        data["applyUserName"] = this.applyUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplyFormDto {
    reason: string | undefined;
    applyStatus: string | undefined;
    applyType: string | undefined;
    wanted: string | undefined;
    resultMessage: string | undefined;
    applyUserName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateApplyFormInput implements ICreateApplyFormInput {
    reason!: string | undefined;
    applyType!: CreateApplyFormInputApplyType | undefined;
    wanted!: CreateApplyFormInputWanted | undefined;
    itemids!: number[] | undefined;
    options!: string | undefined;

    constructor(data?: ICreateApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
            this.applyType = data["applyType"];
            this.wanted = data["wanted"];
            if (Array.isArray(data["itemids"])) {
                this.itemids = [] as any;
                for (let item of data["itemids"])
                    this.itemids!.push(item);
            }
            this.options = data["options"];
        }
    }

    static fromJS(data: any): CreateApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        if (Array.isArray(this.itemids)) {
            data["itemids"] = [];
            for (let item of this.itemids)
                data["itemids"].push(item);
        }
        data["options"] = this.options;
        return data; 
    }
}

export interface ICreateApplyFormInput {
    reason: string | undefined;
    applyType: CreateApplyFormInputApplyType | undefined;
    wanted: CreateApplyFormInputWanted | undefined;
    itemids: number[] | undefined;
    options: string | undefined;
}

export class AuditApplyFormInput implements IAuditApplyFormInput {
    applyFormId!: number | undefined;
    applyStatus!: AuditApplyFormInputApplyStatus | undefined;
    resultMessage!: string | undefined;

    constructor(data?: IAuditApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applyFormId = data["applyFormId"];
            this.applyStatus = data["applyStatus"];
            this.resultMessage = data["resultMessage"];
        }
    }

    static fromJS(data: any): AuditApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applyFormId"] = this.applyFormId;
        data["applyStatus"] = this.applyStatus;
        data["resultMessage"] = this.resultMessage;
        return data; 
    }
}

export interface IAuditApplyFormInput {
    applyFormId: number | undefined;
    applyStatus: AuditApplyFormInputApplyStatus | undefined;
    resultMessage: string | undefined;
}

export class PagedResultDtoOfAwardDto implements IPagedResultDtoOfAwardDto {
    totalCount!: number | undefined;
    items!: AwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAwardDto {
    totalCount: number | undefined;
    items: AwardDto[] | undefined;
}

export class AwardDto implements IAwardDto {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    name!: string | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    isRandomAward!: boolean | undefined;
    description!: string | undefined;
    type!: AwardDtoType | undefined;
    couponUrl!: string | undefined;
    thingType!: AwardDtoThingType | undefined;
    thingId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.name = data["name"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.rate = data["rate"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.isRandomAward = data["isRandomAward"];
            this.description = data["description"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.thingType = data["thingType"];
            this.thingId = data["thingId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAwardDto {
    tenantId: number | undefined;
    activityId: number | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    name: string | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    isRandomAward: boolean | undefined;
    description: string | undefined;
    type: AwardDtoType | undefined;
    couponUrl: string | undefined;
    thingType: AwardDtoThingType | undefined;
    thingId: number | undefined;
    id: number | undefined;
}

export class CreateAwardInput implements ICreateAwardInput {
    activityId!: number | undefined;
    name!: string | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    rate!: number | undefined;
    description!: string | undefined;
    isRandomAward!: boolean | undefined;
    type!: CreateAwardInputType | undefined;
    couponUrl!: string | undefined;
    thingType!: CreateAwardInputThingType | undefined;
    thingId!: number | undefined;

    constructor(data?: ICreateAwardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.rate = data["rate"];
            this.description = data["description"];
            this.isRandomAward = data["isRandomAward"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.thingType = data["thingType"];
            this.thingId = data["thingId"];
        }
    }

    static fromJS(data: any): CreateAwardInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAwardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["isRandomAward"] = this.isRandomAward;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface ICreateAwardInput {
    activityId: number | undefined;
    name: string | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    rate: number | undefined;
    description: string | undefined;
    isRandomAward: boolean | undefined;
    type: CreateAwardInputType | undefined;
    couponUrl: string | undefined;
    thingType: CreateAwardInputThingType | undefined;
    thingId: number | undefined;
}

export class UpdateAwardInput implements IUpdateAwardInput {
    id!: number | undefined;
    activityId!: number | undefined;
    name!: string | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    rate!: number | undefined;
    description!: string | undefined;
    isRandomAward!: boolean | undefined;
    type!: UpdateAwardInputType | undefined;
    couponUrl!: string | undefined;
    thingType!: UpdateAwardInputThingType | undefined;
    thingId!: number | undefined;

    constructor(data?: IUpdateAwardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.rate = data["rate"];
            this.description = data["description"];
            this.isRandomAward = data["isRandomAward"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.thingType = data["thingType"];
            this.thingId = data["thingId"];
        }
    }

    static fromJS(data: any): UpdateAwardInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAwardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["isRandomAward"] = this.isRandomAward;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IUpdateAwardInput {
    id: number | undefined;
    activityId: number | undefined;
    name: string | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    rate: number | undefined;
    description: string | undefined;
    isRandomAward: boolean | undefined;
    type: UpdateAwardInputType | undefined;
    couponUrl: string | undefined;
    thingType: UpdateAwardInputThingType | undefined;
    thingId: number | undefined;
}

export class KeyValueDtoOfInt64 implements IKeyValueDtoOfInt64 {
    key!: number | undefined;
    value!: string | undefined;

    constructor(data?: IKeyValueDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValueDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValueDtoOfInt64 {
    key: number | undefined;
    value: string | undefined;
}

export class KeyValueDtoOfString implements IKeyValueDtoOfString {
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IKeyValueDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValueDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValueDtoOfString {
    key: string | undefined;
    value: string | undefined;
}

export class CreateCourseInput implements ICreateCourseInput {
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICreateCourseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.courseNo = data["courseNo"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): CreateCourseInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateCourseInput {
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class UpdateCourseInput implements IUpdateCourseInput {
    id!: number | undefined;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateCourseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.courseNo = data["courseNo"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateCourseInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateCourseInput {
    id: number | undefined;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class PagedResultDtoOfCourseDto implements IPagedResultDtoOfCourseDto {
    totalCount!: number | undefined;
    items!: CourseDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CourseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCourseDto {
    totalCount: number | undefined;
    items: CourseDto[] | undefined;
}

export class CourseDto implements ICourseDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.courseNo = data["courseNo"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): CourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICourseDto {
    id: number | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class PagedResultDtoOfDeviceActivityDto implements IPagedResultDtoOfDeviceActivityDto {
    totalCount!: number | undefined;
    items!: DeviceActivityDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DeviceActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceActivityDto {
    totalCount: number | undefined;
    items: DeviceActivityDto[] | undefined;
}

export class DeviceActivityDto implements IDeviceActivityDto {
    deviceId!: number | undefined;
    activityId!: number | undefined;
    activity!: ActivityBasicDto | undefined;
    dispatchedActivityId!: number | undefined;
    games!: DeviceActivityGameDto[] | undefined;

    constructor(data?: IDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? ActivityBasicDto.fromJS(data["activity"]) : <any>undefined;
            this.dispatchedActivityId = data["dispatchedActivityId"];
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(DeviceActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceActivityDto {
    deviceId: number | undefined;
    activityId: number | undefined;
    activity: ActivityBasicDto | undefined;
    dispatchedActivityId: number | undefined;
    games: DeviceActivityGameDto[] | undefined;
}

export class DeviceActivityGameDto implements IDeviceActivityGameDto {
    creationTime!: moment.Moment | undefined;
    name!: string | undefined;
    supportedPlayersCount!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;

    constructor(data?: IDeviceActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
        }
    }

    static fromJS(data: any): DeviceActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        return data; 
    }
}

export interface IDeviceActivityGameDto {
    creationTime: moment.Moment | undefined;
    name: string | undefined;
    supportedPlayersCount: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
}

export class CreateDeviceActivityGameInput implements ICreateDeviceActivityGameInput {
    deviceId!: number;
    activityId!: number;
    name!: string;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    supportedPlayersCount!: number | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: CreateDeviceActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: CreateDeviceActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessage!: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    afterGameMessage!: CreateSnsMsgGameInput | undefined;
    isShareAction!: boolean | undefined;
    actionShare!: CreateActionShareInput | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICreateDeviceActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShare = data["actionShare"] ? CreateActionShareInput.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): CreateDeviceActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateDeviceActivityGameInput {
    deviceId: number;
    activityId: number;
    name: string;
    softwareId: number;
    dispatchedSoftwareId: number;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    supportedPlayersCount: number | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: CreateDeviceActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: CreateDeviceActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessage: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    afterGameMessage: CreateSnsMsgGameInput | undefined;
    isShareAction: boolean | undefined;
    actionShare: CreateActionShareInput | undefined;
    extensionData: string | undefined;
}

export class CreateSnsMsgGameInput implements ICreateSnsMsgGameInput {
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: CreateSnsMsgGameInputWeChatType | undefined;
    htmlTemplateID!: number | undefined;

    constructor(data?: ICreateSnsMsgGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
            this.weChatType = data["weChatType"];
            this.htmlTemplateID = data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): CreateSnsMsgGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSnsMsgGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ICreateSnsMsgGameInput {
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: CreateSnsMsgGameInputWeChatType | undefined;
    htmlTemplateID: number | undefined;
}

export class CreateActionShareInput implements ICreateActionShareInput {
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: CreateActionShareInputActivityShareType | undefined;

    constructor(data?: ICreateActionShareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
        }
    }

    static fromJS(data: any): CreateActionShareInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionShareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface ICreateActionShareInput {
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: CreateActionShareInputActivityShareType | undefined;
}

export class DeviceActivityGame implements IDeviceActivityGame {
    dispatchedActivityId!: number | undefined;
    deviceId!: number | undefined;
    deviceActivityId!: number | undefined;
    deviceActivity!: DeviceActivity | undefined;
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    isShareAction!: boolean | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare | undefined;
    supportedPlayersCount!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: DeviceActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: DeviceActivityGameTaobaoAuthorizationType | undefined;
    extensionData!: string | undefined;
    points!: number | undefined;
    isAllowBlack!: boolean | undefined;
    isAllowWhite!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.deviceId = data["deviceId"];
            this.deviceActivityId = data["deviceActivityId"];
            this.deviceActivity = data["deviceActivity"] ? DeviceActivity.fromJS(data["deviceActivity"]) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActivityShare.fromJS(data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMessage.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMessage.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.extensionData = data["extensionData"];
            this.points = data["points"];
            this.isAllowBlack = data["isAllowBlack"];
            this.isAllowWhite = data["isAllowWhite"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["deviceId"] = this.deviceId;
        data["deviceActivityId"] = this.deviceActivityId;
        data["deviceActivity"] = this.deviceActivity ? this.deviceActivity.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["isAllowBlack"] = this.isAllowBlack;
        data["isAllowWhite"] = this.isAllowWhite;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGame {
    dispatchedActivityId: number | undefined;
    deviceId: number | undefined;
    deviceActivityId: number | undefined;
    deviceActivity: DeviceActivity | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    isShareAction: boolean | undefined;
    actionShareId: number | undefined;
    actionShare: ActivityShare | undefined;
    supportedPlayersCount: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: DeviceActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: DeviceActivityGameTaobaoAuthorizationType | undefined;
    extensionData: string | undefined;
    points: number | undefined;
    isAllowBlack: boolean | undefined;
    isAllowWhite: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DeviceActivity implements IDeviceActivity {
    deviceId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    dispatchedActivityId!: number | undefined;
    dispatchedActivity!: DispatchedActivity | undefined;
    games!: DeviceActivityGame[] | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.dispatchedActivity = data["dispatchedActivity"] ? DispatchedActivity.fromJS(data["dispatchedActivity"]) : <any>undefined;
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(DeviceActivityGame.fromJS(item));
            }
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["dispatchedActivity"] = this.dispatchedActivity ? this.dispatchedActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivity {
    deviceId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    dispatchedActivityId: number | undefined;
    dispatchedActivity: DispatchedActivity | undefined;
    games: DeviceActivityGame[] | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Activity implements IActivity {
    tenantId!: number | undefined;
    isAwardType!: boolean | undefined;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    isSendAwardMessage!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage | undefined;
    awardMessageId!: number | undefined;
    awardMessage!: SnsMessage | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    weixinShares!: SnsShare[] | undefined;
    awards!: Award[] | undefined;
    activityShareId!: number | undefined;
    activityShare!: ActivityShare | undefined;
    weixinPublicAccountInfoId!: number | undefined;
    weChatAppID!: string | undefined;
    externalAccessTokenInfoId!: number | undefined;
    taobaoSellerID!: string | undefined;
    alipayApplicationId!: number | undefined;
    alipayAppID!: string | undefined;
    douyinApplicationId!: number | undefined;
    douyinAppID!: string | undefined;
    weiboApplicationId!: number | undefined;
    weiboAppID!: string | undefined;
    isEnableWhiteUser!: boolean | undefined;
    isEnableBlackUser!: boolean | undefined;
    organizer!: string | undefined;
    isAllowedRepeatAward!: boolean | undefined;
    repeatAwardFrequency!: ActivityRepeatAwardFrequency | undefined;
    repeatAwardDurations!: number | undefined;
    repeatAwardTimes!: number | undefined;
    isAllowedShareGetLotteryTimes!: boolean | undefined;
    shareDurations!: number | undefined;
    shareLotteryTimes!: number | undefined;
    isNeedAwardInfo!: boolean | undefined;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean | undefined;
    iconPath!: string | undefined;
    description!: string | undefined;
    activityFlows!: ActivityFlow[] | undefined;
    isNeedRegister!: boolean | undefined;
    isNeedValidate!: boolean | undefined;
    ownerName!: string | undefined;
    isPublic!: boolean | undefined;
    contactor!: string | undefined;
    outerId!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: ActivityAuditStatus | undefined;
    games!: ActivityGame[] | undefined;
    type!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.isAwardType = data["isAwardType"];
            this.organizationUnitId = data["organizationUnitId"];
            this.name = data["name"];
            this.imagePath = data["imagePath"];
            this.address = data["address"];
            this.activityUrl = data["activityUrl"];
            this.activityLogoPath = data["activityLogoPath"];
            this.isSendAwardMessage = data["isSendAwardMessage"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMessage.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMessage.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.awardMessageId = data["awardMessageId"];
            this.awardMessage = data["awardMessage"] ? SnsMessage.fromJS(data["awardMessage"]) : <any>undefined;
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            if (Array.isArray(data["weixinShares"])) {
                this.weixinShares = [] as any;
                for (let item of data["weixinShares"])
                    this.weixinShares!.push(SnsShare.fromJS(item));
            }
            if (Array.isArray(data["awards"])) {
                this.awards = [] as any;
                for (let item of data["awards"])
                    this.awards!.push(Award.fromJS(item));
            }
            this.activityShareId = data["activityShareId"];
            this.activityShare = data["activityShare"] ? ActivityShare.fromJS(data["activityShare"]) : <any>undefined;
            this.weixinPublicAccountInfoId = data["weixinPublicAccountInfoId"];
            this.weChatAppID = data["weChatAppID"];
            this.externalAccessTokenInfoId = data["externalAccessTokenInfoId"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.alipayApplicationId = data["alipayApplicationId"];
            this.alipayAppID = data["alipayAppID"];
            this.douyinApplicationId = data["douyinApplicationId"];
            this.douyinAppID = data["douyinAppID"];
            this.weiboApplicationId = data["weiboApplicationId"];
            this.weiboAppID = data["weiboAppID"];
            this.isEnableWhiteUser = data["isEnableWhiteUser"];
            this.isEnableBlackUser = data["isEnableBlackUser"];
            this.organizer = data["organizer"];
            this.isAllowedRepeatAward = data["isAllowedRepeatAward"];
            this.repeatAwardFrequency = data["repeatAwardFrequency"];
            this.repeatAwardDurations = data["repeatAwardDurations"];
            this.repeatAwardTimes = data["repeatAwardTimes"];
            this.isAllowedShareGetLotteryTimes = data["isAllowedShareGetLotteryTimes"];
            this.shareDurations = data["shareDurations"];
            this.shareLotteryTimes = data["shareLotteryTimes"];
            this.isNeedAwardInfo = data["isNeedAwardInfo"];
            this.rules = data["rules"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = data["isTemplate"];
            this.iconPath = data["iconPath"];
            this.description = data["description"];
            if (Array.isArray(data["activityFlows"])) {
                this.activityFlows = [] as any;
                for (let item of data["activityFlows"])
                    this.activityFlows!.push(ActivityFlow.fromJS(item));
            }
            this.isNeedRegister = data["isNeedRegister"];
            this.isNeedValidate = data["isNeedValidate"];
            this.ownerName = data["ownerName"];
            this.isPublic = data["isPublic"];
            this.contactor = data["contactor"];
            this.outerId = data["outerId"];
            this.contactorPhone = data["contactorPhone"];
            this.auditStatus = data["auditStatus"];
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(ActivityGame.fromJS(item));
            }
            this.type = data["type"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isAwardType"] = this.isAwardType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["isSendAwardMessage"] = this.isSendAwardMessage;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["awardMessageId"] = this.awardMessageId;
        data["awardMessage"] = this.awardMessage ? this.awardMessage.toJSON() : <any>undefined;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        if (Array.isArray(this.weixinShares)) {
            data["weixinShares"] = [];
            for (let item of this.weixinShares)
                data["weixinShares"].push(item.toJSON());
        }
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        data["activityShareId"] = this.activityShareId;
        data["activityShare"] = this.activityShare ? this.activityShare.toJSON() : <any>undefined;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["weChatAppID"] = this.weChatAppID;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["alipayApplicationId"] = this.alipayApplicationId;
        data["alipayAppID"] = this.alipayAppID;
        data["douyinApplicationId"] = this.douyinApplicationId;
        data["douyinAppID"] = this.douyinAppID;
        data["weiboApplicationId"] = this.weiboApplicationId;
        data["weiboAppID"] = this.weiboAppID;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["organizer"] = this.organizer;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["repeatAwardFrequency"] = this.repeatAwardFrequency;
        data["repeatAwardDurations"] = this.repeatAwardDurations;
        data["repeatAwardTimes"] = this.repeatAwardTimes;
        data["isAllowedShareGetLotteryTimes"] = this.isAllowedShareGetLotteryTimes;
        data["shareDurations"] = this.shareDurations;
        data["shareLotteryTimes"] = this.shareLotteryTimes;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["description"] = this.description;
        if (Array.isArray(this.activityFlows)) {
            data["activityFlows"] = [];
            for (let item of this.activityFlows)
                data["activityFlows"].push(item.toJSON());
        }
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["outerId"] = this.outerId;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivity {
    tenantId: number | undefined;
    isAwardType: boolean | undefined;
    organizationUnitId: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    isSendAwardMessage: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage | undefined;
    awardMessageId: number | undefined;
    awardMessage: SnsMessage | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    weixinShares: SnsShare[] | undefined;
    awards: Award[] | undefined;
    activityShareId: number | undefined;
    activityShare: ActivityShare | undefined;
    weixinPublicAccountInfoId: number | undefined;
    weChatAppID: string | undefined;
    externalAccessTokenInfoId: number | undefined;
    taobaoSellerID: string | undefined;
    alipayApplicationId: number | undefined;
    alipayAppID: string | undefined;
    douyinApplicationId: number | undefined;
    douyinAppID: string | undefined;
    weiboApplicationId: number | undefined;
    weiboAppID: string | undefined;
    isEnableWhiteUser: boolean | undefined;
    isEnableBlackUser: boolean | undefined;
    organizer: string | undefined;
    isAllowedRepeatAward: boolean | undefined;
    repeatAwardFrequency: ActivityRepeatAwardFrequency | undefined;
    repeatAwardDurations: number | undefined;
    repeatAwardTimes: number | undefined;
    isAllowedShareGetLotteryTimes: boolean | undefined;
    shareDurations: number | undefined;
    shareLotteryTimes: number | undefined;
    isNeedAwardInfo: boolean | undefined;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean | undefined;
    iconPath: string | undefined;
    description: string | undefined;
    activityFlows: ActivityFlow[] | undefined;
    isNeedRegister: boolean | undefined;
    isNeedValidate: boolean | undefined;
    ownerName: string | undefined;
    isPublic: boolean | undefined;
    contactor: string | undefined;
    outerId: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: ActivityAuditStatus | undefined;
    games: ActivityGame[] | undefined;
    type: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActivityShare implements IActivityShare {
    tenantId!: number | undefined;
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: ActivityShareType | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivityShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityShare {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityShare {
    tenantId: number | undefined;
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: ActivityShareType | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SnsMessage implements ISnsMessage {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: SnsMessageWeChatType | undefined;
    htmlTemplateID!: number | undefined;
    htmlTemplate!: HtmlTemplate | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.title = data["title"];
            this.picUrl = data["picUrl"];
            this.url = data["url"];
            this.textMessage = data["textMessage"];
            this.weChatType = data["weChatType"];
            this.htmlTemplateID = data["htmlTemplateID"];
            this.htmlTemplate = data["htmlTemplate"] ? HtmlTemplate.fromJS(data["htmlTemplate"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsMessage {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: SnsMessageWeChatType | undefined;
    htmlTemplateID: number | undefined;
    htmlTemplate: HtmlTemplate | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DispatchedActivity implements IDispatchedActivity {
    organizationUnitId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    games!: DispatchedActivityGame[] | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDispatchedActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(DispatchedActivityGame.fromJS(item));
            }
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DispatchedActivity {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedActivity {
    organizationUnitId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    games: DispatchedActivityGame[] | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SnsShare implements ISnsShare {
    tenantId!: number | undefined;
    weixinShareType!: SnsShareWeixinShareType | undefined;
    shareAppMessageType!: string | undefined;
    shareAppMessageDataUrl!: string | undefined;
    userActionId!: number | undefined;
    userAction!: UserAction | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    snsUserAwardId!: number | undefined;
    snsUserAward!: SnsUserAward | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.weixinShareType = data["weixinShareType"];
            this.shareAppMessageType = data["shareAppMessageType"];
            this.shareAppMessageDataUrl = data["shareAppMessageDataUrl"];
            this.userActionId = data["userActionId"];
            this.userAction = data["userAction"] ? UserAction.fromJS(data["userAction"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.snsUserAwardId = data["snsUserAwardId"];
            this.snsUserAward = data["snsUserAward"] ? SnsUserAward.fromJS(data["snsUserAward"]) : <any>undefined;
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsShare {
        data = typeof data === 'object' ? data : {};
        let result = new SnsShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["weixinShareType"] = this.weixinShareType;
        data["shareAppMessageType"] = this.shareAppMessageType;
        data["shareAppMessageDataUrl"] = this.shareAppMessageDataUrl;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["snsUserAwardId"] = this.snsUserAwardId;
        data["snsUserAward"] = this.snsUserAward ? this.snsUserAward.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsShare {
    tenantId: number | undefined;
    weixinShareType: SnsShareWeixinShareType | undefined;
    shareAppMessageType: string | undefined;
    shareAppMessageDataUrl: string | undefined;
    userActionId: number | undefined;
    userAction: UserAction | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    snsUserAwardId: number | undefined;
    snsUserAward: SnsUserAward | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Award implements IAward {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    name!: string | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    isRandomAward!: boolean | undefined;
    description!: string | undefined;
    type!: AwardType | undefined;
    couponUrl!: string | undefined;
    thingType!: AwardThingType | undefined;
    thingId!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.name = data["name"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.rate = data["rate"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.isRandomAward = data["isRandomAward"];
            this.description = data["description"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.thingType = data["thingType"];
            this.thingId = data["thingId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Award {
        data = typeof data === 'object' ? data : {};
        let result = new Award();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAward {
    tenantId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    name: string | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    isRandomAward: boolean | undefined;
    description: string | undefined;
    type: AwardType | undefined;
    couponUrl: string | undefined;
    thingType: AwardThingType | undefined;
    thingId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActivityFlow implements IActivityFlow {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    flowUrl!: string | undefined;
    flowType!: ActivityFlowFlowType | undefined;
    isUseOutside!: boolean | undefined;
    htmlTemplateId!: number | undefined;
    htmlTemplate!: HtmlTemplate | undefined;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean | undefined;
    isHasRegister!: boolean | undefined;
    isRegisterInCurrPage!: boolean | undefined;
    isHasGame!: boolean | undefined;
    isHasGameResult!: boolean | undefined;
    isHasReward!: boolean | undefined;
    isHasVote!: boolean | undefined;
    insideHtml!: string | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivityFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.flowUrl = data["flowUrl"];
            this.flowType = data["flowType"];
            this.isUseOutside = data["isUseOutside"];
            this.htmlTemplateId = data["htmlTemplateId"];
            this.htmlTemplate = data["htmlTemplate"] ? HtmlTemplate.fromJS(data["htmlTemplate"]) : <any>undefined;
            this.outsideLink = data["outsideLink"];
            this.isHasIntroduce = data["isHasIntroduce"];
            this.isHasRegister = data["isHasRegister"];
            this.isRegisterInCurrPage = data["isRegisterInCurrPage"];
            this.isHasGame = data["isHasGame"];
            this.isHasGameResult = data["isHasGameResult"];
            this.isHasReward = data["isHasReward"];
            this.isHasVote = data["isHasVote"];
            this.insideHtml = data["insideHtml"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityFlow {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityFlow {
    tenantId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    flowUrl: string | undefined;
    flowType: ActivityFlowFlowType | undefined;
    isUseOutside: boolean | undefined;
    htmlTemplateId: number | undefined;
    htmlTemplate: HtmlTemplate | undefined;
    outsideLink: string | undefined;
    isHasIntroduce: boolean | undefined;
    isHasRegister: boolean | undefined;
    isRegisterInCurrPage: boolean | undefined;
    isHasGame: boolean | undefined;
    isHasGameResult: boolean | undefined;
    isHasReward: boolean | undefined;
    isHasVote: boolean | undefined;
    insideHtml: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActivityGame implements IActivityGame {
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    isShareAction!: boolean | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare | undefined;
    supportedPlayersCount!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: ActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: ActivityGameTaobaoAuthorizationType | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActivityShare.fromJS(data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMessage.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMessage.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.extensionData = data["extensionData"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityGame {
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    isShareAction: boolean | undefined;
    actionShareId: number | undefined;
    actionShare: ActivityShare | undefined;
    supportedPlayersCount: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: ActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: ActivityGameTaobaoAuthorizationType | undefined;
    extensionData: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class HtmlTemplate implements IHtmlTemplate {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    args!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: HtmlTemplateTemplateType | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IHtmlTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.thumbnail = data["thumbnail"];
            this.bigImage = data["bigImage"];
            this.actionUrl = data["actionUrl"];
            this.args = data["args"];
            this.title = data["title"];
            this.logo = data["logo"];
            this.backgroundImage = data["backgroundImage"];
            this.templateType = data["templateType"];
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["args"] = this.args;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplate {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    args: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: HtmlTemplateTemplateType | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DispatchedActivityGame implements IDispatchedActivityGame {
    organizationUnitId!: number | undefined;
    dispatchedActivityId!: number | undefined;
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    isShareAction!: boolean | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare | undefined;
    supportedPlayersCount!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: DispatchedActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: DispatchedActivityGameTaobaoAuthorizationType | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDispatchedActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActivityShare.fromJS(data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMessage.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMessage.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DispatchedActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedActivityGame {
    organizationUnitId: number | undefined;
    dispatchedActivityId: number | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    isShareAction: boolean | undefined;
    actionShareId: number | undefined;
    actionShare: ActivityShare | undefined;
    supportedPlayersCount: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: DispatchedActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: DispatchedActivityGameTaobaoAuthorizationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserAction implements IUserAction {
    tenantId!: number | undefined;
    deviceActivityId!: number | undefined;
    dispatchedActivityId!: number | undefined;
    deviceActivityGameId!: number | undefined;
    deviceActivityGame!: DeviceActivityGame | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    imagePath!: string | undefined;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    status!: UserActionStatus | undefined;
    gameImage!: string | undefined;
    postUrl!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    score!: number | undefined;
    scene_id!: string | undefined;
    qrCodesImg!: string | undefined;
    media_id!: string | undefined;
    describeInfo!: string | undefined;
    clientName!: string | undefined;
    actionName!: string | undefined;
    queueNum!: string | undefined;
    securityCode!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerImage!: string | undefined;
    playerAge!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    snsShares!: SnsShare[] | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    award!: Award | undefined;
    organizationUnitId!: number | undefined;
    organizationUnitName!: string | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    points!: number | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    fromType!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.deviceActivityId = data["deviceActivityId"];
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.deviceActivityGameId = data["deviceActivityGameId"];
            this.deviceActivityGame = data["deviceActivityGame"] ? DeviceActivityGame.fromJS(data["deviceActivityGame"]) : <any>undefined;
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.imagePath = data["imagePath"];
            this.softwareId = data["softwareId"];
            this.softwareName = data["softwareName"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.status = data["status"];
            this.gameImage = data["gameImage"];
            this.postUrl = data["postUrl"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.score = data["score"];
            this.scene_id = data["scene_id"];
            this.qrCodesImg = data["qrCodesImg"];
            this.media_id = data["media_id"];
            this.describeInfo = data["describeInfo"];
            this.clientName = data["clientName"];
            this.actionName = data["actionName"];
            this.queueNum = data["queueNum"];
            this.securityCode = data["securityCode"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerImage = data["playerImage"];
            this.playerAge = data["playerAge"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            if (Array.isArray(data["snsShares"])) {
                this.snsShares = [] as any;
                for (let item of data["snsShares"])
                    this.snsShares!.push(SnsShare.fromJS(item));
            }
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.award = data["award"] ? Award.fromJS(data["award"]) : <any>undefined;
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationUnitName = data["organizationUnitName"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.points = data["points"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.fromType = data["fromType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserAction {
        data = typeof data === 'object' ? data : {};
        let result = new UserAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["deviceActivityId"] = this.deviceActivityId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["gameImage"] = this.gameImage;
        data["postUrl"] = this.postUrl;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["score"] = this.score;
        data["scene_id"] = this.scene_id;
        data["qrCodesImg"] = this.qrCodesImg;
        data["media_id"] = this.media_id;
        data["describeInfo"] = this.describeInfo;
        data["clientName"] = this.clientName;
        data["actionName"] = this.actionName;
        data["queueNum"] = this.queueNum;
        data["securityCode"] = this.securityCode;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerImage"] = this.playerImage;
        data["playerAge"] = this.playerAge;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        if (Array.isArray(this.snsShares)) {
            data["snsShares"] = [];
            for (let item of this.snsShares)
                data["snsShares"].push(item.toJSON());
        }
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["points"] = this.points;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserAction {
    tenantId: number | undefined;
    deviceActivityId: number | undefined;
    dispatchedActivityId: number | undefined;
    deviceActivityGameId: number | undefined;
    deviceActivityGame: DeviceActivityGame | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    imagePath: string | undefined;
    softwareId: number | undefined;
    softwareName: string | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    status: UserActionStatus | undefined;
    gameImage: string | undefined;
    postUrl: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    score: number | undefined;
    scene_id: string | undefined;
    qrCodesImg: string | undefined;
    media_id: string | undefined;
    describeInfo: string | undefined;
    clientName: string | undefined;
    actionName: string | undefined;
    queueNum: string | undefined;
    securityCode: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerImage: string | undefined;
    playerAge: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    snsShares: SnsShare[] | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    award: Award | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    points: number | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    fromType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SnsUserAward implements ISnsUserAward {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    userActionId!: number | undefined;
    userAction!: UserAction | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    awardId!: number | undefined;
    award!: Award | undefined;
    deviceActivityGameId!: number | undefined;
    isNotified!: boolean | undefined;
    isReceived!: boolean | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    receiverName!: string | undefined;
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    expressImageUrl!: string | undefined;
    msgid!: number | undefined;
    isNeedAwardInfo!: boolean | undefined;
    isInvalidated!: boolean | undefined;
    securityCode!: string | undefined;
    verifySecurityCode!: string | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    description!: string | undefined;
    isConfirmed!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.userActionId = data["userActionId"];
            this.userAction = data["userAction"] ? UserAction.fromJS(data["userAction"]) : <any>undefined;
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.awardId = data["awardId"];
            this.award = data["award"] ? Award.fromJS(data["award"]) : <any>undefined;
            this.deviceActivityGameId = data["deviceActivityGameId"];
            this.isNotified = data["isNotified"];
            this.isReceived = data["isReceived"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.receiverName = data["receiverName"];
            this.expressNO = data["expressNO"];
            this.expressCompany = data["expressCompany"];
            this.expressImageUrl = data["expressImageUrl"];
            this.msgid = data["msgid"];
            this.isNeedAwardInfo = data["isNeedAwardInfo"];
            this.isInvalidated = data["isInvalidated"];
            this.securityCode = data["securityCode"];
            this.verifySecurityCode = data["verifySecurityCode"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.description = data["description"];
            this.isConfirmed = data["isConfirmed"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserAward {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["receiverName"] = this.receiverName;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["expressImageUrl"] = this.expressImageUrl;
        data["msgid"] = this.msgid;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isInvalidated"] = this.isInvalidated;
        data["securityCode"] = this.securityCode;
        data["verifySecurityCode"] = this.verifySecurityCode;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isConfirmed"] = this.isConfirmed;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserAward {
    tenantId: number | undefined;
    activityId: number | undefined;
    userActionId: number | undefined;
    userAction: UserAction | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    awardId: number | undefined;
    award: Award | undefined;
    deviceActivityGameId: number | undefined;
    isNotified: boolean | undefined;
    isReceived: boolean | undefined;
    phone: string | undefined;
    address: string | undefined;
    receiverName: string | undefined;
    expressNO: string | undefined;
    expressCompany: string | undefined;
    expressImageUrl: string | undefined;
    msgid: number | undefined;
    isNeedAwardInfo: boolean | undefined;
    isInvalidated: boolean | undefined;
    securityCode: string | undefined;
    verifySecurityCode: string | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    description: string | undefined;
    isConfirmed: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SnsUserInfo implements ISnsUserInfo {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    userActions!: UserAction[] | undefined;
    isBecomeFans!: boolean | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.weixinGroupid = data["weixinGroupid"];
            this.memberId = data["memberId"];
            if (Array.isArray(data["userActions"])) {
                this.userActions = [] as any;
                for (let item of data["userActions"])
                    this.userActions!.push(UserAction.fromJS(item));
            }
            this.isBecomeFans = data["isBecomeFans"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfo {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    userActions: UserAction[] | undefined;
    isBecomeFans: boolean | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UpdateDeviceActivityGameInput implements IUpdateDeviceActivityGameInput {
    id!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    supportedPlayersCount!: number | undefined;
    weChatAuthorizationType!: UpdateDeviceActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: UpdateDeviceActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessage!: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    afterGameMessage!: CreateSnsMsgGameInput | undefined;
    isShareAction!: boolean | undefined;
    actionShare!: CreateActionShareInput | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateDeviceActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShare = data["actionShare"] ? CreateActionShareInput.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateDeviceActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateDeviceActivityGameInput {
    id: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    supportedPlayersCount: number | undefined;
    weChatAuthorizationType: UpdateDeviceActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: UpdateDeviceActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessage: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    afterGameMessage: CreateSnsMsgGameInput | undefined;
    isShareAction: boolean | undefined;
    actionShare: CreateActionShareInput | undefined;
    extensionData: string | undefined;
}

export class GetActivityChatInput implements IGetActivityChatInput {
    activityIds!: ActivityAndSoftwareDto[] | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    tenantId!: number | undefined;

    constructor(data?: IGetActivityChatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["activityIds"])) {
                this.activityIds = [] as any;
                for (let item of data["activityIds"])
                    this.activityIds!.push(ActivityAndSoftwareDto.fromJS(item));
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): GetActivityChatInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityChatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityIds)) {
            data["activityIds"] = [];
            for (let item of this.activityIds)
                data["activityIds"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IGetActivityChatInput {
    activityIds: ActivityAndSoftwareDto[] | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    tenantId: number | undefined;
}

export class ActivityAndSoftwareDto implements IActivityAndSoftwareDto {
    activityId!: number | undefined;
    softwareId!: number | undefined;

    constructor(data?: IActivityAndSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.softwareId = data["softwareId"];
        }
    }

    static fromJS(data: any): ActivityAndSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAndSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["softwareId"] = this.softwareId;
        return data; 
    }
}

export interface IActivityAndSoftwareDto {
    activityId: number | undefined;
    softwareId: number | undefined;
}

export class SummaryReportDto implements ISummaryReportDto {
    interactiveCount!: number | undefined;
    fansCount!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    spreadCount!: number | undefined;
    maleCount!: number | undefined;
    femaleCount!: number | undefined;
    awardCount!: number | undefined;
    gameCount!: number | undefined;
    offlineCount!: number | undefined;
    offlineStopCount!: number | undefined;

    constructor(data?: ISummaryReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.interactiveCount = data["interactiveCount"];
            this.fansCount = data["fansCount"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.spreadCount = data["spreadCount"];
            this.maleCount = data["maleCount"];
            this.femaleCount = data["femaleCount"];
            this.awardCount = data["awardCount"];
            this.gameCount = data["gameCount"];
            this.offlineCount = data["offlineCount"];
            this.offlineStopCount = data["offlineStopCount"];
        }
    }

    static fromJS(data: any): SummaryReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interactiveCount"] = this.interactiveCount;
        data["fansCount"] = this.fansCount;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["spreadCount"] = this.spreadCount;
        data["maleCount"] = this.maleCount;
        data["femaleCount"] = this.femaleCount;
        data["awardCount"] = this.awardCount;
        data["gameCount"] = this.gameCount;
        data["offlineCount"] = this.offlineCount;
        data["offlineStopCount"] = this.offlineStopCount;
        return data; 
    }
}

export interface ISummaryReportDto {
    interactiveCount: number | undefined;
    fansCount: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    spreadCount: number | undefined;
    maleCount: number | undefined;
    femaleCount: number | undefined;
    awardCount: number | undefined;
    gameCount: number | undefined;
    offlineCount: number | undefined;
    offlineStopCount: number | undefined;
}

export class MirrorPublishActivityToDevicesInput implements IMirrorPublishActivityToDevicesInput {
    sourceId!: number | undefined;
    targetIds!: number[] | undefined;
    tenantId!: number | undefined;

    constructor(data?: IMirrorPublishActivityToDevicesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceId = data["sourceId"];
            if (Array.isArray(data["targetIds"])) {
                this.targetIds = [] as any;
                for (let item of data["targetIds"])
                    this.targetIds!.push(item);
            }
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): MirrorPublishActivityToDevicesInput {
        data = typeof data === 'object' ? data : {};
        let result = new MirrorPublishActivityToDevicesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        if (Array.isArray(this.targetIds)) {
            data["targetIds"] = [];
            for (let item of this.targetIds)
                data["targetIds"].push(item);
        }
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IMirrorPublishActivityToDevicesInput {
    sourceId: number | undefined;
    targetIds: number[] | undefined;
    tenantId: number | undefined;
}

export class ChartReportDto implements IChartReportDto {
    title!: string | undefined;
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IChartReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            if (Array.isArray(data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartReportDto {
    title: string | undefined;
    chartItems: ChartItem[] | undefined;
}

export class ChartItem implements IChartItem {
    date!: string | undefined;
    value!: number | undefined;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        return data; 
    }
}

export interface IChartItem {
    date: string | undefined;
    value: number | undefined;
}

export class PagedResultDtoOfDouyinMedia implements IPagedResultDtoOfDouyinMedia {
    totalCount!: number | undefined;
    items!: DouyinMedia[] | undefined;

    constructor(data?: IPagedResultDtoOfDouyinMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DouyinMedia.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDouyinMedia {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDouyinMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDouyinMedia {
    totalCount: number | undefined;
    items: DouyinMedia[] | undefined;
}

export class DouyinMedia implements IDouyinMedia {
    tenantId!: number | undefined;
    app_Key!: string | undefined;
    openId!: string | undefined;
    item_id!: string | undefined;
    title!: string | undefined;
    cover!: string | undefined;
    is_top!: boolean | undefined;
    create_time!: number | undefined;
    is_reviewed!: boolean | undefined;
    share_url!: string | undefined;
    videourl!: string | undefined;
    statistics!: string | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDouyinMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.app_Key = data["app_Key"];
            this.openId = data["openId"];
            this.item_id = data["item_id"];
            this.title = data["title"];
            this.cover = data["cover"];
            this.is_top = data["is_top"];
            this.create_time = data["create_time"];
            this.is_reviewed = data["is_reviewed"];
            this.share_url = data["share_url"];
            this.videourl = data["videourl"];
            this.statistics = data["statistics"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DouyinMedia {
        data = typeof data === 'object' ? data : {};
        let result = new DouyinMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["app_Key"] = this.app_Key;
        data["openId"] = this.openId;
        data["item_id"] = this.item_id;
        data["title"] = this.title;
        data["cover"] = this.cover;
        data["is_top"] = this.is_top;
        data["create_time"] = this.create_time;
        data["is_reviewed"] = this.is_reviewed;
        data["share_url"] = this.share_url;
        data["videourl"] = this.videourl;
        data["statistics"] = this.statistics;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDouyinMedia {
    tenantId: number | undefined;
    app_Key: string | undefined;
    openId: string | undefined;
    item_id: string | undefined;
    title: string | undefined;
    cover: string | undefined;
    is_top: boolean | undefined;
    create_time: number | undefined;
    is_reviewed: boolean | undefined;
    share_url: string | undefined;
    videourl: string | undefined;
    statistics: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfHtmlTemplateDto implements IPagedResultDtoOfHtmlTemplateDto {
    totalCount!: number | undefined;
    items!: HtmlTemplateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfHtmlTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(HtmlTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHtmlTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHtmlTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfHtmlTemplateDto {
    totalCount: number | undefined;
    items: HtmlTemplateDto[] | undefined;
}

export class HtmlTemplateDto implements IHtmlTemplateDto {
    organizationUnitId!: number | undefined;
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: HtmlTemplateDtoTemplateType | undefined;
    description!: string | undefined;
    args!: string | undefined;
    id!: number | undefined;

    constructor(data?: IHtmlTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.thumbnail = data["thumbnail"];
            this.bigImage = data["bigImage"];
            this.actionUrl = data["actionUrl"];
            this.title = data["title"];
            this.logo = data["logo"];
            this.backgroundImage = data["backgroundImage"];
            this.templateType = data["templateType"];
            this.description = data["description"];
            this.args = data["args"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplateDto {
    organizationUnitId: number | undefined;
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: HtmlTemplateDtoTemplateType | undefined;
    description: string | undefined;
    args: string | undefined;
    id: number | undefined;
}

export class CreateHtmlTemplateInput implements ICreateHtmlTemplateInput {
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: CreateHtmlTemplateInputTemplateType | undefined;
    description!: string | undefined;
    args!: string | undefined;

    constructor(data?: ICreateHtmlTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thumbnail = data["thumbnail"];
            this.bigImage = data["bigImage"];
            this.actionUrl = data["actionUrl"];
            this.title = data["title"];
            this.logo = data["logo"];
            this.backgroundImage = data["backgroundImage"];
            this.templateType = data["templateType"];
            this.description = data["description"];
            this.args = data["args"];
        }
    }

    static fromJS(data: any): CreateHtmlTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHtmlTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        return data; 
    }
}

export interface ICreateHtmlTemplateInput {
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: CreateHtmlTemplateInputTemplateType | undefined;
    description: string | undefined;
    args: string | undefined;
}

export class UpdateHtmlTemplateInput implements IUpdateHtmlTemplateInput {
    id!: number | undefined;
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: UpdateHtmlTemplateInputTemplateType | undefined;
    description!: string | undefined;
    args!: string | undefined;

    constructor(data?: IUpdateHtmlTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.thumbnail = data["thumbnail"];
            this.bigImage = data["bigImage"];
            this.actionUrl = data["actionUrl"];
            this.title = data["title"];
            this.logo = data["logo"];
            this.backgroundImage = data["backgroundImage"];
            this.templateType = data["templateType"];
            this.description = data["description"];
            this.args = data["args"];
        }
    }

    static fromJS(data: any): UpdateHtmlTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHtmlTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        return data; 
    }
}

export interface IUpdateHtmlTemplateInput {
    id: number | undefined;
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: UpdateHtmlTemplateInputTemplateType | undefined;
    description: string | undefined;
    args: string | undefined;
}

export class ImportStoreResultDto implements IImportStoreResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean | undefined;

    constructor(data?: IImportStoreResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.importResult = data["importResult"];
            if (Array.isArray(data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = data["importState"];
        }
    }

    static fromJS(data: any): ImportStoreResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportStoreResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportStoreResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean | undefined;
}

export class CreatePaperInput implements ICreatePaperInput {
    name!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    description!: string | undefined;
    owner!: string | undefined;
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number | undefined;
    compositionType!: CreatePaperInputCompositionType | undefined;
    paperUsageType!: CreatePaperInputPaperUsageType | undefined;
    randomCount!: number | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: ICreatePaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.description = data["description"];
            this.owner = data["owner"];
            this.fromType = data["fromType"];
            this.extensionData = data["extensionData"];
            this.outerId = data["outerId"];
            this.questionsCount = data["questionsCount"];
            this.compositionType = data["compositionType"];
            this.paperUsageType = data["paperUsageType"];
            this.randomCount = data["randomCount"];
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreatePaperInput {
    name: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    owner: string | undefined;
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number | undefined;
    compositionType: CreatePaperInputCompositionType | undefined;
    paperUsageType: CreatePaperInputPaperUsageType | undefined;
    randomCount: number | undefined;
    tagIds: number[] | undefined;
}

export class UpdatePaperInput implements IUpdatePaperInput {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    description!: string | undefined;
    owner!: string | undefined;
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number | undefined;
    compositionType!: UpdatePaperInputCompositionType | undefined;
    paperUsageType!: UpdatePaperInputPaperUsageType | undefined;
    randomCount!: number | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdatePaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.description = data["description"];
            this.owner = data["owner"];
            this.fromType = data["fromType"];
            this.extensionData = data["extensionData"];
            this.outerId = data["outerId"];
            this.questionsCount = data["questionsCount"];
            this.compositionType = data["compositionType"];
            this.paperUsageType = data["paperUsageType"];
            this.randomCount = data["randomCount"];
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdatePaperInput {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    owner: string | undefined;
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number | undefined;
    compositionType: UpdatePaperInputCompositionType | undefined;
    paperUsageType: UpdatePaperInputPaperUsageType | undefined;
    randomCount: number | undefined;
    tagIds: number[] | undefined;
}

export class PagedResultDtoOfPaperDto implements IPagedResultDtoOfPaperDto {
    totalCount!: number | undefined;
    items!: PaperDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PaperDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPaperDto {
    totalCount: number | undefined;
    items: PaperDto[] | undefined;
}

export class PaperDto implements IPaperDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    description!: string | undefined;
    owner!: string | undefined;
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number | undefined;
    actualQuestionsCount!: number | undefined;
    compositionType!: PaperDtoCompositionType | undefined;
    paperUsageType!: PaperDtoPaperUsageType | undefined;
    randomCount!: number | undefined;
    tags!: IdNameDto[] | undefined;
    questions!: QuestionDto[] | undefined;

    constructor(data?: IPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.description = data["description"];
            this.owner = data["owner"];
            this.fromType = data["fromType"];
            this.extensionData = data["extensionData"];
            this.outerId = data["outerId"];
            this.questionsCount = data["questionsCount"];
            this.actualQuestionsCount = data["actualQuestionsCount"];
            this.compositionType = data["compositionType"];
            this.paperUsageType = data["paperUsageType"];
            this.randomCount = data["randomCount"];
            if (Array.isArray(data["tags"])) {
                this.tags = [] as any;
                for (let item of data["tags"])
                    this.tags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(data["questions"])) {
                this.questions = [] as any;
                for (let item of data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["actualQuestionsCount"] = this.actualQuestionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaperDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    owner: string | undefined;
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number | undefined;
    actualQuestionsCount: number | undefined;
    compositionType: PaperDtoCompositionType | undefined;
    paperUsageType: PaperDtoPaperUsageType | undefined;
    randomCount: number | undefined;
    tags: IdNameDto[] | undefined;
    questions: QuestionDto[] | undefined;
}

export class IdNameDto implements IIdNameDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number | undefined;
    name: string | undefined;
}

export class QuestionDto implements IQuestionDto {
    id!: number | undefined;
    prefix!: string | undefined;
    title!: string | undefined;
    type!: QuestionDtoType | undefined;
    score!: number | undefined;
    orderNo!: number | undefined;
    content!: string | undefined;
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    enabled!: boolean | undefined;
    outerId!: string | undefined;
    questionScoreType!: QuestionDtoQuestionScoreType | undefined;
    questionItems!: QuestionItemDto[] | undefined;
    tags!: IdNameDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.prefix = data["prefix"];
            this.title = data["title"];
            this.type = data["type"];
            this.score = data["score"];
            this.orderNo = data["orderNo"];
            this.content = data["content"];
            this.answer = data["answer"];
            this.description = data["description"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.enabled = data["enabled"];
            this.outerId = data["outerId"];
            this.questionScoreType = data["questionScoreType"];
            if (Array.isArray(data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(data["tags"])) {
                this.tags = [] as any;
                for (let item of data["tags"])
                    this.tags!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionDto {
    id: number | undefined;
    prefix: string | undefined;
    title: string | undefined;
    type: QuestionDtoType | undefined;
    score: number | undefined;
    orderNo: number | undefined;
    content: string | undefined;
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    enabled: boolean | undefined;
    outerId: string | undefined;
    questionScoreType: QuestionDtoQuestionScoreType | undefined;
    questionItems: QuestionItemDto[] | undefined;
    tags: IdNameDto[] | undefined;
}

export class QuestionItemDto implements IQuestionItemDto {
    id!: number | undefined;
    orderNo!: number | undefined;
    prefix!: string | undefined;
    content!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    extensionData!: string | undefined;
    isAnswer!: boolean | undefined;
    score!: number | undefined;
    description!: string | undefined;
    outerId!: string | undefined;

    constructor(data?: IQuestionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orderNo = data["orderNo"];
            this.prefix = data["prefix"];
            this.content = data["content"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.extensionData = data["extensionData"];
            this.isAnswer = data["isAnswer"];
            this.score = data["score"];
            this.description = data["description"];
            this.outerId = data["outerId"];
        }
    }

    static fromJS(data: any): QuestionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNo"] = this.orderNo;
        data["prefix"] = this.prefix;
        data["content"] = this.content;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["extensionData"] = this.extensionData;
        data["isAnswer"] = this.isAnswer;
        data["score"] = this.score;
        data["description"] = this.description;
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface IQuestionItemDto {
    id: number | undefined;
    orderNo: number | undefined;
    prefix: string | undefined;
    content: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    extensionData: string | undefined;
    isAnswer: boolean | undefined;
    score: number | undefined;
    description: string | undefined;
    outerId: string | undefined;
}

export class PagedResultDtoOfQuestionDto implements IPagedResultDtoOfQuestionDto {
    totalCount!: number | undefined;
    items!: QuestionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuestionDto {
    totalCount: number | undefined;
    items: QuestionDto[] | undefined;
}

export class UpdateQuestionScoreAndOrderInput implements IUpdateQuestionScoreAndOrderInput {
    paperId!: number | undefined;
    questions!: PublishedQuestionDto[] | undefined;

    constructor(data?: IUpdateQuestionScoreAndOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paperId = data["paperId"];
            if (Array.isArray(data["questions"])) {
                this.questions = [] as any;
                for (let item of data["questions"])
                    this.questions!.push(PublishedQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateQuestionScoreAndOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionScoreAndOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paperId"] = this.paperId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateQuestionScoreAndOrderInput {
    paperId: number | undefined;
    questions: PublishedQuestionDto[] | undefined;
}

export class PublishedQuestionDto implements IPublishedQuestionDto {
    id!: number | undefined;
    score!: number | undefined;
    orderNo!: number | undefined;

    constructor(data?: IPublishedQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.score = data["score"];
            this.orderNo = data["orderNo"];
        }
    }

    static fromJS(data: any): PublishedQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        return data; 
    }
}

export interface IPublishedQuestionDto {
    id: number | undefined;
    score: number | undefined;
    orderNo: number | undefined;
}

export class PublishPapersToSoftwares implements IPublishPapersToSoftwares {
    dispathcedSoftwareIds!: number[] | undefined;
    paperIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IPublishPapersToSoftwares) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["dispathcedSoftwareIds"])) {
                this.dispathcedSoftwareIds = [] as any;
                for (let item of data["dispathcedSoftwareIds"])
                    this.dispathcedSoftwareIds!.push(item);
            }
            if (Array.isArray(data["paperIds"])) {
                this.paperIds = [] as any;
                for (let item of data["paperIds"])
                    this.paperIds!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): PublishPapersToSoftwares {
        data = typeof data === 'object' ? data : {};
        let result = new PublishPapersToSoftwares();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dispathcedSoftwareIds)) {
            data["dispathcedSoftwareIds"] = [];
            for (let item of this.dispathcedSoftwareIds)
                data["dispathcedSoftwareIds"].push(item);
        }
        if (Array.isArray(this.paperIds)) {
            data["paperIds"] = [];
            for (let item of this.paperIds)
                data["paperIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishPapersToSoftwares {
    dispathcedSoftwareIds: number[] | undefined;
    paperIds: number[] | undefined;
    action: string | undefined;
}

export class CreateQuestionInput implements ICreateQuestionInput {
    prefix!: string | undefined;
    title!: string | undefined;
    type!: CreateQuestionInputType | undefined;
    score!: number | undefined;
    orderNo!: number | undefined;
    content!: string | undefined;
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    enabled!: boolean | undefined;
    outerId!: string | undefined;
    questionScoreType!: CreateQuestionInputQuestionScoreType | undefined;
    questionItems!: QuestionItemDto[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: ICreateQuestionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prefix = data["prefix"];
            this.title = data["title"];
            this.type = data["type"];
            this.score = data["score"];
            this.orderNo = data["orderNo"];
            this.content = data["content"];
            this.answer = data["answer"];
            this.description = data["description"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.enabled = data["enabled"];
            this.outerId = data["outerId"];
            this.questionScoreType = data["questionScoreType"];
            if (Array.isArray(data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateQuestionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateQuestionInput {
    prefix: string | undefined;
    title: string | undefined;
    type: CreateQuestionInputType | undefined;
    score: number | undefined;
    orderNo: number | undefined;
    content: string | undefined;
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    enabled: boolean | undefined;
    outerId: string | undefined;
    questionScoreType: CreateQuestionInputQuestionScoreType | undefined;
    questionItems: QuestionItemDto[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateQuestionInput implements IUpdateQuestionInput {
    id!: number | undefined;
    prefix!: string | undefined;
    title!: string | undefined;
    type!: UpdateQuestionInputType | undefined;
    score!: number | undefined;
    orderNo!: number | undefined;
    content!: string | undefined;
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    enabled!: boolean | undefined;
    outerId!: string | undefined;
    questionScoreType!: UpdateQuestionInputQuestionScoreType | undefined;
    questionItems!: QuestionItemDto[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdateQuestionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.prefix = data["prefix"];
            this.title = data["title"];
            this.type = data["type"];
            this.score = data["score"];
            this.orderNo = data["orderNo"];
            this.content = data["content"];
            this.answer = data["answer"];
            this.description = data["description"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.enabled = data["enabled"];
            this.outerId = data["outerId"];
            this.questionScoreType = data["questionScoreType"];
            if (Array.isArray(data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateQuestionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateQuestionInput {
    id: number | undefined;
    prefix: string | undefined;
    title: string | undefined;
    type: UpdateQuestionInputType | undefined;
    score: number | undefined;
    orderNo: number | undefined;
    content: string | undefined;
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    enabled: boolean | undefined;
    outerId: string | undefined;
    questionScoreType: UpdateQuestionInputQuestionScoreType | undefined;
    questionItems: QuestionItemDto[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateQuestionStatusInput implements IUpdateQuestionStatusInput {
    ids!: number[] | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IUpdateQuestionStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ids"])) {
                this.ids = [] as any;
                for (let item of data["ids"])
                    this.ids!.push(item);
            }
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateQuestionStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IUpdateQuestionStatusInput {
    ids: number[] | undefined;
    isEnabled: boolean | undefined;
}

export class PublishQuestionsToPapersInput implements IPublishQuestionsToPapersInput {
    questions!: PublishedQuestionDto[] | undefined;
    paperIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IPublishQuestionsToPapersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["questions"])) {
                this.questions = [] as any;
                for (let item of data["questions"])
                    this.questions!.push(PublishedQuestionDto.fromJS(item));
            }
            if (Array.isArray(data["paperIds"])) {
                this.paperIds = [] as any;
                for (let item of data["paperIds"])
                    this.paperIds!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): PublishQuestionsToPapersInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishQuestionsToPapersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.paperIds)) {
            data["paperIds"] = [];
            for (let item of this.paperIds)
                data["paperIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishQuestionsToPapersInput {
    questions: PublishedQuestionDto[] | undefined;
    paperIds: number[] | undefined;
    action: string | undefined;
}

export class NameValueTimeDto implements INameValueTimeDto {
    seconds!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seconds = data["seconds"];
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seconds"] = this.seconds;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueTimeDto {
    seconds: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class UserAwardByActivityDto implements IUserAwardByActivityDto {
    awardCount!: number | undefined;
    verificatedCount!: number | undefined;

    constructor(data?: IUserAwardByActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.awardCount = data["awardCount"];
            this.verificatedCount = data["verificatedCount"];
        }
    }

    static fromJS(data: any): UserAwardByActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardByActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardCount"] = this.awardCount;
        data["verificatedCount"] = this.verificatedCount;
        return data; 
    }
}

export interface IUserAwardByActivityDto {
    awardCount: number | undefined;
    verificatedCount: number | undefined;
}

export class PagedResultDtoOfSensingDeviceActivityDto implements IPagedResultDtoOfSensingDeviceActivityDto {
    totalCount!: number | undefined;
    items!: SensingDeviceActivityDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SensingDeviceActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDeviceActivityDto {
    totalCount: number | undefined;
    items: SensingDeviceActivityDto[] | undefined;
}

export class SensingDeviceActivityDto implements ISensingDeviceActivityDto {
    id!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    weChatAppID!: string | undefined;
    taobaoSellerID!: string | undefined;
    organizer!: string | undefined;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean | undefined;
    iconPath!: string | undefined;
    ownerName!: string | undefined;
    isPublic!: boolean | undefined;
    contactor!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: SensingDeviceActivityDtoAuditStatus | undefined;
    isMine!: boolean | undefined;
    organizationUnitId!: number | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean | undefined;
    games!: DeviceActivityGameDto[] | undefined;

    constructor(data?: ISensingDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.imagePath = data["imagePath"];
            this.address = data["address"];
            this.activityUrl = data["activityUrl"];
            this.activityLogoPath = data["activityLogoPath"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = data["weChatAppID"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.organizer = data["organizer"];
            this.rules = data["rules"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = data["isTemplate"];
            this.iconPath = data["iconPath"];
            this.ownerName = data["ownerName"];
            this.isPublic = data["isPublic"];
            this.contactor = data["contactor"];
            this.contactorPhone = data["contactorPhone"];
            this.auditStatus = data["auditStatus"];
            this.isMine = data["isMine"];
            this.organizationUnitId = data["organizationUnitId"];
            this.description = data["description"];
            this.isNeedRegister = data["isNeedRegister"];
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(DeviceActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["organizer"] = this.organizer;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingDeviceActivityDto {
    id: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    weChatAppID: string | undefined;
    taobaoSellerID: string | undefined;
    organizer: string | undefined;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean | undefined;
    iconPath: string | undefined;
    ownerName: string | undefined;
    isPublic: boolean | undefined;
    contactor: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: SensingDeviceActivityDtoAuditStatus | undefined;
    isMine: boolean | undefined;
    organizationUnitId: number | undefined;
    description: string | undefined;
    isNeedRegister: boolean | undefined;
    games: DeviceActivityGameDto[] | undefined;
}

export class PagedResultDtoOfSensingDeviceAwardDto implements IPagedResultDtoOfSensingDeviceAwardDto {
    totalCount!: number | undefined;
    items!: SensingDeviceAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDeviceAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SensingDeviceAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDeviceAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDeviceAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDeviceAwardDto {
    totalCount: number | undefined;
    items: SensingDeviceAwardDto[] | undefined;
}

export class SensingDeviceAwardDto implements ISensingDeviceAwardDto {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    name!: string | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    isRandomAward!: boolean | undefined;
    description!: string | undefined;
    type!: SensingDeviceAwardDtoType | undefined;
    couponUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISensingDeviceAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.name = data["name"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.rate = data["rate"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.isRandomAward = data["isRandomAward"];
            this.description = data["description"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SensingDeviceAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISensingDeviceAwardDto {
    tenantId: number | undefined;
    activityId: number | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    name: string | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    isRandomAward: boolean | undefined;
    description: string | undefined;
    type: SensingDeviceAwardDtoType | undefined;
    couponUrl: string | undefined;
    id: number | undefined;
}

export class AddUserPaperInput implements IAddUserPaperInput {
    subkey!: string;
    paperId!: number | undefined;
    userActionId!: number | undefined;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number | undefined;
    correctCount!: number | undefined;
    totalScore!: number | undefined;
    opinion!: string | undefined;
    examResult!: AddUserPaperInputExamResult | undefined;
    paperQuestions!: PaperQuestion[] | undefined;

    constructor(data?: IAddUserPaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subkey = data["subkey"];
            this.paperId = data["paperId"];
            this.userActionId = data["userActionId"];
            this.examStartTime = data["examStartTime"] ? moment(data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = data["examEndTime"] ? moment(data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = data["answeredQuestionCount"];
            this.correctCount = data["correctCount"];
            this.totalScore = data["totalScore"];
            this.opinion = data["opinion"];
            this.examResult = data["examResult"];
            if (Array.isArray(data["paperQuestions"])) {
                this.paperQuestions = [] as any;
                for (let item of data["paperQuestions"])
                    this.paperQuestions!.push(PaperQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddUserPaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserPaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["paperId"] = this.paperId;
        data["userActionId"] = this.userActionId;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["opinion"] = this.opinion;
        data["examResult"] = this.examResult;
        if (Array.isArray(this.paperQuestions)) {
            data["paperQuestions"] = [];
            for (let item of this.paperQuestions)
                data["paperQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddUserPaperInput {
    subkey: string;
    paperId: number | undefined;
    userActionId: number | undefined;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number | undefined;
    correctCount: number | undefined;
    totalScore: number | undefined;
    opinion: string | undefined;
    examResult: AddUserPaperInputExamResult | undefined;
    paperQuestions: PaperQuestion[] | undefined;
}

export class PaperQuestion implements IPaperQuestion {
    questionId!: number | undefined;
    answer!: string | undefined;
    comments!: string | undefined;
    questionItemIds!: number[] | undefined;

    constructor(data?: IPaperQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.answer = data["answer"];
            this.comments = data["comments"];
            if (Array.isArray(data["questionItemIds"])) {
                this.questionItemIds = [] as any;
                for (let item of data["questionItemIds"])
                    this.questionItemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PaperQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new PaperQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["answer"] = this.answer;
        data["comments"] = this.comments;
        if (Array.isArray(this.questionItemIds)) {
            data["questionItemIds"] = [];
            for (let item of this.questionItemIds)
                data["questionItemIds"].push(item);
        }
        return data; 
    }
}

export interface IPaperQuestion {
    questionId: number | undefined;
    answer: string | undefined;
    comments: string | undefined;
    questionItemIds: number[] | undefined;
}

export class SingleUserPaperDetailDto implements ISingleUserPaperDetailDto {
    snsUserInfo!: SnsUserInfoDto | undefined;
    userPaper!: UserPaper | undefined;
    questions!: QuestionDto[] | undefined;
    questionItems!: QuestionItemDto[] | undefined;

    constructor(data?: ISingleUserPaperDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoDto.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.userPaper = data["userPaper"] ? UserPaper.fromJS(data["userPaper"]) : <any>undefined;
            if (Array.isArray(data["questions"])) {
                this.questions = [] as any;
                for (let item of data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
            if (Array.isArray(data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleUserPaperDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleUserPaperDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["userPaper"] = this.userPaper ? this.userPaper.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISingleUserPaperDetailDto {
    snsUserInfo: SnsUserInfoDto | undefined;
    userPaper: UserPaper | undefined;
    questions: QuestionDto[] | undefined;
    questionItems: QuestionItemDto[] | undefined;
}

export class UserPaper implements IUserPaper {
    tenantId!: number | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    paperId!: number | undefined;
    paper!: Paper | undefined;
    userActionId!: number | undefined;
    userAction!: UserAction | undefined;
    trainingId!: number | undefined;
    training!: Training | undefined;
    dispatchedSoftwarePaperId!: number | undefined;
    dispatchedSoftwarePaper!: DispatchedSoftwarePaper | undefined;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number | undefined;
    correctCount!: number | undefined;
    totalScore!: number | undefined;
    examResult!: UserPaperExamResult | undefined;
    opinion!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserPaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.paperId = data["paperId"];
            this.paper = data["paper"] ? Paper.fromJS(data["paper"]) : <any>undefined;
            this.userActionId = data["userActionId"];
            this.userAction = data["userAction"] ? UserAction.fromJS(data["userAction"]) : <any>undefined;
            this.trainingId = data["trainingId"];
            this.training = data["training"] ? Training.fromJS(data["training"]) : <any>undefined;
            this.dispatchedSoftwarePaperId = data["dispatchedSoftwarePaperId"];
            this.dispatchedSoftwarePaper = data["dispatchedSoftwarePaper"] ? DispatchedSoftwarePaper.fromJS(data["dispatchedSoftwarePaper"]) : <any>undefined;
            this.examStartTime = data["examStartTime"] ? moment(data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = data["examEndTime"] ? moment(data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = data["answeredQuestionCount"];
            this.correctCount = data["correctCount"];
            this.totalScore = data["totalScore"];
            this.examResult = data["examResult"];
            this.opinion = data["opinion"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPaper {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["dispatchedSoftwarePaperId"] = this.dispatchedSoftwarePaperId;
        data["dispatchedSoftwarePaper"] = this.dispatchedSoftwarePaper ? this.dispatchedSoftwarePaper.toJSON() : <any>undefined;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["examResult"] = this.examResult;
        data["opinion"] = this.opinion;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserPaper {
    tenantId: number | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    paperId: number | undefined;
    paper: Paper | undefined;
    userActionId: number | undefined;
    userAction: UserAction | undefined;
    trainingId: number | undefined;
    training: Training | undefined;
    dispatchedSoftwarePaperId: number | undefined;
    dispatchedSoftwarePaper: DispatchedSoftwarePaper | undefined;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number | undefined;
    correctCount: number | undefined;
    totalScore: number | undefined;
    examResult: UserPaperExamResult | undefined;
    opinion: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Paper implements IPaper {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    description!: string | undefined;
    owner!: string | undefined;
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number | undefined;
    compositionType!: PaperCompositionType | undefined;
    paperUsageType!: PaperUsageType | undefined;
    randomCount!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.logoUrl = data["logoUrl"];
            this.imageUrl = data["imageUrl"];
            this.description = data["description"];
            this.owner = data["owner"];
            this.fromType = data["fromType"];
            this.extensionData = data["extensionData"];
            this.outerId = data["outerId"];
            this.questionsCount = data["questionsCount"];
            this.compositionType = data["compositionType"];
            this.paperUsageType = data["paperUsageType"];
            this.randomCount = data["randomCount"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Paper {
        data = typeof data === 'object' ? data : {};
        let result = new Paper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaper {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    owner: string | undefined;
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number | undefined;
    compositionType: PaperCompositionType | undefined;
    paperUsageType: PaperUsageType | undefined;
    randomCount: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Training implements ITraining {
    tenantId!: number | undefined;
    title!: string | undefined;
    no!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingCategory4 | undefined;
    auditStatus!: TrainingAuditStatus | undefined;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingWay4 | undefined;
    trainingStatus!: TrainingStatus4 | undefined;
    userId!: number | undefined;
    lecturer!: string | undefined;
    paperId!: number | undefined;
    paper!: Paper | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    isCompleted!: boolean | undefined;
    courseId!: number | undefined;
    course!: Course | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.title = data["title"];
            this.no = data["no"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.category = data["category"];
            this.auditStatus = data["auditStatus"];
            this.totalLength = data["totalLength"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.trainingWay = data["trainingWay"];
            this.trainingStatus = data["trainingStatus"];
            this.userId = data["userId"];
            this.lecturer = data["lecturer"];
            this.paperId = data["paperId"];
            this.paper = data["paper"] ? Paper.fromJS(data["paper"]) : <any>undefined;
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.isCompleted = data["isCompleted"];
            this.courseId = data["courseId"];
            this.course = data["course"] ? Course.fromJS(data["course"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["no"] = this.no;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["trainingStatus"] = this.trainingStatus;
        data["userId"] = this.userId;
        data["lecturer"] = this.lecturer;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["isCompleted"] = this.isCompleted;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITraining {
    tenantId: number | undefined;
    title: string | undefined;
    no: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingCategory4 | undefined;
    auditStatus: TrainingAuditStatus | undefined;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingWay4 | undefined;
    trainingStatus: TrainingStatus4 | undefined;
    userId: number | undefined;
    lecturer: string | undefined;
    paperId: number | undefined;
    paper: Paper | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    isCompleted: boolean | undefined;
    courseId: number | undefined;
    course: Course | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DispatchedSoftwarePaper implements IDispatchedSoftwarePaper {
    dispatchedSoftwareId!: number | undefined;
    dispatchedSoftware!: DispatchedSoftware | undefined;
    paperId!: number | undefined;
    paper!: Paper | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDispatchedSoftwarePaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.dispatchedSoftware = data["dispatchedSoftware"] ? DispatchedSoftware.fromJS(data["dispatchedSoftware"]) : <any>undefined;
            this.paperId = data["paperId"];
            this.paper = data["paper"] ? Paper.fromJS(data["paper"]) : <any>undefined;
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DispatchedSoftwarePaper {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftwarePaper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["dispatchedSoftware"] = this.dispatchedSoftware ? this.dispatchedSoftware.toJSON() : <any>undefined;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedSoftwarePaper {
    dispatchedSoftwareId: number | undefined;
    dispatchedSoftware: DispatchedSoftware | undefined;
    paperId: number | undefined;
    paper: Paper | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Course implements ICourse {
    tenantId!: number | undefined;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.courseNo = data["courseNo"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICourse {
    tenantId: number | undefined;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DispatchedSoftware implements IDispatchedSoftware {
    organizationUnitId!: number | undefined;
    tenantId!: number | undefined;
    softwareId!: number | undefined;
    software!: Software | undefined;
    alias!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    extensionData!: string | undefined;
    materialPacketUrl!: string | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDispatchedSoftware) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.tenantId = data["tenantId"];
            this.softwareId = data["softwareId"];
            this.software = data["software"] ? Software.fromJS(data["software"]) : <any>undefined;
            this.alias = data["alias"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.extensionData = data["extensionData"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DispatchedSoftware {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftware();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["tenantId"] = this.tenantId;
        data["softwareId"] = this.softwareId;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedSoftware {
    organizationUnitId: number | undefined;
    tenantId: number | undefined;
    softwareId: number | undefined;
    software: Software | undefined;
    alias: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    extensionData: string | undefined;
    materialPacketUrl: string | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Software implements ISoftware {
    name!: string;
    code!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: number | undefined;
    versionNumber!: string | undefined;
    packageUrl!: string | undefined;
    exePath!: string | undefined;
    type!: number | undefined;
    isShowToTenant!: boolean | undefined;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: SoftwareAuditStatus | undefined;
    extensionData!: string | undefined;
    gameType!: number | undefined;
    description!: string | undefined;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean | undefined;
    isSendWechatBeforeGame!: boolean | undefined;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean | undefined;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean | undefined;
    shareActionTabName!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISoftware) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.owner = data["owner"];
            this.contact = data["contact"];
            this.tenantId = data["tenantId"];
            this.url = data["url"];
            this.logoUrl = data["logoUrl"];
            this.largeImageUrl = data["largeImageUrl"];
            this.envType = data["envType"];
            this.versionNumber = data["versionNumber"];
            this.packageUrl = data["packageUrl"];
            this.exePath = data["exePath"];
            this.type = data["type"];
            this.isShowToTenant = data["isShowToTenant"];
            this.targetResolution_Width = data["targetResolution_Width"];
            this.targetResolution_Height = data["targetResolution_Height"];
            this.setting = data["setting"];
            this.language = data["language"];
            this.auditStatus = data["auditStatus"];
            this.extensionData = data["extensionData"];
            this.gameType = data["gameType"];
            this.description = data["description"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSupportAsync = data["isSupportAsync"];
            this.isSendWechatBeforeGame = data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = data["sendWeChatAfterGameTabName"];
            this.isShareAction = data["isShareAction"];
            this.shareActionTabName = data["shareActionTabName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Software {
        data = typeof data === 'object' ? data : {};
        let result = new Software();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["isShowToTenant"] = this.isShowToTenant;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISoftware {
    name: string;
    code: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: number | undefined;
    versionNumber: string | undefined;
    packageUrl: string | undefined;
    exePath: string | undefined;
    type: number | undefined;
    isShowToTenant: boolean | undefined;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    setting: string | undefined;
    language: string | undefined;
    auditStatus: SoftwareAuditStatus | undefined;
    extensionData: string | undefined;
    gameType: number | undefined;
    description: string | undefined;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean | undefined;
    isSendWechatBeforeGame: boolean | undefined;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean | undefined;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean | undefined;
    shareActionTabName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class AddUserPaperInput4Wechat implements IAddUserPaperInput4Wechat {
    trainingId!: number | undefined;
    paperId!: number | undefined;
    userActionId!: number | undefined;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number | undefined;
    correctCount!: number | undefined;
    totalScore!: number | undefined;
    opinion!: string | undefined;
    examResult!: AddUserPaperInput4WechatExamResult | undefined;
    paperQuestions!: PaperQuestion[] | undefined;

    constructor(data?: IAddUserPaperInput4Wechat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingId = data["trainingId"];
            this.paperId = data["paperId"];
            this.userActionId = data["userActionId"];
            this.examStartTime = data["examStartTime"] ? moment(data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = data["examEndTime"] ? moment(data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = data["answeredQuestionCount"];
            this.correctCount = data["correctCount"];
            this.totalScore = data["totalScore"];
            this.opinion = data["opinion"];
            this.examResult = data["examResult"];
            if (Array.isArray(data["paperQuestions"])) {
                this.paperQuestions = [] as any;
                for (let item of data["paperQuestions"])
                    this.paperQuestions!.push(PaperQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddUserPaperInput4Wechat {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserPaperInput4Wechat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingId"] = this.trainingId;
        data["paperId"] = this.paperId;
        data["userActionId"] = this.userActionId;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["opinion"] = this.opinion;
        data["examResult"] = this.examResult;
        if (Array.isArray(this.paperQuestions)) {
            data["paperQuestions"] = [];
            for (let item of this.paperQuestions)
                data["paperQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddUserPaperInput4Wechat {
    trainingId: number | undefined;
    paperId: number | undefined;
    userActionId: number | undefined;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number | undefined;
    correctCount: number | undefined;
    totalScore: number | undefined;
    opinion: string | undefined;
    examResult: AddUserPaperInput4WechatExamResult | undefined;
    paperQuestions: PaperQuestion[] | undefined;
}

export class PagedResultDtoOfGetPaperAnswerReportDto implements IPagedResultDtoOfGetPaperAnswerReportDto {
    totalCount!: number | undefined;
    items!: GetPaperAnswerReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPaperAnswerReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerReportDto {
    totalCount: number | undefined;
    items: GetPaperAnswerReportDto[] | undefined;
}

export class GetPaperAnswerReportDto implements IGetPaperAnswerReportDto {
    questionId!: number | undefined;
    questionContent!: string | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    questionItemId!: number | undefined;
    questionItemName!: string | undefined;
    prefix!: string | undefined;
    count!: number | undefined;
    percentage!: number | undefined;

    constructor(data?: IGetPaperAnswerReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.questionContent = data["questionContent"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.questionItemId = data["questionItemId"];
            this.questionItemName = data["questionItemName"];
            this.prefix = data["prefix"];
            this.count = data["count"];
            this.percentage = data["percentage"];
        }
    }

    static fromJS(data: any): GetPaperAnswerReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionContent"] = this.questionContent;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["questionItemId"] = this.questionItemId;
        data["questionItemName"] = this.questionItemName;
        data["prefix"] = this.prefix;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        return data; 
    }
}

export interface IGetPaperAnswerReportDto {
    questionId: number | undefined;
    questionContent: string | undefined;
    userId: number | undefined;
    userName: string | undefined;
    questionItemId: number | undefined;
    questionItemName: string | undefined;
    prefix: string | undefined;
    count: number | undefined;
    percentage: number | undefined;
}

export class SensingDeviceStoreInfoDto implements ISensingDeviceStoreInfoDto {
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    storeId!: number | undefined;
    outerId!: string | undefined;
    storeName!: string | undefined;
    activityId!: number | undefined;
    activityName!: string | undefined;
    acitivityNote!: string | undefined;

    constructor(data?: ISensingDeviceStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.storeId = data["storeId"];
            this.outerId = data["outerId"];
            this.storeName = data["storeName"];
            this.activityId = data["activityId"];
            this.activityName = data["activityName"];
            this.acitivityNote = data["acitivityNote"];
        }
    }

    static fromJS(data: any): SensingDeviceStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["storeId"] = this.storeId;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["acitivityNote"] = this.acitivityNote;
        return data; 
    }
}

export interface ISensingDeviceStoreInfoDto {
    deviceId: number | undefined;
    deviceName: string | undefined;
    storeId: number | undefined;
    outerId: string | undefined;
    storeName: string | undefined;
    activityId: number | undefined;
    activityName: string | undefined;
    acitivityNote: string | undefined;
}

export class PagedResultDtoOfSnsUserAwardOuput implements IPagedResultDtoOfSnsUserAwardOuput {
    totalCount!: number | undefined;
    items!: SnsUserAwardOuput[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserAwardOuput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SnsUserAwardOuput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserAwardOuput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserAwardOuput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserAwardOuput {
    totalCount: number | undefined;
    items: SnsUserAwardOuput[] | undefined;
}

export class SnsUserAwardOuput implements ISnsUserAwardOuput {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    userActionId!: number | undefined;
    userAction!: UserActionSimpleOutput | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    awardId!: number | undefined;
    award!: AwardOutput | undefined;
    isNotified!: boolean | undefined;
    isReceived!: boolean | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    receiverName!: string | undefined;
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    expressImageUrl!: string | undefined;
    msgid!: number | undefined;
    isNeedAwardInfo!: boolean | undefined;
    isInvalidated!: boolean | undefined;
    securityCode!: string | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    description!: string | undefined;
    isConfirmed!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserAwardOuput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.userActionId = data["userActionId"];
            this.userAction = data["userAction"] ? UserActionSimpleOutput.fromJS(data["userAction"]) : <any>undefined;
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.awardId = data["awardId"];
            this.award = data["award"] ? AwardOutput.fromJS(data["award"]) : <any>undefined;
            this.isNotified = data["isNotified"];
            this.isReceived = data["isReceived"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.receiverName = data["receiverName"];
            this.expressNO = data["expressNO"];
            this.expressCompany = data["expressCompany"];
            this.expressImageUrl = data["expressImageUrl"];
            this.msgid = data["msgid"];
            this.isNeedAwardInfo = data["isNeedAwardInfo"];
            this.isInvalidated = data["isInvalidated"];
            this.securityCode = data["securityCode"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.description = data["description"];
            this.isConfirmed = data["isConfirmed"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserAwardOuput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAwardOuput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["receiverName"] = this.receiverName;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["expressImageUrl"] = this.expressImageUrl;
        data["msgid"] = this.msgid;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isInvalidated"] = this.isInvalidated;
        data["securityCode"] = this.securityCode;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isConfirmed"] = this.isConfirmed;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserAwardOuput {
    tenantId: number | undefined;
    activityId: number | undefined;
    userActionId: number | undefined;
    userAction: UserActionSimpleOutput | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    awardId: number | undefined;
    award: AwardOutput | undefined;
    isNotified: boolean | undefined;
    isReceived: boolean | undefined;
    phone: string | undefined;
    address: string | undefined;
    receiverName: string | undefined;
    expressNO: string | undefined;
    expressCompany: string | undefined;
    expressImageUrl: string | undefined;
    msgid: number | undefined;
    isNeedAwardInfo: boolean | undefined;
    isInvalidated: boolean | undefined;
    securityCode: string | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    description: string | undefined;
    isConfirmed: boolean | undefined;
    id: number | undefined;
}

export class UserActionSimpleOutput implements IUserActionSimpleOutput {
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserActionSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeId = data["qrCodeId"];
            this.score = data["score"];
            this.postUrl = data["postUrl"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.scanQrCodeTime = data["scanQrCodeTime"];
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserActionSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionSimpleOutput {
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    scanQrCodeTime: string | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class SnsUserInfoOutput implements ISnsUserInfoOutput {
    id!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    country!: string | undefined;
    province!: string | undefined;
    headimgurl!: string | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    snsType!: SnsUserInfoOutputSnsType | undefined;

    constructor(data?: ISnsUserInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.country = data["country"];
            this.province = data["province"];
            this.headimgurl = data["headimgurl"];
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.weixinGroupid = data["weixinGroupid"];
            this.snsType = data["snsType"];
        }
    }

    static fromJS(data: any): SnsUserInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["country"] = this.country;
        data["province"] = this.province;
        data["headimgurl"] = this.headimgurl;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["snsType"] = this.snsType;
        return data; 
    }
}

export interface ISnsUserInfoOutput {
    id: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    country: string | undefined;
    province: string | undefined;
    headimgurl: string | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    snsType: SnsUserInfoOutputSnsType | undefined;
}

export class AwardOutput implements IAwardOutput {
    tenantId!: number | undefined;
    activityId!: number | undefined;
    planQty!: number | undefined;
    actualQty!: number | undefined;
    name!: string | undefined;
    awardSeq!: number | undefined;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number | undefined;
    minScore!: number | undefined;
    maxScore!: number | undefined;
    isRandomAward!: boolean | undefined;
    description!: string | undefined;
    type!: AwardOutputType | undefined;
    couponUrl!: string | undefined;
    thingType!: AwardOutputThingType | undefined;
    thingId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAwardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityId = data["activityId"];
            this.planQty = data["planQty"];
            this.actualQty = data["actualQty"];
            this.name = data["name"];
            this.awardSeq = data["awardSeq"];
            this.awardProduct = data["awardProduct"];
            this.awardImagePath = data["awardImagePath"];
            this.rate = data["rate"];
            this.minScore = data["minScore"];
            this.maxScore = data["maxScore"];
            this.isRandomAward = data["isRandomAward"];
            this.description = data["description"];
            this.type = data["type"];
            this.couponUrl = data["couponUrl"];
            this.thingType = data["thingType"];
            this.thingId = data["thingId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AwardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAwardOutput {
    tenantId: number | undefined;
    activityId: number | undefined;
    planQty: number | undefined;
    actualQty: number | undefined;
    name: string | undefined;
    awardSeq: number | undefined;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number | undefined;
    minScore: number | undefined;
    maxScore: number | undefined;
    isRandomAward: boolean | undefined;
    description: string | undefined;
    type: AwardOutputType | undefined;
    couponUrl: string | undefined;
    thingType: AwardOutputThingType | undefined;
    thingId: number | undefined;
    id: number | undefined;
}

export class SnsDataInput implements ISnsDataInput {
    snsUserInfoId!: number | undefined;
    securityKey!: string | undefined;
    isNeedSendNotify!: boolean | undefined;

    constructor(data?: ISnsDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfoId = data["snsUserInfoId"];
            this.securityKey = data["securityKey"];
            this.isNeedSendNotify = data["isNeedSendNotify"];
        }
    }

    static fromJS(data: any): SnsDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["securityKey"] = this.securityKey;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        return data; 
    }
}

export interface ISnsDataInput {
    snsUserInfoId: number | undefined;
    securityKey: string | undefined;
    isNeedSendNotify: boolean | undefined;
}

export class DoLotteryAwardForCargoBySnsInput implements IDoLotteryAwardForCargoBySnsInput {
    subKey!: string | undefined;
    snsUserInfoId!: number | undefined;
    isNeedSendNotify!: boolean | undefined;
    score!: number | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;

    constructor(data?: IDoLotteryAwardForCargoBySnsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.isNeedSendNotify = data["isNeedSendNotify"];
            this.score = data["score"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): DoLotteryAwardForCargoBySnsInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoLotteryAwardForCargoBySnsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IDoLotteryAwardForCargoBySnsInput {
    subKey: string | undefined;
    snsUserInfoId: number | undefined;
    isNeedSendNotify: boolean | undefined;
    score: number | undefined;
    securityKey: string | undefined;
    params: string | undefined;
}

export class LotteryCargoResultDto implements ILotteryCargoResultDto {
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    userAwardId!: number | undefined;

    constructor(data?: ILotteryCargoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.outerId = data["outerId"];
            this.cargoRoadId = data["cargoRoadId"];
            this.userAwardId = data["userAwardId"];
        }
    }

    static fromJS(data: any): LotteryCargoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LotteryCargoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["userAwardId"] = this.userAwardId;
        return data; 
    }
}

export interface ILotteryCargoResultDto {
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    userAwardId: number | undefined;
}

export class LotteryActionDataInput implements ILotteryActionDataInput {
    isNeedSendNotify!: boolean | undefined;
    score!: number | undefined;
    actionId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: ILotteryActionDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isNeedSendNotify = data["isNeedSendNotify"];
            this.score = data["score"];
            this.actionId = data["actionId"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): LotteryActionDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new LotteryActionDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface ILotteryActionDataInput {
    isNeedSendNotify: boolean | undefined;
    score: number | undefined;
    actionId: number;
    securityKey: string;
    params: string | undefined;
}

export class DoLotteryAwardForCargoByActionInput implements IDoLotteryAwardForCargoByActionInput {
    subKey!: string | undefined;
    productId!: number | undefined;
    skuId!: number | undefined;
    awardId!: number | undefined;
    isNeedSendNotify!: boolean | undefined;
    score!: number | undefined;
    actionId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IDoLotteryAwardForCargoByActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            this.productId = data["productId"];
            this.skuId = data["skuId"];
            this.awardId = data["awardId"];
            this.isNeedSendNotify = data["isNeedSendNotify"];
            this.score = data["score"];
            this.actionId = data["actionId"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): DoLotteryAwardForCargoByActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoLotteryAwardForCargoByActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["awardId"] = this.awardId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IDoLotteryAwardForCargoByActionInput {
    subKey: string | undefined;
    productId: number | undefined;
    skuId: number | undefined;
    awardId: number | undefined;
    isNeedSendNotify: boolean | undefined;
    score: number | undefined;
    actionId: number;
    securityKey: string;
    params: string | undefined;
}

export class AwardDataInput implements IAwardDataInput {
    awardId!: number;
    isNeedSendNotify!: boolean | undefined;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IAwardDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.awardId = data["awardId"];
            this.isNeedSendNotify = data["isNeedSendNotify"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): AwardDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardId"] = this.awardId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IAwardDataInput {
    awardId: number;
    isNeedSendNotify: boolean | undefined;
    securityKey: string;
    params: string | undefined;
}

export class UserAwardDataInput implements IUserAwardDataInput {
    userAwardId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IUserAwardDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userAwardId = data["userAwardId"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): UserAwardDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userAwardId"] = this.userAwardId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IUserAwardDataInput {
    userAwardId: number;
    securityKey: string;
    params: string | undefined;
}

export class ClearActivityDataInput implements IClearActivityDataInput {
    isClearAction!: boolean | undefined;
    isClearUserData!: boolean | undefined;
    isClearAward!: boolean | undefined;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IClearActivityDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isClearAction = data["isClearAction"];
            this.isClearUserData = data["isClearUserData"];
            this.isClearAward = data["isClearAward"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): ClearActivityDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearActivityDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IClearActivityDataInput {
    isClearAction: boolean | undefined;
    isClearUserData: boolean | undefined;
    isClearAward: boolean | undefined;
    securityKey: string;
    params: string | undefined;
}

export class CargoResultDto implements ICargoResultDto {
    thingId!: number | undefined;
    thingName!: string | undefined;
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    userAwardId!: number | undefined;

    constructor(data?: ICargoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thingId = data["thingId"];
            this.thingName = data["thingName"];
            this.outerId = data["outerId"];
            this.cargoRoadId = data["cargoRoadId"];
            this.userAwardId = data["userAwardId"];
        }
    }

    static fromJS(data: any): CargoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["thingName"] = this.thingName;
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["userAwardId"] = this.userAwardId;
        return data; 
    }
}

export interface ICargoResultDto {
    thingId: number | undefined;
    thingName: string | undefined;
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    userAwardId: number | undefined;
}

export class DropCargoInput implements IDropCargoInput {
    subkey!: string | undefined;
    cargoRoadId!: number | undefined;
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: IDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subkey = data["subkey"];
            this.cargoRoadId = data["cargoRoadId"];
            this.cargoThingId = data["cargoThingId"];
            this.extensionData = data["extensionData"];
            this.actionId = data["actionId"];
        }
    }

    static fromJS(data: any): DropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new DropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface IDropCargoInput {
    subkey: string | undefined;
    cargoRoadId: number | undefined;
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    actionId: number | undefined;
}

export class DeviceActivityGameOutput implements IDeviceActivityGameOutput {
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    software!: SoftwareOutput | undefined;
    dispatchedSoftwareId!: number | undefined;
    deviceId!: number | undefined;
    subKey!: string | undefined;
    activityId!: number | undefined;
    activity!: ActivityOutput | undefined;
    isShareAction!: boolean | undefined;
    dispatchedActivityId!: number | undefined;
    supportedPlayersCount!: number | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: DeviceActivityGameOutputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: DeviceActivityGameOutputTaobaoAuthorizationType | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActivityShareOutput | undefined;
    extensionData!: string | undefined;
    points!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceActivityGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.software = data["software"] ? SoftwareOutput.fromJS(data["software"]) : <any>undefined;
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.deviceId = data["deviceId"];
            this.subKey = data["subKey"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? ActivityOutput.fromJS(data["activity"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActivityShareOutput.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
            this.points = data["points"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["deviceId"] = this.deviceId;
        data["subKey"] = this.subKey;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGameOutput {
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    software: SoftwareOutput | undefined;
    dispatchedSoftwareId: number | undefined;
    deviceId: number | undefined;
    subKey: string | undefined;
    activityId: number | undefined;
    activity: ActivityOutput | undefined;
    isShareAction: boolean | undefined;
    dispatchedActivityId: number | undefined;
    supportedPlayersCount: number | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: DeviceActivityGameOutputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: DeviceActivityGameOutputTaobaoAuthorizationType | undefined;
    actionShareId: number | undefined;
    actionShare: ActivityShareOutput | undefined;
    extensionData: string | undefined;
    points: number | undefined;
    id: number | undefined;
}

export class SoftwareOutput implements ISoftwareOutput {
    name!: string | undefined;
    code!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: number | undefined;
    versionNumber!: string | undefined;
    type!: number | undefined;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    language!: string | undefined;
    gameType!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    setting!: string | undefined;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean | undefined;
    isSendWechatBeforeGame!: boolean | undefined;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean | undefined;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean | undefined;
    shareActionTabName!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISoftwareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.owner = data["owner"];
            this.contact = data["contact"];
            this.tenantId = data["tenantId"];
            this.url = data["url"];
            this.logoUrl = data["logoUrl"];
            this.largeImageUrl = data["largeImageUrl"];
            this.envType = data["envType"];
            this.versionNumber = data["versionNumber"];
            this.type = data["type"];
            this.targetResolution_Width = data["targetResolution_Width"];
            this.targetResolution_Height = data["targetResolution_Height"];
            this.language = data["language"];
            this.gameType = data["gameType"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.setting = data["setting"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSupportAsync = data["isSupportAsync"];
            this.isSendWechatBeforeGame = data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = data["sendWeChatAfterGameTabName"];
            this.isShareAction = data["isShareAction"];
            this.shareActionTabName = data["shareActionTabName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SoftwareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["language"] = this.language;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["setting"] = this.setting;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISoftwareOutput {
    name: string | undefined;
    code: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: number | undefined;
    versionNumber: string | undefined;
    type: number | undefined;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    language: string | undefined;
    gameType: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    setting: string | undefined;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean | undefined;
    isSendWechatBeforeGame: boolean | undefined;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean | undefined;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean | undefined;
    shareActionTabName: string | undefined;
    id: number | undefined;
}

export class ActivityOutput implements IActivityOutput {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    isSendAwardMessage!: boolean | undefined;
    beforeWeChatMessageId!: number | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    activityShareId!: number | undefined;
    weChatAppID!: string | undefined;
    weixinPublicAccountInfoId!: number | undefined;
    taobaoSellerID!: string | undefined;
    externalAccessTokenInfoId!: number | undefined;
    isEnableWhiteUser!: boolean | undefined;
    isEnableBlackUser!: boolean | undefined;
    organizer!: string | undefined;
    isAllowedRepeatAward!: boolean | undefined;
    isNeedAwardInfo!: boolean | undefined;
    isNeedValidate!: boolean | undefined;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean | undefined;
    iconPath!: string | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean | undefined;
    ownerName!: string | undefined;
    isPublic!: boolean | undefined;
    contactor!: string | undefined;
    outerId!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: ActivityOutputAuditStatus | undefined;
    activityShare!: ActivityShareOutput | undefined;

    constructor(data?: IActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.name = data["name"];
            this.imagePath = data["imagePath"];
            this.address = data["address"];
            this.activityUrl = data["activityUrl"];
            this.activityLogoPath = data["activityLogoPath"];
            this.isSendAwardMessage = data["isSendAwardMessage"];
            this.beforeWeChatMessageId = data["beforeWeChatMessageId"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.activityShareId = data["activityShareId"];
            this.weChatAppID = data["weChatAppID"];
            this.weixinPublicAccountInfoId = data["weixinPublicAccountInfoId"];
            this.taobaoSellerID = data["taobaoSellerID"];
            this.externalAccessTokenInfoId = data["externalAccessTokenInfoId"];
            this.isEnableWhiteUser = data["isEnableWhiteUser"];
            this.isEnableBlackUser = data["isEnableBlackUser"];
            this.organizer = data["organizer"];
            this.isAllowedRepeatAward = data["isAllowedRepeatAward"];
            this.isNeedAwardInfo = data["isNeedAwardInfo"];
            this.isNeedValidate = data["isNeedValidate"];
            this.rules = data["rules"];
            this.activityExcutedDate = data["activityExcutedDate"] ? moment(data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = data["isTemplate"];
            this.iconPath = data["iconPath"];
            this.description = data["description"];
            this.isNeedRegister = data["isNeedRegister"];
            this.ownerName = data["ownerName"];
            this.isPublic = data["isPublic"];
            this.contactor = data["contactor"];
            this.outerId = data["outerId"];
            this.contactorPhone = data["contactorPhone"];
            this.auditStatus = data["auditStatus"];
            this.activityShare = data["activityShare"] ? ActivityShareOutput.fromJS(data["activityShare"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["isSendAwardMessage"] = this.isSendAwardMessage;
        data["beforeWeChatMessageId"] = this.beforeWeChatMessageId;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["activityShareId"] = this.activityShareId;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["organizer"] = this.organizer;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isNeedValidate"] = this.isNeedValidate;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["outerId"] = this.outerId;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["activityShare"] = this.activityShare ? this.activityShare.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActivityOutput {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    isSendAwardMessage: boolean | undefined;
    beforeWeChatMessageId: number | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    activityShareId: number | undefined;
    weChatAppID: string | undefined;
    weixinPublicAccountInfoId: number | undefined;
    taobaoSellerID: string | undefined;
    externalAccessTokenInfoId: number | undefined;
    isEnableWhiteUser: boolean | undefined;
    isEnableBlackUser: boolean | undefined;
    organizer: string | undefined;
    isAllowedRepeatAward: boolean | undefined;
    isNeedAwardInfo: boolean | undefined;
    isNeedValidate: boolean | undefined;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean | undefined;
    iconPath: string | undefined;
    description: string | undefined;
    isNeedRegister: boolean | undefined;
    ownerName: string | undefined;
    isPublic: boolean | undefined;
    contactor: string | undefined;
    outerId: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: ActivityOutputAuditStatus | undefined;
    activityShare: ActivityShareOutput | undefined;
}

export class ActivityShareOutput implements IActivityShareOutput {
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: ActivityShareOutputActivityShareType | undefined;
    id!: number | undefined;

    constructor(data?: IActivityShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.link = data["link"];
            this.imageLink = data["imageLink"];
            this.description = data["description"];
            this.activityShareType = data["activityShareType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityShareOutput {
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: ActivityShareOutputActivityShareType | undefined;
    id: number | undefined;
}

export class DeviceActivityGameSimpleOutput implements IDeviceActivityGameSimpleOutput {
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    software!: SoftwareOutput | undefined;
    dispatchedSoftwareId!: number | undefined;
    deviceId!: number | undefined;
    activityId!: number | undefined;
    isShareAction!: boolean | undefined;
    dispatchedActivityId!: number | undefined;
    supportedPlayersCount!: number | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: DeviceActivityGameSimpleOutputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: DeviceActivityGameSimpleOutputTaobaoAuthorizationType | undefined;
    actionShareId!: number | undefined;
    extensionData!: string | undefined;
    points!: number | undefined;
    imageLink!: string | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceActivityGameSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.software = data["software"] ? SoftwareOutput.fromJS(data["software"]) : <any>undefined;
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.deviceId = data["deviceId"];
            this.activityId = data["activityId"];
            this.isShareAction = data["isShareAction"];
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.actionShareId = data["actionShareId"];
            this.extensionData = data["extensionData"];
            this.points = data["points"];
            this.imageLink = data["imageLink"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGameSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["isShareAction"] = this.isShareAction;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["actionShareId"] = this.actionShareId;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["imageLink"] = this.imageLink;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGameSimpleOutput {
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    software: SoftwareOutput | undefined;
    dispatchedSoftwareId: number | undefined;
    deviceId: number | undefined;
    activityId: number | undefined;
    isShareAction: boolean | undefined;
    dispatchedActivityId: number | undefined;
    supportedPlayersCount: number | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: DeviceActivityGameSimpleOutputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: DeviceActivityGameSimpleOutputTaobaoAuthorizationType | undefined;
    actionShareId: number | undefined;
    extensionData: string | undefined;
    points: number | undefined;
    imageLink: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAwardOutput implements IPagedResultDtoOfAwardOutput {
    totalCount!: number | undefined;
    items!: AwardOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfAwardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AwardOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAwardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAwardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAwardOutput {
    totalCount: number | undefined;
    items: AwardOutput[] | undefined;
}

export class SensingDeviceUserInfoInput implements ISensingDeviceUserInfoInput {
    subKey!: string;
    memberIds!: number[] | undefined;

    constructor(data?: ISensingDeviceUserInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            if (Array.isArray(data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of data["memberIds"])
                    this.memberIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SensingDeviceUserInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceUserInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        return data; 
    }
}

export interface ISensingDeviceUserInfoInput {
    subKey: string;
    memberIds: number[] | undefined;
}

export class UserInteractiveDto implements IUserInteractiveDto {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    interactiveCount!: number | undefined;

    constructor(data?: IUserInteractiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headImgUrl = data["headImgUrl"];
            this.nickName = data["nickName"];
            this.interactiveCount = data["interactiveCount"];
        }
    }

    static fromJS(data: any): UserInteractiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInteractiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["interactiveCount"] = this.interactiveCount;
        return data; 
    }
}

export interface IUserInteractiveDto {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    interactiveCount: number | undefined;
}

export class UpdateActivityAwardsInput implements IUpdateActivityAwardsInput {
    securityKey!: string | undefined;
    cargoStocks!: CargoStock[] | undefined;

    constructor(data?: IUpdateActivityAwardsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.securityKey = data["securityKey"];
            if (Array.isArray(data["cargoStocks"])) {
                this.cargoStocks = [] as any;
                for (let item of data["cargoStocks"])
                    this.cargoStocks!.push(CargoStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateActivityAwardsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityAwardsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        if (Array.isArray(this.cargoStocks)) {
            data["cargoStocks"] = [];
            for (let item of this.cargoStocks)
                data["cargoStocks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateActivityAwardsInput {
    securityKey: string | undefined;
    cargoStocks: CargoStock[] | undefined;
}

export class CargoStock implements ICargoStock {
    cargoRoadId!: number | undefined;
    replenishCargoThing!: ReplenishCargoThingInput[] | undefined;

    constructor(data?: ICargoStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cargoRoadId = data["cargoRoadId"];
            if (Array.isArray(data["replenishCargoThing"])) {
                this.replenishCargoThing = [] as any;
                for (let item of data["replenishCargoThing"])
                    this.replenishCargoThing!.push(ReplenishCargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoStock {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargoRoadId"] = this.cargoRoadId;
        if (Array.isArray(this.replenishCargoThing)) {
            data["replenishCargoThing"] = [];
            for (let item of this.replenishCargoThing)
                data["replenishCargoThing"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoStock {
    cargoRoadId: number | undefined;
    replenishCargoThing: ReplenishCargoThingInput[] | undefined;
}

export class ReplenishCargoThingInput implements IReplenishCargoThingInput {
    thingId!: number | undefined;
    stock!: number | undefined;

    constructor(data?: IReplenishCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thingId = data["thingId"];
            this.stock = data["stock"];
        }
    }

    static fromJS(data: any): ReplenishCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["stock"] = this.stock;
        return data; 
    }
}

export interface IReplenishCargoThingInput {
    thingId: number | undefined;
    stock: number | undefined;
}

export class PagedResultDtoOfPlayGameOutput implements IPagedResultDtoOfPlayGameOutput {
    totalCount!: number | undefined;
    items!: PlayGameOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfPlayGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PlayGameOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPlayGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPlayGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPlayGameOutput {
    totalCount: number | undefined;
    items: PlayGameOutput[] | undefined;
}

export class PlayGameOutput implements IPlayGameOutput {
    gameName!: string | undefined;
    count!: number | undefined;
    gameId!: number | undefined;
    maxScore!: number | undefined;
    actionUrl!: string | undefined;

    constructor(data?: IPlayGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gameName = data["gameName"];
            this.count = data["count"];
            this.gameId = data["gameId"];
            this.maxScore = data["maxScore"];
            this.actionUrl = data["actionUrl"];
        }
    }

    static fromJS(data: any): PlayGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PlayGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["count"] = this.count;
        data["gameId"] = this.gameId;
        data["maxScore"] = this.maxScore;
        data["actionUrl"] = this.actionUrl;
        return data; 
    }
}

export interface IPlayGameOutput {
    gameName: string | undefined;
    count: number | undefined;
    gameId: number | undefined;
    maxScore: number | undefined;
    actionUrl: string | undefined;
}

export class PagedResultDtoOfUserActionPlayInfoOutput implements IPagedResultDtoOfUserActionPlayInfoOutput {
    totalCount!: number | undefined;
    items!: UserActionPlayInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionPlayInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserActionPlayInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionPlayInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionPlayInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionPlayInfoOutput {
    totalCount: number | undefined;
    items: UserActionPlayInfoOutput[] | undefined;
}

export class UserActionPlayInfoOutput implements IUserActionPlayInfoOutput {
    gameName!: string | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean | undefined;
    failReason!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserActionPlayInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gameName = data["gameName"];
            this.qrCodeId = data["qrCodeId"];
            this.score = data["score"];
            this.postUrl = data["postUrl"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.scanQrCodeTime = data["scanQrCodeTime"];
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = data["isSuccess"];
            this.failReason = data["failReason"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserActionPlayInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionPlayInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionPlayInfoOutput {
    gameName: string | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    scanQrCodeTime: string | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean | undefined;
    failReason: string | undefined;
    id: number | undefined;
}

export class RankUserActionInfoOutput implements IRankUserActionInfoOutput {
    rank!: number | undefined;
    rankRate!: number | undefined;
    userType!: string | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean | undefined;
    failReason!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRankUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rank = data["rank"];
            this.rankRate = data["rankRate"];
            this.userType = data["userType"];
            this.qrCodeId = data["qrCodeId"];
            this.score = data["score"];
            this.postUrl = data["postUrl"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.scanQrCodeTime = data["scanQrCodeTime"];
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = data["isSuccess"];
            this.failReason = data["failReason"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RankUserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RankUserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["rankRate"] = this.rankRate;
        data["userType"] = this.userType;
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRankUserActionInfoOutput {
    rank: number | undefined;
    rankRate: number | undefined;
    userType: string | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    scanQrCodeTime: string | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean | undefined;
    failReason: string | undefined;
    id: number | undefined;
}

export class UserGameRank implements IUserGameRank {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    score!: number | undefined;

    constructor(data?: IUserGameRank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headImgUrl = data["headImgUrl"];
            this.nickName = data["nickName"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): UserGameRank {
        data = typeof data === 'object' ? data : {};
        let result = new UserGameRank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IUserGameRank {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    score: number | undefined;
}

export class GetActivityActionsForNextGameDto implements IGetActivityActionsForNextGameDto {
    activityGames!: ActivityGameActionsDto[] | undefined;

    constructor(data?: IGetActivityActionsForNextGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["activityGames"])) {
                this.activityGames = [] as any;
                for (let item of data["activityGames"])
                    this.activityGames!.push(ActivityGameActionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetActivityActionsForNextGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityActionsForNextGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityGames)) {
            data["activityGames"] = [];
            for (let item of this.activityGames)
                data["activityGames"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetActivityActionsForNextGameDto {
    activityGames: ActivityGameActionsDto[] | undefined;
}

export class ActivityGameActionsDto implements IActivityGameActionsDto {
    deviceActivityGame!: DeviceActivityGameSimpleOutput | undefined;
    userActions!: UserActionDto[] | undefined;

    constructor(data?: IActivityGameActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceActivityGame = data["deviceActivityGame"] ? DeviceActivityGameSimpleOutput.fromJS(data["deviceActivityGame"]) : <any>undefined;
            if (Array.isArray(data["userActions"])) {
                this.userActions = [] as any;
                for (let item of data["userActions"])
                    this.userActions!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityGameActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IActivityGameActionsDto {
    deviceActivityGame: DeviceActivityGameSimpleOutput | undefined;
    userActions: UserActionDto[] | undefined;
}

export class UserActionDto implements IUserActionDto {
    id!: number | undefined;
    snsUserId!: number | undefined;
    headimgurl!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    province!: string | undefined;
    city!: string | undefined;
    snsType!: UserActionDtoSnsType | undefined;
    activityId!: number | undefined;
    activityName!: string | undefined;
    snsAppID!: string | undefined;
    softwareName!: string | undefined;
    softwareId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    score!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    awardId!: number | undefined;
    awardName!: string | undefined;

    constructor(data?: IUserActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.snsUserId = data["snsUserId"];
            this.headimgurl = data["headimgurl"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.province = data["province"];
            this.city = data["city"];
            this.snsType = data["snsType"];
            this.activityId = data["activityId"];
            this.activityName = data["activityName"];
            this.snsAppID = data["snsAppID"];
            this.softwareName = data["softwareName"];
            this.softwareId = data["softwareId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.score = data["score"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.awardId = data["awardId"];
            this.awardName = data["awardName"];
        }
    }

    static fromJS(data: any): UserActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["snsUserId"] = this.snsUserId;
        data["headimgurl"] = this.headimgurl;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["province"] = this.province;
        data["city"] = this.city;
        data["snsType"] = this.snsType;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["snsAppID"] = this.snsAppID;
        data["softwareName"] = this.softwareName;
        data["softwareId"] = this.softwareId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["score"] = this.score;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["awardId"] = this.awardId;
        data["awardName"] = this.awardName;
        return data; 
    }
}

export interface IUserActionDto {
    id: number | undefined;
    snsUserId: number | undefined;
    headimgurl: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    province: string | undefined;
    city: string | undefined;
    snsType: UserActionDtoSnsType | undefined;
    activityId: number | undefined;
    activityName: string | undefined;
    snsAppID: string | undefined;
    softwareName: string | undefined;
    softwareId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    score: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    awardId: number | undefined;
    awardName: string | undefined;
}

export class PagedResultDtoOfUserActionDto implements IPagedResultDtoOfUserActionDto {
    totalCount!: number | undefined;
    items!: UserActionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionDto {
    totalCount: number | undefined;
    items: UserActionDto[] | undefined;
}

export class GetLastPlayedUserInfosDto implements IGetLastPlayedUserInfosDto {
    securityKey!: string | undefined;
    deviceGameName!: string | undefined;
    userActions!: UserActionDto[] | undefined;

    constructor(data?: IGetLastPlayedUserInfosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.securityKey = data["securityKey"];
            this.deviceGameName = data["deviceGameName"];
            if (Array.isArray(data["userActions"])) {
                this.userActions = [] as any;
                for (let item of data["userActions"])
                    this.userActions!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLastPlayedUserInfosDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLastPlayedUserInfosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        data["deviceGameName"] = this.deviceGameName;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLastPlayedUserInfosDto {
    securityKey: string | undefined;
    deviceGameName: string | undefined;
    userActions: UserActionDto[] | undefined;
}

export class ActivityUserDataOutput implements IActivityUserDataOutput {
    snsUserInfoId!: number;
    name!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    interests!: string | undefined;
    isSigned!: boolean | undefined;
    isValidated!: boolean | undefined;
    isRegistered!: boolean | undefined;
    isGamed!: boolean | undefined;
    totalPoints!: number | undefined;
    faceUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: IActivityUserDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfoId = data["snsUserInfoId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.interests = data["interests"];
            this.isSigned = data["isSigned"];
            this.isValidated = data["isValidated"];
            this.isRegistered = data["isRegistered"];
            this.isGamed = data["isGamed"];
            this.totalPoints = data["totalPoints"];
            this.faceUrl = data["faceUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityUserDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityUserDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["interests"] = this.interests;
        data["isSigned"] = this.isSigned;
        data["isValidated"] = this.isValidated;
        data["isRegistered"] = this.isRegistered;
        data["isGamed"] = this.isGamed;
        data["totalPoints"] = this.totalPoints;
        data["faceUrl"] = this.faceUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityUserDataOutput {
    snsUserInfoId: number;
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    interests: string | undefined;
    isSigned: boolean | undefined;
    isValidated: boolean | undefined;
    isRegistered: boolean | undefined;
    isGamed: boolean | undefined;
    totalPoints: number | undefined;
    faceUrl: string | undefined;
    id: number | undefined;
}

export class AddOrUpdateActivityUserInput implements IAddOrUpdateActivityUserInput {
    openId!: string;
    snsType!: AddOrUpdateActivityUserInputSnsType | undefined;
    securityKey!: string | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    interests!: string | undefined;

    constructor(data?: IAddOrUpdateActivityUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.snsType = data["snsType"];
            this.securityKey = data["securityKey"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.interests = data["interests"];
        }
    }

    static fromJS(data: any): AddOrUpdateActivityUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateActivityUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["interests"] = this.interests;
        return data; 
    }
}

export interface IAddOrUpdateActivityUserInput {
    openId: string;
    snsType: AddOrUpdateActivityUserInputSnsType | undefined;
    securityKey: string | undefined;
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    interests: string | undefined;
}

export class SnsUserSimpleDataInput implements ISnsUserSimpleDataInput {
    openId!: string;
    snsType!: SnsUserSimpleDataInputSnsType | undefined;
    securityKey!: string;
    params!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: ISnsUserSimpleDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.snsType = data["snsType"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
            this.actionId = data["actionId"];
        }
    }

    static fromJS(data: any): SnsUserSimpleDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserSimpleDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface ISnsUserSimpleDataInput {
    openId: string;
    snsType: SnsUserSimpleDataInputSnsType | undefined;
    securityKey: string;
    params: string | undefined;
    actionId: number | undefined;
}

export class PagedResultDtoOfUserRoomMessageOutput implements IPagedResultDtoOfUserRoomMessageOutput {
    totalCount!: number | undefined;
    items!: UserRoomMessageOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserRoomMessageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserRoomMessageOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserRoomMessageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserRoomMessageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserRoomMessageOutput {
    totalCount: number | undefined;
    items: UserRoomMessageOutput[] | undefined;
}

export class UserRoomMessageOutput implements IUserRoomMessageOutput {
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    type!: UserRoomMessageOutputType | undefined;
    content!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserRoomMessageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.type = data["type"];
            this.content = data["content"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRoomMessageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoomMessageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["content"] = this.content;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserRoomMessageOutput {
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    type: UserRoomMessageOutputType | undefined;
    content: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SnsUserTextDataInput implements ISnsUserTextDataInput {
    text!: string;
    openId!: string;
    snsType!: SnsUserTextDataInputSnsType | undefined;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: ISnsUserTextDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.openId = data["openId"];
            this.snsType = data["snsType"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): SnsUserTextDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserTextDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface ISnsUserTextDataInput {
    text: string;
    openId: string;
    snsType: SnsUserTextDataInputSnsType | undefined;
    securityKey: string;
    params: string | undefined;
}

export class AddOrUpdateSnsUserInfoInput implements IAddOrUpdateSnsUserInfoInput {
    subKey!: string | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    gameName!: string | undefined;
    score!: string | undefined;

    constructor(data?: IAddOrUpdateSnsUserInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subKey = data["subKey"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.gameName = data["gameName"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): AddOrUpdateSnsUserInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSnsUserInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["gameName"] = this.gameName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IAddOrUpdateSnsUserInfoInput {
    subKey: string | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    gameName: string | undefined;
    score: string | undefined;
}

export class Qrcode4LoginInput implements IQrcode4LoginInput {
    securityKey!: string;
    params!: string | undefined;
    isSendWeChatMsg!: boolean | undefined;
    qrType!: Qrcode4LoginInputQrType | undefined;
    snsType!: Qrcode4LoginInputSnsType | undefined;
    targetUrl!: string | undefined;
    isTransferred!: boolean | undefined;

    constructor(data?: IQrcode4LoginInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.securityKey = data["securityKey"];
            this.params = data["params"];
            this.isSendWeChatMsg = data["isSendWeChatMsg"];
            this.qrType = data["qrType"];
            this.snsType = data["snsType"];
            this.targetUrl = data["targetUrl"];
            this.isTransferred = data["isTransferred"];
        }
    }

    static fromJS(data: any): Qrcode4LoginInput {
        data = typeof data === 'object' ? data : {};
        let result = new Qrcode4LoginInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        data["isSendWeChatMsg"] = this.isSendWeChatMsg;
        data["qrType"] = this.qrType;
        data["snsType"] = this.snsType;
        data["targetUrl"] = this.targetUrl;
        data["isTransferred"] = this.isTransferred;
        return data; 
    }
}

export interface IQrcode4LoginInput {
    securityKey: string;
    params: string | undefined;
    isSendWeChatMsg: boolean | undefined;
    qrType: Qrcode4LoginInputQrType | undefined;
    snsType: Qrcode4LoginInputSnsType | undefined;
    targetUrl: string | undefined;
    isTransferred: boolean | undefined;
}

export class QrcodeOutput implements IQrcodeOutput {
    qrCodeUrl!: string | undefined;
    qrCodeImage!: string | undefined;
    qrCodeId!: string | undefined;

    constructor(data?: IQrcodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeUrl = data["qrCodeUrl"];
            this.qrCodeImage = data["qrCodeImage"];
            this.qrCodeId = data["qrCodeId"];
        }
    }

    static fromJS(data: any): QrcodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new QrcodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["qrCodeImage"] = this.qrCodeImage;
        data["qrCodeId"] = this.qrCodeId;
        return data; 
    }
}

export interface IQrcodeOutput {
    qrCodeUrl: string | undefined;
    qrCodeImage: string | undefined;
    qrCodeId: string | undefined;
}

export class PagedResultDtoOfSnsUserInfoOutput implements IPagedResultDtoOfSnsUserInfoOutput {
    totalCount!: number | undefined;
    items!: SnsUserInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SnsUserInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserInfoOutput {
    totalCount: number | undefined;
    items: SnsUserInfoOutput[] | undefined;
}

export class UserActionInfoOutput implements IUserActionInfoOutput {
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean | undefined;
    failReason!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeId = data["qrCodeId"];
            this.score = data["score"];
            this.postUrl = data["postUrl"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.scanQrCodeTime = data["scanQrCodeTime"];
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = data["isSuccess"];
            this.failReason = data["failReason"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionInfoOutput {
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    scanQrCodeTime: string | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean | undefined;
    failReason: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserActionInfoOutput implements IPagedResultDtoOfUserActionInfoOutput {
    totalCount!: number | undefined;
    items!: UserActionInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserActionInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionInfoOutput {
    totalCount: number | undefined;
    items: UserActionInfoOutput[] | undefined;
}

export class PagedResultDtoOfActivityDataUserOutput implements IPagedResultDtoOfActivityDataUserOutput {
    totalCount!: number | undefined;
    items!: ActivityDataUserOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityDataUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ActivityDataUserOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityDataUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityDataUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityDataUserOutput {
    totalCount: number | undefined;
    items: ActivityDataUserOutput[] | undefined;
}

export class ActivityDataUserOutput implements IActivityDataUserOutput {
    snsUserInfo!: SnsUserInfoOutput | undefined;
    activityUserData!: ActivityUserDataOutput | undefined;

    constructor(data?: IActivityDataUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.activityUserData = data["activityUserData"] ? ActivityUserDataOutput.fromJS(data["activityUserData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityDataUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDataUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["activityUserData"] = this.activityUserData ? this.activityUserData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActivityDataUserOutput {
    snsUserInfo: SnsUserInfoOutput | undefined;
    activityUserData: ActivityUserDataOutput | undefined;
}

export class SnsUserAwardsSimpleOutput implements ISnsUserAwardsSimpleOutput {
    canNextAward!: boolean | undefined;
    canFreeLottery!: boolean | undefined;
    canShareGetFreeLottery!: boolean | undefined;
    currentLotteryTimes!: number | undefined;
    awards!: SnsUserAwardOuput[] | undefined;

    constructor(data?: ISnsUserAwardsSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canNextAward = data["canNextAward"];
            this.canFreeLottery = data["canFreeLottery"];
            this.canShareGetFreeLottery = data["canShareGetFreeLottery"];
            this.currentLotteryTimes = data["currentLotteryTimes"];
            if (Array.isArray(data["awards"])) {
                this.awards = [] as any;
                for (let item of data["awards"])
                    this.awards!.push(SnsUserAwardOuput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SnsUserAwardsSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAwardsSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canNextAward"] = this.canNextAward;
        data["canFreeLottery"] = this.canFreeLottery;
        data["canShareGetFreeLottery"] = this.canShareGetFreeLottery;
        data["currentLotteryTimes"] = this.currentLotteryTimes;
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISnsUserAwardsSimpleOutput {
    canNextAward: boolean | undefined;
    canFreeLottery: boolean | undefined;
    canShareGetFreeLottery: boolean | undefined;
    currentLotteryTimes: number | undefined;
    awards: SnsUserAwardOuput[] | undefined;
}

export class ClearSnsUserDataInput implements IClearSnsUserDataInput {
    isClearAction!: boolean | undefined;
    isClearUserData!: boolean | undefined;
    isClearAward!: boolean | undefined;
    openId!: string;
    snsType!: ClearSnsUserDataInputSnsType | undefined;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IClearSnsUserDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isClearAction = data["isClearAction"];
            this.isClearUserData = data["isClearUserData"];
            this.isClearAward = data["isClearAward"];
            this.openId = data["openId"];
            this.snsType = data["snsType"];
            this.securityKey = data["securityKey"];
            this.params = data["params"];
        }
    }

    static fromJS(data: any): ClearSnsUserDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearSnsUserDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IClearSnsUserDataInput {
    isClearAction: boolean | undefined;
    isClearUserData: boolean | undefined;
    isClearAward: boolean | undefined;
    openId: string;
    snsType: ClearSnsUserDataInputSnsType | undefined;
    securityKey: string;
    params: string | undefined;
}

export class GetLimitQrcodeByWechatInput implements IGetLimitQrcodeByWechatInput {
    action_name!: string | undefined;
    action_info!: ActionInfo | undefined;

    constructor(data?: IGetLimitQrcodeByWechatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action_name = data["action_name"];
            this.action_info = data["action_info"] ? ActionInfo.fromJS(data["action_info"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLimitQrcodeByWechatInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLimitQrcodeByWechatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action_name"] = this.action_name;
        data["action_info"] = this.action_info ? this.action_info.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLimitQrcodeByWechatInput {
    action_name: string | undefined;
    action_info: ActionInfo | undefined;
}

export class ActionInfo implements IActionInfo {
    scene!: Scene | undefined;

    constructor(data?: IActionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scene = data["scene"] ? Scene.fromJS(data["scene"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scene"] = this.scene ? this.scene.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionInfo {
    scene: Scene | undefined;
}

export class Scene implements IScene {
    scene_str!: string | undefined;

    constructor(data?: IScene) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scene_str = data["scene_str"];
        }
    }

    static fromJS(data: any): Scene {
        data = typeof data === 'object' ? data : {};
        let result = new Scene();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scene_str"] = this.scene_str;
        return data; 
    }
}

export interface IScene {
    scene_str: string | undefined;
}

export class PagedResultDtoOfGetWechatMediaDto implements IPagedResultDtoOfGetWechatMediaDto {
    totalCount!: number | undefined;
    items!: GetWechatMediaDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWechatMediaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatMediaDto {
    totalCount: number | undefined;
    items: GetWechatMediaDto[] | undefined;
}

export class GetWechatMediaDto implements IGetWechatMediaDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    media_id!: string | undefined;
    mediaType!: GetWechatMediaDtoMediaType | undefined;
    title!: string | undefined;
    name!: string | undefined;
    author!: string | undefined;
    digest!: string | undefined;
    thumb_media_id!: string | undefined;
    show_cover_pic!: boolean | undefined;
    content_source_url!: string | undefined;
    url!: string | undefined;
    thumb_url!: string | undefined;
    need_open_comment!: string | undefined;
    only_fans_can_comment!: string | undefined;
    tags!: Tag[] | undefined;

    constructor(data?: IGetWechatMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.media_id = data["media_id"];
            this.mediaType = data["mediaType"];
            this.title = data["title"];
            this.name = data["name"];
            this.author = data["author"];
            this.digest = data["digest"];
            this.thumb_media_id = data["thumb_media_id"];
            this.show_cover_pic = data["show_cover_pic"];
            this.content_source_url = data["content_source_url"];
            this.url = data["url"];
            this.thumb_url = data["thumb_url"];
            this.need_open_comment = data["need_open_comment"];
            this.only_fans_can_comment = data["only_fans_can_comment"];
            if (Array.isArray(data["tags"])) {
                this.tags = [] as any;
                for (let item of data["tags"])
                    this.tags!.push(Tag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["media_id"] = this.media_id;
        data["mediaType"] = this.mediaType;
        data["title"] = this.title;
        data["name"] = this.name;
        data["author"] = this.author;
        data["digest"] = this.digest;
        data["thumb_media_id"] = this.thumb_media_id;
        data["show_cover_pic"] = this.show_cover_pic;
        data["content_source_url"] = this.content_source_url;
        data["url"] = this.url;
        data["thumb_url"] = this.thumb_url;
        data["need_open_comment"] = this.need_open_comment;
        data["only_fans_can_comment"] = this.only_fans_can_comment;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetWechatMediaDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    media_id: string | undefined;
    mediaType: GetWechatMediaDtoMediaType | undefined;
    title: string | undefined;
    name: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    thumb_media_id: string | undefined;
    show_cover_pic: boolean | undefined;
    content_source_url: string | undefined;
    url: string | undefined;
    thumb_url: string | undefined;
    need_open_comment: string | undefined;
    only_fans_can_comment: string | undefined;
    tags: Tag[] | undefined;
}

export class Tag implements ITag {
    value!: string;
    type!: TagType | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.type = data["type"];
            this.iconUrl = data["iconUrl"];
            this.isSpecial = data["isSpecial"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.orderNumber = data["orderNumber"];
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class MergeSnsUsersInput implements IMergeSnsUsersInput {
    openIds!: string[] | undefined;
    memberId!: number | undefined;

    constructor(data?: IMergeSnsUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["openIds"])) {
                this.openIds = [] as any;
                for (let item of data["openIds"])
                    this.openIds!.push(item);
            }
            this.memberId = data["memberId"];
        }
    }

    static fromJS(data: any): MergeSnsUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeSnsUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.openIds)) {
            data["openIds"] = [];
            for (let item of this.openIds)
                data["openIds"].push(item);
        }
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface IMergeSnsUsersInput {
    openIds: string[] | undefined;
    memberId: number | undefined;
}

export class SnsUserInfoWithMemberDto implements ISnsUserInfoWithMemberDto {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    userActions!: UserAction[] | undefined;
    isBecomeFans!: boolean | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoWithMemberDtoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    point!: string | undefined;
    memberLevel!: string | undefined;
    regPhone!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserInfoWithMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.weixinGroupid = data["weixinGroupid"];
            this.memberId = data["memberId"];
            if (Array.isArray(data["userActions"])) {
                this.userActions = [] as any;
                for (let item of data["userActions"])
                    this.userActions!.push(UserAction.fromJS(item));
            }
            this.isBecomeFans = data["isBecomeFans"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
            this.point = data["point"];
            this.memberLevel = data["memberLevel"];
            this.regPhone = data["regPhone"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoWithMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoWithMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["point"] = this.point;
        data["memberLevel"] = this.memberLevel;
        data["regPhone"] = this.regPhone;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoWithMemberDto {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    userActions: UserAction[] | undefined;
    isBecomeFans: boolean | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoWithMemberDtoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    point: string | undefined;
    memberLevel: string | undefined;
    regPhone: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OAuthUserInfo implements IOAuthUserInfo {
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    province!: string | undefined;
    city!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    privilege!: string[] | undefined;
    unionid!: string | undefined;

    constructor(data?: IOAuthUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.province = data["province"];
            this.city = data["city"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            if (Array.isArray(data["privilege"])) {
                this.privilege = [] as any;
                for (let item of data["privilege"])
                    this.privilege!.push(item);
            }
            this.unionid = data["unionid"];
        }
    }

    static fromJS(data: any): OAuthUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["province"] = this.province;
        data["city"] = this.city;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        if (Array.isArray(this.privilege)) {
            data["privilege"] = [];
            for (let item of this.privilege)
                data["privilege"].push(item);
        }
        data["unionid"] = this.unionid;
        return data; 
    }
}

export interface IOAuthUserInfo {
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    province: string | undefined;
    city: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    privilege: string[] | undefined;
    unionid: string | undefined;
}

export class PagedResultDtoOfSpecailUserDto implements IPagedResultDtoOfSpecailUserDto {
    totalCount!: number | undefined;
    items!: SpecailUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSpecailUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SpecailUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSpecailUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSpecailUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSpecailUserDto {
    totalCount: number | undefined;
    items: SpecailUserDto[] | undefined;
}

export class SpecailUserDto implements ISpecailUserDto {
    tenantId!: number | undefined;
    openID!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoDto | undefined;
    awardSeqs!: string | undefined;
    activityId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    type!: SpecailUserDtoType | undefined;
    id!: number | undefined;

    constructor(data?: ISpecailUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.openID = data["openID"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoDto.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.awardSeqs = data["awardSeqs"];
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.description = data["description"];
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SpecailUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecailUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["openID"] = this.openID;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardSeqs"] = this.awardSeqs;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISpecailUserDto {
    tenantId: number | undefined;
    openID: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoDto | undefined;
    awardSeqs: string | undefined;
    activityId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    type: SpecailUserDtoType | undefined;
    id: number | undefined;
}

export class CreateSpecialUserInput implements ICreateSpecialUserInput {
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    type!: CreateSpecialUserInputType;

    constructor(data?: ICreateSpecialUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.awardSeqs = data["awardSeqs"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.description = data["description"];
            this.forAward = data["forAward"];
            this.forLottery = data["forLottery"];
            this.forUseTicket = data["forUseTicket"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): CreateSpecialUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSpecialUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICreateSpecialUserInput {
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    type: CreateSpecialUserInputType;
}

export class UpdateSpecialUserInput implements IUpdateSpecialUserInput {
    id!: number | undefined;
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    type!: UpdateSpecialUserInputType;

    constructor(data?: IUpdateSpecialUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.awardSeqs = data["awardSeqs"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.description = data["description"];
            this.forAward = data["forAward"];
            this.forLottery = data["forLottery"];
            this.forUseTicket = data["forUseTicket"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): UpdateSpecialUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSpecialUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUpdateSpecialUserInput {
    id: number | undefined;
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    type: UpdateSpecialUserInputType;
}

export class StoreActivityGame implements IStoreActivityGame {
    dispatchedActivityId!: number | undefined;
    storeId!: number | undefined;
    storeActivityId!: number | undefined;
    storeActivity!: StoreActivity | undefined;
    tenantId!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    isShareAction!: boolean | undefined;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare | undefined;
    supportedPlayersCount!: number | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage | undefined;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number | undefined;
    minPlayTimeDiff!: number | undefined;
    isGameStarted!: boolean | undefined;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    securityKey!: string | undefined;
    weChatAuthorizationType!: StoreActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: StoreActivityGameTaobaoAuthorizationType | undefined;
    extensionData!: string | undefined;
    points!: number | undefined;
    isAllowBlack!: boolean | undefined;
    isAllowWhite!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IStoreActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.storeId = data["storeId"];
            this.storeActivityId = data["storeActivityId"];
            this.storeActivity = data["storeActivity"] ? StoreActivity.fromJS(data["storeActivity"]) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShareId = data["actionShareId"];
            this.actionShare = data["actionShare"] ? ActivityShare.fromJS(data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = data["beforeGameMessageId"];
            this.beforeGameMessage = data["beforeGameMessage"] ? SnsMessage.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = data["afterGameMessageId"];
            this.afterGameMessage = data["afterGameMessage"] ? SnsMessage.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.onlineBackground = data["onlineBackground"];
            this.onlineForeground = data["onlineForeground"];
            this.offlineBackground = data["offlineBackground"];
            this.offlineForeground = data["offlineForeground"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.maxPlayCountPerUser = data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = data["minPlayTimeDiff"];
            this.isGameStarted = data["isGameStarted"];
            this.lastGameOverTime = data["lastGameOverTime"] ? moment(data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.securityKey = data["securityKey"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.extensionData = data["extensionData"];
            this.points = data["points"];
            this.isAllowBlack = data["isAllowBlack"];
            this.isAllowWhite = data["isAllowWhite"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StoreActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new StoreActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["storeId"] = this.storeId;
        data["storeActivityId"] = this.storeActivityId;
        data["storeActivity"] = this.storeActivity ? this.storeActivity.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["isAllowBlack"] = this.isAllowBlack;
        data["isAllowWhite"] = this.isAllowWhite;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreActivityGame {
    dispatchedActivityId: number | undefined;
    storeId: number | undefined;
    storeActivityId: number | undefined;
    storeActivity: StoreActivity | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    isShareAction: boolean | undefined;
    actionShareId: number | undefined;
    actionShare: ActivityShare | undefined;
    supportedPlayersCount: number | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage | undefined;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number | undefined;
    minPlayTimeDiff: number | undefined;
    isGameStarted: boolean | undefined;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    securityKey: string | undefined;
    weChatAuthorizationType: StoreActivityGameWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: StoreActivityGameTaobaoAuthorizationType | undefined;
    extensionData: string | undefined;
    points: number | undefined;
    isAllowBlack: boolean | undefined;
    isAllowWhite: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class StoreActivity implements IStoreActivity {
    storeId!: number | undefined;
    activityId!: number | undefined;
    activity!: Activity | undefined;
    dispatchedActivityId!: number | undefined;
    dispatchedActivity!: DispatchedActivity | undefined;
    games!: StoreActivityGame[] | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IStoreActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeId = data["storeId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.dispatchedActivityId = data["dispatchedActivityId"];
            this.dispatchedActivity = data["dispatchedActivity"] ? DispatchedActivity.fromJS(data["dispatchedActivity"]) : <any>undefined;
            if (Array.isArray(data["games"])) {
                this.games = [] as any;
                for (let item of data["games"])
                    this.games!.push(StoreActivityGame.fromJS(item));
            }
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StoreActivity {
        data = typeof data === 'object' ? data : {};
        let result = new StoreActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["dispatchedActivity"] = this.dispatchedActivity ? this.dispatchedActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreActivity {
    storeId: number | undefined;
    activityId: number | undefined;
    activity: Activity | undefined;
    dispatchedActivityId: number | undefined;
    dispatchedActivity: DispatchedActivity | undefined;
    games: StoreActivityGame[] | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UpdateStoreActivityGameInput implements IUpdateStoreActivityGameInput {
    id!: number | undefined;
    name!: string | undefined;
    softwareId!: number | undefined;
    dispatchedSoftwareId!: number | undefined;
    isNeedCheckBeforScanQRCode!: boolean | undefined;
    supportedPlayersCount!: number | undefined;
    weChatAuthorizationType!: UpdateStoreActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType!: UpdateStoreActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean | undefined;
    beforeGameMessage!: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame!: boolean | undefined;
    afterGameMessage!: CreateSnsMsgGameInput | undefined;
    isShareAction!: boolean | undefined;
    actionShare!: CreateActionShareInput | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateStoreActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.softwareId = data["softwareId"];
            this.dispatchedSoftwareId = data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = data["supportedPlayersCount"];
            this.weChatAuthorizationType = data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = data["taobaoAuthorizationType"];
            this.materialPacketUrl = data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = data["isShareAction"];
            this.actionShare = data["actionShare"] ? CreateActionShareInput.fromJS(data["actionShare"]) : <any>undefined;
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateStoreActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateStoreActivityGameInput {
    id: number | undefined;
    name: string | undefined;
    softwareId: number | undefined;
    dispatchedSoftwareId: number | undefined;
    isNeedCheckBeforScanQRCode: boolean | undefined;
    supportedPlayersCount: number | undefined;
    weChatAuthorizationType: UpdateStoreActivityGameInputWeChatAuthorizationType | undefined;
    taobaoAuthorizationType: UpdateStoreActivityGameInputTaobaoAuthorizationType | undefined;
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean | undefined;
    beforeGameMessage: CreateSnsMsgGameInput | undefined;
    isSendSnsMsgAfterGame: boolean | undefined;
    afterGameMessage: CreateSnsMsgGameInput | undefined;
    isShareAction: boolean | undefined;
    actionShare: CreateActionShareInput | undefined;
    extensionData: string | undefined;
}

export class CreateTrainingInput implements ICreateTrainingInput {
    title!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: CreateTrainingInputCategory | undefined;
    auditStatus!: CreateTrainingInputAuditStatus | undefined;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: CreateTrainingInputTrainingWay | undefined;
    userId!: number | undefined;
    courseId!: number | undefined;
    groupIds!: number[] | undefined;
    paperId!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICreateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.category = data["category"];
            this.auditStatus = data["auditStatus"];
            this.totalLength = data["totalLength"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.trainingWay = data["trainingWay"];
            this.userId = data["userId"];
            this.courseId = data["courseId"];
            if (Array.isArray(data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.paperId = data["paperId"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): CreateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["paperId"] = this.paperId;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateTrainingInput {
    title: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: CreateTrainingInputCategory | undefined;
    auditStatus: CreateTrainingInputAuditStatus | undefined;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: CreateTrainingInputTrainingWay | undefined;
    userId: number | undefined;
    courseId: number | undefined;
    groupIds: number[] | undefined;
    paperId: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class UpdateTrainingInput implements IUpdateTrainingInput {
    id!: number | undefined;
    title!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: UpdateTrainingInputCategory | undefined;
    auditStatus!: UpdateTrainingInputAuditStatus | undefined;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: UpdateTrainingInputTrainingWay | undefined;
    userId!: number | undefined;
    courseId!: number | undefined;
    groupIds!: number[] | undefined;
    paperId!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.category = data["category"];
            this.auditStatus = data["auditStatus"];
            this.totalLength = data["totalLength"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.trainingWay = data["trainingWay"];
            this.userId = data["userId"];
            this.courseId = data["courseId"];
            if (Array.isArray(data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.paperId = data["paperId"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["paperId"] = this.paperId;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateTrainingInput {
    id: number | undefined;
    title: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: UpdateTrainingInputCategory | undefined;
    auditStatus: UpdateTrainingInputAuditStatus | undefined;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: UpdateTrainingInputTrainingWay | undefined;
    userId: number | undefined;
    courseId: number | undefined;
    groupIds: number[] | undefined;
    paperId: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class PagedResultDtoOfTrainingBasicDto implements IPagedResultDtoOfTrainingBasicDto {
    totalCount!: number | undefined;
    items!: TrainingBasicDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTrainingBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TrainingBasicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTrainingBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTrainingBasicDto {
    totalCount: number | undefined;
    items: TrainingBasicDto[] | undefined;
}

export class TrainingBasicDto implements ITrainingBasicDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    title!: string | undefined;
    no!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingBasicDtoCategory | undefined;
    auditStatus!: TrainingBasicDtoAuditStatus | undefined;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingBasicDtoTrainingWay | undefined;
    trainingStatus!: TrainingBasicDtoTrainingStatus | undefined;
    userId!: number | undefined;
    courseId!: number | undefined;
    lecturer!: string | undefined;
    departmentDisplayNames!: string[] | undefined;
    score!: number | undefined;
    participaterCount!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    questionNaireId!: number | undefined;
    isMine!: boolean | undefined;
    isCompleted!: boolean | undefined;
    paperId!: number | undefined;

    constructor(data?: ITrainingBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.title = data["title"];
            this.no = data["no"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.category = data["category"];
            this.auditStatus = data["auditStatus"];
            this.totalLength = data["totalLength"];
            this.fileUrl = data["fileUrl"];
            this.picUrl = data["picUrl"];
            this.trainingWay = data["trainingWay"];
            this.trainingStatus = data["trainingStatus"];
            this.userId = data["userId"];
            this.courseId = data["courseId"];
            this.lecturer = data["lecturer"];
            if (Array.isArray(data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.score = data["score"];
            this.participaterCount = data["participaterCount"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.questionNaireId = data["questionNaireId"];
            this.isMine = data["isMine"];
            this.isCompleted = data["isCompleted"];
            this.paperId = data["paperId"];
        }
    }

    static fromJS(data: any): TrainingBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["no"] = this.no;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["trainingStatus"] = this.trainingStatus;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["lecturer"] = this.lecturer;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["score"] = this.score;
        data["participaterCount"] = this.participaterCount;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["questionNaireId"] = this.questionNaireId;
        data["isMine"] = this.isMine;
        data["isCompleted"] = this.isCompleted;
        data["paperId"] = this.paperId;
        return data; 
    }
}

export interface ITrainingBasicDto {
    id: number | undefined;
    tenantId: number | undefined;
    title: string | undefined;
    no: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingBasicDtoCategory | undefined;
    auditStatus: TrainingBasicDtoAuditStatus | undefined;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingBasicDtoTrainingWay | undefined;
    trainingStatus: TrainingBasicDtoTrainingStatus | undefined;
    userId: number | undefined;
    courseId: number | undefined;
    lecturer: string | undefined;
    departmentDisplayNames: string[] | undefined;
    score: number | undefined;
    participaterCount: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    questionNaireId: number | undefined;
    isMine: boolean | undefined;
    isCompleted: boolean | undefined;
    paperId: number | undefined;
}

export class TrainingAuditInput implements ITrainingAuditInput {
    trainingIds!: number[] | undefined;
    currentAuditStatus!: TrainingAuditInputCurrentAuditStatus | undefined;
    targetAuditStatus!: TrainingAuditInputTargetAuditStatus | undefined;

    constructor(data?: ITrainingAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["trainingIds"])) {
                this.trainingIds = [] as any;
                for (let item of data["trainingIds"])
                    this.trainingIds!.push(item);
            }
            this.currentAuditStatus = data["currentAuditStatus"];
            this.targetAuditStatus = data["targetAuditStatus"];
        }
    }

    static fromJS(data: any): TrainingAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.trainingIds)) {
            data["trainingIds"] = [];
            for (let item of this.trainingIds)
                data["trainingIds"].push(item);
        }
        data["currentAuditStatus"] = this.currentAuditStatus;
        data["targetAuditStatus"] = this.targetAuditStatus;
        return data; 
    }
}

export interface ITrainingAuditInput {
    trainingIds: number[] | undefined;
    currentAuditStatus: TrainingAuditInputCurrentAuditStatus | undefined;
    targetAuditStatus: TrainingAuditInputTargetAuditStatus | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class BatchSetCourseTagsInput implements IBatchSetCourseTagsInput {
    tagIds!: number[] | undefined;
    courseIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IBatchSetCourseTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(data["courseIds"])) {
                this.courseIds = [] as any;
                for (let item of data["courseIds"])
                    this.courseIds!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): BatchSetCourseTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new BatchSetCourseTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.courseIds)) {
            data["courseIds"] = [];
            for (let item of this.courseIds)
                data["courseIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IBatchSetCourseTagsInput {
    tagIds: number[] | undefined;
    courseIds: number[] | undefined;
    action: string | undefined;
}

export class AutoGenerateTrainingInput implements IAutoGenerateTrainingInput {
    userId!: number | undefined;
    courseTagId!: number | undefined;
    startTime!: moment.Moment | undefined;

    constructor(data?: IAutoGenerateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.courseTagId = data["courseTagId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AutoGenerateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AutoGenerateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["courseTagId"] = this.courseTagId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAutoGenerateTrainingInput {
    userId: number | undefined;
    courseTagId: number | undefined;
    startTime: moment.Moment | undefined;
}

export class TrainingSimpleDto implements ITrainingSimpleDto {
    ownerTrainings!: TrainingSimpleInfo[] | undefined;
    allTrainings!: TrainingSimpleInfo[] | undefined;

    constructor(data?: ITrainingSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ownerTrainings"])) {
                this.ownerTrainings = [] as any;
                for (let item of data["ownerTrainings"])
                    this.ownerTrainings!.push(TrainingSimpleInfo.fromJS(item));
            }
            if (Array.isArray(data["allTrainings"])) {
                this.allTrainings = [] as any;
                for (let item of data["allTrainings"])
                    this.allTrainings!.push(TrainingSimpleInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ownerTrainings)) {
            data["ownerTrainings"] = [];
            for (let item of this.ownerTrainings)
                data["ownerTrainings"].push(item.toJSON());
        }
        if (Array.isArray(this.allTrainings)) {
            data["allTrainings"] = [];
            for (let item of this.allTrainings)
                data["allTrainings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingSimpleDto {
    ownerTrainings: TrainingSimpleInfo[] | undefined;
    allTrainings: TrainingSimpleInfo[] | undefined;
}

export class TrainingSimpleInfo implements ITrainingSimpleInfo {
    id!: number | undefined;
    ownerName!: string | undefined;
    name!: string | undefined;
    startTime!: moment.Moment | undefined;
    address!: string | undefined;
    isCompleted!: boolean | undefined;
    departmentDisplayNames!: string[] | undefined;
    score!: number | undefined;
    participaterCount!: number | undefined;

    constructor(data?: ITrainingSimpleInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ownerName = data["ownerName"];
            this.name = data["name"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.address = data["address"];
            this.isCompleted = data["isCompleted"];
            if (Array.isArray(data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.score = data["score"];
            this.participaterCount = data["participaterCount"];
        }
    }

    static fromJS(data: any): TrainingSimpleInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSimpleInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerName"] = this.ownerName;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["score"] = this.score;
        data["participaterCount"] = this.participaterCount;
        return data; 
    }
}

export interface ITrainingSimpleInfo {
    id: number | undefined;
    ownerName: string | undefined;
    name: string | undefined;
    startTime: moment.Moment | undefined;
    address: string | undefined;
    isCompleted: boolean | undefined;
    departmentDisplayNames: string[] | undefined;
    score: number | undefined;
    participaterCount: number | undefined;
}

export class SingleTrainingInfo implements ISingleTrainingInfo {
    id!: number | undefined;
    ownerName!: string | undefined;
    address!: string | undefined;
    name!: string | undefined;
    isCompleted!: boolean | undefined;
    paperId!: number | undefined;
    departmentDisplayNames!: string[] | undefined;
    startTime!: moment.Moment | undefined;
    questionDtos!: QuestionDto[] | undefined;

    constructor(data?: ISingleTrainingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ownerName = data["ownerName"];
            this.address = data["address"];
            this.name = data["name"];
            this.isCompleted = data["isCompleted"];
            this.paperId = data["paperId"];
            if (Array.isArray(data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            if (Array.isArray(data["questionDtos"])) {
                this.questionDtos = [] as any;
                for (let item of data["questionDtos"])
                    this.questionDtos!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleTrainingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SingleTrainingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["name"] = this.name;
        data["isCompleted"] = this.isCompleted;
        data["paperId"] = this.paperId;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        if (Array.isArray(this.questionDtos)) {
            data["questionDtos"] = [];
            for (let item of this.questionDtos)
                data["questionDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISingleTrainingInfo {
    id: number | undefined;
    ownerName: string | undefined;
    address: string | undefined;
    name: string | undefined;
    isCompleted: boolean | undefined;
    paperId: number | undefined;
    departmentDisplayNames: string[] | undefined;
    startTime: moment.Moment | undefined;
    questionDtos: QuestionDto[] | undefined;
}

export class GetUserPapers4WechatDto implements IGetUserPapers4WechatDto {
    opinion!: string | undefined;
    userQuestionItems!: UserPaperQuestionId[] | undefined;

    constructor(data?: IGetUserPapers4WechatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.opinion = data["opinion"];
            if (Array.isArray(data["userQuestionItems"])) {
                this.userQuestionItems = [] as any;
                for (let item of data["userQuestionItems"])
                    this.userQuestionItems!.push(UserPaperQuestionId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserPapers4WechatDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPapers4WechatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opinion"] = this.opinion;
        if (Array.isArray(this.userQuestionItems)) {
            data["userQuestionItems"] = [];
            for (let item of this.userQuestionItems)
                data["userQuestionItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserPapers4WechatDto {
    opinion: string | undefined;
    userQuestionItems: UserPaperQuestionId[] | undefined;
}

export class UserPaperQuestionId implements IUserPaperQuestionId {
    questionId!: number | undefined;
    questionItemId!: number | undefined;

    constructor(data?: IUserPaperQuestionId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.questionItemId = data["questionItemId"];
        }
    }

    static fromJS(data: any): UserPaperQuestionId {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaperQuestionId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionItemId"] = this.questionItemId;
        return data; 
    }
}

export interface IUserPaperQuestionId {
    questionId: number | undefined;
    questionItemId: number | undefined;
}

export class ActionInfoDto implements IActionInfoDto {
    storeOuterId!: string | undefined;
    extensionData!: string | undefined;
    expiredTime!: moment.Moment | undefined;

    constructor(data?: IActionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeOuterId = data["storeOuterId"];
            this.extensionData = data["extensionData"];
            this.expiredTime = data["expiredTime"] ? moment(data["expiredTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["extensionData"] = this.extensionData;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IActionInfoDto {
    storeOuterId: string | undefined;
    extensionData: string | undefined;
    expiredTime: moment.Moment | undefined;
}

export class ActionInfoForOrderDto implements IActionInfoForOrderDto {
    tenantId!: number | undefined;
    subKey!: string | undefined;
    activity!: ActivityForOrder | undefined;
    snsUserInfo!: SnsUserInfoForOrder | undefined;

    constructor(data?: IActionInfoForOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.subKey = data["subKey"];
            this.activity = data["activity"] ? ActivityForOrder.fromJS(data["activity"]) : <any>undefined;
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoForOrder.fromJS(data["snsUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfoForOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfoForOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["subKey"] = this.subKey;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionInfoForOrderDto {
    tenantId: number | undefined;
    subKey: string | undefined;
    activity: ActivityForOrder | undefined;
    snsUserInfo: SnsUserInfoForOrder | undefined;
}

export class ActivityForOrder implements IActivityForOrder {
    id!: number | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    weChatAppID!: string | undefined;
    rules!: string | undefined;

    constructor(data?: IActivityForOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = data["weChatAppID"];
            this.rules = data["rules"];
        }
    }

    static fromJS(data: any): ActivityForOrder {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityForOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["rules"] = this.rules;
        return data; 
    }
}

export interface IActivityForOrder {
    id: number | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    weChatAppID: string | undefined;
    rules: string | undefined;
}

export class SnsUserInfoForOrder implements ISnsUserInfoForOrder {
    id!: number | undefined;
    openid!: string | undefined;
    memberId!: number | undefined;

    constructor(data?: ISnsUserInfoForOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.openid = data["openid"];
            this.memberId = data["memberId"];
        }
    }

    static fromJS(data: any): SnsUserInfoForOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoForOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openid"] = this.openid;
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface ISnsUserInfoForOrder {
    id: number | undefined;
    openid: string | undefined;
    memberId: number | undefined;
}

export class ActivityPayRecordInput implements IActivityPayRecordInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    activityPayType!: ActivityPayRecordInputActivityPayType | undefined;
    payAmount!: number | undefined;
    actionId!: number | undefined;
    openid!: string | undefined;
    activityId!: number | undefined;
    payOrder!: string | undefined;
    tradNumber!: string | undefined;
    payResult!: boolean | undefined;
    orderPayRecordId!: number | undefined;
    tickets!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IActivityPayRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.activityPayType = data["activityPayType"];
            this.payAmount = data["payAmount"];
            this.actionId = data["actionId"];
            this.openid = data["openid"];
            this.activityId = data["activityId"];
            this.payOrder = data["payOrder"];
            this.tradNumber = data["tradNumber"];
            this.payResult = data["payResult"];
            this.orderPayRecordId = data["orderPayRecordId"];
            this.tickets = data["tickets"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): ActivityPayRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityPayRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["activityPayType"] = this.activityPayType;
        data["payAmount"] = this.payAmount;
        data["actionId"] = this.actionId;
        data["openid"] = this.openid;
        data["activityId"] = this.activityId;
        data["payOrder"] = this.payOrder;
        data["tradNumber"] = this.tradNumber;
        data["payResult"] = this.payResult;
        data["orderPayRecordId"] = this.orderPayRecordId;
        data["tickets"] = this.tickets;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IActivityPayRecordInput {
    id: number | undefined;
    tenantId: number | undefined;
    activityPayType: ActivityPayRecordInputActivityPayType | undefined;
    payAmount: number | undefined;
    actionId: number | undefined;
    openid: string | undefined;
    activityId: number | undefined;
    payOrder: string | undefined;
    tradNumber: string | undefined;
    payResult: boolean | undefined;
    orderPayRecordId: number | undefined;
    tickets: string | undefined;
    extensionData: string | undefined;
}

export class ActivityPayRecord implements IActivityPayRecord {
    tenantId!: number | undefined;
    activityPayType!: ActivityPayRecordActivityPayType | undefined;
    payAmount!: number | undefined;
    actionId!: number | undefined;
    openid!: string | undefined;
    activityId!: number | undefined;
    payOrder!: string | undefined;
    tradNumber!: string | undefined;
    payResult!: boolean | undefined;
    orderPayRecordId!: number | undefined;
    tickets!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActivityPayRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.activityPayType = data["activityPayType"];
            this.payAmount = data["payAmount"];
            this.actionId = data["actionId"];
            this.openid = data["openid"];
            this.activityId = data["activityId"];
            this.payOrder = data["payOrder"];
            this.tradNumber = data["tradNumber"];
            this.payResult = data["payResult"];
            this.orderPayRecordId = data["orderPayRecordId"];
            this.tickets = data["tickets"];
            this.extensionData = data["extensionData"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityPayRecord {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityPayRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityPayType"] = this.activityPayType;
        data["payAmount"] = this.payAmount;
        data["actionId"] = this.actionId;
        data["openid"] = this.openid;
        data["activityId"] = this.activityId;
        data["payOrder"] = this.payOrder;
        data["tradNumber"] = this.tradNumber;
        data["payResult"] = this.payResult;
        data["orderPayRecordId"] = this.orderPayRecordId;
        data["tickets"] = this.tickets;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityPayRecord {
    tenantId: number | undefined;
    activityPayType: ActivityPayRecordActivityPayType | undefined;
    payAmount: number | undefined;
    actionId: number | undefined;
    openid: string | undefined;
    activityId: number | undefined;
    payOrder: string | undefined;
    tradNumber: string | undefined;
    payResult: boolean | undefined;
    orderPayRecordId: number | undefined;
    tickets: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class QrcodeActionOutput implements IQrcodeActionOutput {
    actionId!: number | undefined;
    qrCodeUrl!: string | undefined;
    qrCodeImage!: string | undefined;
    qrCodeId!: string | undefined;

    constructor(data?: IQrcodeActionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionId = data["actionId"];
            this.qrCodeUrl = data["qrCodeUrl"];
            this.qrCodeImage = data["qrCodeImage"];
            this.qrCodeId = data["qrCodeId"];
        }
    }

    static fromJS(data: any): QrcodeActionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new QrcodeActionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["qrCodeImage"] = this.qrCodeImage;
        data["qrCodeId"] = this.qrCodeId;
        return data; 
    }
}

export interface IQrcodeActionOutput {
    actionId: number | undefined;
    qrCodeUrl: string | undefined;
    qrCodeImage: string | undefined;
    qrCodeId: string | undefined;
}

export class PagedResultDtoOfSnsUserQrcode implements IPagedResultDtoOfSnsUserQrcode {
    totalCount!: number | undefined;
    items!: SnsUserQrcode[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserQrcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SnsUserQrcode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserQrcode {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserQrcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserQrcode {
    totalCount: number | undefined;
    items: SnsUserQrcode[] | undefined;
}

export class SnsUserQrcode implements ISnsUserQrcode {
    tenantId!: number | undefined;
    qrCodeID!: string | undefined;
    openId!: string | undefined;
    gameId!: number | undefined;
    nickname!: string | undefined;
    headimgurl!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserQrcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.qrCodeID = data["qrCodeID"];
            this.openId = data["openId"];
            this.gameId = data["gameId"];
            this.nickname = data["nickname"];
            this.headimgurl = data["headimgurl"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserQrcode {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserQrcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["qrCodeID"] = this.qrCodeID;
        data["openId"] = this.openId;
        data["gameId"] = this.gameId;
        data["nickname"] = this.nickname;
        data["headimgurl"] = this.headimgurl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserQrcode {
    tenantId: number | undefined;
    qrCodeID: string | undefined;
    openId: string | undefined;
    gameId: number | undefined;
    nickname: string | undefined;
    headimgurl: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SendCustomMessageInput implements ISendCustomMessageInput {
    securityKey!: string | undefined;
    openId!: string | undefined;
    type!: string | undefined;
    content!: string | undefined;
    title!: string | undefined;
    imageUrl!: string | undefined;
    url!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: ISendCustomMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.securityKey = data["securityKey"];
            this.openId = data["openId"];
            this.type = data["type"];
            this.content = data["content"];
            this.title = data["title"];
            this.imageUrl = data["imageUrl"];
            this.url = data["url"];
            this.picUrl = data["picUrl"];
        }
    }

    static fromJS(data: any): SendCustomMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendCustomMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        data["openId"] = this.openId;
        data["type"] = this.type;
        data["content"] = this.content;
        data["title"] = this.title;
        data["imageUrl"] = this.imageUrl;
        data["url"] = this.url;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface ISendCustomMessageInput {
    securityKey: string | undefined;
    openId: string | undefined;
    type: string | undefined;
    content: string | undefined;
    title: string | undefined;
    imageUrl: string | undefined;
    url: string | undefined;
    picUrl: string | undefined;
}

export class UserActionDataOutput implements IUserActionDataOutput {
    deviceActivityGame!: DeviceActivityGameOutput | undefined;
    device!: DeviceSimpleDto | undefined;
    externalAccessSession!: string | undefined;
    transferActionUrl!: string | undefined;
    activityFlows!: ActivityFlowOutput[] | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean | undefined;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean | undefined;
    failReason!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserActionDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceActivityGame = data["deviceActivityGame"] ? DeviceActivityGameOutput.fromJS(data["deviceActivityGame"]) : <any>undefined;
            this.device = data["device"] ? DeviceSimpleDto.fromJS(data["device"]) : <any>undefined;
            this.externalAccessSession = data["externalAccessSession"];
            this.transferActionUrl = data["transferActionUrl"];
            if (Array.isArray(data["activityFlows"])) {
                this.activityFlows = [] as any;
                for (let item of data["activityFlows"])
                    this.activityFlows!.push(ActivityFlowOutput.fromJS(item));
            }
            this.qrCodeId = data["qrCodeId"];
            this.score = data["score"];
            this.postUrl = data["postUrl"];
            this.gameImage = data["gameImage"];
            this.playerImage = data["playerImage"];
            this.playerPhone = data["playerPhone"];
            this.playerEmail = data["playerEmail"];
            this.playerAge = data["playerAge"];
            this.shareCount = data["shareCount"];
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.scanQrCodeTime = data["scanQrCodeTime"];
            this.isSigned = data["isSigned"];
            this.awardId = data["awardId"];
            this.isForged = data["isForged"];
            this.forgedReason = data["forgedReason"];
            this.type = data["type"];
            this.extensionData = data["extensionData"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = data["isSuccess"];
            this.failReason = data["failReason"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserActionDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["externalAccessSession"] = this.externalAccessSession;
        data["transferActionUrl"] = this.transferActionUrl;
        if (Array.isArray(this.activityFlows)) {
            data["activityFlows"] = [];
            for (let item of this.activityFlows)
                data["activityFlows"].push(item.toJSON());
        }
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionDataOutput {
    deviceActivityGame: DeviceActivityGameOutput | undefined;
    device: DeviceSimpleDto | undefined;
    externalAccessSession: string | undefined;
    transferActionUrl: string | undefined;
    activityFlows: ActivityFlowOutput[] | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number | undefined;
    shareCount: number | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    scanQrCodeTime: string | undefined;
    isSigned: boolean | undefined;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean | undefined;
    failReason: string | undefined;
    id: number | undefined;
}

export class DeviceSimpleDto implements IDeviceSimpleDto {
    id!: number | undefined;
    name!: string | undefined;
    mac!: string | undefined;
    os!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    outType!: string | undefined;
    taobaoDeviceId!: string | undefined;
    subKey!: string | undefined;

    constructor(data?: IDeviceSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.mac = data["mac"];
            this.os = data["os"];
            this.onlineTrafficTarget = data["onlineTrafficTarget"];
            this.outerId = data["outerId"];
            this.storeId = data["storeId"];
            this.storeName = data["storeName"];
            this.storeOuterId = data["storeOuterId"];
            this.outType = data["outType"];
            this.taobaoDeviceId = data["taobaoDeviceId"];
            this.subKey = data["subKey"];
        }
    }

    static fromJS(data: any): DeviceSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["os"] = this.os;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["outType"] = this.outType;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface IDeviceSimpleDto {
    id: number | undefined;
    name: string | undefined;
    mac: string | undefined;
    os: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    outType: string | undefined;
    taobaoDeviceId: string | undefined;
    subKey: string | undefined;
}

export class ActivityFlowOutput implements IActivityFlowOutput {
    flowUrl!: string | undefined;
    flowType!: ActivityFlowOutputFlowType | undefined;
    isUseOutside!: boolean | undefined;
    htmlTemplateId!: number | undefined;
    htmlTemplate!: HtmlTemplateOutput | undefined;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean | undefined;
    isHasRegister!: boolean | undefined;
    isRegisterInCurrPage!: boolean | undefined;
    isHasGame!: boolean | undefined;
    isHasGameResult!: boolean | undefined;
    isHasReward!: boolean | undefined;
    isHasVote!: boolean | undefined;
    insideHtml!: string | undefined;
    id!: number | undefined;

    constructor(data?: IActivityFlowOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flowUrl = data["flowUrl"];
            this.flowType = data["flowType"];
            this.isUseOutside = data["isUseOutside"];
            this.htmlTemplateId = data["htmlTemplateId"];
            this.htmlTemplate = data["htmlTemplate"] ? HtmlTemplateOutput.fromJS(data["htmlTemplate"]) : <any>undefined;
            this.outsideLink = data["outsideLink"];
            this.isHasIntroduce = data["isHasIntroduce"];
            this.isHasRegister = data["isHasRegister"];
            this.isRegisterInCurrPage = data["isRegisterInCurrPage"];
            this.isHasGame = data["isHasGame"];
            this.isHasGameResult = data["isHasGameResult"];
            this.isHasReward = data["isHasReward"];
            this.isHasVote = data["isHasVote"];
            this.insideHtml = data["insideHtml"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityFlowOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityFlowOutput {
    flowUrl: string | undefined;
    flowType: ActivityFlowOutputFlowType | undefined;
    isUseOutside: boolean | undefined;
    htmlTemplateId: number | undefined;
    htmlTemplate: HtmlTemplateOutput | undefined;
    outsideLink: string | undefined;
    isHasIntroduce: boolean | undefined;
    isHasRegister: boolean | undefined;
    isRegisterInCurrPage: boolean | undefined;
    isHasGame: boolean | undefined;
    isHasGameResult: boolean | undefined;
    isHasReward: boolean | undefined;
    isHasVote: boolean | undefined;
    insideHtml: string | undefined;
    id: number | undefined;
}

export class HtmlTemplateOutput implements IHtmlTemplateOutput {
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    args!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: HtmlTemplateOutputTemplateType | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IHtmlTemplateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thumbnail = data["thumbnail"];
            this.bigImage = data["bigImage"];
            this.actionUrl = data["actionUrl"];
            this.args = data["args"];
            this.title = data["title"];
            this.logo = data["logo"];
            this.backgroundImage = data["backgroundImage"];
            this.templateType = data["templateType"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["args"] = this.args;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplateOutput {
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    args: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: HtmlTemplateOutputTemplateType | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetGameImageBase64Input implements IGetGameImageBase64Input {
    imageUrl!: string | undefined;

    constructor(data?: IGetGameImageBase64Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): GetGameImageBase64Input {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameImageBase64Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IGetGameImageBase64Input {
    imageUrl: string | undefined;
}

export class AddSnsAndActionInput implements IAddSnsAndActionInput {
    tenandId!: number | undefined;
    openId!: string | undefined;
    securityKey!: string | undefined;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;
    memberId!: number | undefined;
    appId!: string | undefined;

    constructor(data?: IAddSnsAndActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenandId = data["tenandId"];
            this.openId = data["openId"];
            this.securityKey = data["securityKey"];
            this.nickName = data["nickName"];
            this.headImgUrl = data["headImgUrl"];
            this.memberId = data["memberId"];
            this.appId = data["appId"];
        }
    }

    static fromJS(data: any): AddSnsAndActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSnsAndActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenandId"] = this.tenandId;
        data["openId"] = this.openId;
        data["securityKey"] = this.securityKey;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        data["memberId"] = this.memberId;
        data["appId"] = this.appId;
        return data; 
    }
}

export interface IAddSnsAndActionInput {
    tenandId: number | undefined;
    openId: string | undefined;
    securityKey: string | undefined;
    nickName: string | undefined;
    headImgUrl: string | undefined;
    memberId: number | undefined;
    appId: string | undefined;
}

export class CreateUserActionInput implements ICreateUserActionInput {
    snsUserInfoId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    score!: number | undefined;
    gameImage!: string | undefined;

    constructor(data?: ICreateUserActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.snsUserInfoId = data["snsUserInfoId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.score = data["score"];
            this.gameImage = data["gameImage"];
        }
    }

    static fromJS(data: any): CreateUserActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["score"] = this.score;
        data["gameImage"] = this.gameImage;
        return data; 
    }
}

export interface ICreateUserActionInput {
    snsUserInfoId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    score: number | undefined;
    gameImage: string | undefined;
}

export class UpdateUserActionInput implements IUpdateUserActionInput {
    id!: number | undefined;
    snsUserInfoId!: number | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    viewCount!: number | undefined;
    likeCount!: number | undefined;
    score!: number | undefined;
    gameImage!: string | undefined;

    constructor(data?: IUpdateUserActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.viewCount = data["viewCount"];
            this.likeCount = data["likeCount"];
            this.score = data["score"];
            this.gameImage = data["gameImage"];
        }
    }

    static fromJS(data: any): UpdateUserActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["score"] = this.score;
        data["gameImage"] = this.gameImage;
        return data; 
    }
}

export interface IUpdateUserActionInput {
    id: number | undefined;
    snsUserInfoId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    viewCount: number | undefined;
    likeCount: number | undefined;
    score: number | undefined;
    gameImage: string | undefined;
}

export class PagedResultDtoOfSnsUserActionSumDto implements IPagedResultDtoOfSnsUserActionSumDto {
    totalCount!: number | undefined;
    items!: SnsUserActionSumDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserActionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SnsUserActionSumDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserActionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserActionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserActionSumDto {
    totalCount: number | undefined;
    items: SnsUserActionSumDto[] | undefined;
}

export class SnsUserActionSumDto implements ISnsUserActionSumDto {
    actionCount!: number | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    isBecomeFans!: boolean | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserActionSumDtoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISnsUserActionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionCount = data["actionCount"];
            this.tenantId = data["tenantId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.isBecomeFans = data["isBecomeFans"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
            this.memberId = data["memberId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SnsUserActionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserActionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionCount"] = this.actionCount;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserActionSumDto {
    actionCount: number | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    isBecomeFans: boolean | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserActionSumDtoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number | undefined;
}

export class MakeUserToSpecialInput implements IMakeUserToSpecialInput {
    userId!: number;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    type!: MakeUserToSpecialInputType;

    constructor(data?: IMakeUserToSpecialInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.forAward = data["forAward"];
            this.forLottery = data["forLottery"];
            this.forUseTicket = data["forUseTicket"];
            this.activityId = data["activityId"];
            this.name = data["name"];
            this.awardSeqs = data["awardSeqs"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.identityID = data["identityID"];
            this.companyName = data["companyName"];
            this.description = data["description"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): MakeUserToSpecialInput {
        data = typeof data === 'object' ? data : {};
        let result = new MakeUserToSpecialInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["type"] = this.type;
        return data; 
    }
}

export interface IMakeUserToSpecialInput {
    userId: number;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    type: MakeUserToSpecialInputType;
}

export class SimpleMemberInfoDto implements ISimpleMemberInfoDto {
    memberId!: number | undefined;
    tenantId!: number | undefined;
    regPhone!: string | undefined;
    name!: string | undefined;

    constructor(data?: ISimpleMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.tenantId = data["tenantId"];
            this.regPhone = data["regPhone"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SimpleMemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleMemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["tenantId"] = this.tenantId;
        data["regPhone"] = this.regPhone;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISimpleMemberInfoDto {
    memberId: number | undefined;
    tenantId: number | undefined;
    regPhone: string | undefined;
    name: string | undefined;
}

export class PagedResultDtoOfGetUserPaperDto implements IPagedResultDtoOfGetUserPaperDto {
    totalCount!: number | undefined;
    items!: GetUserPaperDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserPaperDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserPaperDto {
    totalCount: number | undefined;
    items: GetUserPaperDto[] | undefined;
}

export class GetUserPaperDto implements IGetUserPaperDto {
    id!: number | undefined;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number | undefined;
    correctCount!: number | undefined;
    totalScore!: number | undefined;
    examResult!: GetUserPaperDtoExamResult | undefined;
    snsUserInfo!: SnsUserInfoOutput | undefined;
    paper!: PaperDto | undefined;
    userAction!: UserActionDto | undefined;
    opinion!: string | undefined;

    constructor(data?: IGetUserPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.examStartTime = data["examStartTime"] ? moment(data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = data["examEndTime"] ? moment(data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = data["answeredQuestionCount"];
            this.correctCount = data["correctCount"];
            this.totalScore = data["totalScore"];
            this.examResult = data["examResult"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.paper = data["paper"] ? PaperDto.fromJS(data["paper"]) : <any>undefined;
            this.userAction = data["userAction"] ? UserActionDto.fromJS(data["userAction"]) : <any>undefined;
            this.opinion = data["opinion"];
        }
    }

    static fromJS(data: any): GetUserPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["examResult"] = this.examResult;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["opinion"] = this.opinion;
        return data; 
    }
}

export interface IGetUserPaperDto {
    id: number | undefined;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number | undefined;
    correctCount: number | undefined;
    totalScore: number | undefined;
    examResult: GetUserPaperDtoExamResult | undefined;
    snsUserInfo: SnsUserInfoOutput | undefined;
    paper: PaperDto | undefined;
    userAction: UserActionDto | undefined;
    opinion: string | undefined;
}

export class PagedResultDtoOfGetPaperOpinionReportDto implements IPagedResultDtoOfGetPaperOpinionReportDto {
    totalCount!: number | undefined;
    items!: GetPaperOpinionReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperOpinionReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPaperOpinionReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperOpinionReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperOpinionReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperOpinionReportDto {
    totalCount: number | undefined;
    items: GetPaperOpinionReportDto[] | undefined;
}

export class GetPaperOpinionReportDto implements IGetPaperOpinionReportDto {
    opinion!: string | undefined;
    nickName!: string | undefined;
    userName!: string | undefined;
    trainingTitle!: string | undefined;

    constructor(data?: IGetPaperOpinionReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.opinion = data["opinion"];
            this.nickName = data["nickName"];
            this.userName = data["userName"];
            this.trainingTitle = data["trainingTitle"];
        }
    }

    static fromJS(data: any): GetPaperOpinionReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperOpinionReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opinion"] = this.opinion;
        data["nickName"] = this.nickName;
        data["userName"] = this.userName;
        data["trainingTitle"] = this.trainingTitle;
        return data; 
    }
}

export interface IGetPaperOpinionReportDto {
    opinion: string | undefined;
    nickName: string | undefined;
    userName: string | undefined;
    trainingTitle: string | undefined;
}

export class PagedResultDtoOfGetPaperAnswerCompetitionDto implements IPagedResultDtoOfGetPaperAnswerCompetitionDto {
    totalCount!: number | undefined;
    items!: GetPaperAnswerCompetitionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerCompetitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPaperAnswerCompetitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerCompetitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerCompetitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerCompetitionDto {
    totalCount: number | undefined;
    items: GetPaperAnswerCompetitionDto[] | undefined;
}

export class GetPaperAnswerCompetitionDto implements IGetPaperAnswerCompetitionDto {
    nickName!: string | undefined;
    openId!: string | undefined;
    headImage!: string | undefined;
    rank!: number | undefined;
    totalScore!: number | undefined;
    partakeTimes!: number | undefined;

    constructor(data?: IGetPaperAnswerCompetitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nickName = data["nickName"];
            this.openId = data["openId"];
            this.headImage = data["headImage"];
            this.rank = data["rank"];
            this.totalScore = data["totalScore"];
            this.partakeTimes = data["partakeTimes"];
        }
    }

    static fromJS(data: any): GetPaperAnswerCompetitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerCompetitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickName"] = this.nickName;
        data["openId"] = this.openId;
        data["headImage"] = this.headImage;
        data["rank"] = this.rank;
        data["totalScore"] = this.totalScore;
        data["partakeTimes"] = this.partakeTimes;
        return data; 
    }
}

export interface IGetPaperAnswerCompetitionDto {
    nickName: string | undefined;
    openId: string | undefined;
    headImage: string | undefined;
    rank: number | undefined;
    totalScore: number | undefined;
    partakeTimes: number | undefined;
}

export class PagedResultDtoOfGetPaperAnswerInvestigateDto implements IPagedResultDtoOfGetPaperAnswerInvestigateDto {
    totalCount!: number | undefined;
    items!: GetPaperAnswerInvestigateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerInvestigateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPaperAnswerInvestigateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerInvestigateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerInvestigateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerInvestigateDto {
    totalCount: number | undefined;
    items: GetPaperAnswerInvestigateDto[] | undefined;
}

export class GetPaperAnswerInvestigateDto implements IGetPaperAnswerInvestigateDto {
    questionId!: number | undefined;
    questionName!: string | undefined;
    getPaperAnswerReportDtos!: GetPaperAnswerReportDto[] | undefined;

    constructor(data?: IGetPaperAnswerInvestigateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.questionName = data["questionName"];
            if (Array.isArray(data["getPaperAnswerReportDtos"])) {
                this.getPaperAnswerReportDtos = [] as any;
                for (let item of data["getPaperAnswerReportDtos"])
                    this.getPaperAnswerReportDtos!.push(GetPaperAnswerReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPaperAnswerInvestigateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerInvestigateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionName"] = this.questionName;
        if (Array.isArray(this.getPaperAnswerReportDtos)) {
            data["getPaperAnswerReportDtos"] = [];
            for (let item of this.getPaperAnswerReportDtos)
                data["getPaperAnswerReportDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPaperAnswerInvestigateDto {
    questionId: number | undefined;
    questionName: string | undefined;
    getPaperAnswerReportDtos: GetPaperAnswerReportDto[] | undefined;
}

export class UserPaperRep implements IUserPaperRep {
    name!: string | undefined;
    regPhone!: string | undefined;
    sex!: string | undefined;
    snsUserInfoId!: number | undefined;
    createDate!: moment.Moment | undefined;
    extensionData!: string | undefined;
    nickName!: string | undefined;
    answer1!: string | undefined;
    answer2!: string | undefined;
    answer3!: string | undefined;
    answer4!: string | undefined;
    answer5!: string | undefined;
    answer6!: string | undefined;
    acne_score!: string | undefined;
    speckle_score!: string | undefined;
    mole_score!: string | undefined;
    wrinkle_score!: string | undefined;
    eye_bags_score!: string | undefined;
    dark_circle_score!: string | undefined;
    blackhead_score!: string | undefined;
    pore_score!: string | undefined;
    smooth_score!: string | undefined;

    constructor(data?: IUserPaperRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.regPhone = data["regPhone"];
            this.sex = data["sex"];
            this.snsUserInfoId = data["snsUserInfoId"];
            this.createDate = data["createDate"] ? moment(data["createDate"].toString()) : <any>undefined;
            this.extensionData = data["extensionData"];
            this.nickName = data["nickName"];
            this.answer1 = data["answer1"];
            this.answer2 = data["answer2"];
            this.answer3 = data["answer3"];
            this.answer4 = data["answer4"];
            this.answer5 = data["answer5"];
            this.answer6 = data["answer6"];
            this.acne_score = data["acne_score"];
            this.speckle_score = data["speckle_score"];
            this.mole_score = data["mole_score"];
            this.wrinkle_score = data["wrinkle_score"];
            this.eye_bags_score = data["eye_bags_score"];
            this.dark_circle_score = data["dark_circle_score"];
            this.blackhead_score = data["blackhead_score"];
            this.pore_score = data["pore_score"];
            this.smooth_score = data["smooth_score"];
        }
    }

    static fromJS(data: any): UserPaperRep {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaperRep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["regPhone"] = this.regPhone;
        data["sex"] = this.sex;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["nickName"] = this.nickName;
        data["answer1"] = this.answer1;
        data["answer2"] = this.answer2;
        data["answer3"] = this.answer3;
        data["answer4"] = this.answer4;
        data["answer5"] = this.answer5;
        data["answer6"] = this.answer6;
        data["acne_score"] = this.acne_score;
        data["speckle_score"] = this.speckle_score;
        data["mole_score"] = this.mole_score;
        data["wrinkle_score"] = this.wrinkle_score;
        data["eye_bags_score"] = this.eye_bags_score;
        data["dark_circle_score"] = this.dark_circle_score;
        data["blackhead_score"] = this.blackhead_score;
        data["pore_score"] = this.pore_score;
        data["smooth_score"] = this.smooth_score;
        return data; 
    }
}

export interface IUserPaperRep {
    name: string | undefined;
    regPhone: string | undefined;
    sex: string | undefined;
    snsUserInfoId: number | undefined;
    createDate: moment.Moment | undefined;
    extensionData: string | undefined;
    nickName: string | undefined;
    answer1: string | undefined;
    answer2: string | undefined;
    answer3: string | undefined;
    answer4: string | undefined;
    answer5: string | undefined;
    answer6: string | undefined;
    acne_score: string | undefined;
    speckle_score: string | undefined;
    mole_score: string | undefined;
    wrinkle_score: string | undefined;
    eye_bags_score: string | undefined;
    dark_circle_score: string | undefined;
    blackhead_score: string | undefined;
    pore_score: string | undefined;
    smooth_score: string | undefined;
}

export class TakeAwardRep implements ITakeAwardRep {
    date!: moment.Moment | undefined;
    nickName!: string | undefined;
    ticketNo!: string | undefined;
    award!: string | undefined;

    constructor(data?: ITakeAwardRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.nickName = data["nickName"];
            this.ticketNo = data["ticketNo"];
            this.award = data["award"];
        }
    }

    static fromJS(data: any): TakeAwardRep {
        data = typeof data === 'object' ? data : {};
        let result = new TakeAwardRep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["nickName"] = this.nickName;
        data["ticketNo"] = this.ticketNo;
        data["award"] = this.award;
        return data; 
    }
}

export interface ITakeAwardRep {
    date: moment.Moment | undefined;
    nickName: string | undefined;
    ticketNo: string | undefined;
    award: string | undefined;
}

export class PagedResultDtoOfGetWechatMenuDto implements IPagedResultDtoOfGetWechatMenuDto {
    totalCount!: number | undefined;
    items!: GetWechatMenuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWechatMenuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatMenuDto {
    totalCount: number | undefined;
    items: GetWechatMenuDto[] | undefined;
}

export class GetWechatMenuDto implements IGetWechatMenuDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    displayName!: string | undefined;
    menuType!: GetWechatMenuDtoMenuType | undefined;
    status!: boolean | undefined;
    menuContent!: any | undefined;

    constructor(data?: IGetWechatMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.displayName = data["displayName"];
            this.menuType = data["menuType"];
            this.status = data["status"];
            this.menuContent = data["menuContent"];
        }
    }

    static fromJS(data: any): GetWechatMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        data["status"] = this.status;
        data["menuContent"] = this.menuContent;
        return data; 
    }
}

export interface IGetWechatMenuDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    displayName: string | undefined;
    menuType: GetWechatMenuDtoMenuType | undefined;
    status: boolean | undefined;
    menuContent: any | undefined;
}

export class AddOrUpdateMenuInput implements IAddOrUpdateMenuInput {
    id!: number | undefined;
    weixinAppID!: string | undefined;
    menuContent!: any | undefined;
    displayName!: string | undefined;
    menuType!: AddOrUpdateMenuInputMenuType | undefined;

    constructor(data?: IAddOrUpdateMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.weixinAppID = data["weixinAppID"];
            this.menuContent = data["menuContent"];
            this.displayName = data["displayName"];
            this.menuType = data["menuType"];
        }
    }

    static fromJS(data: any): AddOrUpdateMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["weixinAppID"] = this.weixinAppID;
        data["menuContent"] = this.menuContent;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        return data; 
    }
}

export interface IAddOrUpdateMenuInput {
    id: number | undefined;
    weixinAppID: string | undefined;
    menuContent: any | undefined;
    displayName: string | undefined;
    menuType: AddOrUpdateMenuInputMenuType | undefined;
}

export class AddOrUpdateConditionalMenuInput implements IAddOrUpdateConditionalMenuInput {
    id!: number | undefined;
    weixinAppID!: string | undefined;
    menuContent!: ConditionalButtonGroup | undefined;
    displayName!: string | undefined;
    menuType!: AddOrUpdateConditionalMenuInputMenuType | undefined;

    constructor(data?: IAddOrUpdateConditionalMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.weixinAppID = data["weixinAppID"];
            this.menuContent = data["menuContent"] ? ConditionalButtonGroup.fromJS(data["menuContent"]) : <any>undefined;
            this.displayName = data["displayName"];
            this.menuType = data["menuType"];
        }
    }

    static fromJS(data: any): AddOrUpdateConditionalMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateConditionalMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["weixinAppID"] = this.weixinAppID;
        data["menuContent"] = this.menuContent ? this.menuContent.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        return data; 
    }
}

export interface IAddOrUpdateConditionalMenuInput {
    id: number | undefined;
    weixinAppID: string | undefined;
    menuContent: ConditionalButtonGroup | undefined;
    displayName: string | undefined;
    menuType: AddOrUpdateConditionalMenuInputMenuType | undefined;
}

export class ConditionalButtonGroup implements IConditionalButtonGroup {
    matchrule!: MenuMatchRule | undefined;
    menuid!: number | undefined;
    button!: BaseButton[] | undefined;

    constructor(data?: IConditionalButtonGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchrule = data["matchrule"] ? MenuMatchRule.fromJS(data["matchrule"]) : <any>undefined;
            this.menuid = data["menuid"];
            if (Array.isArray(data["button"])) {
                this.button = [] as any;
                for (let item of data["button"])
                    this.button!.push(BaseButton.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionalButtonGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalButtonGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchrule"] = this.matchrule ? this.matchrule.toJSON() : <any>undefined;
        data["menuid"] = this.menuid;
        if (Array.isArray(this.button)) {
            data["button"] = [];
            for (let item of this.button)
                data["button"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConditionalButtonGroup {
    matchrule: MenuMatchRule | undefined;
    menuid: number | undefined;
    button: BaseButton[] | undefined;
}

export class MenuMatchRule implements IMenuMatchRule {
    tag_id!: string | undefined;
    group_id!: string | undefined;
    sex!: string | undefined;
    country!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    client_platform_type!: string | undefined;
    language!: string | undefined;

    constructor(data?: IMenuMatchRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tag_id = data["tag_id"];
            this.group_id = data["group_id"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.client_platform_type = data["client_platform_type"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): MenuMatchRule {
        data = typeof data === 'object' ? data : {};
        let result = new MenuMatchRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag_id"] = this.tag_id;
        data["group_id"] = this.group_id;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["client_platform_type"] = this.client_platform_type;
        data["language"] = this.language;
        return data; 
    }
}

export interface IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;
}

export class BaseButton implements IBaseButton {
    name!: string | undefined;

    constructor(data?: IBaseButton) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BaseButton {
        data = typeof data === 'object' ? data : {};
        let result = new BaseButton();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IBaseButton {
    name: string | undefined;
}

export class PagedResultDtoOfGetWechatTemplateMessageDto implements IPagedResultDtoOfGetWechatTemplateMessageDto {
    totalCount!: number | undefined;
    items!: GetWechatTemplateMessageDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatTemplateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWechatTemplateMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatTemplateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatTemplateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatTemplateMessageDto {
    totalCount: number | undefined;
    items: GetWechatTemplateMessageDto[] | undefined;
}

export class GetWechatTemplateMessageDto implements IGetWechatTemplateMessageDto {
    id!: number | undefined;
    templateId!: string | undefined;
    templateMessageType!: GetWechatTemplateMessageDtoTemplateMessageType | undefined;
    weixinAppID!: string | undefined;
    title!: string | undefined;
    primaryIndustry!: string | undefined;
    deputyIndustry!: string | undefined;
    content!: string | undefined;
    example!: string | undefined;

    constructor(data?: IGetWechatTemplateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.templateId = data["templateId"];
            this.templateMessageType = data["templateMessageType"];
            this.weixinAppID = data["weixinAppID"];
            this.title = data["title"];
            this.primaryIndustry = data["primaryIndustry"];
            this.deputyIndustry = data["deputyIndustry"];
            this.content = data["content"];
            this.example = data["example"];
        }
    }

    static fromJS(data: any): GetWechatTemplateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatTemplateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateId"] = this.templateId;
        data["templateMessageType"] = this.templateMessageType;
        data["weixinAppID"] = this.weixinAppID;
        data["title"] = this.title;
        data["primaryIndustry"] = this.primaryIndustry;
        data["deputyIndustry"] = this.deputyIndustry;
        data["content"] = this.content;
        data["example"] = this.example;
        return data; 
    }
}

export interface IGetWechatTemplateMessageDto {
    id: number | undefined;
    templateId: string | undefined;
    templateMessageType: GetWechatTemplateMessageDtoTemplateMessageType | undefined;
    weixinAppID: string | undefined;
    title: string | undefined;
    primaryIndustry: string | undefined;
    deputyIndustry: string | undefined;
    content: string | undefined;
    example: string | undefined;
}

export class SetMediaTagsInput implements ISetMediaTagsInput {
    wechatMediaIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetMediaTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["wechatMediaIds"])) {
                this.wechatMediaIds = [] as any;
                for (let item of data["wechatMediaIds"])
                    this.wechatMediaIds!.push(item);
            }
            if (Array.isArray(data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.action = data["action"];
        }
    }

    static fromJS(data: any): SetMediaTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetMediaTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.wechatMediaIds)) {
            data["wechatMediaIds"] = [];
            for (let item of this.wechatMediaIds)
                data["wechatMediaIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetMediaTagsInput {
    wechatMediaIds: number[] | undefined;
    tagIds: number[] | undefined;
    action: string | undefined;
}

export class PagedResultDtoOfGetMessageSeedDto implements IPagedResultDtoOfGetMessageSeedDto {
    totalCount!: number | undefined;
    items!: GetMessageSeedDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMessageSeedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMessageSeedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMessageSeedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMessageSeedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMessageSeedDto {
    totalCount: number | undefined;
    items: GetMessageSeedDto[] | undefined;
}

export class GetMessageSeedDto implements IGetMessageSeedDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    title!: string | undefined;
    messageCode!: string | undefined;
    description!: string | undefined;
    usage!: string | undefined;

    constructor(data?: IGetMessageSeedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.title = data["title"];
            this.messageCode = data["messageCode"];
            this.description = data["description"];
            this.usage = data["usage"];
        }
    }

    static fromJS(data: any): GetMessageSeedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMessageSeedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["messageCode"] = this.messageCode;
        data["description"] = this.description;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface IGetMessageSeedDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    title: string | undefined;
    messageCode: string | undefined;
    description: string | undefined;
    usage: string | undefined;
}

export class AddOrUpdateMessageSeedInput implements IAddOrUpdateMessageSeedInput {
    id!: number | undefined;
    title!: string | undefined;
    messageCode!: string;
    description!: string | undefined;
    usage!: string | undefined;

    constructor(data?: IAddOrUpdateMessageSeedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.messageCode = data["messageCode"];
            this.description = data["description"];
            this.usage = data["usage"];
        }
    }

    static fromJS(data: any): AddOrUpdateMessageSeedInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMessageSeedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["messageCode"] = this.messageCode;
        data["description"] = this.description;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface IAddOrUpdateMessageSeedInput {
    id: number | undefined;
    title: string | undefined;
    messageCode: string;
    description: string | undefined;
    usage: string | undefined;
}

export class WeChatJSViewModel implements IWeChatJSViewModel {
    signature!: string | undefined;
    appId!: string | undefined;
    timestamp!: string | undefined;
    nonceStr!: string | undefined;
    currentOpenId!: string | undefined;
    componentAppID!: string | undefined;
    scope!: string | undefined;

    constructor(data?: IWeChatJSViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signature = data["signature"];
            this.appId = data["appId"];
            this.timestamp = data["timestamp"];
            this.nonceStr = data["nonceStr"];
            this.currentOpenId = data["currentOpenId"];
            this.componentAppID = data["componentAppID"];
            this.scope = data["scope"];
        }
    }

    static fromJS(data: any): WeChatJSViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatJSViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signature"] = this.signature;
        data["appId"] = this.appId;
        data["timestamp"] = this.timestamp;
        data["nonceStr"] = this.nonceStr;
        data["currentOpenId"] = this.currentOpenId;
        data["componentAppID"] = this.componentAppID;
        data["scope"] = this.scope;
        return data; 
    }
}

export interface IWeChatJSViewModel {
    signature: string | undefined;
    appId: string | undefined;
    timestamp: string | undefined;
    nonceStr: string | undefined;
    currentOpenId: string | undefined;
    componentAppID: string | undefined;
    scope: string | undefined;
}

export class PagedResultDtoOfWeixinMpDto implements IPagedResultDtoOfWeixinMpDto {
    totalCount!: number | undefined;
    items!: WeixinMpDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWeixinMpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WeixinMpDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWeixinMpDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWeixinMpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWeixinMpDto {
    totalCount: number | undefined;
    items: WeixinMpDto[] | undefined;
}

export class WeixinMpDto implements IWeixinMpDto {
    weixinAppID!: string | undefined;
    expires_in!: number | undefined;
    name!: string | undefined;
    iconPath!: string | undefined;
    nickName!: string | undefined;
    head_img!: string | undefined;
    service_type_info!: WeixinMpDtoService_type_info | undefined;
    verify_type_info!: WeixinMpDtoVerify_type_info | undefined;
    user_name!: string | undefined;
    alias!: string | undefined;
    qrcode_url!: string | undefined;
    status!: WeixinMpDtoStatus | undefined;
    func_infos!: string | undefined;
    authorizationTime!: moment.Moment | undefined;
    unAuthorizationTime!: moment.Moment | undefined;
    expiredTime!: moment.Moment | undefined;
    awardTemplateId!: string | undefined;
    mpType!: WeixinMpDtoMpType | undefined;
    organizationUnitId!: number | undefined;
    isMine!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWeixinMpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.weixinAppID = data["weixinAppID"];
            this.expires_in = data["expires_in"];
            this.name = data["name"];
            this.iconPath = data["iconPath"];
            this.nickName = data["nickName"];
            this.head_img = data["head_img"];
            this.service_type_info = data["service_type_info"];
            this.verify_type_info = data["verify_type_info"];
            this.user_name = data["user_name"];
            this.alias = data["alias"];
            this.qrcode_url = data["qrcode_url"];
            this.status = data["status"];
            this.func_infos = data["func_infos"];
            this.authorizationTime = data["authorizationTime"] ? moment(data["authorizationTime"].toString()) : <any>undefined;
            this.unAuthorizationTime = data["unAuthorizationTime"] ? moment(data["unAuthorizationTime"].toString()) : <any>undefined;
            this.expiredTime = data["expiredTime"] ? moment(data["expiredTime"].toString()) : <any>undefined;
            this.awardTemplateId = data["awardTemplateId"];
            this.mpType = data["mpType"];
            this.organizationUnitId = data["organizationUnitId"];
            this.isMine = data["isMine"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WeixinMpDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeixinMpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weixinAppID"] = this.weixinAppID;
        data["expires_in"] = this.expires_in;
        data["name"] = this.name;
        data["iconPath"] = this.iconPath;
        data["nickName"] = this.nickName;
        data["head_img"] = this.head_img;
        data["service_type_info"] = this.service_type_info;
        data["verify_type_info"] = this.verify_type_info;
        data["user_name"] = this.user_name;
        data["alias"] = this.alias;
        data["qrcode_url"] = this.qrcode_url;
        data["status"] = this.status;
        data["func_infos"] = this.func_infos;
        data["authorizationTime"] = this.authorizationTime ? this.authorizationTime.toISOString() : <any>undefined;
        data["unAuthorizationTime"] = this.unAuthorizationTime ? this.unAuthorizationTime.toISOString() : <any>undefined;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        data["awardTemplateId"] = this.awardTemplateId;
        data["mpType"] = this.mpType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isMine"] = this.isMine;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWeixinMpDto {
    weixinAppID: string | undefined;
    expires_in: number | undefined;
    name: string | undefined;
    iconPath: string | undefined;
    nickName: string | undefined;
    head_img: string | undefined;
    service_type_info: WeixinMpDtoService_type_info | undefined;
    verify_type_info: WeixinMpDtoVerify_type_info | undefined;
    user_name: string | undefined;
    alias: string | undefined;
    qrcode_url: string | undefined;
    status: WeixinMpDtoStatus | undefined;
    func_infos: string | undefined;
    authorizationTime: moment.Moment | undefined;
    unAuthorizationTime: moment.Moment | undefined;
    expiredTime: moment.Moment | undefined;
    awardTemplateId: string | undefined;
    mpType: WeixinMpDtoMpType | undefined;
    organizationUnitId: number | undefined;
    isMine: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class MpAuthorzieUrlDto implements IMpAuthorzieUrlDto {
    url!: string | undefined;

    constructor(data?: IMpAuthorzieUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MpAuthorzieUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new MpAuthorzieUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IMpAuthorzieUrlDto {
    url: string | undefined;
}

export class WechatLoginResultDto implements IWechatLoginResultDto {
    isBind!: boolean | undefined;
    unionid!: string | undefined;
    tenantId!: number | undefined;
    authenticateResultModel!: AuthenticateResultModel | undefined;

    constructor(data?: IWechatLoginResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isBind = data["isBind"];
            this.unionid = data["unionid"];
            this.tenantId = data["tenantId"];
            this.authenticateResultModel = data["authenticateResultModel"] ? AuthenticateResultModel.fromJS(data["authenticateResultModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WechatLoginResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatLoginResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isBind"] = this.isBind;
        data["unionid"] = this.unionid;
        data["tenantId"] = this.tenantId;
        data["authenticateResultModel"] = this.authenticateResultModel ? this.authenticateResultModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWechatLoginResultDto {
    isBind: boolean | undefined;
    unionid: string | undefined;
    tenantId: number | undefined;
    authenticateResultModel: AuthenticateResultModel | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (Array.isArray(data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
            this.refreshTokenExpireInSeconds = data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number | undefined;
}

export class WeixinOpenPlatformDto implements IWeixinOpenPlatformDto {
    name!: string | undefined;
    componentAppID!: string | undefined;
    icon!: string | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWeixinOpenPlatformDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.componentAppID = data["componentAppID"];
            this.icon = data["icon"];
            this.description = data["description"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WeixinOpenPlatformDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeixinOpenPlatformDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["componentAppID"] = this.componentAppID;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWeixinOpenPlatformDto {
    name: string | undefined;
    componentAppID: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum AuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum FlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum Type {
    Activity = "Activity",
    Training = "Training",
}

export enum ApplyStatus {
    Applied = "Applied",
    Cancel = "Cancel",
    Accepted = "Accepted",
    Rejected = "Rejected",
}

export enum TemplateEnum {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum Type2 {
    Single = "Single",
    Multiple = "Multiple",
    Text = "Text",
}

export enum QuestionScoreType {
    Partial = "Partial",
    Full = "Full",
}

export enum SnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType2 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType3 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType4 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType5 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType6 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum AuditStatus2 {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingCategory {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum TrainingWay {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum TrainingStatus {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum AuditStatus3 {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingCategory2 {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum TrainingWay2 {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum TrainingStatus2 {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum AuditStatus4 {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingCategory3 {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum TrainingWay3 {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum TrainingStatus3 {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum WeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum QrType2 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType7 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType3 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType8 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType4 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType9 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType5 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType10 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum WeChatAuthorizationType2 {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum QrType6 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType11 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType7 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType12 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType8 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType13 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType9 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType14 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType10 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType15 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum QrType11 {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum SnsType16 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType17 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType18 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum ShareType {
    ShareAppMessage = "ShareAppMessage",
    ShareTimeline = "ShareTimeline",
    ShareQQ = "ShareQQ",
    ShareWeibo = "ShareWeibo",
    ShareQZone = "ShareQZone",
    Like = "Like",
}

export enum SnsType19 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType20 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType21 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsType22 {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum ActivityBasicDtoAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum CreateBasicActivityInputAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum UpdateBasicActivityInputAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityAuditInputCurrentAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityAuditInputTargetAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityFlowDtoFlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum ActivityFlowSettingsInputFlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum ActivityGameDtoWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityGameDtoTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum SnsMsgBeforeGameDtoWeChatType {
    Text = "Text",
    News = "News",
}

export enum SnsMsgAfterGameDtoWeChatType {
    Text = "Text",
    News = "News",
}

export enum ActionShareDtoActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum ActivityGameSettingsInputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityGameSettingsInputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityAwardDtoAwardThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum ActivityShareSettingsDtoActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum ActivityShareSettingsInputActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum SnsUserInfoDtoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum CreateApplyFormInputApplyType {
    Activity = "Activity",
    Training = "Training",
}

export enum CreateApplyFormInputWanted {
    Online = "Online",
    Offline = "Offline",
}

export enum AuditApplyFormInputApplyStatus {
    Applied = "Applied",
    Cancel = "Cancel",
    Accepted = "Accepted",
    Rejected = "Rejected",
}

export enum AwardDtoType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum AwardDtoThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum CreateAwardInputType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum CreateAwardInputThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum UpdateAwardInputType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum UpdateAwardInputThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum CreateDeviceActivityGameInputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum CreateDeviceActivityGameInputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum CreateSnsMsgGameInputWeChatType {
    Text = "Text",
    News = "News",
}

export enum CreateActionShareInputActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum DeviceActivityGameWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum DeviceActivityGameTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityRepeatAwardFrequency {
    None = "None",
    Day = "Day",
    Week = "Week",
    Month = "Month",
    Year = "Year",
}

export enum ActivityAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum SnsMessageWeChatType {
    Text = "Text",
    News = "News",
}

export enum SnsShareWeixinShareType {
    ShareAppMessage = "ShareAppMessage",
    ShareTimeline = "ShareTimeline",
    ShareQQ = "ShareQQ",
    ShareWeibo = "ShareWeibo",
    ShareQZone = "ShareQZone",
    Like = "Like",
}

export enum AwardType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum AwardThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum ActivityFlowFlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum ActivityGameWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityGameTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum HtmlTemplateTemplateType {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum DispatchedActivityGameWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum DispatchedActivityGameTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum UserActionStatus {
    Start = "Start",
    Waitting = "Waitting",
    Playing = "Playing",
    Done = "Done",
    AwardEdit = "AwardEdit",
    NotGetPrizeWithNoAward = "NotGetPrizeWithNoAward",
    NotGetPrize = "NotGetPrize",
}

export enum SnsUserInfoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum UpdateDeviceActivityGameInputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum UpdateDeviceActivityGameInputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum HtmlTemplateDtoTemplateType {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum CreateHtmlTemplateInputTemplateType {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum UpdateHtmlTemplateInputTemplateType {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum CreatePaperInputCompositionType {
    Fixed = "Fixed",
    Random = "Random",
    FixedPlusRandom = "FixedPlusRandom",
}

export enum CreatePaperInputPaperUsageType {
    Competition = "Competition",
    GamePK = "GamePK",
    Vote = "Vote",
    Investigate = "Investigate",
}

export enum UpdatePaperInputCompositionType {
    Fixed = "Fixed",
    Random = "Random",
    FixedPlusRandom = "FixedPlusRandom",
}

export enum UpdatePaperInputPaperUsageType {
    Competition = "Competition",
    GamePK = "GamePK",
    Vote = "Vote",
    Investigate = "Investigate",
}

export enum PaperDtoCompositionType {
    Fixed = "Fixed",
    Random = "Random",
    FixedPlusRandom = "FixedPlusRandom",
}

export enum PaperDtoPaperUsageType {
    Competition = "Competition",
    GamePK = "GamePK",
    Vote = "Vote",
    Investigate = "Investigate",
}

export enum QuestionDtoType {
    Single = "Single",
    Multiple = "Multiple",
    Text = "Text",
}

export enum QuestionDtoQuestionScoreType {
    Partial = "Partial",
    Full = "Full",
}

export enum CreateQuestionInputType {
    Single = "Single",
    Multiple = "Multiple",
    Text = "Text",
}

export enum CreateQuestionInputQuestionScoreType {
    Partial = "Partial",
    Full = "Full",
}

export enum UpdateQuestionInputType {
    Single = "Single",
    Multiple = "Multiple",
    Text = "Text",
}

export enum UpdateQuestionInputQuestionScoreType {
    Partial = "Partial",
    Full = "Full",
}

export enum SensingDeviceActivityDtoAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum SensingDeviceAwardDtoType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum AddUserPaperInputExamResult {
    NoneOk = "NoneOk",
    PartOk = "PartOk",
    AllOk = "AllOk",
}

export enum UserPaperExamResult {
    NoneOk = "NoneOk",
    PartOk = "PartOk",
    AllOk = "AllOk",
}

export enum PaperCompositionType {
    Fixed = "Fixed",
    Random = "Random",
    FixedPlusRandom = "FixedPlusRandom",
}

export enum PaperUsageType {
    Competition = "Competition",
    GamePK = "GamePK",
    Vote = "Vote",
    Investigate = "Investigate",
}

export enum TrainingCategory4 {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum TrainingAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingWay4 {
    InSideShareAndLecturerTeach = "InSideShareAndLecturerTeach",
    InSideShareAndVideoTeach = "InSideShareAndVideoTeach",
    OutSideShareAndLecturerTeach = "OutSideShareAndLecturerTeach",
    OutSideShareAndVideoTeach = "OutSideShareAndVideoTeach",
}

export enum TrainingStatus4 {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum SoftwareAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum AddUserPaperInput4WechatExamResult {
    NoneOk = "NoneOk",
    PartOk = "PartOk",
    AllOk = "AllOk",
}

export enum SnsUserInfoOutputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum AwardOutputType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export enum AwardOutputThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export enum DeviceActivityGameOutputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum DeviceActivityGameOutputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum ActivityOutputAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityShareOutputActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum DeviceActivityGameSimpleOutputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum DeviceActivityGameSimpleOutputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum UserActionDtoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum AddOrUpdateActivityUserInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SnsUserSimpleDataInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum UserRoomMessageOutputType {
    Text = "Text",
    Emoji = "Emoji",
    Audio = "Audio",
    RedPacket = "RedPacket",
    File = "File",
    Location = "Location",
    Image = "Image",
}

export enum SnsUserTextDataInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum Qrcode4LoginInputQrType {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum Qrcode4LoginInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum ClearSnsUserDataInputSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum GetWechatMediaDtoMediaType {
    News = "News",
    Image = "Image",
    Video = "Video",
    Voice = "Voice",
}

export enum TagType {
    Resource = "Resource",
    Device = "Device",
    Product = "Product",
    Ads = "Ads",
    Other = "Other",
    Brand = "Brand",
    Question = "Question",
    Counter = "Counter",
    WechatPublicMessage = "WechatPublicMessage",
}

export enum SnsUserInfoWithMemberDtoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum SpecailUserDtoType {
    White = "White",
    Black = "Black",
}

export enum CreateSpecialUserInputType {
    White = "White",
    Black = "Black",
}

export enum UpdateSpecialUserInputType {
    White = "White",
    Black = "Black",
}

export enum StoreActivityGameWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum StoreActivityGameTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum UpdateStoreActivityGameInputWeChatAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum UpdateStoreActivityGameInputTaobaoAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export enum CreateTrainingInputCategory {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum CreateTrainingInputAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum CreateTrainingInputTrainingWay {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum UpdateTrainingInputCategory {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum UpdateTrainingInputAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum UpdateTrainingInputTrainingWay {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum TrainingBasicDtoCategory {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export enum TrainingBasicDtoAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingBasicDtoTrainingWay {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export enum TrainingBasicDtoTrainingStatus {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum TrainingAuditInputCurrentAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum TrainingAuditInputTargetAuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export enum ActivityPayRecordInputActivityPayType {
    Cash = "Cash",
    Point = "Point",
    Ticket = "Ticket",
}

export enum ActivityPayRecordActivityPayType {
    Cash = "Cash",
    Point = "Point",
    Ticket = "Ticket",
}

export enum ActivityFlowOutputFlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum HtmlTemplateOutputTemplateType {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum SnsUserActionSumDtoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export enum MakeUserToSpecialInputType {
    White = "White",
    Black = "Black",
}

export enum GetUserPaperDtoExamResult {
    NoneOk = "NoneOk",
    PartOk = "PartOk",
    AllOk = "AllOk",
}

export enum GetWechatMenuDtoMenuType {
    Normal = "Normal",
    Individualization = "Individualization",
}

export enum AddOrUpdateMenuInputMenuType {
    Normal = "Normal",
    Individualization = "Individualization",
}

export enum AddOrUpdateConditionalMenuInputMenuType {
    Normal = "Normal",
    Individualization = "Individualization",
}

export enum GetWechatTemplateMessageDtoTemplateMessageType {
    付款成功通知 = "付款成功通知",
    订单支付通知 = "订单支付通知",
    订单发货通知 = "订单发货通知",
    退款申请通知 = "退款申请通知",
    退款审核通知 = "退款审核通知",
    退款成功通知 = "退款成功通知",
    取货通知 = "取货通知",
    防盗器报警通知 = "防盗器报警通知",
    商机认领提醒 = "商机认领提醒",
}

export enum WeixinMpDtoService_type_info {
    Subscribe = "Subscribe",
    HistoryToSubscribe = "HistoryToSubscribe",
    Service = "Service",
}

export enum WeixinMpDtoVerify_type_info {
    UnAuthentication = "UnAuthentication",
    WechatAuthentication = "WechatAuthentication",
    SinaWeiboAuthentication = "SinaWeiboAuthentication",
    QQweiboAuthentication = "QQweiboAuthentication",
    NoNameAuthentication = "NoNameAuthentication",
    NoNameBySinaWeiboAuthentication = "NoNameBySinaWeiboAuthentication",
    NoNameByQqWeiboAuthentication = "NoNameByQqWeiboAuthentication",
}

export enum WeixinMpDtoStatus {
    Authrozied = "Authrozied",
    UnAuthrozied = "UnAuthrozied",
    Locked = "Locked",
    UnLocked = "UnLocked",
}

export enum WeixinMpDtoMpType {
    Private = "Private",
    Public = "Public",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}