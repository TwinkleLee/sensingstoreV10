/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_ACTIVITY_URL = new InjectionToken<string>('API_ACTIVITY_URL');

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getActivityById(input: number | undefined): Observable<ActivityBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityById(response: HttpResponseBase): Observable<ActivityBasicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityBasicDto>(<any>null);
    }

    /**
     * 清除用户互动数据以及中将相关的数据
     * @param body (optional) 
     * @return Success
     */
    clearUserActivityData(body: ClearActivityUserDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ClearUserActivityData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserActivityData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearUserActivityData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param isTemplate (optional) check is template, null returns all
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivities(auditStatus: AuditStatus | undefined, startTime: moment.Moment | undefined, isTemplate: boolean | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivities?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (isTemplate === null)
            throw new Error("The parameter 'isTemplate' cannot be null.");
        else if (isTemplate !== undefined)
            url_ += "IsTemplate=" + encodeURIComponent("" + isTemplate) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivities(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivities(response: HttpResponseBase): Observable<PagedResultDtoOfActivityBasicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityBasicDto>(<any>null);
    }

    /**
     * 创建活动
     * @param body (optional) 
     * @return Success
     */
    createActivity(body: CreateBasicActivityInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivity(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createActivityFromTemplate(body: ActivityFromTemplateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivityFromTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivityFromTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivityFromTemplate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivityFromTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除某个活动
     * @param id (optional) 
     * @return Success
     */
    deleteActivity(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新活动的基本信息
     * @param body (optional) 
     * @return Success
     */
    updateActivity(body: UpdateBasicActivityInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/UpdateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 下发活动到ou或device
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrStoreOrDevices(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/PublishToOrganizationOrStoreOrDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrStoreOrDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrStoreOrDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrStoreOrDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 发布或者撤销全部 EntityIds 不需要传值
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrStoreOrDevices(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/PublishAllToOrganizationOrStoreOrDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrStoreOrDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrStoreOrDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrStoreOrDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activityAudit(body: ActivityAuditInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivityAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getActivityFlow(activityId: number | undefined, flowType: FlowType): Observable<ActivityFlowDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityFlow?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (flowType === undefined || flowType === null)
            throw new Error("The parameter 'flowType' must be defined and cannot be null.");
        else
            url_ += "FlowType=" + encodeURIComponent("" + flowType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityFlow(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFlowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFlowDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityFlow(response: HttpResponseBase): Observable<ActivityFlowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFlowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFlowDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activityFlowSettings(body: ActivityFlowSettingsInput | undefined): Observable<ActivityFlowDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityFlowSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityFlowSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityFlowSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFlowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFlowDto>><any>_observableThrow(response_);
        }));
    }

    protected processActivityFlowSettings(response: HttpResponseBase): Observable<ActivityFlowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFlowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFlowDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByActivityId(activityId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGamesByActivityId?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByActivityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByActivityId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByActivityId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGameForSelectByActivityId(activityId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGameForSelectByActivityId?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGameForSelectByActivityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGameForSelectByActivityId(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGameForSelectByActivityId(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getActivityGameById(id: number | undefined): Observable<ActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityGameById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGameById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGameById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGameById(response: HttpResponseBase): Observable<ActivityGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateActivityGame(body: ActivityGameSettingsInput | undefined): Observable<ActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateOrUpdateActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateActivityGame(response: HttpResponseBase): Observable<ActivityGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param activityGameIds (optional) 
     * @return Success
     */
    deleteActivityGame(activityId: number | undefined, activityGameIds: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivityGame?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (activityGameIds === null)
            throw new Error("The parameter 'activityGameIds' cannot be null.");
        else if (activityGameIds !== undefined)
            activityGameIds && activityGameIds.forEach(item => { url_ += "ActivityGameIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getAwardSettings(activityId: number | undefined): Observable<AwardSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetAwardSettings?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardSettings(response: HttpResponseBase): Observable<AwardSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardSettingsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    awardSettings(body: AwardSettingsDto | undefined): Observable<AwardSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/AwardSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAwardSettings(response: HttpResponseBase): Observable<AwardSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardSettingsDto>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityAward(deviceId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetDeviceActivityAward?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityAward(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityAward(response: HttpResponseBase): Observable<PagedResultDtoOfActivityAwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityAwardDto>(<any>null);
    }

    /**
     * 删除中奖信息
     * @param ids (optional) 
     * @return Success
     */
    deleteActivityAward(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteActivityAward?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivityAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获得活动下面中奖用户信息
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityAwardUser(activityId: number | undefined, deviceId: number | undefined, activityGameId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityAwardUser?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityAwardUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityAwardUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityAwardUser(response: HttpResponseBase): Observable<PagedResultDtoOfUserAwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserAwardDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserAwardExpressInfo(body: UpdateSnsUserAwardExpressInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/UpdateUserAwardExpressInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserAwardExpressInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserAwardExpressInfo(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserAwardExpressInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param awardId (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    doLotteryAction2Award(awardId: number | undefined, actionId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DoLotteryAction2Award?";
        if (awardId === null)
            throw new Error("The parameter 'awardId' cannot be null.");
        else if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAction2Award(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAction2Award(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAction2Award(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getAwardMessageSettings(activityId: number | undefined): Observable<AwardMessageSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetAwardMessageSettings?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardMessageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardMessageSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardMessageSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardMessageSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardMessageSettings(response: HttpResponseBase): Observable<AwardMessageSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardMessageSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardMessageSettingsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    awardMessageSettings(body: AwardMessageSettingsInput | undefined): Observable<AwardMessageSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/AwardMessageSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardMessageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardMessageSettings(<any>response_);
                } catch (e) {
                    return <Observable<AwardMessageSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardMessageSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAwardMessageSettings(response: HttpResponseBase): Observable<AwardMessageSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardMessageSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardMessageSettingsDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getActivityShareSettings(activityId: number | undefined): Observable<ActivityShareSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityShareSettings?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityShareSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityShareSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityShareSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityShareSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityShareSettings(response: HttpResponseBase): Observable<ActivityShareSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityShareSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityShareSettingsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activityShareSettings(body: ActivityShareSettingsInput | undefined): Observable<ActivityShareSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ActivityShareSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityShareSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityShareSettings(<any>response_);
                } catch (e) {
                    return <Observable<ActivityShareSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityShareSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processActivityShareSettings(response: HttpResponseBase): Observable<ActivityShareSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityShareSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityShareSettingsDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityUserDatas(activityId: number | undefined, deviceId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityUserDataDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivityUserDatas?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityUserDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityUserDatas(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityUserDatas(response: HttpResponseBase): Observable<PagedResultDtoOfActivityUserDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityUserDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityUserDataDto>(<any>null);
    }

    /**
     * @param isValidate (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateActivityUserDatas(isValidate: boolean | undefined, body: number[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ValidateActivityUserDatas?";
        if (isValidate === null)
            throw new Error("The parameter 'isValidate' cannot be null.");
        else if (isValidate !== undefined)
            url_ += "isValidate=" + encodeURIComponent("" + isValidate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateActivityUserDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateActivityUserDatas(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateActivityUserDatas(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearActivityData(body: DoClearActivityDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Activity/ClearActivityData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActivityData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActivityData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class AlipayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    alipayNotify(): Observable<void> {
        let url_ = this.baseUrl + "/Alipay/AlipayNotify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlipayNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlipayNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAlipayNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param auth_code (optional) 
     * @param app_id (optional) 
     * @param scope (optional) 
     * @param source (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(auth_code: string | undefined, app_id: string | undefined, scope: string | undefined, source: string | undefined, state: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Alipay/CallBack?";
        if (auth_code === null)
            throw new Error("The parameter 'auth_code' cannot be null.");
        else if (auth_code !== undefined)
            url_ += "auth_code=" + encodeURIComponent("" + auth_code) + "&";
        if (app_id === null)
            throw new Error("The parameter 'app_id' cannot be null.");
        else if (app_id !== undefined)
            url_ += "app_id=" + encodeURIComponent("" + app_id) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApplyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取审核列表
     * @param type 类型 product,coupon,ads....
     * @param applyStatus (optional) Accepted,Rejected
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyForms(type: ApplyFormType, applyStatus: ApplyStatus | undefined, start: moment.Moment | undefined, end: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfApplyFormDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyForms?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (applyStatus === null)
            throw new Error("The parameter 'applyStatus' cannot be null.");
        else if (applyStatus !== undefined)
            url_ += "ApplyStatus=" + encodeURIComponent("" + applyStatus) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "End=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyForms(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyForms(response: HttpResponseBase): Observable<PagedResultDtoOfApplyFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApplyFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApplyFormDto>(<any>null);
    }

    /**
     * Create ApplyForm
     * @param body (optional) 
     * @return Success
     */
    createApplyForm(body: CreateApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/CreateApplyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 审批特定提交
     * @param body (optional) 
     * @return Success
     */
    audit(body: AuditApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AwardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param activityGameId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwards(activityId: number | undefined, activityGameId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/GetAwards?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwards(response: HttpResponseBase): Observable<PagedResultDtoOfAwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAwardDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAward(body: CreateAwardInput | undefined): Observable<AwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/CreateAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAward(<any>response_);
                } catch (e) {
                    return <Observable<AwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAward(response: HttpResponseBase): Observable<AwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAward(body: UpdateAwardInput | undefined): Observable<AwardDto> {
        let url_ = this.baseUrl + "/api/services/app/Award/UpdateAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAward(<any>response_);
                } catch (e) {
                    return <Observable<AwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAward(response: HttpResponseBase): Observable<AwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwardDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @param ids (optional) 
     * @return Success
     */
    deleteAward(activityId: number | undefined, ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Award/DeleteAward?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    activityTemplateSelect(): Observable<KeyValueDtoOfInt64[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/ActivityTemplateSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityTemplateSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityTemplateSelect(<any>response_);
                } catch (e) {
                    return <Observable<KeyValueDtoOfInt64[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyValueDtoOfInt64[]>><any>_observableThrow(response_);
        }));
    }

    protected processActivityTemplateSelect(response: HttpResponseBase): Observable<KeyValueDtoOfInt64[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValueDtoOfInt64.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValueDtoOfInt64[]>(<any>null);
    }

    /**
     * Drop Down for flow types
     * @return Success
     */
    flowTypeSelect(): Observable<KeyValueDtoOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/FlowTypeSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlowTypeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlowTypeSelect(<any>response_);
                } catch (e) {
                    return <Observable<KeyValueDtoOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyValueDtoOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processFlowTypeSelect(response: HttpResponseBase): Observable<KeyValueDtoOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValueDtoOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyValueDtoOfString[]>(<any>null);
    }

    /**
     * 敏感词汇检验
     * @param text (optional) 
     * @return Success
     */
    textCensor(text: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Common/TextCensor?";
        if (text === null)
            throw new Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTextCensor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTextCensor(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processTextCensor(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCourse(body: CreateCourseInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Course/CreateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCourse(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCourse(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCourse(body: UpdateCourseInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/UpdateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCourse(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/DeleteCourse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteCourses(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Course/BatchDeleteCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteCourses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteCourses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param courseNo (optional) 
     * @param name (optional) 
     * @param tagId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCourses(id: number | undefined, courseNo: string | undefined, name: string | undefined, tagId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCourseDto> {
        let url_ = this.baseUrl + "/api/services/app/Course/GetCourses?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (courseNo === null)
            throw new Error("The parameter 'courseNo' cannot be null.");
        else if (courseNo !== undefined)
            url_ += "CourseNo=" + encodeURIComponent("" + courseNo) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourses(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCourseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCourseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourses(response: HttpResponseBase): Observable<PagedResultDtoOfCourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCourseDto>(<any>null);
    }
}

@Injectable()
export class DeviceActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivitiesById(deviceId: number, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetDeviceActivitiesById?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivitiesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivitiesById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivitiesById(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceActivityDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByIdAndDeviceId(deviceId: number, activityId: number, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetActivityGamesByIdAndDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByIdAndDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByIdAndDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByIdAndDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeviceActivityGame(body: CreateDeviceActivityGameInput | undefined): Observable<DeviceActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/CreateDeviceActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceActivityGame(response: HttpResponseBase): Observable<DeviceActivityGame> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGame>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeviceActivityGame(body: UpdateDeviceActivityGameInput | undefined): Observable<DeviceActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/UpdateDeviceActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceActivityGame(response: HttpResponseBase): Observable<DeviceActivityGame> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGame>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceActivityGame(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/DeleteDeviceActivityGame?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getActivityChat(body: GetActivityChatInput | undefined): Observable<SummaryReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/GetActivityChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityChat(<any>response_);
                } catch (e) {
                    return <Observable<SummaryReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SummaryReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityChat(response: HttpResponseBase): Observable<SummaryReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SummaryReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryReportDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     * @deprecated
     */
    mirrorPublishActivityToDevices(body: MirrorPublishActivityToDevicesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceActivity/MirrorPublishActivityToDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMirrorPublishActivityToDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMirrorPublishActivityToDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMirrorPublishActivityToDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DouyinServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(code: string | undefined, state: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/CallBack?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    authCallBack(code: string | undefined, state: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/AuthCallBack?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuthCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDouyinMediaAuthorizeUrl(): Observable<string> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinMediaAuthorizeUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinMediaAuthorizeUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinMediaAuthorizeUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinMediaAuthorizeUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @return Success
     */
    getDouyinUserData(startTime: moment.Moment | undefined, endTime: moment.Moment | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinUserData?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinUserData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinUserData(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinUserData(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDouyinMedia(subkey: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDouyinMedia> {
        let url_ = this.baseUrl + "/Douyin/GetDouyinMedia?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDouyinMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDouyinMedia(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDouyinMedia>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDouyinMedia>><any>_observableThrow(response_);
        }));
    }

    protected processGetDouyinMedia(response: HttpResponseBase): Observable<PagedResultDtoOfDouyinMedia> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDouyinMedia.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDouyinMedia>(<any>null);
    }

    /**
     * @return Success
     */
    syncDouyinMedia(): Observable<void> {
        let url_ = this.baseUrl + "/Douyin/SyncDouyinMedia";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncDouyinMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncDouyinMedia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncDouyinMedia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&";
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HtmlTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param templateEnum (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getHtmlTemplates(templateEnum: TemplateEnum | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfHtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/GetHtmlTemplates?";
        if (templateEnum === null)
            throw new Error("The parameter 'templateEnum' cannot be null.");
        else if (templateEnum !== undefined)
            url_ += "TemplateEnum=" + encodeURIComponent("" + templateEnum) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHtmlTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHtmlTemplates(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHtmlTemplates(response: HttpResponseBase): Observable<PagedResultDtoOfHtmlTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfHtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHtmlTemplateDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createHtmlTemplate(body: CreateHtmlTemplateInput | undefined): Observable<HtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/CreateHtmlTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<HtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHtmlTemplate(response: HttpResponseBase): Observable<HtmlTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HtmlTemplateDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateHtmlTemplate(body: UpdateHtmlTemplateInput | undefined): Observable<HtmlTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/UpdateHtmlTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<HtmlTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HtmlTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHtmlTemplate(response: HttpResponseBase): Observable<HtmlTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HtmlTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HtmlTemplateDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteHtmlTemplate(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HtmlTemplate/DeleteHtmlTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHtmlTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHtmlTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHtmlTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ImportQuestionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param excel (optional) 
     * @return Success
     */
    importQuestionByExcel(excel: FileParameter | undefined): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportQuestions/ImportQuestionByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excel === null || excel === undefined)
            throw new Error("The parameter 'excel' cannot be null.");
        else
            content_.append("excel", excel.data, excel.fileName ? excel.fileName : "excel");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportQuestionByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportQuestionByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportQuestionByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class ImportTrainingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importTrainingsByExcel(): Observable<string> {
        let url_ = this.baseUrl + "/ImportTrainings/ImportTrainingsByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTrainingsByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTrainingsByExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportTrainingsByExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param excel (optional) 
     * @return Success
     */
    importQuestionByExcel(excel: FileParameter | undefined): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportTrainings/ImportQuestionByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excel === null || excel === undefined)
            throw new Error("The parameter 'excel' cannot be null.");
        else
            content_.append("excel", excel.data, excel.fileName ? excel.fileName : "excel");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportQuestionByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportQuestionByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportQuestionByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class PaperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaper(body: CreatePaperInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paper/CreatePaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaper(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaper(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePaper(body: UpdatePaperInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/UpdatePaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapers(organizationUnitId: number | undefined, tagIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetPapers?";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param dispatchedSoftwareId (optional) 
     * @param organizationUnitId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDispatchedPapers(dispatchedSoftwareId: number | undefined, organizationUnitId: number | undefined, tagIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetDispatchedPapers?";
        if (dispatchedSoftwareId === null)
            throw new Error("The parameter 'dispatchedSoftwareId' cannot be null.");
        else if (dispatchedSoftwareId !== undefined)
            url_ += "DispatchedSoftwareId=" + encodeURIComponent("" + dispatchedSoftwareId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispatchedPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispatchedPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispatchedPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaper(id: number | undefined): Observable<PaperDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetPaper?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaper(<any>response_);
                } catch (e) {
                    return <Observable<PaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaper(response: HttpResponseBase): Observable<PaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaperDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionsByPaperId(paperId: number | undefined, tagIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetQuestionsByPaperId?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * 获取不在当前试卷下的题目
     * @param paperId (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getNoUsedQuestionsByPaperId(paperId: number | undefined, tagIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Paper/GetNoUsedQuestionsByPaperId?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoUsedQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoUsedQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNoUsedQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePaper(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/DeletePaper?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePapers(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/DeletePapers?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePapers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePapers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量更新试卷下面试题的分数和排序
     * @param body (optional) 
     * @return Success
     */
    updateQuestionScoreAndOrder(body: UpdateQuestionScoreAndOrderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/UpdateQuestionScoreAndOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionScoreAndOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionScoreAndOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionScoreAndOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加随机题目到试卷
     * @param paperId (optional) 
     * @return Success
     */
    addRandomQuestionsToPaper(paperId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/AddRandomQuestionsToPaper?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "paperId=" + encodeURIComponent("" + paperId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRandomQuestionsToPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRandomQuestionsToPaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRandomQuestionsToPaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishPapersToSoftwares(body: PublishPapersToSoftwares | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paper/PublishPapersToSoftwares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishPapersToSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishPapersToSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishPapersToSoftwares(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PublicAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    createPublicAccountMenu(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PublicAccount/CreatePublicAccountMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePublicAccountMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePublicAccountMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePublicAccountMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param qrcodeId (optional) 
     * @return Success
     */
    showqrcode(qrcodeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/showqrcode?";
        if (qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' cannot be null.");
        else if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowqrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowqrcode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShowqrcode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuestionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createQuestion(body: CreateQuestionInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Question/CreateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestion(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQuestion(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateQuestion(body: UpdateQuestionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/UpdateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param tagIds (optional) 
     * @param questionScoreType (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestions(type: QuestionTypeEnum | undefined, tagIds: number[] | undefined, questionScoreType: QuestionScoreTypeEnum | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetQuestions?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (questionScoreType === null)
            throw new Error("The parameter 'questionScoreType' cannot be null.");
        else if (questionScoreType !== undefined)
            url_ += "QuestionScoreType=" + encodeURIComponent("" + questionScoreType) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestions(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param tagIds (optional) 
     * @param questionScoreType (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionList(type: QuestionTypeEnum | undefined, tagIds: number[] | undefined, questionScoreType: QuestionScoreTypeEnum | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<QuestionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetQuestionList?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (questionScoreType === null)
            throw new Error("The parameter 'questionScoreType' cannot be null.");
        else if (questionScoreType !== undefined)
            url_ += "QuestionScoreType=" + encodeURIComponent("" + questionScoreType) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionList(<any>response_);
                } catch (e) {
                    return <Observable<QuestionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionList(response: HttpResponseBase): Observable<QuestionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuestion(id: number | undefined): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetQuestion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestion(<any>response_);
                } catch (e) {
                    return <Observable<QuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestion(response: HttpResponseBase): Observable<QuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteQuestion(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/DeleteQuestion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteQuestions(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/DeleteQuestions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQuestions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateQuestionStatus(body: UpdateQuestionStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/UpdateQuestionStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加删除qustion 到 试卷
     * @param body (optional) 
     * @return Success
     */
    publishQuestionsToPapers(body: PublishQuestionsToPapersInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/PublishQuestionsToPapers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishQuestionsToPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishQuestionsToPapers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishQuestionsToPapers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReleaseApiTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    releaseApiTest(): Observable<NameValueTimeDto[]> {
        let url_ = this.baseUrl + "/api/ReleaseApiTest/ReleaseApiTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseApiTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseApiTest(<any>response_);
                } catch (e) {
                    return <Observable<NameValueTimeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueTimeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseApiTest(response: HttpResponseBase): Observable<NameValueTimeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueTimeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueTimeDto[]>(<any>null);
    }
}

@Injectable()
export class RepertoryHelpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    subScriptionRepertoryNotifie(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/RepertoryHelp/SubScriptionRepertoryNotifie";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubScriptionRepertoryNotifie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubScriptionRepertoryNotifie(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSubScriptionRepertoryNotifie(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param openid (optional) 
     * @param weChatAppID (optional) 
     * @param thingName (optional) 
     * @param deviceName (optional) 
     * @param cargoName (optional) 
     * @return Success
     */
    senMessageTest(openid: string | undefined, weChatAppID: string | undefined, thingName: string | undefined, deviceName: string | undefined, cargoName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/RepertoryHelp/SenMessageTest?";
        if (openid === null)
            throw new Error("The parameter 'openid' cannot be null.");
        else if (openid !== undefined)
            url_ += "openid=" + encodeURIComponent("" + openid) + "&";
        if (weChatAppID === null)
            throw new Error("The parameter 'weChatAppID' cannot be null.");
        else if (weChatAppID !== undefined)
            url_ += "WeChatAppID=" + encodeURIComponent("" + weChatAppID) + "&";
        if (thingName === null)
            throw new Error("The parameter 'thingName' cannot be null.");
        else if (thingName !== undefined)
            url_ += "ThingName=" + encodeURIComponent("" + thingName) + "&";
        if (deviceName === null)
            throw new Error("The parameter 'deviceName' cannot be null.");
        else if (deviceName !== undefined)
            url_ += "DeviceName=" + encodeURIComponent("" + deviceName) + "&";
        if (cargoName === null)
            throw new Error("The parameter 'cargoName' cannot be null.");
        else if (cargoName !== undefined)
            url_ += "CargoName=" + encodeURIComponent("" + cargoName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSenMessageTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSenMessageTest(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSenMessageTest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param softwareId (optional) 
     * @param activityGameId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getTotal(startTime: moment.Moment, endTime: moment.Moment, activityId: number | undefined, deviceId: number | undefined, softwareId: number | undefined, activityGameId: number | undefined, tenantId: number | undefined): Observable<SummaryReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetTotal?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotal(<any>response_);
                } catch (e) {
                    return <Observable<SummaryReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SummaryReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotal(response: HttpResponseBase): Observable<SummaryReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SummaryReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryReportDto>(<any>null);
    }

    /**
     * @param type 日别，月别，周别。。。
     * @param activityId (optional) 
     * @param deviceId (optional) 
     * @param softwareId (optional) 
     * @param activityGameId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getActivityLabelChartReport(labels: string, type: string, startTime: moment.Moment, endTime: moment.Moment, activityId: number | undefined, deviceId: number | undefined, softwareId: number | undefined, activityGameId: number | undefined, tenantId: number | undefined): Observable<ChartReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetActivityLabelChartReport?";
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "Labels=" + encodeURIComponent("" + labels) + "&";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLabelChartReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLabelChartReport(<any>response_);
                } catch (e) {
                    return <Observable<ChartReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLabelChartReport(response: HttpResponseBase): Observable<ChartReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartReportDto[]>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    getUserAwardReportByActivity(activityId: number | undefined): Observable<UserAwardByActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetUserAwardReportByActivity?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAwardReportByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAwardReportByActivity(<any>response_);
                } catch (e) {
                    return <Observable<UserAwardByActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAwardByActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAwardReportByActivity(response: HttpResponseBase): Observable<UserAwardByActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAwardByActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAwardByActivityDto>(<any>null);
    }
}

@Injectable()
export class SengsingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取特定终端的活动信息一览
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivities(subkey: string, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSensingDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetActivities?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivities(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivities(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceActivityDto>(<any>null);
    }

    /**
     * 获取特定终端的活动游戏信息一览
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGames(subkey: string, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ActivityGameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetActivityGames?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGames(<any>response_);
                } catch (e) {
                    return <Observable<ActivityGameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityGameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGames(response: HttpResponseBase): Observable<ActivityGameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityGameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityGameDto[]>(<any>null);
    }

    /**
     * 获取特定终端的奖品信息一览
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwards(subkey: string, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetAwards?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwards(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceAwardDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwardsBySecurityKey(securityKey: string, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetAwardsBySecurityKey?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsBySecurityKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsBySecurityKey(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceAwardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsBySecurityKey(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceAwardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceAwardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceAwardDto>(<any>null);
    }

    /**
     * @param softwareId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapers(subkey: string, softwareId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPapers?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapers(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * @param tags (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPapersByTags(subkey: string, tags: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPapersByTags?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (tags === null)
            throw new Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            tags && tags.forEach(item => { url_ += "Tags=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPapersByTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPapersByTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPapersByTags(response: HttpResponseBase): Observable<PagedResultDtoOfPaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaperDto>(<any>null);
    }

    /**
     * 获取试卷的题目
     * @param paperId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getQuestionsByPaperId(subkey: string, paperId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetQuestionsByPaperId?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsByPaperId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsByPaperId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsByPaperId(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserPaper(body: AddUserPaperInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/AddUserPaper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserPaper(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserPaper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userActionId (optional) 
     * @return Success
     */
    getUserPaper(subKey: string | undefined, paperId: number | undefined, trainingId: number | undefined, userActionId: number | undefined): Observable<SingleUserPaperDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetUserPaper?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userActionId === null)
            throw new Error("The parameter 'userActionId' cannot be null.");
        else if (userActionId !== undefined)
            url_ += "UserActionId=" + encodeURIComponent("" + userActionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaper(<any>response_);
                } catch (e) {
                    return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaper(response: HttpResponseBase): Observable<SingleUserPaperDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserPaperDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleUserPaperDetailDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserPaper4WeChat(body: AddUserPaperInput4Wechat | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/AddUserPaper4WeChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserPaper4WeChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserPaper4WeChat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserPaper4WeChat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReport(subkey: string, paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetPaperAnswerReport?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerReportDto>(<any>null);
    }

    /**
     * @param securityKey (optional) 
     * @return Success
     */
    getDeviceInfoBySecurityKey(securityKey: string | undefined): Observable<SensingDeviceStoreInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/GetDeviceInfoBySecurityKey?";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceInfoBySecurityKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceInfoBySecurityKey(<any>response_);
                } catch (e) {
                    return <Observable<SensingDeviceStoreInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensingDeviceStoreInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceInfoBySecurityKey(response: HttpResponseBase): Observable<SensingDeviceStoreInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensingDeviceStoreInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensingDeviceStoreInfoDto>(<any>null);
    }

    /**
     * 设备的镜像发布活动
     * @param body (optional) 
     * @return Success
     */
    mirrorPublishActivityToDevices(body: DeviceMirrorPublishInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SengsingDevice/MirrorPublishActivityToDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMirrorPublishActivityToDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMirrorPublishActivityToDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMirrorPublishActivityToDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingDeviceActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 特定活动中，中奖的用户.
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWinUserAwards(isGameLevel: boolean | undefined, securityKey: string, softwareCode: string | undefined, clientId: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetWinUserAwards?";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWinUserAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWinUserAwards(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWinUserAwards(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserAwardOuput>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getSnsUserAwardById(userAwardId: number, securityKey: string, params: string | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetSnsUserAwardById?";
        if (userAwardId === undefined || userAwardId === null)
            throw new Error("The parameter 'userAwardId' must be defined and cannot be null.");
        else
            url_ += "UserAwardId=" + encodeURIComponent("" + userAwardId) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSnsUserAwardById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSnsUserAwardById(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSnsUserAwardById(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doLotteryAwardBySnsUserInfo(body: SnsDataInput | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardBySnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardBySnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardBySnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardBySnsUserInfo(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doLotteryForCargoBySnsUserInfo(body: DoLotteryAwardForCargoBySnsInput | undefined): Observable<LotteryCargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryForCargoBySnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryForCargoBySnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryForCargoBySnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<LotteryCargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LotteryCargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryForCargoBySnsUserInfo(response: HttpResponseBase): Observable<LotteryCargoResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LotteryCargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LotteryCargoResultDto>(<any>null);
    }

    /**
     * 有用户的特定Action,进行抽奖.
     * @param body (optional) 
     * @return Success
     */
    doLotteryAwardByAction(body: LotteryActionDataInput | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardByAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardByAction(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * 有用户的特定Action,进行抽奖.
     * @param body (optional) 
     * @return Success
     */
    doLotteryAwardForCargoByAction(body: DoLotteryAwardForCargoByActionInput | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardForCargoByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardForCargoByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardForCargoByAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardForCargoByAction(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doLotteryForCargoByAction(body: DoLotteryAwardForCargoByActionInput | undefined): Observable<LotteryCargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryForCargoByAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryForCargoByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryForCargoByAction(<any>response_);
                } catch (e) {
                    return <Observable<LotteryCargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LotteryCargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryForCargoByAction(response: HttpResponseBase): Observable<LotteryCargoResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LotteryCargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LotteryCargoResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doLotteryAwardByActionWithScore(body: LotteryActionDataInput | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryAwardByActionWithScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryAwardByActionWithScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryAwardByActionWithScore(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryAwardByActionWithScore(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * 特定奖项,随机抽出中将人数.
     * @param body (optional) 
     * @return Success
     */
    doLotteryUserByAwardId(body: AwardDataInput | undefined): Observable<SnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DoLotteryUserByAwardId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoLotteryUserByAwardId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoLotteryUserByAwardId(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processDoLotteryUserByAwardId(response: HttpResponseBase): Observable<SnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardOuput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAwardNotify(body: UserAwardDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/SendAwardNotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAwardNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAwardNotify(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendAwardNotify(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearActivityDatas(body: ClearActivityDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ClearActivityDatas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActivityDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActivityDatas(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActivityDatas(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 只找货道
     * @param body (optional) 
     * @return Success
     */
    checkLotteryForCargo(body: DoLotteryAwardForCargoBySnsInput | undefined): Observable<CargoResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/CheckLotteryForCargo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckLotteryForCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckLotteryForCargo(<any>response_);
                } catch (e) {
                    return <Observable<CargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckLotteryForCargo(response: HttpResponseBase): Observable<CargoResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dropCagoByInput(body: DropCargoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/DropCagoByInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCagoByInput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCagoByInput(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCagoByInput(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getDeviceActivityGameInfo(securityKey: string, params: string | undefined): Observable<DeviceActivityGameOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameInfo?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameInfo(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameInfo(response: HttpResponseBase): Observable<DeviceActivityGameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceActivityGameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGameOutput>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getActivityInfo(subKey: string | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityInfo?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityInfo(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityInfo(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    getDeviceActivityGames(securityKey: string, params: string | undefined): Observable<DeviceActivityGameSimpleOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGames?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGames(<any>response_);
                } catch (e) {
                    return <Observable<DeviceActivityGameSimpleOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceActivityGameSimpleOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGames(response: HttpResponseBase): Observable<DeviceActivityGameSimpleOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceActivityGameSimpleOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceActivityGameSimpleOutput[]>(<any>null);
    }

    /**
     * 得到特定活动下的所有奖品信息.
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAwardsByActivity(securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAwardOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetAwardsByActivity?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAwardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAwardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfAwardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAwardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAwardOutput>(<any>null);
    }

    /**
     * @param memberIds (optional) 
     * @return Success
     */
    getUserInfosByMemberIds(subKey: string, memberIds: number[] | undefined): Observable<SnsUserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserInfosByMemberIds?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (memberIds === null)
            throw new Error("The parameter 'memberIds' cannot be null.");
        else if (memberIds !== undefined)
            memberIds && memberIds.forEach(item => { url_ += "MemberIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfosByMemberIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfosByMemberIds(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfosByMemberIds(response: HttpResponseBase): Observable<SnsUserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SnsUserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    queryUserInfosByMemberIds(body: SensingDeviceUserInfoInput | undefined): Observable<SnsUserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/QueryUserInfosByMemberIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUserInfosByMemberIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUserInfosByMemberIds(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryUserInfosByMemberIds(response: HttpResponseBase): Observable<SnsUserInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SnsUserInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoDto[]>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param activityId (optional) 
     * @return Success
     */
    getUserInteractive(subKey: string | undefined, activityId: number[] | undefined): Observable<UserInteractiveDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserInteractive?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            activityId && activityId.forEach(item => { url_ += "ActivityId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInteractive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInteractive(<any>response_);
                } catch (e) {
                    return <Observable<UserInteractiveDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInteractiveDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInteractive(response: HttpResponseBase): Observable<UserInteractiveDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInteractiveDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInteractiveDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateActivityAwards(body: UpdateActivityAwardsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/UpdateActivityAwards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActivityAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActivityAwards(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActivityAwards(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityUserDatas(securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityUserDataDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityUserDatas?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityUserDatas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityUserDatas(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityUserDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityUserDatas(response: HttpResponseBase): Observable<PagedResultDtoOfActivityUserDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityUserDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityUserDataDto>(<any>null);
    }

    /**
     * 获取我玩过的游戏列表，特定活动下的
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPlayGamesByUser(openId: string, snsType: _definitions_EnumSnsType, securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPlayGameOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetPlayGamesByUser?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlayGamesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlayGamesByUser(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPlayGameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPlayGameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlayGamesByUser(response: HttpResponseBase): Observable<PagedResultDtoOfPlayGameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPlayGameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPlayGameOutput>(<any>null);
    }

    /**
     * 获取我互动的数据，特定活动或游戏下的
     * @param minScore (optional) 
     * @param isGameLevel (optional) 
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyActionsInActivity(minScore: number | undefined, isGameLevel: boolean | undefined, openId: string, snsType: _definitions_EnumSnsType, securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserActionPlayInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyActionsInActivity?";
        if (minScore === null)
            throw new Error("The parameter 'minScore' cannot be null.");
        else if (minScore !== undefined)
            url_ += "MinScore=" + encodeURIComponent("" + minScore) + "&";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyActionsInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyActionsInActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionPlayInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionPlayInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyActionsInActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionPlayInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionPlayInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionPlayInfoOutput>(<any>null);
    }

    /**
     * 获取我互动数据的排名，特定活动或者游戏下的.
     * @param rankColumn (optional) 
     * @param rank (optional) 
     * @param isGameLevel (optional) 
     * @param actionId (optional) 
     * @param params (optional) 
     * @return Success
     */
    getMyRankInActivity(rankColumn: string | undefined, rank: number | undefined, isGameLevel: boolean | undefined, actionId: number | undefined, openId: string, snsType: _definitions_EnumSnsType, securityKey: string, params: string | undefined): Observable<RankUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyRankInActivity?";
        if (rankColumn === null)
            throw new Error("The parameter 'rankColumn' cannot be null.");
        else if (rankColumn !== undefined)
            url_ += "RankColumn=" + encodeURIComponent("" + rankColumn) + "&";
        if (rank === null)
            throw new Error("The parameter 'rank' cannot be null.");
        else if (rank !== undefined)
            url_ += "Rank=" + encodeURIComponent("" + rank) + "&";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyRankInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyRankInActivity(<any>response_);
                } catch (e) {
                    return <Observable<RankUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RankUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyRankInActivity(response: HttpResponseBase): Observable<RankUserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RankUserActionInfoOutput>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param deviceActivityGameId (optional) 
     * @return Success
     */
    getUserPlayGameScoreRank(subKey: string | undefined, deviceActivityGameId: number | undefined): Observable<UserGameRank[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserPlayGameScoreRank?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (deviceActivityGameId === null)
            throw new Error("The parameter 'deviceActivityGameId' cannot be null.");
        else if (deviceActivityGameId !== undefined)
            url_ += "deviceActivityGameId=" + encodeURIComponent("" + deviceActivityGameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPlayGameScoreRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPlayGameScoreRank(<any>response_);
                } catch (e) {
                    return <Observable<UserGameRank[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGameRank[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPlayGameScoreRank(response: HttpResponseBase): Observable<UserGameRank[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserGameRank.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserGameRank[]>(<any>null);
    }

    /**
     * @param securityKeys (optional) 
     * @param openId (optional) 
     * @return Success
     */
    getActivityActionsForNextGame(securityKeys: string[] | undefined, openId: string | undefined): Observable<GetActivityActionsForNextGameDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityActionsForNextGame?";
        if (securityKeys === null)
            throw new Error("The parameter 'securityKeys' cannot be null.");
        else if (securityKeys !== undefined)
            securityKeys && securityKeys.forEach(item => { url_ += "securityKeys=" + encodeURIComponent("" + item) + "&"; });
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityActionsForNextGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityActionsForNextGame(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityActionsForNextGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityActionsForNextGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityActionsForNextGame(response: HttpResponseBase): Observable<GetActivityActionsForNextGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetActivityActionsForNextGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityActionsForNextGameDto>(<any>null);
    }

    /**
     * @param securityKey (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityGameUserActions(securityKey: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameUserActions?";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionDto>(<any>null);
    }

    /**
     * @param securityKeys (optional) 
     * @return Success
     */
    getLastPlayedUserInfos(securityKeys: string[] | undefined): Observable<GetLastPlayedUserInfosDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetLastPlayedUserInfos?";
        if (securityKeys === null)
            throw new Error("The parameter 'securityKeys' cannot be null.");
        else if (securityKeys !== undefined)
            securityKeys && securityKeys.forEach(item => { url_ += "securityKeys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastPlayedUserInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastPlayedUserInfos(<any>response_);
                } catch (e) {
                    return <Observable<GetLastPlayedUserInfosDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLastPlayedUserInfosDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastPlayedUserInfos(response: HttpResponseBase): Observable<GetLastPlayedUserInfosDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetLastPlayedUserInfosDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLastPlayedUserInfosDto[]>(<any>null);
    }

    /**
     * 获取我活动级别的数据
     * @param params (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    getMyPersonDataInActivity(openId: string, snsType: _definitions_EnumSnsType, securityKey: string, params: string | undefined, actionId: number | undefined): Observable<ActivityUserDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyPersonDataInActivity?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPersonDataInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPersonDataInActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityUserDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityUserDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyPersonDataInActivity(response: HttpResponseBase): Observable<ActivityUserDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityUserDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityUserDataOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateMyPersonData(body: AddOrUpdateActivityUserInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/AddOrUpdateMyPersonData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMyPersonData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMyPersonData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMyPersonData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mySignInActivity(body: SnsUserSimpleDataInput | undefined): Observable<ActivityUserDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/MySignInActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMySignInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMySignInActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityUserDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityUserDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processMySignInActivity(response: HttpResponseBase): Observable<ActivityUserDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityUserDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityUserDataOutput>(<any>null);
    }

    /**
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityChattingRecords(securityKey: string, softwareCode: string | undefined, clientId: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetActivityChattingRecords?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityChattingRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityChattingRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityChattingRecords(response: HttpResponseBase): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserRoomMessageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserRoomMessageOutput>(<any>null);
    }

    /**
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceActivityGameChattingRecords(securityKey: string, softwareCode: string | undefined, clientId: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDeviceActivityGameChattingRecords?";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceActivityGameChattingRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceActivityGameChattingRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserRoomMessageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceActivityGameChattingRecords(response: HttpResponseBase): Observable<PagedResultDtoOfUserRoomMessageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserRoomMessageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserRoomMessageOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTextMessageByUser(body: SnsUserTextDataInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/SendTextMessageByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTextMessageByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTextMessageByUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSendTextMessageByUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getFaceRecognizeResult(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetFaceRecognizeResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaceRecognizeResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaceRecognizeResult(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetFaceRecognizeResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateSnsUserInfo(body: AddOrUpdateSnsUserInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/AddOrUpdateSnsUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateSnsUserInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取二维码
     * @param body (optional) 
     * @return Success
     */
    createQrCode4Login(body: Qrcode4LoginInput | undefined): Observable<QrcodeOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/CreateQrCode4Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQrCode4Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQrCode4Login(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQrCode4Login(response: HttpResponseBase): Observable<QrcodeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeOutput>(<any>null);
    }

    /**
     * 找出所有扫描此二维码的用户
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getScanQrCodeUsers(qrcodeId: number, securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetScanQrCodeUsers?";
        if (qrcodeId === undefined || qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' must be defined and cannot be null.");
        else
            url_ += "QrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScanQrCodeUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScanQrCodeUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetScanQrCodeUsers(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserInfoOutput>(<any>null);
    }

    /**
     * 找出特定互动的信息包含用户的用户
     * @param params (optional) 
     * @return Success
     */
    getUserActionById(actionId: number, securityKey: string, params: string | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionById?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionById(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * 找出所有扫描此二维码用户的Action.
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getScanQrCodeUserActions(qrcodeId: number, securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetScanQrCodeUserActions?";
        if (qrcodeId === undefined || qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' must be defined and cannot be null.");
        else
            url_ += "QrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScanQrCodeUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScanQrCodeUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetScanQrCodeUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * 获取当前活动下所有的互动信息.
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getUserActionsByActivity(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, securityKey: string, softwareCode: string | undefined, clientId: string | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionsByActivity?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * 获取当前活动下当前游戏的所有互动信息.
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getUserActionsByActivityGame(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, securityKey: string, softwareCode: string | undefined, clientId: string | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetUserActionsByActivityGame?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsByActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsByActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsByActivityGame(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDataUsers(isGameLevel: boolean | undefined, securityKey: string, softwareCode: string | undefined, clientId: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityDataUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetDataUsers?";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityDataUserOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityDataUserOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataUsers(response: HttpResponseBase): Observable<PagedResultDtoOfActivityDataUserOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityDataUserOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityDataUserOutput>(<any>null);
    }

    /**
     * 获取排行，支持活动或游戏级别的排行.
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param isGameLevel (optional) 
     * @param softwareCode (optional) 
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getRankedUsersWithActionByActivity(rankColumn: string, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, isGameLevel: boolean | undefined, securityKey: string, softwareCode: string | undefined, clientId: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetRankedUsersWithActionByActivity?";
        if (rankColumn === undefined || rankColumn === null)
            throw new Error("The parameter 'rankColumn' must be defined and cannot be null.");
        else
            url_ += "RankColumn=" + encodeURIComponent("" + rankColumn) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (softwareCode === null)
            throw new Error("The parameter 'softwareCode' cannot be null.");
        else if (softwareCode !== undefined)
            url_ += "SoftwareCode=" + encodeURIComponent("" + softwareCode) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRankedUsersWithActionByActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRankedUsersWithActionByActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRankedUsersWithActionByActivity(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionInfoOutput>(<any>null);
    }

    /**
     * 获取我的中将信息,支持活动或游戏级别的
     * @param isGameLevel (optional) 
     * @param params (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyAwardsInActivity(isGameLevel: boolean | undefined, openId: string, snsType: _definitions_EnumSnsType, securityKey: string, params: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetMyAwardsInActivity?";
        if (isGameLevel === null)
            throw new Error("The parameter 'isGameLevel' cannot be null.");
        else if (isGameLevel !== undefined)
            url_ += "IsGameLevel=" + encodeURIComponent("" + isGameLevel) + "&";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAwardsInActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAwardsInActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserAwardOuput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyAwardsInActivity(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserAwardOuput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserAwardOuput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserAwardOuput>(<any>null);
    }

    /**
     * 判断当前用户的Action是否还可以中奖，以及Action的用户在当前活动的中奖历史
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    getAwardsByUserAndAction(openId: string, avatarUrl: string | undefined, actionId: number, score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<SnsUserAwardsSimpleOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetAwardsByUserAndAction?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (avatarUrl === null)
            throw new Error("The parameter 'avatarUrl' cannot be null.");
        else if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwardsByUserAndAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwardsByUserAndAction(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserAwardsSimpleOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserAwardsSimpleOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAwardsByUserAndAction(response: HttpResponseBase): Observable<SnsUserAwardsSimpleOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserAwardsSimpleOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserAwardsSimpleOutput>(<any>null);
    }

    /**
     * 用户确认中将
     * @param body (optional) 
     * @return Success
     */
    confirmUserAwardById(body: UserAwardDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ConfirmUserAwardById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUserAwardById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUserAwardById(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmUserAwardById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 清除用户互动数据以及中将相关的数据
     * @param body (optional) 
     * @return Success
     */
    clearActionAndAwardsByUser(body: ClearSnsUserDataInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/ClearActionAndAwardsByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearActionAndAwardsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearActionAndAwardsByUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processClearActionAndAwardsByUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param body (optional) 
     * @return Success
     */
    getWeChatLimitQrocdeTicket(token: string | undefined, body: GetLimitQrcodeByWechatInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDeviceActivity/GetWeChatLimitQrocdeTicket?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeChatLimitQrocdeTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeChatLimitQrocdeTicket(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeChatLimitQrocdeTicket(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingWechatManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param weixinAppID (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param tagIds (optional) 
     * @param showTagResult (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMedias(subKey: string | undefined, weixinAppID: string | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, tagIds: number[] | undefined, showTagResult: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetWechatMediaDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingWechatManage/GetWechatMedias?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (showTagResult === null)
            throw new Error("The parameter 'showTagResult' cannot be null.");
        else if (showTagResult !== undefined)
            url_ += "ShowTagResult=" + encodeURIComponent("" + showTagResult) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMedias(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMedias(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMediaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMediaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMediaDto>(<any>null);
    }

    /**
     * 获取微信token
     * @param weixinAppID (optional) 
     * @return Success
     */
    getWeixinAccessToken(weixinAppID: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingWechatManage/GetWeixinAccessToken?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinAccessToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinAccessToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SnsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeSnsUsers(body: MergeSnsUsersInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sns/MergeSnsUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeSnsUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeSnsUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeSnsUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SnsUserInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleSnsUserInfo(id: number | undefined): Observable<SnsUserInfoWithMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetSingleSnsUserInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSnsUserInfo(response: HttpResponseBase): Observable<SnsUserInfoWithMemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoWithMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoWithMemberDto>(<any>null);
    }

    /**
     * @param snsAppId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateSnsUserInfo(snsAppId: string | undefined, memberId: number | undefined, body: OAuthUserInfo | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/InsertOrUpdateSnsUserInfo?";
        if (snsAppId === null)
            throw new Error("The parameter 'snsAppId' cannot be null.");
        else if (snsAppId !== undefined)
            url_ += "snsAppId=" + encodeURIComponent("" + snsAppId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateSnsUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateSnsUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateSnsUserInfo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 读取微信商城用户信息
     * @param memberId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getUserInfo(memberId: number | undefined, tenantId: number | undefined): Observable<SnsUserInfoWithMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetUserInfo?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoWithMemberDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<SnsUserInfoWithMemberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoWithMemberDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoWithMemberDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param openId (optional) 
     * @return Success
     */
    getUserInfoByOpenId(tenantId: number | undefined, openId: string | undefined): Observable<SnsUserInfo> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/GetUserInfoByOpenId?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfoByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfoByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfoByOpenId(response: HttpResponseBase): Observable<SnsUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfo>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    isManager(memberId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SnsUserInfo/IsManager?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsManager(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsManager(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class SpecialUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param activityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(activityId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetUsers?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfSpecailUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSpecailUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: CreateSpecialUserInput | undefined): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateSpecialUserInput | undefined): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    deleteWhiteUser(activityId: number | undefined, ids: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/DeleteWhiteUser?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWhiteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWhiteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWhiteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWhiteInfoByUser(activityId: number, snsUserId: number): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetWhiteInfoByUser?";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (snsUserId === undefined || snsUserId === null)
            throw new Error("The parameter 'snsUserId' must be defined and cannot be null.");
        else
            url_ += "SnsUserId=" + encodeURIComponent("" + snsUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWhiteInfoByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWhiteInfoByUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWhiteInfoByUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getBlackInfoByUser(activityId: number, snsUserId: number): Observable<SpecailUserDto> {
        let url_ = this.baseUrl + "/api/services/app/SpecialUser/GetBlackInfoByUser?";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (snsUserId === undefined || snsUserId === null)
            throw new Error("The parameter 'snsUserId' must be defined and cannot be null.");
        else
            url_ += "SnsUserId=" + encodeURIComponent("" + snsUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlackInfoByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlackInfoByUser(<any>response_);
                } catch (e) {
                    return <Observable<SpecailUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpecailUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlackInfoByUser(response: HttpResponseBase): Observable<SpecailUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecailUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecailUserDto>(<any>null);
    }
}

@Injectable()
export class StoreActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStoreActivitiesById(storeId: number, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/GetStoreActivitiesById?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined and cannot be null.");
        else
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreActivitiesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreActivitiesById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreActivitiesById(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceActivityDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivityGamesByIdAndStoreId(deviceId: number, activityId: number, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityGameDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/GetActivityGamesByIdAndStoreId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined and cannot be null.");
        else
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityGamesByIdAndStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityGamesByIdAndStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityGameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityGamesByIdAndStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfActivityGameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfActivityGameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityGameDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStoreActivityGame(body: CreateDeviceActivityGameInput | undefined): Observable<StoreActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/CreateStoreActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<StoreActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStoreActivityGame(response: HttpResponseBase): Observable<StoreActivityGame> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreActivityGame>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStoreActivityGame(body: UpdateStoreActivityGameInput | undefined): Observable<StoreActivityGame> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/UpdateStoreActivityGame";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<StoreActivityGame>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreActivityGame>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStoreActivityGame(response: HttpResponseBase): Observable<StoreActivityGame> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreActivityGame.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreActivityGame>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStoreActivityGame(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreActivity/DeleteStoreActivityGame?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStoreActivityGame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStoreActivityGame(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStoreActivityGame(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取标签的列表，支持分页（无筛选条件）
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * 根据类型获取设备、品牌、店铺的标签
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: TagType | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * 新建设备、品牌、店铺标签
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * 修改设备、品牌、店铺的标签
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * 删除设备、品牌、店铺的标签
     * @param id (optional) 
     * @return Success
     */
    deleteTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查看前N个Tag（N为传入得参数,可能用于下拉列表）
     * @param count (optional) 
     * @return Success
     */
    tagTopForSelect(count: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/TagTopForSelect?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTagTopForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTagTopForSelect(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTagTopForSelect(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class TemplateMessageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param weixinAppID (optional) 
     * @param openId (optional) 
     * @param orderId (optional) 
     * @param type (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendTemplateMessage(tenantId: number | undefined, weixinAppID: string | undefined, openId: string | undefined, orderId: string | undefined, type: number | undefined, body: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TemplateMessage/SendTemplateMessage?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "weixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTemplateMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTemplateMessage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendTemplateMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTraining(body: CreateTrainingInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Training/CreateTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTraining(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTraining(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTraining(body: UpdateTrainingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/UpdateTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param trainingUserId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTrainings(id: number | undefined, auditStatus: AuditStatus | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, organizationUnitId: number | undefined, trainingCategory: TrainingCategoryEnum | undefined, trainingWay: TrainingWayEnum | undefined, trainingStatus: TrainingStatusEnum | undefined, trainingUserId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTrainingBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainings?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (trainingCategory === null)
            throw new Error("The parameter 'trainingCategory' cannot be null.");
        else if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&";
        if (trainingWay === null)
            throw new Error("The parameter 'trainingWay' cannot be null.");
        else if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&";
        if (trainingStatus === null)
            throw new Error("The parameter 'trainingStatus' cannot be null.");
        else if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&";
        if (trainingUserId === null)
            throw new Error("The parameter 'trainingUserId' cannot be null.");
        else if (trainingUserId !== undefined)
            url_ += "TrainingUserId=" + encodeURIComponent("" + trainingUserId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainings(response: HttpResponseBase): Observable<PagedResultDtoOfTrainingBasicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTrainingBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTrainingBasicDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMyTrainings(id: number | undefined, auditStatus: AuditStatus | undefined, startTime: moment.Moment | undefined, organizationUnitId: number | undefined, trainingCategory: TrainingCategoryEnum | undefined, trainingWay: TrainingWayEnum | undefined, trainingStatus: TrainingStatusEnum | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTrainingBasicDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetMyTrainings?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (trainingCategory === null)
            throw new Error("The parameter 'trainingCategory' cannot be null.");
        else if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&";
        if (trainingWay === null)
            throw new Error("The parameter 'trainingWay' cannot be null.");
        else if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&";
        if (trainingStatus === null)
            throw new Error("The parameter 'trainingStatus' cannot be null.");
        else if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyTrainings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingBasicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyTrainings(response: HttpResponseBase): Observable<PagedResultDtoOfTrainingBasicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTrainingBasicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTrainingBasicDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartmentForSelect(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetDepartmentForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentForSelect(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentForSelect(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTraining(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/DeleteTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteTraining(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/BatchDeleteTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trainingAudit(body: TrainingAuditInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/TrainingAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrainingAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrainingAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTrainingAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param startTime (optional) 
     * @param organizationUnitId (optional) 
     * @param trainingCategory (optional) 
     * @param trainingWay (optional) 
     * @param trainingStatus (optional) 
     * @param trainingUserId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTrainingsToExcel(id: number | undefined, auditStatus: AuditStatus | undefined, startTime: moment.Moment | undefined, organizationUnitId: number | undefined, trainingCategory: TrainingCategoryEnum | undefined, trainingWay: TrainingWayEnum | undefined, trainingStatus: TrainingStatusEnum | undefined, trainingUserId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainingsToExcel?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (trainingCategory === null)
            throw new Error("The parameter 'trainingCategory' cannot be null.");
        else if (trainingCategory !== undefined)
            url_ += "TrainingCategory=" + encodeURIComponent("" + trainingCategory) + "&";
        if (trainingWay === null)
            throw new Error("The parameter 'trainingWay' cannot be null.");
        else if (trainingWay !== undefined)
            url_ += "TrainingWay=" + encodeURIComponent("" + trainingWay) + "&";
        if (trainingStatus === null)
            throw new Error("The parameter 'trainingStatus' cannot be null.");
        else if (trainingStatus !== undefined)
            url_ += "TrainingStatus=" + encodeURIComponent("" + trainingStatus) + "&";
        if (trainingUserId === null)
            throw new Error("The parameter 'trainingUserId' cannot be null.");
        else if (trainingUserId !== undefined)
            url_ += "TrainingUserId=" + encodeURIComponent("" + trainingUserId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 设置标签
     * @param body (optional) 
     * @return Success
     */
    batchSetCourseTags(body: BatchSetCourseTagsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/BatchSetCourseTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchSetCourseTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchSetCourseTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchSetCourseTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autoGenerateTrainingByTag(body: AutoGenerateTrainingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/AutoGenerateTrainingByTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoGenerateTrainingByTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoGenerateTrainingByTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAutoGenerateTrainingByTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkTraining(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/CheckTraining";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getTrainingBasicInfo(openId: string | undefined, tenantId: number | undefined): Observable<TrainingSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetTrainingBasicInfo?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingBasicInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingBasicInfo(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingBasicInfo(response: HttpResponseBase): Observable<TrainingSimpleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSimpleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completeTraining(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/CompleteTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteTraining(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getSingleTraining4Wechat(id: number | undefined, tenantId: number | undefined): Observable<SingleTrainingInfo> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetSingleTraining4Wechat?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleTraining4Wechat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleTraining4Wechat(<any>response_);
                } catch (e) {
                    return <Observable<SingleTrainingInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleTrainingInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleTraining4Wechat(response: HttpResponseBase): Observable<SingleTrainingInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleTrainingInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleTrainingInfo>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @return Success
     */
    getUserPapers4Wechat(openId: string | undefined, paperId: number | undefined, trainingId: number | undefined): Observable<GetUserPapers4WechatDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetUserPapers4Wechat?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "paperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPapers4Wechat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPapers4Wechat(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPapers4WechatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPapers4WechatDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPapers4Wechat(response: HttpResponseBase): Observable<GetUserPapers4WechatDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPapers4WechatDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPapers4WechatDto>(<any>null);
    }
}

@Injectable()
export class TrainingListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToFile(body: TrainingBasicDto[] | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingListExcelExporter/ExportToFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param qrcodeId (optional) 
     * @return Success
     */
    qrcode(qrcodeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Qrcode?";
        if (qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' cannot be null.");
        else if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQrcode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processQrcode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param gameId (optional) 
     * @param isShared (optional) 
     * @param openid (optional) 
     * @param needAuth (optional) 
     * @param isPostData (optional) 
     * @param weChatAuthorizationType (optional) 
     * @param from (optional) 
     * @return Success
     */
    action(actionId: number | undefined, gameId: number | undefined, isShared: boolean | undefined, openid: string | undefined, needAuth: boolean | undefined, isPostData: boolean | undefined, weChatAuthorizationType: SnsActivityAuthorizationType | undefined, from: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Action?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (gameId === null)
            throw new Error("The parameter 'gameId' cannot be null.");
        else if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
        if (isShared === null)
            throw new Error("The parameter 'isShared' cannot be null.");
        else if (isShared !== undefined)
            url_ += "isShared=" + encodeURIComponent("" + isShared) + "&";
        if (openid === null)
            throw new Error("The parameter 'openid' cannot be null.");
        else if (openid !== undefined)
            url_ += "openid=" + encodeURIComponent("" + openid) + "&";
        if (needAuth === null)
            throw new Error("The parameter 'needAuth' cannot be null.");
        else if (needAuth !== undefined)
            url_ += "needAuth=" + encodeURIComponent("" + needAuth) + "&";
        if (isPostData === null)
            throw new Error("The parameter 'isPostData' cannot be null.");
        else if (isPostData !== undefined)
            url_ += "isPostData=" + encodeURIComponent("" + isPostData) + "&";
        if (weChatAuthorizationType === null)
            throw new Error("The parameter 'weChatAuthorizationType' cannot be null.");
        else if (weChatAuthorizationType !== undefined)
            url_ += "WeChatAuthorizationType=" + encodeURIComponent("" + weChatAuthorizationType) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param urlSource (optional) 
     * @param storeId (optional) 
     * @param deviceId (optional) 
     * @param memberId (optional) 
     * @param weixinAccountId (optional) 
     * @return Success
     */
    weishop(tenantId: number | undefined, urlSource: string | undefined, storeId: string | undefined, deviceId: number | undefined, memberId: number | undefined, weixinAccountId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Weishop?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (urlSource === null)
            throw new Error("The parameter 'urlSource' cannot be null.");
        else if (urlSource !== undefined)
            url_ += "urlSource=" + encodeURIComponent("" + urlSource) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "MemberId=" + encodeURIComponent("" + memberId) + "&";
        if (weixinAccountId === null)
            throw new Error("The parameter 'weixinAccountId' cannot be null.");
        else if (weixinAccountId !== undefined)
            url_ += "weixinAccountId=" + encodeURIComponent("" + weixinAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeishop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeishop(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWeishop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param weixinAccountId (optional) 
     * @param mediaIds (optional) 
     * @return Success
     */
    getWechatImg(tenantId: number | undefined, memberId: number | undefined, weixinAccountId: number | undefined, mediaIds: string[] | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/Transfer/GetWechatImg?";
        if (weixinAccountId === null)
            throw new Error("The parameter 'weixinAccountId' cannot be null.");
        else if (weixinAccountId !== undefined)
            url_ += "weixinAccountId=" + encodeURIComponent("" + weixinAccountId) + "&";
        if (mediaIds === null)
            throw new Error("The parameter 'mediaIds' cannot be null.");
        else if (mediaIds !== undefined)
            mediaIds && mediaIds.forEach(item => { url_ += "mediaIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "memberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatImg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatImg(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatImg(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    activity(): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/Activity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param securitykey (optional) 
     * @param callBack (optional) 
     * @return Success
     */
    weChatAuthorize(securitykey: string | undefined, callBack: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Transfer/WeChatAuthorize?";
        if (securitykey === null)
            throw new Error("The parameter 'securitykey' cannot be null.");
        else if (securitykey !== undefined)
            url_ += "securitykey=" + encodeURIComponent("" + securitykey) + "&";
        if (callBack === null)
            throw new Error("The parameter 'callBack' cannot be null.");
        else if (callBack !== undefined)
            url_ += "callBack=" + encodeURIComponent("" + callBack) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeChatAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeChatAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processWeChatAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserActionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param eventKey (optional) 
     * @return Success
     */
    getActionInfoGet(eventKey: string | undefined): Observable<ActionInfoDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfo?";
        if (eventKey === null)
            throw new Error("The parameter 'eventKey' cannot be null.");
        else if (eventKey !== undefined)
            url_ += "EventKey=" + encodeURIComponent("" + eventKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoGet(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoGet(response: HttpResponseBase): Observable<ActionInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoDto>(<any>null);
    }

    /**
     * @param eventKey (optional) 
     * @return Success
     */
    getActionInfoPost(eventKey: string | undefined): Observable<ActionInfoDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfo?";
        if (eventKey === null)
            throw new Error("The parameter 'eventKey' cannot be null.");
        else if (eventKey !== undefined)
            url_ += "EventKey=" + encodeURIComponent("" + eventKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoPost(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoPost(response: HttpResponseBase): Observable<ActionInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @param subKey (optional) 
     * @return Success
     */
    getCargoByActionIdInDevice(actionId: number | undefined, securityKey: string | undefined, subKey: string | undefined): Observable<CargoResultDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetCargoByActionIdInDevice?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoByActionIdInDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoByActionIdInDevice(<any>response_);
                } catch (e) {
                    return <Observable<CargoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoByActionIdInDevice(response: HttpResponseBase): Observable<CargoResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoResultDto>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    getActionInfoById(actionId: number | undefined, securityKey: string | undefined): Observable<ActionInfoForOrderDto> {
        let url_ = this.baseUrl + "/api/UserAction/GetActionInfoById?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "securityKey=" + encodeURIComponent("" + securityKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfoById(<any>response_);
                } catch (e) {
                    return <Observable<ActionInfoForOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionInfoForOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionInfoById(response: HttpResponseBase): Observable<ActionInfoForOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoForOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoForOrderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateActivityPayRecord(body: ActivityPayRecordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserAction/AddOrUpdateActivityPayRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateActivityPayRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateActivityPayRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateActivityPayRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param payOrder (optional) 
     * @return Success
     */
    getActivityPayRecordByPayOrder(payOrder: string | undefined): Observable<ActivityPayRecord> {
        let url_ = this.baseUrl + "/api/UserAction/GetActivityPayRecordByPayOrder?";
        if (payOrder === null)
            throw new Error("The parameter 'payOrder' cannot be null.");
        else if (payOrder !== undefined)
            url_ += "payOrder=" + encodeURIComponent("" + payOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityPayRecordByPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityPayRecordByPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<ActivityPayRecord>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityPayRecord>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityPayRecordByPayOrder(response: HttpResponseBase): Observable<ActivityPayRecord> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityPayRecord.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityPayRecord>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcode(score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcode?";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcode(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcode(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * 扫码传库存生成二维码接口
    DDD
     * @param gameId (optional) 
     * @param targetUrl (optional) 
     * @param tel (optional) 
     * @return Success
     */
    createActionInform(gameId: number | undefined, targetUrl: string | undefined, tel: string | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/CreateActionInform?";
        if (gameId === null)
            throw new Error("The parameter 'gameId' cannot be null.");
        else if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (tel === null)
            throw new Error("The parameter 'tel' cannot be null.");
        else if (tel !== undefined)
            url_ += "Tel=" + encodeURIComponent("" + tel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActionInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActionInform(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActionInform(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * 扫码确认后收集用户信息
     * @param openId (optional) 
     * @param gameId (optional) 
     * @return Success
     */
    snsConfirm(openId: string | undefined, gameId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/UserAction/SnsConfirm?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (gameId === null)
            throw new Error("The parameter 'gameId' cannot be null.");
        else if (gameId !== undefined)
            url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSnsConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSnsConfirm(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSnsConfirm(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 扫码确认后收集用户信息
     * @param gameID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSnsUserInform(gameID: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSnsUserQrcode> {
        let url_ = this.baseUrl + "/api/UserAction/GetSnsUserInform?";
        if (gameID === null)
            throw new Error("The parameter 'gameID' cannot be null.");
        else if (gameID !== undefined)
            url_ += "GameID=" + encodeURIComponent("" + gameID) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSnsUserInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSnsUserInform(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserQrcode>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserQrcode>><any>_observableThrow(response_);
        }));
    }

    protected processGetSnsUserInform(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserQrcode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserQrcode.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserQrcode>(<any>null);
    }

    /**
     * 扫码确认后收集用户信息
     * @param id (optional) 
     * @return Success
     */
    deleteSnsUserInform(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserAction/DeleteSnsUserInform?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSnsUserInform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSnsUserInform(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSnsUserInform(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeOnline(score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeOnline?";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeOnline(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeOnline(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeWithSeconds(score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeWithSeconds?";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeWithSeconds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeWithSeconds(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeWithSeconds(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerData4ActionQrcodeLimit(score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerData4ActionQrcodeLimit?";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerData4ActionQrcodeLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerData4ActionQrcodeLimit(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerData4ActionQrcodeLimit(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param weChatAuthorizationType (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerDataWithAuthorizationType4ActionQrcode(score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, weChatAuthorizationType: SnsActivityAuthorizationType | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<QrcodeActionOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerDataWithAuthorizationType4ActionQrcode?";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (weChatAuthorizationType === null)
            throw new Error("The parameter 'weChatAuthorizationType' cannot be null.");
        else if (weChatAuthorizationType !== undefined)
            url_ += "WeChatAuthorizationType=" + encodeURIComponent("" + weChatAuthorizationType) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerDataWithAuthorizationType4ActionQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerDataWithAuthorizationType4ActionQrcode(<any>response_);
                } catch (e) {
                    return <Observable<QrcodeActionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<QrcodeActionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerDataWithAuthorizationType4ActionQrcode(response: HttpResponseBase): Observable<QrcodeActionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrcodeActionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QrcodeActionOutput>(<any>null);
    }

    /**
     * @param extensionData (optional) 
     * @param securityKey (optional) 
     * @return Success
     */
    updateActionExtension(actionId: number, extensionData: string | undefined, securityKey: string | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/UpdateActionExtension?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (securityKey === null)
            throw new Error("The parameter 'securityKey' cannot be null.");
        else if (securityKey !== undefined)
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActionExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActionExtension(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateActionExtension(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * todo:need to actiondata for replacing all data.
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postPlayerDataByAction(actionId: number, score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostPlayerDataByAction?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerDataByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerDataByAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerDataByAction(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendCustomMessage(body: SendCustomMessageInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/SendCustomMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendCustomMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendCustomMessage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendCustomMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postDataByUser(openId: string, avatarUrl: string | undefined, actionId: number, score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostDataByUser?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (avatarUrl === null)
            throw new Error("The parameter 'avatarUrl' cannot be null.");
        else if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDataByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDataByUser(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostDataByUser(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param score (optional) 
     * @param type (optional) 
     * @param extensionData (optional) 
     * @param fromType (optional) 
     * @param snsUserInfoId (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param playerImage (optional) 
     * @param playingImage (optional) 
     * @return Success
     */
    postDataByUserForPoint(openId: string, avatarUrl: string | undefined, actionId: number, score: number | undefined, type: string | undefined, extensionData: string | undefined, fromType: string | undefined, snsUserInfoId: number | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, playerImage: FileParameter | undefined, playingImage: FileParameter | undefined): Observable<UserActionInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/PostDataByUserForPoint?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (avatarUrl === null)
            throw new Error("The parameter 'avatarUrl' cannot be null.");
        else if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (extensionData === null)
            throw new Error("The parameter 'extensionData' cannot be null.");
        else if (extensionData !== undefined)
            url_ += "ExtensionData=" + encodeURIComponent("" + extensionData) + "&";
        if (fromType === null)
            throw new Error("The parameter 'fromType' cannot be null.");
        else if (fromType !== undefined)
            url_ += "FromType=" + encodeURIComponent("" + fromType) + "&";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (playerImage === null || playerImage === undefined)
            throw new Error("The parameter 'playerImage' cannot be null.");
        else
            content_.append("PlayerImage", playerImage.data, playerImage.fileName ? playerImage.fileName : "PlayerImage");
        if (playingImage === null || playingImage === undefined)
            throw new Error("The parameter 'playingImage' cannot be null.");
        else
            content_.append("PlayingImage", playingImage.data, playingImage.fileName ? playingImage.fileName : "PlayingImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDataByUserForPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDataByUserForPoint(<any>response_);
                } catch (e) {
                    return <Observable<UserActionInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processPostDataByUserForPoint(response: HttpResponseBase): Observable<UserActionInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param phone (optional) 
     * @param name (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @param headerImage (optional) 
     * @return Success
     */
    registerFaceMemberWithForm(openId: string, avatarUrl: string | undefined, phone: string | undefined, name: string | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined, headerImage: FileParameter | undefined): Observable<SnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/RegisterFaceMemberWithForm?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (avatarUrl === null)
            throw new Error("The parameter 'avatarUrl' cannot be null.");
        else if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (headerImage === null || headerImage === undefined)
            throw new Error("The parameter 'headerImage' cannot be null.");
        else
            content_.append("HeaderImage", headerImage.data, headerImage.fileName ? headerImage.fileName : "HeaderImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceMemberWithForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceMemberWithForm(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceMemberWithForm(response: HttpResponseBase): Observable<SnsUserInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoOutput>(<any>null);
    }

    /**
     * @param avatarUrl (optional) 
     * @param faceUrl (optional) 
     * @param phone (optional) 
     * @param name (optional) 
     * @param isSendWeChatMsg (optional) 
     * @param targetUrl (optional) 
     * @param isTransferred (optional) 
     * @param params (optional) 
     * @return Success
     */
    registerFaceMember(openId: string, avatarUrl: string | undefined, faceUrl: string | undefined, phone: string | undefined, name: string | undefined, isSendWeChatMsg: boolean | undefined, qrType: EnumQRStatus, snsType: _definitions_EnumSnsType, targetUrl: string | undefined, isTransferred: boolean | undefined, securityKey: string, params: string | undefined): Observable<SnsUserInfoOutput> {
        let url_ = this.baseUrl + "/api/UserAction/RegisterFaceMember?";
        if (openId === undefined || openId === null)
            throw new Error("The parameter 'openId' must be defined and cannot be null.");
        else
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (avatarUrl === null)
            throw new Error("The parameter 'avatarUrl' cannot be null.");
        else if (avatarUrl !== undefined)
            url_ += "AvatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        if (faceUrl === null)
            throw new Error("The parameter 'faceUrl' cannot be null.");
        else if (faceUrl !== undefined)
            url_ += "FaceUrl=" + encodeURIComponent("" + faceUrl) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isSendWeChatMsg === null)
            throw new Error("The parameter 'isSendWeChatMsg' cannot be null.");
        else if (isSendWeChatMsg !== undefined)
            url_ += "IsSendWeChatMsg=" + encodeURIComponent("" + isSendWeChatMsg) + "&";
        if (qrType === undefined || qrType === null)
            throw new Error("The parameter 'qrType' must be defined and cannot be null.");
        else
            url_ += "QrType=" + encodeURIComponent("" + qrType) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (targetUrl === null)
            throw new Error("The parameter 'targetUrl' cannot be null.");
        else if (targetUrl !== undefined)
            url_ += "TargetUrl=" + encodeURIComponent("" + targetUrl) + "&";
        if (isTransferred === null)
            throw new Error("The parameter 'isTransferred' cannot be null.");
        else if (isTransferred !== undefined)
            url_ += "IsTransferred=" + encodeURIComponent("" + isTransferred) + "&";
        if (securityKey === undefined || securityKey === null)
            throw new Error("The parameter 'securityKey' must be defined and cannot be null.");
        else
            url_ += "SecurityKey=" + encodeURIComponent("" + securityKey) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterFaceMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFaceMember(<any>response_);
                } catch (e) {
                    return <Observable<SnsUserInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SnsUserInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterFaceMember(response: HttpResponseBase): Observable<SnsUserInfoOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SnsUserInfoOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SnsUserInfoOutput>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    actionDataById(actionId: number | undefined): Observable<UserActionDataOutput> {
        let url_ = this.baseUrl + "/api/UserAction/ActionDataById?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActionDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActionDataById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processActionDataById(response: HttpResponseBase): Observable<UserActionDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDataOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGameImageBase64(body: GetGameImageBase64Input | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/UserAction/GetGameImageBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGameImageBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGameImageBase64(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetGameImageBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param neededData (optional) 
     * @return Success
     */
    queryNeededActionDataById(actionId: number | undefined, neededData: string[] | undefined): Observable<UserActionDataOutput> {
        let url_ = this.baseUrl + "/api/UserAction/QueryNeededActionDataById?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (neededData === null)
            throw new Error("The parameter 'neededData' cannot be null.");
        else if (neededData !== undefined)
            neededData && neededData.forEach(item => { url_ += "neededData=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryNeededActionDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryNeededActionDataById(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processQueryNeededActionDataById(response: HttpResponseBase): Observable<UserActionDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDataOutput>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param openId (optional) 
     * @return Success
     */
    likeAction(actionId: number | undefined, openId: string | undefined, snsType: _definitions_EnumSnsType): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/LikeAction?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "snsType=" + encodeURIComponent("" + snsType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLikeAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLikeAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processLikeAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @return Success
     */
    shareAction(actionId: number, openId: string | undefined, snsType: _definitions_EnumSnsType, shareType: EnumWeixinShareType): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/ShareAction?";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined and cannot be null.");
        else
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (shareType === undefined || shareType === null)
            throw new Error("The parameter 'shareType' must be defined and cannot be null.");
        else
            url_ += "ShareType=" + encodeURIComponent("" + shareType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShareAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShareAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processShareAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @param openId (optional) 
     * @return Success
     */
    viewAction(actionId: number | undefined, openId: string | undefined, snsType: _definitions_EnumSnsType): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserAction/ViewAction?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (snsType === undefined || snsType === null)
            throw new Error("The parameter 'snsType' must be defined and cannot be null.");
        else
            url_ += "snsType=" + encodeURIComponent("" + snsType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewAction(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processViewAction(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSnsAndAction(body: AddSnsAndActionInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/UserAction/AddSnsAndAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSnsAndAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSnsAndAction(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddSnsAndAction(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) UserAction => SnsUserInfo => EnumSnsType
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserActions(snsUserInfoId: number | undefined, activityId: number | undefined, softwareId: number | undefined, deviceId: number | undefined, activityGameId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, snsType: _definitions_EnumSnsType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUserActions?";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (snsType === null)
            throw new Error("The parameter 'snsType' cannot be null.");
        else if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActions(response: HttpResponseBase): Observable<PagedResultDtoOfUserActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserActionDto>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) UserAction => SnsUserInfo => EnumSnsType
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserActionsToExcel(snsUserInfoId: number | undefined, activityId: number | undefined, softwareId: number | undefined, deviceId: number | undefined, activityGameId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, snsType: _definitions_EnumSnsType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUserActionsToExcel?";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (snsType === null)
            throw new Error("The parameter 'snsType' cannot be null.");
        else if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserActionsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserAction(body: CreateUserActionInput | undefined): Observable<UserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/CreateUserAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserAction(response: HttpResponseBase): Observable<UserActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserAction(body: UpdateUserActionInput | undefined): Observable<UserActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/UpdateUserAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserAction(<any>response_);
                } catch (e) {
                    return <Observable<UserActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserAction(response: HttpResponseBase): Observable<UserActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserActionDto>(<any>null);
    }

    /**
     * @param snsUserInfoId (optional) 
     * @param activityId (optional) 
     * @param softwareId (optional) 
     * @param deviceId (optional) 
     * @param activityGameId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param snsType (optional) UserAction => SnsUserInfo => EnumSnsType
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsersAndActionsSum(snsUserInfoId: number | undefined, activityId: number | undefined, softwareId: number | undefined, deviceId: number | undefined, activityGameId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, snsType: _definitions_EnumSnsType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSnsUserActionSumDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetUsersAndActionsSum?";
        if (snsUserInfoId === null)
            throw new Error("The parameter 'snsUserInfoId' cannot be null.");
        else if (snsUserInfoId !== undefined)
            url_ += "SnsUserInfoId=" + encodeURIComponent("" + snsUserInfoId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activityGameId === null)
            throw new Error("The parameter 'activityGameId' cannot be null.");
        else if (activityGameId !== undefined)
            url_ += "ActivityGameId=" + encodeURIComponent("" + activityGameId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (snsType === null)
            throw new Error("The parameter 'snsType' cannot be null.");
        else if (snsType !== undefined)
            url_ += "SnsType=" + encodeURIComponent("" + snsType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersAndActionsSum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersAndActionsSum(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSnsUserActionSumDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSnsUserActionSumDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersAndActionsSum(response: HttpResponseBase): Observable<PagedResultDtoOfSnsUserActionSumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSnsUserActionSumDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSnsUserActionSumDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    makeUserToSpecial(body: MakeUserToSpecialInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/MakeUserToSpecial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeUserToSpecial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeUserToSpecial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeUserToSpecial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteUserAction(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/DeleteUserAction?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserAction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param actionId (optional) 
     * @return Success
     */
    getMemberInfoByActionId(actionId: number | undefined): Observable<SimpleMemberInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAction/GetMemberInfoByActionId?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfoByActionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfoByActionId(<any>response_);
                } catch (e) {
                    return <Observable<SimpleMemberInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleMemberInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfoByActionId(response: HttpResponseBase): Observable<SimpleMemberInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleMemberInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleMemberInfoDto>(<any>null);
    }
}

@Injectable()
export class UserPaperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param paperId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserPapers(startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, paperId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetUserPaperDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPapers?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPapers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPapers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserPaperDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserPaperDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPapers(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserPaperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserPaperDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserPaperDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReport(paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerReport?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerReportDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperOpinionReport(paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPaperOpinionReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperOpinionReport?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperOpinionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperOpinionReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperOpinionReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperOpinionReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperOpinionReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperOpinionReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperOpinionReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperOpinionReportDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerCompetitionReport(paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerCompetitionReport?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerCompetitionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerCompetitionReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerCompetitionReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerCompetitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerCompetitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerCompetitionDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerInvestigateReport(paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerInvestigateReport?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerInvestigateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerInvestigateReport(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerInvestigateReport(response: HttpResponseBase): Observable<PagedResultDtoOfGetPaperAnswerInvestigateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPaperAnswerInvestigateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPaperAnswerInvestigateDto>(<any>null);
    }

    /**
     * @param paperId (optional) 
     * @param trainingId (optional) 
     * @param userId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaperAnswerReportToExcel(paperId: number | undefined, trainingId: number | undefined, userId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetPaperAnswerReportToExcel?";
        if (paperId === null)
            throw new Error("The parameter 'paperId' cannot be null.");
        else if (paperId !== undefined)
            url_ += "PaperId=" + encodeURIComponent("" + paperId) + "&";
        if (trainingId === null)
            throw new Error("The parameter 'trainingId' cannot be null.");
        else if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaperAnswerReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaperAnswerReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaperAnswerReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取单个用户问卷的详细
     * @param id (optional) 
     * @return Success
     */
    getSingleUserPaperDetail(id: number | undefined): Observable<SingleUserPaperDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetSingleUserPaperDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleUserPaperDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleUserPaperDetail(<any>response_);
                } catch (e) {
                    return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleUserPaperDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleUserPaperDetail(response: HttpResponseBase): Observable<SingleUserPaperDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserPaperDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleUserPaperDetailDto>(<any>null);
    }

    /**
     * 查詢UserPaper导出报表
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserPaperQuestionRep(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<UserPaperRep[]> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPaperQuestionRep?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaperQuestionRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaperQuestionRep(<any>response_);
                } catch (e) {
                    return <Observable<UserPaperRep[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPaperRep[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaperQuestionRep(response: HttpResponseBase): Observable<UserPaperRep[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPaperRep.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPaperRep[]>(<any>null);
    }

    /**
     * 精美导出UserPaperExcel
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserPaperListToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserPaper/GetUserPaperListToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPaperListToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPaperListToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPaperListToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WechatManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMenus(weixinAppID: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetWechatMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMenus?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMenus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMenus(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMenuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMenuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMenuDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatConditionalMenus(weixinAppID: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetWechatMenuDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatConditionalMenus?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatConditionalMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatConditionalMenus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMenuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatConditionalMenus(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMenuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMenuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMenuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWechatMenuDetail(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMenuDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMenuDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMenuDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMenuDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWechatConditionalMenuDetail(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatConditionalMenuDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatConditionalMenuDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatConditionalMenuDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatConditionalMenuDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWechatMenu(body: AddOrUpdateMenuInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateWechatMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWechatConditionalMenu(body: AddOrUpdateConditionalMenuInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateWechatConditionalMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWechatConditionalMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWechatConditionalMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWechatConditionalMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    activeWechatMenu(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ActiveWechatMenu?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processActiveWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    activeConditionalWechatMenu(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ActiveConditionalWechatMenu?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveConditionalWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveConditionalWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processActiveConditionalWechatMenu(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteWechatMenu(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteWechatMenu?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWechatMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteConditionalWechatMenu(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteConditionalWechatMenu?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteConditionalWechatMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteConditionalWechatMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteConditionalWechatMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param tagIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatMedias(weixinAppID: string, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, tagIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetWechatMediaDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatMedias?";
        if (weixinAppID === undefined || weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' must be defined and cannot be null.");
        else
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatMedias(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatMediaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatMedias(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatMediaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatMediaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatMediaDto>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWechatTemplateMessages(weixinAppID: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetWechatTemplateMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatTemplateMessages?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatTemplateMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatTemplateMessages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWechatTemplateMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWechatTemplateMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatTemplateMessages(response: HttpResponseBase): Observable<PagedResultDtoOfGetWechatTemplateMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWechatTemplateMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWechatTemplateMessageDto>(<any>null);
    }

    /**
     * 在公众号平台同步微信模板消息
     * @param weixinAppID (optional) 
     * @return Success
     */
    syncWechatTemplateMessages(weixinAppID: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SyncWechatTemplateMessages?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncWechatTemplateMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncWechatTemplateMessages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncWechatTemplateMessages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @param initial (optional) 
     * @return Success
     */
    syncMedias(weixinAppID: string | undefined, initial: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SyncMedias?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        if (initial === null)
            throw new Error("The parameter 'initial' cannot be null.");
        else if (initial !== undefined)
            url_ += "initial=" + encodeURIComponent("" + initial) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncMedias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncMedias(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSyncMedias(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setMediaTags(body: SetMediaTagsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SetMediaTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMediaTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMediaTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetMediaTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMessageSeeds(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetMessageSeedDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetMessageSeeds?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMessageSeedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMessageSeedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessageSeeds(response: HttpResponseBase): Observable<PagedResultDtoOfGetMessageSeedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMessageSeedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMessageSeedDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateMessageSeed(body: AddOrUpdateMessageSeedInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/AddOrUpdateMessageSeed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateMessageSeed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateMessageSeed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateMessageSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param weixinAppID (optional) 
     * @return Success
     */
    applyMessageSeeds(weixinAppID: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/ApplyMessageSeeds?";
        if (weixinAppID === null)
            throw new Error("The parameter 'weixinAppID' cannot be null.");
        else if (weixinAppID !== undefined)
            url_ += "WeixinAppID=" + encodeURIComponent("" + weixinAppID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApplyMessageSeeds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    setWechatNotifier(memberId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/SetWechatNotifier?";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWechatNotifier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWechatNotifier(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetWechatNotifier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWechatNotifier(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/GetWechatNotifier";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatNotifier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatNotifier(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatNotifier(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMessageSeeds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatManage/DeleteMessageSeeds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMessageSeeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMessageSeeds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMessageSeeds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeiboServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    callBack(code: string | undefined, state: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weibo/CallBack?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param mediaId (optional) 
     * @param activityId (optional) 
     * @return Success
     */
    getMedia(mediaId: string | undefined, activityId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/GetMedia?";
        if (mediaId === null)
            throw new Error("The parameter 'mediaId' cannot be null.");
        else if (mediaId !== undefined)
            url_ += "mediaId=" + encodeURIComponent("" + mediaId) + "&";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedia(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedia(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 中奖成功 发送中奖消息
     * @param userAwardId (optional) 
     * @return Success
     */
    awardMessageNotify(userAwardId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/AwardMessageNotify?";
        if (userAwardId === null)
            throw new Error("The parameter 'userAwardId' cannot be null.");
        else if (userAwardId !== undefined)
            url_ += "userAwardId=" + encodeURIComponent("" + userAwardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardMessageNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardMessageNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAwardMessageNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 签到成功推送模板消息
     * @param actionId (optional) 
     * @param fisrt (optional) 
     * @param remark (optional) 
     * @return Success
     */
    signInTemplateMessageNotify(actionId: number | undefined, fisrt: string | undefined, remark: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Weixin/SignInTemplateMessageNotify?";
        if (actionId === null)
            throw new Error("The parameter 'actionId' cannot be null.");
        else if (actionId !== undefined)
            url_ += "actionId=" + encodeURIComponent("" + actionId) + "&";
        if (fisrt === null)
            throw new Error("The parameter 'fisrt' cannot be null.");
        else if (fisrt !== undefined)
            url_ += "fisrt=" + encodeURIComponent("" + fisrt) + "&";
        if (remark === null)
            throw new Error("The parameter 'remark' cannot be null.");
        else if (remark !== undefined)
            url_ += "remark=" + encodeURIComponent("" + remark) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignInTemplateMessageNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignInTemplateMessageNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignInTemplateMessageNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinJSSDKServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param appid (optional) 
     * @param openId (optional) 
     * @return Success
     */
    index(appid: string | undefined, openId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinJSSDK/Index?";
        if (appid === null)
            throw new Error("The parameter 'appid' cannot be null.");
        else if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param appid (optional) 
     * @param openId (optional) 
     * @param url (optional) 
     * @return Success
     */
    getWeChatJsViewModel(tenantId: number | undefined, appid: string | undefined, openId: string | undefined, url: string | undefined): Observable<WeChatJSViewModel> {
        let url_ = this.baseUrl + "/WeixinJSSDK/GetWeChatJsViewModel?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (appid === null)
            throw new Error("The parameter 'appid' cannot be null.");
        else if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeChatJsViewModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeChatJsViewModel(<any>response_);
                } catch (e) {
                    return <Observable<WeChatJSViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatJSViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeChatJsViewModel(response: HttpResponseBase): Observable<WeChatJSViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeChatJSViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatJSViewModel>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param url (optional) 
     * @param weixinAppId (optional) 
     * @return Success
     */
    getWeishopJsViewModel(tenantId: number | undefined, memberId: number | undefined, url: string | undefined, weixinAppId: number | undefined): Observable<WeChatJSViewModel> {
        let url_ = this.baseUrl + "/WeixinJSSDK/GetWeishopJsViewModel?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (memberId === null)
            throw new Error("The parameter 'memberId' cannot be null.");
        else if (memberId !== undefined)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        if (weixinAppId === null)
            throw new Error("The parameter 'weixinAppId' cannot be null.");
        else if (weixinAppId !== undefined)
            url_ += "weixinAppId=" + encodeURIComponent("" + weixinAppId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopJsViewModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopJsViewModel(<any>response_);
                } catch (e) {
                    return <Observable<WeChatJSViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatJSViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopJsViewModel(response: HttpResponseBase): Observable<WeChatJSViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeChatJSViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatJSViewModel>(<any>null);
    }
}

@Injectable()
export class WeixinMpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWeixinMps(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfWeixinMpDto> {
        let url_ = this.baseUrl + "/api/services/app/WeixinMp/GetWeixinMps?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinMps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinMps(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWeixinMpDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWeixinMpDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinMps(response: HttpResponseBase): Observable<PagedResultDtoOfWeixinMpDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWeixinMpDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWeixinMpDto>(<any>null);
    }

    /**
     * @param weixinOpenPlatformId (optional) 
     * @return Success
     */
    getMpAuthorzieUrl(weixinOpenPlatformId: number | undefined): Observable<MpAuthorzieUrlDto> {
        let url_ = this.baseUrl + "/api/services/app/WeixinMp/GetMpAuthorzieUrl?";
        if (weixinOpenPlatformId === null)
            throw new Error("The parameter 'weixinOpenPlatformId' cannot be null.");
        else if (weixinOpenPlatformId !== undefined)
            url_ += "weixinOpenPlatformId=" + encodeURIComponent("" + weixinOpenPlatformId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMpAuthorzieUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMpAuthorzieUrl(<any>response_);
                } catch (e) {
                    return <Observable<MpAuthorzieUrlDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MpAuthorzieUrlDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMpAuthorzieUrl(response: HttpResponseBase): Observable<MpAuthorzieUrlDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MpAuthorzieUrlDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MpAuthorzieUrlDto>(<any>null);
    }
}

@Injectable()
export class WeixinOAuth2ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userActionId (optional) 
     * @param returnUrl (optional) 用户尝试进入的需要登录的页面
     * @return Success
     */
    index(userActionId: number | undefined, returnUrl: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/Index?";
        if (userActionId === null)
            throw new Error("The parameter 'userActionId' cannot be null.");
        else if (userActionId !== undefined)
            url_ += "userActionId=" + encodeURIComponent("" + userActionId) + "&";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * OAuthScope.snsapi_userinfo方式回调
     * @param code (optional) 
     * @param state (optional) 
     * @param returnUrl (optional) 用户最初尝试进入的页面
     * @return Success
     */
    userInfoCallback(code: string | undefined, state: string | undefined, returnUrl: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/UserInfoCallback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInfoCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInfoCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserInfoCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * OAuthScope.snsapi_base方式回调
     * @param code (optional) 
     * @param state (optional) 
     * @param returnUrl (optional) 用户最初尝试进入的页面
     * @return Success
     */
    baseCallback(code: string | undefined, state: string | undefined, returnUrl: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/BaseCallback?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaseCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaseCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBaseCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    callBackTest(): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/CallBackTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBackTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBackTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBackTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @param appid (optional) 
     * @return Success
     */
    callBack(code: string | undefined, state: string | undefined, appid: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/CallBack?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (appid === null)
            throw new Error("The parameter 'appid' cannot be null.");
        else if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 小程序或者微信登录
     * @param code (optional) 
     * @param state (optional) 
     * @param appid (optional) 
     * @param from (optional) 
     * @return Success
     */
    getLoginResult(code: string | undefined, state: string | undefined, appid: string | undefined, from: string | undefined): Observable<WechatLoginResultDto> {
        let url_ = this.baseUrl + "/WeixinOAuth2/GetLoginResult?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (appid === null)
            throw new Error("The parameter 'appid' cannot be null.");
        else if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginResult(<any>response_);
                } catch (e) {
                    return <Observable<WechatLoginResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WechatLoginResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginResult(response: HttpResponseBase): Observable<WechatLoginResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WechatLoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WechatLoginResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getWechatLoginUrl(): Observable<string> {
        let url_ = this.baseUrl + "/WeixinOAuth2/GetWechatLoginUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatLoginUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatLoginUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatLoginUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 测试ReturnUrl
     * @return Success
     */
    testReturnUrl(): Observable<void> {
        let url_ = this.baseUrl + "/WeixinOAuth2/TestReturnUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestReturnUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestReturnUrl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestReturnUrl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeixinOpenPlatformServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取下拉框显示的淘宝 appid
     * @return Success
     */
    getWeixinOpenPlatformList(): Observable<WeixinOpenPlatformDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeixinOpenPlatform/GetWeixinOpenPlatformList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeixinOpenPlatformList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeixinOpenPlatformList(<any>response_);
                } catch (e) {
                    return <Observable<WeixinOpenPlatformDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeixinOpenPlatformDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeixinOpenPlatformList(response: HttpResponseBase): Observable<WeixinOpenPlatformDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeixinOpenPlatformDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeixinOpenPlatformDto[]>(<any>null);
    }
}

@Injectable()
export class WexinOpenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ACTIVITY_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    host(): Observable<void> {
        let url_ = this.baseUrl + "/api/WexinOpen/Host";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 绑定公众号的回掉函数
     * @param state (optional) 
     * @param auth_code (optional) 
     * @param expires_in (optional) 
     * @return Success
     */
    callBack(state: string | undefined, auth_code: string | undefined, expires_in: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WexinOpen/CallBack?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (auth_code === null)
            throw new Error("The parameter 'auth_code' cannot be null.");
        else if (auth_code !== undefined)
            url_ += "auth_code=" + encodeURIComponent("" + auth_code) + "&";
        if (expires_in === null)
            throw new Error("The parameter 'expires_in' cannot be null.");
        else if (expires_in !== undefined)
            url_ += "expires_in=" + encodeURIComponent("" + expires_in) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 公众号授权事件接收
     * @param signature (optional) 
     * @param timestamp (optional) 
     * @param nonce (optional) 
     * @param encrypt_type (optional) 
     * @param msg_signature (optional) 
     * @return Success
     */
    sysMessage(signature: string | undefined, timestamp: string | undefined, nonce: string | undefined, encrypt_type: string | undefined, msg_signature: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WexinOpen/SysMessage?";
        if (signature === null)
            throw new Error("The parameter 'signature' cannot be null.");
        else if (signature !== undefined)
            url_ += "signature=" + encodeURIComponent("" + signature) + "&";
        if (timestamp === null)
            throw new Error("The parameter 'timestamp' cannot be null.");
        else if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent("" + timestamp) + "&";
        if (nonce === null)
            throw new Error("The parameter 'nonce' cannot be null.");
        else if (nonce !== undefined)
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        if (encrypt_type === null)
            throw new Error("The parameter 'encrypt_type' cannot be null.");
        else if (encrypt_type !== undefined)
            url_ += "encrypt_type=" + encodeURIComponent("" + encrypt_type) + "&";
        if (msg_signature === null)
            throw new Error("The parameter 'msg_signature' cannot be null.");
        else if (msg_signature !== undefined)
            url_ += "msg_signature=" + encodeURIComponent("" + msg_signature) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMessage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSysMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 代替公众号接受事件,用最终用户的交互
     * @param domainId (optional) 
     * @param appId (optional) 
     * @param signature (optional) 
     * @param msg_Signature (optional) 
     * @param timestamp (optional) 
     * @param nonce (optional) 
     * @param token (optional) 
     * @param encodingAESKey (optional) 
     * @return Success
     */
    eventMsg(id: string, domainId: string | undefined, appId: string | undefined, signature: string | undefined, msg_Signature: string | undefined, timestamp: string | undefined, nonce: string | undefined, token: string | undefined, encodingAESKey: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WexinOpen/EventMsg/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (domainId === null)
            throw new Error("The parameter 'domainId' cannot be null.");
        else if (domainId !== undefined)
            url_ += "DomainId=" + encodeURIComponent("" + domainId) + "&";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "AppId=" + encodeURIComponent("" + appId) + "&";
        if (signature === null)
            throw new Error("The parameter 'signature' cannot be null.");
        else if (signature !== undefined)
            url_ += "Signature=" + encodeURIComponent("" + signature) + "&";
        if (msg_Signature === null)
            throw new Error("The parameter 'msg_Signature' cannot be null.");
        else if (msg_Signature !== undefined)
            url_ += "Msg_Signature=" + encodeURIComponent("" + msg_Signature) + "&";
        if (timestamp === null)
            throw new Error("The parameter 'timestamp' cannot be null.");
        else if (timestamp !== undefined)
            url_ += "Timestamp=" + encodeURIComponent("" + timestamp) + "&";
        if (nonce === null)
            throw new Error("The parameter 'nonce' cannot be null.");
        else if (nonce !== undefined)
            url_ += "Nonce=" + encodeURIComponent("" + nonce) + "&";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "Token=" + encodeURIComponent("" + token) + "&";
        if (encodingAESKey === null)
            throw new Error("The parameter 'encodingAESKey' cannot be null.");
        else if (encodingAESKey !== undefined)
            url_ += "EncodingAESKey=" + encodeURIComponent("" + encodingAESKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventMsg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventMsg(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEventMsg(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    jscode2Session(code: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/WexinOpen/Jscode2Session?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJscode2Session(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJscode2Session(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processJscode2Session(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    refreshToken(): Observable<void> {
        let url_ = this.baseUrl + "/api/WexinOpen/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export enum _definitions_EnumSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    AliPay = "AliPay",
    AliPay_WeChat = "AliPay_WeChat",
    Douyin = "Douyin",
    Weibo = "Weibo",
    Others = "Others",
}

export class ActionInfo implements IActionInfo {
    scene!: Scene;

    constructor(data?: IActionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scene = _data["scene"] ? Scene.fromJS(_data["scene"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scene"] = this.scene ? this.scene.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionInfo {
    scene: Scene;
}

export class ActionInfoDto implements IActionInfoDto {
    storeOuterId!: string | undefined;
    extensionData!: string | undefined;
    expiredTime!: moment.Moment | undefined;

    constructor(data?: IActionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeOuterId = _data["storeOuterId"];
            this.extensionData = _data["extensionData"];
            this.expiredTime = _data["expiredTime"] ? moment(_data["expiredTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOuterId"] = this.storeOuterId;
        data["extensionData"] = this.extensionData;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IActionInfoDto {
    storeOuterId: string | undefined;
    extensionData: string | undefined;
    expiredTime: moment.Moment | undefined;
}

export class ActionInfoForOrderDto implements IActionInfoForOrderDto {
    tenantId!: number;
    subKey!: string | undefined;
    activity!: ActivityForOrder;
    snsUserInfo!: SnsUserInfoForOrder;

    constructor(data?: IActionInfoForOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.subKey = _data["subKey"];
            this.activity = _data["activity"] ? ActivityForOrder.fromJS(_data["activity"]) : <any>undefined;
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoForOrder.fromJS(_data["snsUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionInfoForOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfoForOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["subKey"] = this.subKey;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionInfoForOrderDto {
    tenantId: number;
    subKey: string | undefined;
    activity: ActivityForOrder;
    snsUserInfo: SnsUserInfoForOrder;
}

export class ActionShareDto implements IActionShareDto {
    id!: number | undefined;
    title!: string | undefined;
    /** 分享链接 */
    link!: string | undefined;
    /** 分享图标 */
    imageLink!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;

    constructor(data?: IActionShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
        }
    }

    static fromJS(data: any): ActionShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActionShareDto {
    id: number | undefined;
    title: string | undefined;
    /** 分享链接 */
    link: string | undefined;
    /** 分享图标 */
    imageLink: string | undefined;
    /** 描述 */
    description: string | undefined;
    activityShareType: EnumActivityShareType;
}

export enum ActionStatus {
    Start = "Start",
    Waitting = "Waitting",
    Playing = "Playing",
    Done = "Done",
    AwardEdit = "AwardEdit",
    NotGetPrizeWithNoAward = "NotGetPrizeWithNoAward",
    NotGetPrize = "NotGetPrize",
}

export class Activity implements IActivity {
    tenantId!: number;
    isAwardType!: boolean;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    isSendAwardMessage!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage;
    awardMessageId!: number | undefined;
    awardMessage!: SnsMessage;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    viewCount!: number;
    likeCount!: number;
    weixinShares!: SnsShare[] | undefined;
    awards!: Award[] | undefined;
    activityShareId!: number | undefined;
    activityShare!: ActivityShare;
    weixinPublicAccountInfoId!: number;
    weChatAppID!: string | undefined;
    externalAccessTokenInfoId!: number;
    taobaoSellerID!: string | undefined;
    alipayApplicationId!: number;
    alipayAppID!: string | undefined;
    douyinApplicationId!: number;
    douyinAppID!: string | undefined;
    weiboApplicationId!: number;
    weiboAppID!: string | undefined;
    isEnableWhiteUser!: boolean;
    isEnableBlackUser!: boolean;
    organizer!: string | undefined;
    isAllowedRepeatAward!: boolean;
    repeatAwardFrequency!: FrequencyType;
    repeatAwardDurations!: number | undefined;
    repeatAwardTimes!: number | undefined;
    isAllowedShareGetLotteryTimes!: boolean;
    shareDurations!: number | undefined;
    shareLotteryTimes!: number | undefined;
    isNeedAwardInfo!: boolean;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean;
    iconPath!: string | undefined;
    description!: string | undefined;
    activityFlows!: ActivityFlow[] | undefined;
    isNeedRegister!: boolean;
    isNeedValidate!: boolean;
    ownerName!: string | undefined;
    isPublic!: boolean;
    contactor!: string | undefined;
    outerId!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: AuditStatus;
    games!: ActivityGame[] | undefined;
    type!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.isAwardType = _data["isAwardType"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.address = _data["address"];
            this.activityUrl = _data["activityUrl"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.isSendAwardMessage = _data["isSendAwardMessage"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMessage.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMessage.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.awardMessageId = _data["awardMessageId"];
            this.awardMessage = _data["awardMessage"] ? SnsMessage.fromJS(_data["awardMessage"]) : <any>undefined;
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            if (Array.isArray(_data["weixinShares"])) {
                this.weixinShares = [] as any;
                for (let item of _data["weixinShares"])
                    this.weixinShares!.push(SnsShare.fromJS(item));
            }
            if (Array.isArray(_data["awards"])) {
                this.awards = [] as any;
                for (let item of _data["awards"])
                    this.awards!.push(Award.fromJS(item));
            }
            this.activityShareId = _data["activityShareId"];
            this.activityShare = _data["activityShare"] ? ActivityShare.fromJS(_data["activityShare"]) : <any>undefined;
            this.weixinPublicAccountInfoId = _data["weixinPublicAccountInfoId"];
            this.weChatAppID = _data["weChatAppID"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.alipayApplicationId = _data["alipayApplicationId"];
            this.alipayAppID = _data["alipayAppID"];
            this.douyinApplicationId = _data["douyinApplicationId"];
            this.douyinAppID = _data["douyinAppID"];
            this.weiboApplicationId = _data["weiboApplicationId"];
            this.weiboAppID = _data["weiboAppID"];
            this.isEnableWhiteUser = _data["isEnableWhiteUser"];
            this.isEnableBlackUser = _data["isEnableBlackUser"];
            this.organizer = _data["organizer"];
            this.isAllowedRepeatAward = _data["isAllowedRepeatAward"];
            this.repeatAwardFrequency = _data["repeatAwardFrequency"];
            this.repeatAwardDurations = _data["repeatAwardDurations"];
            this.repeatAwardTimes = _data["repeatAwardTimes"];
            this.isAllowedShareGetLotteryTimes = _data["isAllowedShareGetLotteryTimes"];
            this.shareDurations = _data["shareDurations"];
            this.shareLotteryTimes = _data["shareLotteryTimes"];
            this.isNeedAwardInfo = _data["isNeedAwardInfo"];
            this.rules = _data["rules"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = _data["isTemplate"];
            this.iconPath = _data["iconPath"];
            this.description = _data["description"];
            if (Array.isArray(_data["activityFlows"])) {
                this.activityFlows = [] as any;
                for (let item of _data["activityFlows"])
                    this.activityFlows!.push(ActivityFlow.fromJS(item));
            }
            this.isNeedRegister = _data["isNeedRegister"];
            this.isNeedValidate = _data["isNeedValidate"];
            this.ownerName = _data["ownerName"];
            this.isPublic = _data["isPublic"];
            this.contactor = _data["contactor"];
            this.outerId = _data["outerId"];
            this.contactorPhone = _data["contactorPhone"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(ActivityGame.fromJS(item));
            }
            this.type = _data["type"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isAwardType"] = this.isAwardType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["isSendAwardMessage"] = this.isSendAwardMessage;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["awardMessageId"] = this.awardMessageId;
        data["awardMessage"] = this.awardMessage ? this.awardMessage.toJSON() : <any>undefined;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        if (Array.isArray(this.weixinShares)) {
            data["weixinShares"] = [];
            for (let item of this.weixinShares)
                data["weixinShares"].push(item.toJSON());
        }
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        data["activityShareId"] = this.activityShareId;
        data["activityShare"] = this.activityShare ? this.activityShare.toJSON() : <any>undefined;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["weChatAppID"] = this.weChatAppID;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["alipayApplicationId"] = this.alipayApplicationId;
        data["alipayAppID"] = this.alipayAppID;
        data["douyinApplicationId"] = this.douyinApplicationId;
        data["douyinAppID"] = this.douyinAppID;
        data["weiboApplicationId"] = this.weiboApplicationId;
        data["weiboAppID"] = this.weiboAppID;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["organizer"] = this.organizer;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["repeatAwardFrequency"] = this.repeatAwardFrequency;
        data["repeatAwardDurations"] = this.repeatAwardDurations;
        data["repeatAwardTimes"] = this.repeatAwardTimes;
        data["isAllowedShareGetLotteryTimes"] = this.isAllowedShareGetLotteryTimes;
        data["shareDurations"] = this.shareDurations;
        data["shareLotteryTimes"] = this.shareLotteryTimes;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["description"] = this.description;
        if (Array.isArray(this.activityFlows)) {
            data["activityFlows"] = [];
            for (let item of this.activityFlows)
                data["activityFlows"].push(item.toJSON());
        }
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["outerId"] = this.outerId;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivity {
    tenantId: number;
    isAwardType: boolean;
    organizationUnitId: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    isSendAwardMessage: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage;
    awardMessageId: number | undefined;
    awardMessage: SnsMessage;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    viewCount: number;
    likeCount: number;
    weixinShares: SnsShare[] | undefined;
    awards: Award[] | undefined;
    activityShareId: number | undefined;
    activityShare: ActivityShare;
    weixinPublicAccountInfoId: number;
    weChatAppID: string | undefined;
    externalAccessTokenInfoId: number;
    taobaoSellerID: string | undefined;
    alipayApplicationId: number;
    alipayAppID: string | undefined;
    douyinApplicationId: number;
    douyinAppID: string | undefined;
    weiboApplicationId: number;
    weiboAppID: string | undefined;
    isEnableWhiteUser: boolean;
    isEnableBlackUser: boolean;
    organizer: string | undefined;
    isAllowedRepeatAward: boolean;
    repeatAwardFrequency: FrequencyType;
    repeatAwardDurations: number | undefined;
    repeatAwardTimes: number | undefined;
    isAllowedShareGetLotteryTimes: boolean;
    shareDurations: number | undefined;
    shareLotteryTimes: number | undefined;
    isNeedAwardInfo: boolean;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean;
    iconPath: string | undefined;
    description: string | undefined;
    activityFlows: ActivityFlow[] | undefined;
    isNeedRegister: boolean;
    isNeedValidate: boolean;
    ownerName: string | undefined;
    isPublic: boolean;
    contactor: string | undefined;
    outerId: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: AuditStatus;
    games: ActivityGame[] | undefined;
    type: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityAndSoftwareDto implements IActivityAndSoftwareDto {
    activityId!: number;
    softwareId!: number | undefined;

    constructor(data?: IActivityAndSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.softwareId = _data["softwareId"];
        }
    }

    static fromJS(data: any): ActivityAndSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAndSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["softwareId"] = this.softwareId;
        return data; 
    }
}

export interface IActivityAndSoftwareDto {
    activityId: number;
    softwareId: number | undefined;
}

export class ActivityAuditInput implements IActivityAuditInput {
    activityIds!: number[] | undefined;
    currentAuditStatus!: AuditStatus;
    targetAuditStatus!: AuditStatus;

    constructor(data?: IActivityAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activityIds"])) {
                this.activityIds = [] as any;
                for (let item of _data["activityIds"])
                    this.activityIds!.push(item);
            }
            this.currentAuditStatus = _data["currentAuditStatus"];
            this.targetAuditStatus = _data["targetAuditStatus"];
        }
    }

    static fromJS(data: any): ActivityAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityIds)) {
            data["activityIds"] = [];
            for (let item of this.activityIds)
                data["activityIds"].push(item);
        }
        data["currentAuditStatus"] = this.currentAuditStatus;
        data["targetAuditStatus"] = this.targetAuditStatus;
        return data; 
    }
}

export interface IActivityAuditInput {
    activityIds: number[] | undefined;
    currentAuditStatus: AuditStatus;
    targetAuditStatus: AuditStatus;
}

export class ActivityAwardDto implements IActivityAwardDto {
    activityId!: number;
    awardId!: number;
    awardName!: string | undefined;
    activityName!: string | undefined;
    awardIcon!: string | undefined;
    awardPicUrl!: string | undefined;
    awardCouponUrl!: string | undefined;
    awardThingType!: ThingType;

    constructor(data?: IActivityAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.awardId = _data["awardId"];
            this.awardName = _data["awardName"];
            this.activityName = _data["activityName"];
            this.awardIcon = _data["awardIcon"];
            this.awardPicUrl = _data["awardPicUrl"];
            this.awardCouponUrl = _data["awardCouponUrl"];
            this.awardThingType = _data["awardThingType"];
        }
    }

    static fromJS(data: any): ActivityAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["awardId"] = this.awardId;
        data["awardName"] = this.awardName;
        data["activityName"] = this.activityName;
        data["awardIcon"] = this.awardIcon;
        data["awardPicUrl"] = this.awardPicUrl;
        data["awardCouponUrl"] = this.awardCouponUrl;
        data["awardThingType"] = this.awardThingType;
        return data; 
    }
}

export interface IActivityAwardDto {
    activityId: number;
    awardId: number;
    awardName: string | undefined;
    activityName: string | undefined;
    awardIcon: string | undefined;
    awardPicUrl: string | undefined;
    awardCouponUrl: string | undefined;
    awardThingType: ThingType;
}

export class ActivityBasicDto implements IActivityBasicDto {
    /** 活动Id */
    id!: number;
    /** 活动名称 */
    name!: string | undefined;
    /** 活动图片 */
    imagePath!: string | undefined;
    /** 活动线下地址 */
    address!: string | undefined;
    /** 活动的首页url */
    activityUrl!: string | undefined;
    /** 活动Logo的url */
    activityLogoPath!: string | undefined;
    /** 活动开始时间 */
    openDate!: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate!: moment.Moment | undefined;
    /** 公众号appid */
    weChatAppID!: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId!: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId!: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID!: string | undefined;
    /** 活动主办方 */
    organizer!: string | undefined;
    /** 活动规则 */
    rules!: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate!: moment.Moment | undefined;
    /** 该活动是否是模板 */
    isTemplate!: boolean;
    /** 图标路径 更多用处是在创建活动选模板的时候 */
    iconPath!: string | undefined;
    /** 活动的所有者 */
    ownerName!: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic!: boolean;
    /** 活动联系人 */
    contactor!: string | undefined;
    /** 活动联系人电话 */
    contactorPhone!: string | undefined;
    auditStatus!: AuditStatus;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean;
    isNeedValidate!: boolean;

    constructor(data?: IActivityBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.address = _data["address"];
            this.activityUrl = _data["activityUrl"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = _data["weChatAppID"];
            this.weixinPublicAccountInfoId = _data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.organizer = _data["organizer"];
            this.rules = _data["rules"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = _data["isTemplate"];
            this.iconPath = _data["iconPath"];
            this.ownerName = _data["ownerName"];
            this.isPublic = _data["isPublic"];
            this.contactor = _data["contactor"];
            this.contactorPhone = _data["contactorPhone"];
            this.auditStatus = _data["auditStatus"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.description = _data["description"];
            this.isNeedRegister = _data["isNeedRegister"];
            this.isNeedValidate = _data["isNeedValidate"];
        }
    }

    static fromJS(data: any): ActivityBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["organizer"] = this.organizer;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        return data; 
    }
}

export interface IActivityBasicDto {
    /** 活动Id */
    id: number;
    /** 活动名称 */
    name: string | undefined;
    /** 活动图片 */
    imagePath: string | undefined;
    /** 活动线下地址 */
    address: string | undefined;
    /** 活动的首页url */
    activityUrl: string | undefined;
    /** 活动Logo的url */
    activityLogoPath: string | undefined;
    /** 活动开始时间 */
    openDate: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate: moment.Moment | undefined;
    /** 公众号appid */
    weChatAppID: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID: string | undefined;
    /** 活动主办方 */
    organizer: string | undefined;
    /** 活动规则 */
    rules: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate: moment.Moment | undefined;
    /** 该活动是否是模板 */
    isTemplate: boolean;
    /** 图标路径 更多用处是在创建活动选模板的时候 */
    iconPath: string | undefined;
    /** 活动的所有者 */
    ownerName: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic: boolean;
    /** 活动联系人 */
    contactor: string | undefined;
    /** 活动联系人电话 */
    contactorPhone: string | undefined;
    auditStatus: AuditStatus;
    isMine: boolean;
    organizationUnitId: number | undefined;
    description: string | undefined;
    isNeedRegister: boolean;
    isNeedValidate: boolean;
}

export class ActivityDataUserOutput implements IActivityDataUserOutput {
    snsUserInfo!: SnsUserInfoOutput;
    activityUserData!: ActivityUserDataOutput;

    constructor(data?: IActivityDataUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.activityUserData = _data["activityUserData"] ? ActivityUserDataOutput.fromJS(_data["activityUserData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityDataUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDataUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["activityUserData"] = this.activityUserData ? this.activityUserData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActivityDataUserOutput {
    snsUserInfo: SnsUserInfoOutput;
    activityUserData: ActivityUserDataOutput;
}

export class ActivityFlow implements IActivityFlow {
    tenantId!: number;
    activityId!: number;
    activity!: Activity;
    flowUrl!: string | undefined;
    flowType!: FlowType;
    isUseOutside!: boolean;
    htmlTemplateId!: number | undefined;
    htmlTemplate!: HtmlTemplate;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean;
    isHasRegister!: boolean;
    isRegisterInCurrPage!: boolean;
    isHasGame!: boolean;
    isHasGameResult!: boolean;
    isHasReward!: boolean;
    isHasVote!: boolean;
    insideHtml!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IActivityFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.flowUrl = _data["flowUrl"];
            this.flowType = _data["flowType"];
            this.isUseOutside = _data["isUseOutside"];
            this.htmlTemplateId = _data["htmlTemplateId"];
            this.htmlTemplate = _data["htmlTemplate"] ? HtmlTemplate.fromJS(_data["htmlTemplate"]) : <any>undefined;
            this.outsideLink = _data["outsideLink"];
            this.isHasIntroduce = _data["isHasIntroduce"];
            this.isHasRegister = _data["isHasRegister"];
            this.isRegisterInCurrPage = _data["isRegisterInCurrPage"];
            this.isHasGame = _data["isHasGame"];
            this.isHasGameResult = _data["isHasGameResult"];
            this.isHasReward = _data["isHasReward"];
            this.isHasVote = _data["isHasVote"];
            this.insideHtml = _data["insideHtml"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityFlow {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityFlow {
    tenantId: number;
    activityId: number;
    activity: Activity;
    flowUrl: string | undefined;
    flowType: FlowType;
    isUseOutside: boolean;
    htmlTemplateId: number | undefined;
    htmlTemplate: HtmlTemplate;
    outsideLink: string | undefined;
    isHasIntroduce: boolean;
    isHasRegister: boolean;
    isRegisterInCurrPage: boolean;
    isHasGame: boolean;
    isHasGameResult: boolean;
    isHasReward: boolean;
    isHasVote: boolean;
    insideHtml: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityFlowDto implements IActivityFlowDto {
    id!: number;
    /** 所属的租户 Id */
    tenantId!: number;
    activityId!: number;
    /** Flow Url */
    flowUrl!: string | undefined;
    flowType!: FlowType;
    isUseOutside!: boolean;
    /** 本地链接 */
    htmlTemplateId!: number | undefined;
    /** 外链 */
    outsideLink!: string | undefined;
    /** 下面字段都是控制底部的bar
是否有活动介绍 */
    isHasIntroduce!: boolean;
    isHasRegister!: boolean;
    isRegisterInCurrPage!: boolean;
    isHasGame!: boolean;
    isHasGameResult!: boolean;
    isHasReward!: boolean;
    isHasVote!: boolean;
    insideHtml!: string | undefined;

    constructor(data?: IActivityFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.flowUrl = _data["flowUrl"];
            this.flowType = _data["flowType"];
            this.isUseOutside = _data["isUseOutside"];
            this.htmlTemplateId = _data["htmlTemplateId"];
            this.outsideLink = _data["outsideLink"];
            this.isHasIntroduce = _data["isHasIntroduce"];
            this.isHasRegister = _data["isHasRegister"];
            this.isRegisterInCurrPage = _data["isRegisterInCurrPage"];
            this.isHasGame = _data["isHasGame"];
            this.isHasGameResult = _data["isHasGameResult"];
            this.isHasReward = _data["isHasReward"];
            this.isHasVote = _data["isHasVote"];
            this.insideHtml = _data["insideHtml"];
        }
    }

    static fromJS(data: any): ActivityFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        return data; 
    }
}

export interface IActivityFlowDto {
    id: number;
    /** 所属的租户 Id */
    tenantId: number;
    activityId: number;
    /** Flow Url */
    flowUrl: string | undefined;
    flowType: FlowType;
    isUseOutside: boolean;
    /** 本地链接 */
    htmlTemplateId: number | undefined;
    /** 外链 */
    outsideLink: string | undefined;
    /** 下面字段都是控制底部的bar
是否有活动介绍 */
    isHasIntroduce: boolean;
    isHasRegister: boolean;
    isRegisterInCurrPage: boolean;
    isHasGame: boolean;
    isHasGameResult: boolean;
    isHasReward: boolean;
    isHasVote: boolean;
    insideHtml: string | undefined;
}

export class ActivityFlowOutput implements IActivityFlowOutput {
    flowUrl!: string | undefined;
    flowType!: FlowType;
    isUseOutside!: boolean;
    htmlTemplateId!: number | undefined;
    htmlTemplate!: HtmlTemplateOutput;
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean;
    isHasRegister!: boolean;
    isRegisterInCurrPage!: boolean;
    isHasGame!: boolean;
    isHasGameResult!: boolean;
    isHasReward!: boolean;
    isHasVote!: boolean;
    insideHtml!: string | undefined;
    id!: number;

    constructor(data?: IActivityFlowOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flowUrl = _data["flowUrl"];
            this.flowType = _data["flowType"];
            this.isUseOutside = _data["isUseOutside"];
            this.htmlTemplateId = _data["htmlTemplateId"];
            this.htmlTemplate = _data["htmlTemplate"] ? HtmlTemplateOutput.fromJS(_data["htmlTemplate"]) : <any>undefined;
            this.outsideLink = _data["outsideLink"];
            this.isHasIntroduce = _data["isHasIntroduce"];
            this.isHasRegister = _data["isHasRegister"];
            this.isRegisterInCurrPage = _data["isRegisterInCurrPage"];
            this.isHasGame = _data["isHasGame"];
            this.isHasGameResult = _data["isHasGameResult"];
            this.isHasReward = _data["isHasReward"];
            this.isHasVote = _data["isHasVote"];
            this.insideHtml = _data["insideHtml"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityFlowOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["isUseOutside"] = this.isUseOutside;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityFlowOutput {
    flowUrl: string | undefined;
    flowType: FlowType;
    isUseOutside: boolean;
    htmlTemplateId: number | undefined;
    htmlTemplate: HtmlTemplateOutput;
    outsideLink: string | undefined;
    isHasIntroduce: boolean;
    isHasRegister: boolean;
    isRegisterInCurrPage: boolean;
    isHasGame: boolean;
    isHasGameResult: boolean;
    isHasReward: boolean;
    isHasVote: boolean;
    insideHtml: string | undefined;
    id: number;
}

export class ActivityFlowSettingsInput implements IActivityFlowSettingsInput {
    id!: number | undefined;
    activityId!: number;
    flowUrl!: string | undefined;
    flowType!: FlowType;
    /** 本地链接 */
    htmlTemplateId!: number | undefined;
    isUseOutside!: boolean;
    /** 外链 */
    outsideLink!: string | undefined;
    isHasIntroduce!: boolean;
    isHasRegister!: boolean;
    isRegisterInCurrPage!: boolean;
    isHasGame!: boolean;
    isHasGameResult!: boolean;
    isHasReward!: boolean;
    isHasVote!: boolean;
    insideHtml!: string | undefined;

    constructor(data?: IActivityFlowSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityId = _data["activityId"];
            this.flowUrl = _data["flowUrl"];
            this.flowType = _data["flowType"];
            this.htmlTemplateId = _data["htmlTemplateId"];
            this.isUseOutside = _data["isUseOutside"];
            this.outsideLink = _data["outsideLink"];
            this.isHasIntroduce = _data["isHasIntroduce"];
            this.isHasRegister = _data["isHasRegister"];
            this.isRegisterInCurrPage = _data["isRegisterInCurrPage"];
            this.isHasGame = _data["isHasGame"];
            this.isHasGameResult = _data["isHasGameResult"];
            this.isHasReward = _data["isHasReward"];
            this.isHasVote = _data["isHasVote"];
            this.insideHtml = _data["insideHtml"];
        }
    }

    static fromJS(data: any): ActivityFlowSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFlowSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["flowUrl"] = this.flowUrl;
        data["flowType"] = this.flowType;
        data["htmlTemplateId"] = this.htmlTemplateId;
        data["isUseOutside"] = this.isUseOutside;
        data["outsideLink"] = this.outsideLink;
        data["isHasIntroduce"] = this.isHasIntroduce;
        data["isHasRegister"] = this.isHasRegister;
        data["isRegisterInCurrPage"] = this.isRegisterInCurrPage;
        data["isHasGame"] = this.isHasGame;
        data["isHasGameResult"] = this.isHasGameResult;
        data["isHasReward"] = this.isHasReward;
        data["isHasVote"] = this.isHasVote;
        data["insideHtml"] = this.insideHtml;
        return data; 
    }
}

export interface IActivityFlowSettingsInput {
    id: number | undefined;
    activityId: number;
    flowUrl: string | undefined;
    flowType: FlowType;
    /** 本地链接 */
    htmlTemplateId: number | undefined;
    isUseOutside: boolean;
    /** 外链 */
    outsideLink: string | undefined;
    isHasIntroduce: boolean;
    isHasRegister: boolean;
    isRegisterInCurrPage: boolean;
    isHasGame: boolean;
    isHasGameResult: boolean;
    isHasReward: boolean;
    isHasVote: boolean;
    insideHtml: string | undefined;
}

export class ActivityForOrder implements IActivityForOrder {
    id!: number;
    /** 活动开始时间 */
    openDate!: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate!: moment.Moment | undefined;
    /** 公众号AppId */
    weChatAppID!: string | undefined;
    /** 活动规则 */
    rules!: string | undefined;

    constructor(data?: IActivityForOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = _data["weChatAppID"];
            this.rules = _data["rules"];
        }
    }

    static fromJS(data: any): ActivityForOrder {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityForOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["rules"] = this.rules;
        return data; 
    }
}

export interface IActivityForOrder {
    id: number;
    /** 活动开始时间 */
    openDate: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate: moment.Moment | undefined;
    /** 公众号AppId */
    weChatAppID: string | undefined;
    /** 活动规则 */
    rules: string | undefined;
}

export class ActivityFromTemplateInput implements IActivityFromTemplateInput {
    id!: number;
    /** 活动名称 */
    name!: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic!: boolean;
    isTemplate!: boolean;

    constructor(data?: IActivityFromTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isPublic = _data["isPublic"];
            this.isTemplate = _data["isTemplate"];
        }
    }

    static fromJS(data: any): ActivityFromTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFromTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isPublic"] = this.isPublic;
        data["isTemplate"] = this.isTemplate;
        return data; 
    }
}

export interface IActivityFromTemplateInput {
    id: number;
    /** 活动名称 */
    name: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic: boolean;
    isTemplate: boolean;
}

export class ActivityGame implements IActivityGame {
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    activityId!: number;
    activity!: Activity;
    isShareAction!: boolean;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare;
    supportedPlayersCount!: number;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage;
    isSendSnsMsgAfterGame!: boolean;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    extensionData!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActivityShare.fromJS(_data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMessage.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMessage.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.extensionData = _data["extensionData"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityGame {
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    activityId: number;
    activity: Activity;
    isShareAction: boolean;
    actionShareId: number | undefined;
    actionShare: ActivityShare;
    supportedPlayersCount: number;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage;
    isSendSnsMsgAfterGame: boolean;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    extensionData: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityGameActionsDto implements IActivityGameActionsDto {
    deviceActivityGame!: DeviceActivityGameSimpleOutput;
    userActions!: UserActionDto[] | undefined;

    constructor(data?: IActivityGameActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceActivityGame = _data["deviceActivityGame"] ? DeviceActivityGameSimpleOutput.fromJS(_data["deviceActivityGame"]) : <any>undefined;
            if (Array.isArray(_data["userActions"])) {
                this.userActions = [] as any;
                for (let item of _data["userActions"])
                    this.userActions!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityGameActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IActivityGameActionsDto {
    deviceActivityGame: DeviceActivityGameSimpleOutput;
    userActions: UserActionDto[] | undefined;
}

export class ActivityGameDto implements IActivityGameDto {
    name!: string | undefined;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode!: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount!: number;
    softwareName!: string | undefined;
    gameType!: number;
    /** 游戏密钥 */
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    isSendWechatBeforeGame!: boolean;
    isSendWechatAfterGame!: boolean;
    isShareAction!: boolean;
    tenantId!: number;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    activityId!: number;
    /** 游戏后的分享设置 */
    actionShareId!: number | undefined;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendSnsMsgBeforeGame!: boolean;
    afterGameMessageId!: number | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendSnsMsgAfterGame!: boolean;
    /** 线上模板的背景图片 */
    onlineBackground!: string | undefined;
    /** 线上模板的前景图片 */
    onlineForeground!: string | undefined;
    /** 线下游戏的背景图片 */
    offlineBackground!: string | undefined;
    /** 线下游戏前景图片 */
    offlineForeground!: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    /** 一个用户多长时间内最多玩几次 */
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    /** 活动关联的游戏是否已经开始 */
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMsgBeforeGameDto;
    afterGameMessage!: SnsMsgAfterGameDto;
    actionShare!: ActionShareDto;
    extensionData!: string | undefined;
    id!: number;

    constructor(data?: IActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.softwareName = _data["softwareName"];
            this.gameType = _data["gameType"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.isShareAction = _data["isShareAction"];
            this.tenantId = _data["tenantId"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.activityId = _data["activityId"];
            this.actionShareId = _data["actionShareId"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMsgBeforeGameDto.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMsgAfterGameDto.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.actionShare = _data["actionShare"] ? ActionShareDto.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["softwareName"] = this.softwareName;
        data["gameType"] = this.gameType;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["isShareAction"] = this.isShareAction;
        data["tenantId"] = this.tenantId;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["actionShareId"] = this.actionShareId;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityGameDto {
    name: string | undefined;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount: number;
    softwareName: string | undefined;
    gameType: number;
    /** 游戏密钥 */
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    isSendWechatBeforeGame: boolean;
    isSendWechatAfterGame: boolean;
    isShareAction: boolean;
    tenantId: number;
    softwareId: number;
    dispatchedSoftwareId: number;
    activityId: number;
    /** 游戏后的分享设置 */
    actionShareId: number | undefined;
    /** 是否在游戏前发送消息
比如有些游戏需要先扫码才能玩，一旦用户扫码，用户的微信会接收到一条消息，这个时候就是游戏前发送消息 */
    isSendSnsMsgBeforeGame: boolean;
    afterGameMessageId: number | undefined;
    /** 是否在游戏后发送消息
用户玩完游戏后，系统会推送一些游戏成绩到用户微信里，决定是否发这样的消息 */
    isSendSnsMsgAfterGame: boolean;
    /** 线上模板的背景图片 */
    onlineBackground: string | undefined;
    /** 线上模板的前景图片 */
    onlineForeground: string | undefined;
    /** 线下游戏的背景图片 */
    offlineBackground: string | undefined;
    /** 线下游戏前景图片 */
    offlineForeground: string | undefined;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    /** 一个用户多长时间内最多玩几次 */
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    /** 活动关联的游戏是否已经开始 */
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMsgBeforeGameDto;
    afterGameMessage: SnsMsgAfterGameDto;
    actionShare: ActionShareDto;
    extensionData: string | undefined;
    id: number;
}

export class ActivityGameSettingsInput implements IActivityGameSettingsInput {
    activityId!: number;
    id!: number | undefined;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number | undefined;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode!: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount!: number;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMsgBeforeGameDto;
    isSendSnsMsgAfterGame!: boolean;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMsgAfterGameDto;
    isShareAction!: boolean;
    actionShareId!: number | undefined;
    actionShare!: ActionShareDto;
    /** 配置文件的存储 */
    extensionData!: string | undefined;

    constructor(data?: IActivityGameSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMsgBeforeGameDto.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMsgAfterGameDto.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActionShareDto.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): ActivityGameSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityGameSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IActivityGameSettingsInput {
    activityId: number;
    id: number | undefined;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number | undefined;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount: number;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMsgBeforeGameDto;
    isSendSnsMsgAfterGame: boolean;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMsgAfterGameDto;
    isShareAction: boolean;
    actionShareId: number | undefined;
    actionShare: ActionShareDto;
    /** 配置文件的存储 */
    extensionData: string | undefined;
}

export class ActivityOutput implements IActivityOutput {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    imagePath!: string | undefined;
    address!: string | undefined;
    activityUrl!: string | undefined;
    activityLogoPath!: string | undefined;
    isSendAwardMessage!: boolean;
    beforeWeChatMessageId!: number | undefined;
    openDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    viewCount!: number;
    likeCount!: number;
    activityShareId!: number | undefined;
    weChatAppID!: string | undefined;
    weixinPublicAccountInfoId!: number;
    taobaoSellerID!: string | undefined;
    externalAccessTokenInfoId!: number;
    isEnableWhiteUser!: boolean;
    isEnableBlackUser!: boolean;
    organizer!: string | undefined;
    isAllowedRepeatAward!: boolean;
    isNeedAwardInfo!: boolean;
    isNeedValidate!: boolean;
    rules!: string | undefined;
    activityExcutedDate!: moment.Moment | undefined;
    isTemplate!: boolean;
    iconPath!: string | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean;
    ownerName!: string | undefined;
    isPublic!: boolean;
    contactor!: string | undefined;
    outerId!: string | undefined;
    contactorPhone!: string | undefined;
    auditStatus!: AuditStatus;
    activityShare!: ActivityShareOutput;

    constructor(data?: IActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.address = _data["address"];
            this.activityUrl = _data["activityUrl"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.isSendAwardMessage = _data["isSendAwardMessage"];
            this.beforeWeChatMessageId = _data["beforeWeChatMessageId"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.activityShareId = _data["activityShareId"];
            this.weChatAppID = _data["weChatAppID"];
            this.weixinPublicAccountInfoId = _data["weixinPublicAccountInfoId"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
            this.isEnableWhiteUser = _data["isEnableWhiteUser"];
            this.isEnableBlackUser = _data["isEnableBlackUser"];
            this.organizer = _data["organizer"];
            this.isAllowedRepeatAward = _data["isAllowedRepeatAward"];
            this.isNeedAwardInfo = _data["isNeedAwardInfo"];
            this.isNeedValidate = _data["isNeedValidate"];
            this.rules = _data["rules"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = _data["isTemplate"];
            this.iconPath = _data["iconPath"];
            this.description = _data["description"];
            this.isNeedRegister = _data["isNeedRegister"];
            this.ownerName = _data["ownerName"];
            this.isPublic = _data["isPublic"];
            this.contactor = _data["contactor"];
            this.outerId = _data["outerId"];
            this.contactorPhone = _data["contactorPhone"];
            this.auditStatus = _data["auditStatus"];
            this.activityShare = _data["activityShare"] ? ActivityShareOutput.fromJS(_data["activityShare"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["isSendAwardMessage"] = this.isSendAwardMessage;
        data["beforeWeChatMessageId"] = this.beforeWeChatMessageId;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["activityShareId"] = this.activityShareId;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["organizer"] = this.organizer;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isNeedValidate"] = this.isNeedValidate;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["outerId"] = this.outerId;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["activityShare"] = this.activityShare ? this.activityShare.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActivityOutput {
    tenantId: number;
    organizationUnitId: number | undefined;
    name: string | undefined;
    imagePath: string | undefined;
    address: string | undefined;
    activityUrl: string | undefined;
    activityLogoPath: string | undefined;
    isSendAwardMessage: boolean;
    beforeWeChatMessageId: number | undefined;
    openDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    viewCount: number;
    likeCount: number;
    activityShareId: number | undefined;
    weChatAppID: string | undefined;
    weixinPublicAccountInfoId: number;
    taobaoSellerID: string | undefined;
    externalAccessTokenInfoId: number;
    isEnableWhiteUser: boolean;
    isEnableBlackUser: boolean;
    organizer: string | undefined;
    isAllowedRepeatAward: boolean;
    isNeedAwardInfo: boolean;
    isNeedValidate: boolean;
    rules: string | undefined;
    activityExcutedDate: moment.Moment | undefined;
    isTemplate: boolean;
    iconPath: string | undefined;
    description: string | undefined;
    isNeedRegister: boolean;
    ownerName: string | undefined;
    isPublic: boolean;
    contactor: string | undefined;
    outerId: string | undefined;
    contactorPhone: string | undefined;
    auditStatus: AuditStatus;
    activityShare: ActivityShareOutput;
}

export class ActivityPayRecord implements IActivityPayRecord {
    tenantId!: number;
    activityPayType!: ActivityPayType;
    payAmount!: number;
    actionId!: number;
    openid!: string | undefined;
    activityId!: number;
    payOrder!: string | undefined;
    tradNumber!: string | undefined;
    payResult!: boolean;
    orderPayRecordId!: number | undefined;
    tickets!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IActivityPayRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityPayType = _data["activityPayType"];
            this.payAmount = _data["payAmount"];
            this.actionId = _data["actionId"];
            this.openid = _data["openid"];
            this.activityId = _data["activityId"];
            this.payOrder = _data["payOrder"];
            this.tradNumber = _data["tradNumber"];
            this.payResult = _data["payResult"];
            this.orderPayRecordId = _data["orderPayRecordId"];
            this.tickets = _data["tickets"];
            this.extensionData = _data["extensionData"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityPayRecord {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityPayRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityPayType"] = this.activityPayType;
        data["payAmount"] = this.payAmount;
        data["actionId"] = this.actionId;
        data["openid"] = this.openid;
        data["activityId"] = this.activityId;
        data["payOrder"] = this.payOrder;
        data["tradNumber"] = this.tradNumber;
        data["payResult"] = this.payResult;
        data["orderPayRecordId"] = this.orderPayRecordId;
        data["tickets"] = this.tickets;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityPayRecord {
    tenantId: number;
    activityPayType: ActivityPayType;
    payAmount: number;
    actionId: number;
    openid: string | undefined;
    activityId: number;
    payOrder: string | undefined;
    tradNumber: string | undefined;
    payResult: boolean;
    orderPayRecordId: number | undefined;
    tickets: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityPayRecordInput implements IActivityPayRecordInput {
    id!: number;
    tenantId!: number;
    activityPayType!: ActivityPayType;
    payAmount!: number;
    actionId!: number;
    openid!: string | undefined;
    activityId!: number;
    payOrder!: string | undefined;
    tradNumber!: string | undefined;
    payResult!: boolean;
    orderPayRecordId!: number | undefined;
    tickets!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IActivityPayRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.activityPayType = _data["activityPayType"];
            this.payAmount = _data["payAmount"];
            this.actionId = _data["actionId"];
            this.openid = _data["openid"];
            this.activityId = _data["activityId"];
            this.payOrder = _data["payOrder"];
            this.tradNumber = _data["tradNumber"];
            this.payResult = _data["payResult"];
            this.orderPayRecordId = _data["orderPayRecordId"];
            this.tickets = _data["tickets"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): ActivityPayRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityPayRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["activityPayType"] = this.activityPayType;
        data["payAmount"] = this.payAmount;
        data["actionId"] = this.actionId;
        data["openid"] = this.openid;
        data["activityId"] = this.activityId;
        data["payOrder"] = this.payOrder;
        data["tradNumber"] = this.tradNumber;
        data["payResult"] = this.payResult;
        data["orderPayRecordId"] = this.orderPayRecordId;
        data["tickets"] = this.tickets;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IActivityPayRecordInput {
    id: number;
    tenantId: number;
    activityPayType: ActivityPayType;
    payAmount: number;
    actionId: number;
    openid: string | undefined;
    activityId: number;
    payOrder: string | undefined;
    tradNumber: string | undefined;
    payResult: boolean;
    orderPayRecordId: number | undefined;
    tickets: string | undefined;
    extensionData: string | undefined;
}

export enum ActivityPayType {
    Cash = "Cash",
    Point = "Point",
    Ticket = "Ticket",
}

export class ActivityShare implements IActivityShare {
    tenantId!: number;
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IActivityShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityShare {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityShare {
    tenantId: number;
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: EnumActivityShareType;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityShareOutput implements IActivityShareOutput {
    title!: string | undefined;
    link!: string | undefined;
    imageLink!: string | undefined;
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;
    id!: number;

    constructor(data?: IActivityShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityShareOutput {
    title: string | undefined;
    link: string | undefined;
    imageLink: string | undefined;
    description: string | undefined;
    activityShareType: EnumActivityShareType;
    id: number;
}

export class ActivityShareSettingsDto implements IActivityShareSettingsDto {
    id!: number | undefined;
    /** 所属的租户 Id */
    tenantId!: number;
    title!: string | undefined;
    /** 分享链接 */
    link!: string | undefined;
    /** 分享图标 */
    imageLink!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;

    constructor(data?: IActivityShareSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
        }
    }

    static fromJS(data: any): ActivityShareSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActivityShareSettingsDto {
    id: number | undefined;
    /** 所属的租户 Id */
    tenantId: number;
    title: string | undefined;
    /** 分享链接 */
    link: string | undefined;
    /** 分享图标 */
    imageLink: string | undefined;
    /** 描述 */
    description: string | undefined;
    activityShareType: EnumActivityShareType;
}

export class ActivityShareSettingsInput implements IActivityShareSettingsInput {
    id!: number | undefined;
    activityId!: number;
    title!: string | undefined;
    /** 分享链接 */
    link!: string | undefined;
    /** 分享图标 */
    imageLink!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;

    constructor(data?: IActivityShareSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityId = _data["activityId"];
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
        }
    }

    static fromJS(data: any): ActivityShareSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityShareSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface IActivityShareSettingsInput {
    id: number | undefined;
    activityId: number;
    title: string | undefined;
    /** 分享链接 */
    link: string | undefined;
    /** 分享图标 */
    imageLink: string | undefined;
    /** 描述 */
    description: string | undefined;
    activityShareType: EnumActivityShareType;
}

export class ActivityUserDataDto implements IActivityUserDataDto {
    /** 所属的租户 Id */
    tenantId!: number;
    /** 活动唯一id */
    activityId!: number;
    /** 基本微信用户数据 */
    snsUserInfoId!: number;
    snsUserInfo!: SnsUserInfoDto;
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 联系地址 */
    address!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    /** 用户公司名 */
    companyName!: string | undefined;
    /** 是否签到 */
    isSigned!: boolean;
    /** 身份是否被认证 */
    isValidated!: boolean;
    /** 是否完成注册 */
    isRegistered!: boolean;
    isGamed!: boolean;
    deviceActivityId!: number | undefined;
    dispatchedActivityId!: number | undefined;
    userActionId!: number | undefined;
    id!: number;

    constructor(data?: IActivityUserDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoDto.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.isSigned = _data["isSigned"];
            this.isValidated = _data["isValidated"];
            this.isRegistered = _data["isRegistered"];
            this.isGamed = _data["isGamed"];
            this.deviceActivityId = _data["deviceActivityId"];
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.userActionId = _data["userActionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityUserDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityUserDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["isSigned"] = this.isSigned;
        data["isValidated"] = this.isValidated;
        data["isRegistered"] = this.isRegistered;
        data["isGamed"] = this.isGamed;
        data["deviceActivityId"] = this.deviceActivityId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["userActionId"] = this.userActionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityUserDataDto {
    /** 所属的租户 Id */
    tenantId: number;
    /** 活动唯一id */
    activityId: number;
    /** 基本微信用户数据 */
    snsUserInfoId: number;
    snsUserInfo: SnsUserInfoDto;
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 联系地址 */
    address: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    /** 用户公司名 */
    companyName: string | undefined;
    /** 是否签到 */
    isSigned: boolean;
    /** 身份是否被认证 */
    isValidated: boolean;
    /** 是否完成注册 */
    isRegistered: boolean;
    isGamed: boolean;
    deviceActivityId: number | undefined;
    dispatchedActivityId: number | undefined;
    userActionId: number | undefined;
    id: number;
}

export class ActivityUserDataOutput implements IActivityUserDataOutput {
    snsUserInfoId!: number;
    /** 用户真是姓名 */
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 联系地址 */
    address!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    /** 用户公司名 */
    companyName!: string | undefined;
    /** 兴趣 */
    interests!: string | undefined;
    /** 是否签到 */
    isSigned!: boolean;
    /** 身份是否被认证 */
    isValidated!: boolean;
    /** 是否完成注册 */
    isRegistered!: boolean;
    isGamed!: boolean;
    totalPoints!: number;
    faceUrl!: string | undefined;
    id!: number;

    constructor(data?: IActivityUserDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.interests = _data["interests"];
            this.isSigned = _data["isSigned"];
            this.isValidated = _data["isValidated"];
            this.isRegistered = _data["isRegistered"];
            this.isGamed = _data["isGamed"];
            this.totalPoints = _data["totalPoints"];
            this.faceUrl = _data["faceUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityUserDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityUserDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["interests"] = this.interests;
        data["isSigned"] = this.isSigned;
        data["isValidated"] = this.isValidated;
        data["isRegistered"] = this.isRegistered;
        data["isGamed"] = this.isGamed;
        data["totalPoints"] = this.totalPoints;
        data["faceUrl"] = this.faceUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActivityUserDataOutput {
    snsUserInfoId: number;
    /** 用户真是姓名 */
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 联系地址 */
    address: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    /** 用户公司名 */
    companyName: string | undefined;
    /** 兴趣 */
    interests: string | undefined;
    /** 是否签到 */
    isSigned: boolean;
    /** 身份是否被认证 */
    isValidated: boolean;
    /** 是否完成注册 */
    isRegistered: boolean;
    isGamed: boolean;
    totalPoints: number;
    faceUrl: string | undefined;
    id: number;
}

export class AddOrUpdateActivityUserInput implements IAddOrUpdateActivityUserInput {
    openId!: string;
    snsType!: _definitions_EnumSnsType;
    securityKey!: string | undefined;
    /** 用户真是姓名 */
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 联系地址 */
    address!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    /** 用户公司名 */
    companyName!: string | undefined;
    interests!: string | undefined;

    constructor(data?: IAddOrUpdateActivityUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.snsType = _data["snsType"];
            this.securityKey = _data["securityKey"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.interests = _data["interests"];
        }
    }

    static fromJS(data: any): AddOrUpdateActivityUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateActivityUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["interests"] = this.interests;
        return data; 
    }
}

export interface IAddOrUpdateActivityUserInput {
    openId: string;
    snsType: _definitions_EnumSnsType;
    securityKey: string | undefined;
    /** 用户真是姓名 */
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 联系地址 */
    address: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    /** 用户公司名 */
    companyName: string | undefined;
    interests: string | undefined;
}

export class AddOrUpdateConditionalMenuInput implements IAddOrUpdateConditionalMenuInput {
    id!: number | undefined;
    weixinAppID!: string | undefined;
    menuContent!: ConditionalButtonGroup;
    displayName!: string | undefined;
    menuType!: MenuType;

    constructor(data?: IAddOrUpdateConditionalMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.weixinAppID = _data["weixinAppID"];
            this.menuContent = _data["menuContent"] ? ConditionalButtonGroup.fromJS(_data["menuContent"]) : <any>undefined;
            this.displayName = _data["displayName"];
            this.menuType = _data["menuType"];
        }
    }

    static fromJS(data: any): AddOrUpdateConditionalMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateConditionalMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["weixinAppID"] = this.weixinAppID;
        data["menuContent"] = this.menuContent ? this.menuContent.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        return data; 
    }
}

export interface IAddOrUpdateConditionalMenuInput {
    id: number | undefined;
    weixinAppID: string | undefined;
    menuContent: ConditionalButtonGroup;
    displayName: string | undefined;
    menuType: MenuType;
}

export class AddOrUpdateMenuInput implements IAddOrUpdateMenuInput {
    id!: number | undefined;
    weixinAppID!: string | undefined;
    menuContent!: any | undefined;
    displayName!: string | undefined;
    menuType!: MenuType;

    constructor(data?: IAddOrUpdateMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.weixinAppID = _data["weixinAppID"];
            this.menuContent = _data["menuContent"];
            this.displayName = _data["displayName"];
            this.menuType = _data["menuType"];
        }
    }

    static fromJS(data: any): AddOrUpdateMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["weixinAppID"] = this.weixinAppID;
        data["menuContent"] = this.menuContent;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        return data; 
    }
}

export interface IAddOrUpdateMenuInput {
    id: number | undefined;
    weixinAppID: string | undefined;
    menuContent: any | undefined;
    displayName: string | undefined;
    menuType: MenuType;
}

export class AddOrUpdateMessageSeedInput implements IAddOrUpdateMessageSeedInput {
    id!: number | undefined;
    title!: string | undefined;
    messageCode!: string;
    description!: string | undefined;
    usage!: string | undefined;

    constructor(data?: IAddOrUpdateMessageSeedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.messageCode = _data["messageCode"];
            this.description = _data["description"];
            this.usage = _data["usage"];
        }
    }

    static fromJS(data: any): AddOrUpdateMessageSeedInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateMessageSeedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["messageCode"] = this.messageCode;
        data["description"] = this.description;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface IAddOrUpdateMessageSeedInput {
    id: number | undefined;
    title: string | undefined;
    messageCode: string;
    description: string | undefined;
    usage: string | undefined;
}

export class AddOrUpdateSnsUserInfoInput implements IAddOrUpdateSnsUserInfoInput {
    subKey!: string | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    gameName!: string | undefined;
    score!: string | undefined;

    constructor(data?: IAddOrUpdateSnsUserInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.gameName = _data["gameName"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): AddOrUpdateSnsUserInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSnsUserInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["gameName"] = this.gameName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IAddOrUpdateSnsUserInfoInput {
    subKey: string | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    gameName: string | undefined;
    score: string | undefined;
}

export class AddSnsAndActionInput implements IAddSnsAndActionInput {
    tenandId!: number;
    openId!: string | undefined;
    securityKey!: string | undefined;
    nickName!: string | undefined;
    headImgUrl!: string | undefined;
    memberId!: number;
    appId!: string | undefined;

    constructor(data?: IAddSnsAndActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenandId = _data["tenandId"];
            this.openId = _data["openId"];
            this.securityKey = _data["securityKey"];
            this.nickName = _data["nickName"];
            this.headImgUrl = _data["headImgUrl"];
            this.memberId = _data["memberId"];
            this.appId = _data["appId"];
        }
    }

    static fromJS(data: any): AddSnsAndActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSnsAndActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenandId"] = this.tenandId;
        data["openId"] = this.openId;
        data["securityKey"] = this.securityKey;
        data["nickName"] = this.nickName;
        data["headImgUrl"] = this.headImgUrl;
        data["memberId"] = this.memberId;
        data["appId"] = this.appId;
        return data; 
    }
}

export interface IAddSnsAndActionInput {
    tenandId: number;
    openId: string | undefined;
    securityKey: string | undefined;
    nickName: string | undefined;
    headImgUrl: string | undefined;
    memberId: number;
    appId: string | undefined;
}

export class AddUserPaperInput implements IAddUserPaperInput {
    subkey!: string;
    paperId!: number;
    userActionId!: number;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number;
    correctCount!: number;
    totalScore!: number;
    opinion!: string | undefined;
    examResult!: ExamEnum;
    paperQuestions!: PaperQuestion[] | undefined;

    constructor(data?: IAddUserPaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.paperId = _data["paperId"];
            this.userActionId = _data["userActionId"];
            this.examStartTime = _data["examStartTime"] ? moment(_data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = _data["examEndTime"] ? moment(_data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = _data["answeredQuestionCount"];
            this.correctCount = _data["correctCount"];
            this.totalScore = _data["totalScore"];
            this.opinion = _data["opinion"];
            this.examResult = _data["examResult"];
            if (Array.isArray(_data["paperQuestions"])) {
                this.paperQuestions = [] as any;
                for (let item of _data["paperQuestions"])
                    this.paperQuestions!.push(PaperQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddUserPaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserPaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["paperId"] = this.paperId;
        data["userActionId"] = this.userActionId;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["opinion"] = this.opinion;
        data["examResult"] = this.examResult;
        if (Array.isArray(this.paperQuestions)) {
            data["paperQuestions"] = [];
            for (let item of this.paperQuestions)
                data["paperQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddUserPaperInput {
    subkey: string;
    paperId: number;
    userActionId: number;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number;
    correctCount: number;
    totalScore: number;
    opinion: string | undefined;
    examResult: ExamEnum;
    paperQuestions: PaperQuestion[] | undefined;
}

export class AddUserPaperInput4Wechat implements IAddUserPaperInput4Wechat {
    trainingId!: number | undefined;
    paperId!: number;
    userActionId!: number;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number;
    correctCount!: number;
    totalScore!: number;
    opinion!: string | undefined;
    examResult!: ExamEnum;
    paperQuestions!: PaperQuestion[] | undefined;

    constructor(data?: IAddUserPaperInput4Wechat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingId = _data["trainingId"];
            this.paperId = _data["paperId"];
            this.userActionId = _data["userActionId"];
            this.examStartTime = _data["examStartTime"] ? moment(_data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = _data["examEndTime"] ? moment(_data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = _data["answeredQuestionCount"];
            this.correctCount = _data["correctCount"];
            this.totalScore = _data["totalScore"];
            this.opinion = _data["opinion"];
            this.examResult = _data["examResult"];
            if (Array.isArray(_data["paperQuestions"])) {
                this.paperQuestions = [] as any;
                for (let item of _data["paperQuestions"])
                    this.paperQuestions!.push(PaperQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddUserPaperInput4Wechat {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserPaperInput4Wechat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingId"] = this.trainingId;
        data["paperId"] = this.paperId;
        data["userActionId"] = this.userActionId;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["opinion"] = this.opinion;
        data["examResult"] = this.examResult;
        if (Array.isArray(this.paperQuestions)) {
            data["paperQuestions"] = [];
            for (let item of this.paperQuestions)
                data["paperQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddUserPaperInput4Wechat {
    trainingId: number | undefined;
    paperId: number;
    userActionId: number;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number;
    correctCount: number;
    totalScore: number;
    opinion: string | undefined;
    examResult: ExamEnum;
    paperQuestions: PaperQuestion[] | undefined;
}

export class ApplyFormDto implements IApplyFormDto {
    reason!: string | undefined;
    /** the current status of the application. */
    applyStatus!: string | undefined;
    /** the type of Application. */
    applyType!: string | undefined;
    /** what your want. */
    wanted!: string | undefined;
    resultMessage!: string | undefined;
    applyUserName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyStatus = _data["applyStatus"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            this.resultMessage = _data["resultMessage"];
            this.applyUserName = _data["applyUserName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyStatus"] = this.applyStatus;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        data["resultMessage"] = this.resultMessage;
        data["applyUserName"] = this.applyUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplyFormDto {
    reason: string | undefined;
    /** the current status of the application. */
    applyStatus: string | undefined;
    /** the type of Application. */
    applyType: string | undefined;
    /** what your want. */
    wanted: string | undefined;
    resultMessage: string | undefined;
    applyUserName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum ApplyFormType {
    Activity = "Activity",
    Training = "Training",
}

export enum ApplyStatus {
    Applied = "Applied",
    Cancel = "Cancel",
    Accepted = "Accepted",
    Rejected = "Rejected",
}

export enum ApplyWanted {
    Online = "Online",
    Offline = "Offline",
}

export class AuditApplyFormInput implements IAuditApplyFormInput {
    applyFormId!: number;
    applyStatus!: ApplyStatus;
    resultMessage!: string | undefined;

    constructor(data?: IAuditApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applyFormId = _data["applyFormId"];
            this.applyStatus = _data["applyStatus"];
            this.resultMessage = _data["resultMessage"];
        }
    }

    static fromJS(data: any): AuditApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applyFormId"] = this.applyFormId;
        data["applyStatus"] = this.applyStatus;
        data["resultMessage"] = this.resultMessage;
        return data; 
    }
}

export interface IAuditApplyFormInput {
    applyFormId: number;
    applyStatus: ApplyStatus;
    resultMessage: string | undefined;
}

export enum AuditStatus {
    Offline = "Offline",
    Online = "Online",
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class AutoGenerateTrainingInput implements IAutoGenerateTrainingInput {
    userId!: number;
    courseTagId!: number;
    startTime!: moment.Moment;

    constructor(data?: IAutoGenerateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.courseTagId = _data["courseTagId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AutoGenerateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AutoGenerateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["courseTagId"] = this.courseTagId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAutoGenerateTrainingInput {
    userId: number;
    courseTagId: number;
    startTime: moment.Moment;
}

export class Award implements IAward {
    tenantId!: number;
    activityId!: number;
    activity!: Activity;
    planQty!: number;
    actualQty!: number;
    name!: string | undefined;
    awardSeq!: number;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number;
    minScore!: number;
    maxScore!: number;
    isRandomAward!: boolean;
    description!: string | undefined;
    type!: AwardType;
    couponUrl!: string | undefined;
    thingType!: ThingType;
    thingId!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.name = _data["name"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.rate = _data["rate"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.isRandomAward = _data["isRandomAward"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.thingType = _data["thingType"];
            this.thingId = _data["thingId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Award {
        data = typeof data === 'object' ? data : {};
        let result = new Award();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAward {
    tenantId: number;
    activityId: number;
    activity: Activity;
    planQty: number;
    actualQty: number;
    name: string | undefined;
    awardSeq: number;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number;
    minScore: number;
    maxScore: number;
    isRandomAward: boolean;
    description: string | undefined;
    type: AwardType;
    couponUrl: string | undefined;
    thingType: ThingType;
    thingId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AwardDataInput implements IAwardDataInput {
    awardId!: number;
    isNeedSendNotify!: boolean;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IAwardDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.awardId = _data["awardId"];
            this.isNeedSendNotify = _data["isNeedSendNotify"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): AwardDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardId"] = this.awardId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IAwardDataInput {
    awardId: number;
    isNeedSendNotify: boolean;
    securityKey: string;
    params: string | undefined;
}

export class AwardDto implements IAwardDto {
    /** 所属的租户 Id */
    tenantId!: number;
    /** 活动id */
    activityId!: number;
    /** 计划奖品数 */
    planQty!: number;
    /** 已发奖品数 */
    actualQty!: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name!: string | undefined;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq!: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct!: string | undefined;
    /** 奖品图片 */
    awardImagePath!: string | undefined;
    /** 中奖概率 */
    rate!: number;
    /** 最低中奖分数 */
    minScore!: number;
    /** 最高中奖分数 */
    maxScore!: number;
    /** Random Award Switch. Not used now. */
    isRandomAward!: boolean;
    /** 描述 */
    description!: string | undefined;
    type!: AwardType;
    couponUrl!: string | undefined;
    thingType!: ThingType;
    thingId!: number;
    id!: number;

    constructor(data?: IAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.name = _data["name"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.rate = _data["rate"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.isRandomAward = _data["isRandomAward"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.thingType = _data["thingType"];
            this.thingId = _data["thingId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAwardDto {
    /** 所属的租户 Id */
    tenantId: number;
    /** 活动id */
    activityId: number;
    /** 计划奖品数 */
    planQty: number;
    /** 已发奖品数 */
    actualQty: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name: string | undefined;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct: string | undefined;
    /** 奖品图片 */
    awardImagePath: string | undefined;
    /** 中奖概率 */
    rate: number;
    /** 最低中奖分数 */
    minScore: number;
    /** 最高中奖分数 */
    maxScore: number;
    /** Random Award Switch. Not used now. */
    isRandomAward: boolean;
    /** 描述 */
    description: string | undefined;
    type: AwardType;
    couponUrl: string | undefined;
    thingType: ThingType;
    thingId: number;
    id: number;
}

export class AwardMessageSettingsDto implements IAwardMessageSettingsDto {
    id!: number | undefined;
    htmlTemplateID!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    /** 当消息类型是文本时，输出的内容。 */
    textMessage!: string | undefined;

    constructor(data?: IAwardMessageSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.htmlTemplateID = _data["htmlTemplateID"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
        }
    }

    static fromJS(data: any): AwardMessageSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardMessageSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        return data; 
    }
}

export interface IAwardMessageSettingsDto {
    id: number | undefined;
    htmlTemplateID: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    /** 当消息类型是文本时，输出的内容。 */
    textMessage: string | undefined;
}

export class AwardMessageSettingsInput implements IAwardMessageSettingsInput {
    activityId!: number;
    id!: number | undefined;
    htmlTemplateID!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    /** 当消息类型是文本时，输出的内容。 */
    textMessage!: string | undefined;

    constructor(data?: IAwardMessageSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.id = _data["id"];
            this.htmlTemplateID = _data["htmlTemplateID"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
        }
    }

    static fromJS(data: any): AwardMessageSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardMessageSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["id"] = this.id;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        return data; 
    }
}

export interface IAwardMessageSettingsInput {
    activityId: number;
    id: number | undefined;
    htmlTemplateID: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    /** 当消息类型是文本时，输出的内容。 */
    textMessage: string | undefined;
}

export class AwardOutput implements IAwardOutput {
    tenantId!: number;
    activityId!: number;
    planQty!: number;
    actualQty!: number;
    name!: string | undefined;
    awardSeq!: number;
    awardProduct!: string | undefined;
    awardImagePath!: string | undefined;
    rate!: number;
    minScore!: number;
    maxScore!: number;
    isRandomAward!: boolean;
    description!: string | undefined;
    type!: AwardType;
    couponUrl!: string | undefined;
    thingType!: ThingType;
    thingId!: number;
    id!: number;

    constructor(data?: IAwardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.name = _data["name"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.rate = _data["rate"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.isRandomAward = _data["isRandomAward"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.thingType = _data["thingType"];
            this.thingId = _data["thingId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AwardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AwardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAwardOutput {
    tenantId: number;
    activityId: number;
    planQty: number;
    actualQty: number;
    name: string | undefined;
    awardSeq: number;
    awardProduct: string | undefined;
    awardImagePath: string | undefined;
    rate: number;
    minScore: number;
    maxScore: number;
    isRandomAward: boolean;
    description: string | undefined;
    type: AwardType;
    couponUrl: string | undefined;
    thingType: ThingType;
    thingId: number;
    id: number;
}

export class AwardSettingsDto implements IAwardSettingsDto {
    id!: number;
    /** 是否启用白名单 */
    isEnableWhiteUser!: boolean;
    /** 是否启用黑名单 */
    isEnableBlackUser!: boolean;
    /** 是否允许某一个人重复中奖 */
    isAllowedRepeatAward!: boolean;
    repeatAwardDurations!: number | undefined;
    /** 重复中奖对应次数 */
    repeatAwardTimes!: number | undefined;
    /** 是否分享获取次数 */
    isAllowedShareGetLotteryTimes!: boolean;
    /** 重复分享对应间隔 */
    shareDurations!: number | undefined;
    /** 重复分享对应获得抽奖次数 */
    shareLotteryTimes!: number | undefined;
    /** 是否需要填写中奖信息，如地址姓名电话等。 */
    isNeedAwardInfo!: boolean;
    /** 是否区分奖品分类 */
    isAwardType!: boolean;

    constructor(data?: IAwardSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isEnableWhiteUser = _data["isEnableWhiteUser"];
            this.isEnableBlackUser = _data["isEnableBlackUser"];
            this.isAllowedRepeatAward = _data["isAllowedRepeatAward"];
            this.repeatAwardDurations = _data["repeatAwardDurations"];
            this.repeatAwardTimes = _data["repeatAwardTimes"];
            this.isAllowedShareGetLotteryTimes = _data["isAllowedShareGetLotteryTimes"];
            this.shareDurations = _data["shareDurations"];
            this.shareLotteryTimes = _data["shareLotteryTimes"];
            this.isNeedAwardInfo = _data["isNeedAwardInfo"];
            this.isAwardType = _data["isAwardType"];
        }
    }

    static fromJS(data: any): AwardSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEnableWhiteUser"] = this.isEnableWhiteUser;
        data["isEnableBlackUser"] = this.isEnableBlackUser;
        data["isAllowedRepeatAward"] = this.isAllowedRepeatAward;
        data["repeatAwardDurations"] = this.repeatAwardDurations;
        data["repeatAwardTimes"] = this.repeatAwardTimes;
        data["isAllowedShareGetLotteryTimes"] = this.isAllowedShareGetLotteryTimes;
        data["shareDurations"] = this.shareDurations;
        data["shareLotteryTimes"] = this.shareLotteryTimes;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isAwardType"] = this.isAwardType;
        return data; 
    }
}

export interface IAwardSettingsDto {
    id: number;
    /** 是否启用白名单 */
    isEnableWhiteUser: boolean;
    /** 是否启用黑名单 */
    isEnableBlackUser: boolean;
    /** 是否允许某一个人重复中奖 */
    isAllowedRepeatAward: boolean;
    repeatAwardDurations: number | undefined;
    /** 重复中奖对应次数 */
    repeatAwardTimes: number | undefined;
    /** 是否分享获取次数 */
    isAllowedShareGetLotteryTimes: boolean;
    /** 重复分享对应间隔 */
    shareDurations: number | undefined;
    /** 重复分享对应获得抽奖次数 */
    shareLotteryTimes: number | undefined;
    /** 是否需要填写中奖信息，如地址姓名电话等。 */
    isNeedAwardInfo: boolean;
    /** 是否区分奖品分类 */
    isAwardType: boolean;
}

export enum AwardType {
    Coupon = "Coupon",
    Product = "Product",
    Placeholder = "Placeholder",
}

export class BaseButton implements IBaseButton {
    name!: string | undefined;

    constructor(data?: IBaseButton) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BaseButton {
        data = typeof data === 'object' ? data : {};
        let result = new BaseButton();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IBaseButton {
    name: string | undefined;
}

export class BatchSetCourseTagsInput implements IBatchSetCourseTagsInput {
    tagIds!: number[] | undefined;
    courseIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: IBatchSetCourseTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["courseIds"])) {
                this.courseIds = [] as any;
                for (let item of _data["courseIds"])
                    this.courseIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): BatchSetCourseTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new BatchSetCourseTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.courseIds)) {
            data["courseIds"] = [];
            for (let item of this.courseIds)
                data["courseIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IBatchSetCourseTagsInput {
    tagIds: number[] | undefined;
    courseIds: number[] | undefined;
    action: string | undefined;
}

export class CargoResultDto implements ICargoResultDto {
    thingId!: number | undefined;
    thingName!: string | undefined;
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    userAwardId!: number;

    constructor(data?: ICargoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.thingName = _data["thingName"];
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.userAwardId = _data["userAwardId"];
        }
    }

    static fromJS(data: any): CargoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["thingName"] = this.thingName;
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["userAwardId"] = this.userAwardId;
        return data; 
    }
}

export interface ICargoResultDto {
    thingId: number | undefined;
    thingName: string | undefined;
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    userAwardId: number;
}

export class CargoStock implements ICargoStock {
    cargoRoadId!: number;
    replenishCargoThing!: ReplenishCargoThingInput[] | undefined;

    constructor(data?: ICargoStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cargoRoadId = _data["cargoRoadId"];
            if (Array.isArray(_data["replenishCargoThing"])) {
                this.replenishCargoThing = [] as any;
                for (let item of _data["replenishCargoThing"])
                    this.replenishCargoThing!.push(ReplenishCargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoStock {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargoRoadId"] = this.cargoRoadId;
        if (Array.isArray(this.replenishCargoThing)) {
            data["replenishCargoThing"] = [];
            for (let item of this.replenishCargoThing)
                data["replenishCargoThing"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoStock {
    cargoRoadId: number;
    replenishCargoThing: ReplenishCargoThingInput[] | undefined;
}

export class ChartItem implements IChartItem {
    date!: string | undefined;
    value!: number;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        return data; 
    }
}

export interface IChartItem {
    date: string | undefined;
    value: number;
}

export class ChartReportDto implements IChartReportDto {
    title!: string | undefined;
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IChartReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of _data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartReportDto {
    title: string | undefined;
    chartItems: ChartItem[] | undefined;
}

export class ClearActivityDataInput implements IClearActivityDataInput {
    isClearAction!: boolean;
    isClearUserData!: boolean;
    isClearAward!: boolean;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IClearActivityDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isClearAction = _data["isClearAction"];
            this.isClearUserData = _data["isClearUserData"];
            this.isClearAward = _data["isClearAward"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): ClearActivityDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearActivityDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IClearActivityDataInput {
    isClearAction: boolean;
    isClearUserData: boolean;
    isClearAward: boolean;
    securityKey: string;
    params: string | undefined;
}

export class ClearActivityUserDataInput implements IClearActivityUserDataInput {
    activityId!: number;
    snsUserInfoId!: number;

    constructor(data?: IClearActivityUserDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.snsUserInfoId = _data["snsUserInfoId"];
        }
    }

    static fromJS(data: any): ClearActivityUserDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearActivityUserDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        return data; 
    }
}

export interface IClearActivityUserDataInput {
    activityId: number;
    snsUserInfoId: number;
}

export class ClearSnsUserDataInput implements IClearSnsUserDataInput {
    isClearAction!: boolean;
    isClearUserData!: boolean;
    isClearAward!: boolean;
    openId!: string;
    snsType!: _definitions_EnumSnsType;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IClearSnsUserDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isClearAction = _data["isClearAction"];
            this.isClearUserData = _data["isClearUserData"];
            this.isClearAward = _data["isClearAward"];
            this.openId = _data["openId"];
            this.snsType = _data["snsType"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): ClearSnsUserDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearSnsUserDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IClearSnsUserDataInput {
    isClearAction: boolean;
    isClearUserData: boolean;
    isClearAward: boolean;
    openId: string;
    snsType: _definitions_EnumSnsType;
    securityKey: string;
    params: string | undefined;
}

export class ConditionalButtonGroup implements IConditionalButtonGroup {
    matchrule!: MenuMatchRule;
    menuid!: number;
    button!: BaseButton[] | undefined;

    constructor(data?: IConditionalButtonGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchrule = _data["matchrule"] ? MenuMatchRule.fromJS(_data["matchrule"]) : <any>undefined;
            this.menuid = _data["menuid"];
            if (Array.isArray(_data["button"])) {
                this.button = [] as any;
                for (let item of _data["button"])
                    this.button!.push(BaseButton.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionalButtonGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalButtonGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchrule"] = this.matchrule ? this.matchrule.toJSON() : <any>undefined;
        data["menuid"] = this.menuid;
        if (Array.isArray(this.button)) {
            data["button"] = [];
            for (let item of this.button)
                data["button"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConditionalButtonGroup {
    matchrule: MenuMatchRule;
    menuid: number;
    button: BaseButton[] | undefined;
}

export class Course implements ICourse {
    tenantId!: number;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    courseTags!: CourseTag[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.courseNo = _data["courseNo"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["courseTags"])) {
                this.courseTags = [] as any;
                for (let item of _data["courseTags"])
                    this.courseTags!.push(CourseTag.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.courseTags)) {
            data["courseTags"] = [];
            for (let item of this.courseTags)
                data["courseTags"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICourse {
    tenantId: number;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    courseTags: CourseTag[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CourseDto implements ICourseDto {
    id!: number;
    tenantId!: number;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    courseTags!: IdNameDto[] | undefined;

    constructor(data?: ICourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.courseNo = _data["courseNo"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["courseTags"])) {
                this.courseTags = [] as any;
                for (let item of _data["courseTags"])
                    this.courseTags!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.courseTags)) {
            data["courseTags"] = [];
            for (let item of this.courseTags)
                data["courseTags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICourseDto {
    id: number;
    tenantId: number;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    courseTags: IdNameDto[] | undefined;
}

export class CourseTag implements ICourseTag {
    tenantId!: number;
    courseId!: number;
    course!: Course;
    tagId!: number;
    tag!: Tag;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICourseTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CourseTag {
        data = typeof data === 'object' ? data : {};
        let result = new CourseTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICourseTag {
    tenantId: number;
    courseId: number;
    course: Course;
    tagId: number;
    tag: Tag;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateActionShareInput implements ICreateActionShareInput {
    title!: string | undefined;
    /** 分享链接 */
    link!: string | undefined;
    /** 分享图标 */
    imageLink!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    activityShareType!: EnumActivityShareType;

    constructor(data?: ICreateActionShareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.link = _data["link"];
            this.imageLink = _data["imageLink"];
            this.description = _data["description"];
            this.activityShareType = _data["activityShareType"];
        }
    }

    static fromJS(data: any): CreateActionShareInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionShareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["imageLink"] = this.imageLink;
        data["description"] = this.description;
        data["activityShareType"] = this.activityShareType;
        return data; 
    }
}

export interface ICreateActionShareInput {
    title: string | undefined;
    /** 分享链接 */
    link: string | undefined;
    /** 分享图标 */
    imageLink: string | undefined;
    /** 描述 */
    description: string | undefined;
    activityShareType: EnumActivityShareType;
}

export class CreateApplyFormInput implements ICreateApplyFormInput {
    reason!: string | undefined;
    applyType!: ApplyFormType;
    wanted!: ApplyWanted;
    /** 申请的项目id */
    itemids!: number[] | undefined;
    /** 申请时的额外参数, All,Party */
    options!: string | undefined;

    constructor(data?: ICreateApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            if (Array.isArray(_data["itemids"])) {
                this.itemids = [] as any;
                for (let item of _data["itemids"])
                    this.itemids!.push(item);
            }
            this.options = _data["options"];
        }
    }

    static fromJS(data: any): CreateApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        if (Array.isArray(this.itemids)) {
            data["itemids"] = [];
            for (let item of this.itemids)
                data["itemids"].push(item);
        }
        data["options"] = this.options;
        return data; 
    }
}

export interface ICreateApplyFormInput {
    reason: string | undefined;
    applyType: ApplyFormType;
    wanted: ApplyWanted;
    /** 申请的项目id */
    itemids: number[] | undefined;
    /** 申请时的额外参数, All,Party */
    options: string | undefined;
}

export class CreateAwardInput implements ICreateAwardInput {
    /** 活动id */
    activityId!: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name!: string | undefined;
    /** 计划奖品数 */
    planQty!: number;
    /** 已发奖品数 */
    actualQty!: number;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq!: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct!: string | undefined;
    /** 奖品图片 */
    awardImagePath!: string | undefined;
    /** 最低中奖分数 */
    minScore!: number;
    /** 最高中奖分数 */
    maxScore!: number;
    /** 中奖概率 */
    rate!: number;
    /** 描述 */
    description!: string | undefined;
    /** Random Award Switch. Not used now. */
    isRandomAward!: boolean;
    type!: AwardType;
    couponUrl!: string | undefined;
    thingType!: ThingType;
    thingId!: number;

    constructor(data?: ICreateAwardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.isRandomAward = _data["isRandomAward"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.thingType = _data["thingType"];
            this.thingId = _data["thingId"];
        }
    }

    static fromJS(data: any): CreateAwardInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAwardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["isRandomAward"] = this.isRandomAward;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface ICreateAwardInput {
    /** 活动id */
    activityId: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name: string | undefined;
    /** 计划奖品数 */
    planQty: number;
    /** 已发奖品数 */
    actualQty: number;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct: string | undefined;
    /** 奖品图片 */
    awardImagePath: string | undefined;
    /** 最低中奖分数 */
    minScore: number;
    /** 最高中奖分数 */
    maxScore: number;
    /** 中奖概率 */
    rate: number;
    /** 描述 */
    description: string | undefined;
    /** Random Award Switch. Not used now. */
    isRandomAward: boolean;
    type: AwardType;
    couponUrl: string | undefined;
    thingType: ThingType;
    thingId: number;
}

export class CreateBasicActivityInput implements ICreateBasicActivityInput {
    /** 活动名称 */
    name!: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate!: moment.Moment | undefined;
    /** 活动主办方 */
    organizer!: string | undefined;
    /** 活动的所有者 */
    ownerName!: string | undefined;
    /** 活动线下地址 */
    address!: string | undefined;
    /** 活动开始时间 */
    openDate!: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate!: moment.Moment | undefined;
    /** 活动描述 */
    description!: string | undefined;
    /** 次活动需要注册， */
    isNeedRegister!: boolean;
    /** 活动注册的人是否需要人工验证 */
    isNeedValidate!: boolean;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic!: boolean;
    /** 公众号AppId/Taobao卖家的Id */
    weChatAppID!: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId!: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId!: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID!: string | undefined;
    /** 活动规则 */
    rules!: string | undefined;
    /** 活动Logo的url */
    activityLogoPath!: string | undefined;
    /** 活动图片 */
    imagePath!: string | undefined;
    /** 该活动是否是模板 */
    isTemplate!: boolean;
    auditStatus!: AuditStatus;
    organizationUnitId!: number | undefined;

    constructor(data?: ICreateBasicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.organizer = _data["organizer"];
            this.ownerName = _data["ownerName"];
            this.address = _data["address"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isNeedRegister = _data["isNeedRegister"];
            this.isNeedValidate = _data["isNeedValidate"];
            this.isPublic = _data["isPublic"];
            this.weChatAppID = _data["weChatAppID"];
            this.weixinPublicAccountInfoId = _data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.rules = _data["rules"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.imagePath = _data["imagePath"];
            this.isTemplate = _data["isTemplate"];
            this.auditStatus = _data["auditStatus"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateBasicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBasicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["organizer"] = this.organizer;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["isPublic"] = this.isPublic;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["rules"] = this.rules;
        data["activityLogoPath"] = this.activityLogoPath;
        data["imagePath"] = this.imagePath;
        data["isTemplate"] = this.isTemplate;
        data["auditStatus"] = this.auditStatus;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateBasicActivityInput {
    /** 活动名称 */
    name: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate: moment.Moment | undefined;
    /** 活动主办方 */
    organizer: string | undefined;
    /** 活动的所有者 */
    ownerName: string | undefined;
    /** 活动线下地址 */
    address: string | undefined;
    /** 活动开始时间 */
    openDate: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate: moment.Moment | undefined;
    /** 活动描述 */
    description: string | undefined;
    /** 次活动需要注册， */
    isNeedRegister: boolean;
    /** 活动注册的人是否需要人工验证 */
    isNeedValidate: boolean;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic: boolean;
    /** 公众号AppId/Taobao卖家的Id */
    weChatAppID: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID: string | undefined;
    /** 活动规则 */
    rules: string | undefined;
    /** 活动Logo的url */
    activityLogoPath: string | undefined;
    /** 活动图片 */
    imagePath: string | undefined;
    /** 该活动是否是模板 */
    isTemplate: boolean;
    auditStatus: AuditStatus;
    organizationUnitId: number | undefined;
}

export class CreateCourseInput implements ICreateCourseInput {
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: ICreateCourseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.courseNo = _data["courseNo"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCourseInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateCourseInput {
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    tagIds: number[] | undefined;
}

export class CreateDeviceActivityGameInput implements ICreateDeviceActivityGameInput {
    deviceId!: number;
    activityId!: number;
    name!: string;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode!: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount!: number;
    /** 游戏密钥 */
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessage!: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame!: boolean;
    afterGameMessage!: CreateSnsMsgGameInput;
    isShareAction!: boolean;
    actionShare!: CreateActionShareInput;
    extensionData!: string | undefined;

    constructor(data?: ICreateDeviceActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = _data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShare = _data["actionShare"] ? CreateActionShareInput.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): CreateDeviceActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateDeviceActivityGameInput {
    deviceId: number;
    activityId: number;
    name: string;
    softwareId: number;
    dispatchedSoftwareId: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount: number;
    /** 游戏密钥 */
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessage: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame: boolean;
    afterGameMessage: CreateSnsMsgGameInput;
    isShareAction: boolean;
    actionShare: CreateActionShareInput;
    extensionData: string | undefined;
}

export class CreateHtmlTemplateInput implements ICreateHtmlTemplateInput {
    /** 缩略图 */
    thumbnail!: string | undefined;
    /** 大图 */
    bigImage!: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl!: string | undefined;
    /** 备用字段 */
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: TemplateEnum;
    /** 描述 */
    description!: string | undefined;
    args!: string | undefined;

    constructor(data?: ICreateHtmlTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thumbnail = _data["thumbnail"];
            this.bigImage = _data["bigImage"];
            this.actionUrl = _data["actionUrl"];
            this.title = _data["title"];
            this.logo = _data["logo"];
            this.backgroundImage = _data["backgroundImage"];
            this.templateType = _data["templateType"];
            this.description = _data["description"];
            this.args = _data["args"];
        }
    }

    static fromJS(data: any): CreateHtmlTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHtmlTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        return data; 
    }
}

export interface ICreateHtmlTemplateInput {
    /** 缩略图 */
    thumbnail: string | undefined;
    /** 大图 */
    bigImage: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl: string | undefined;
    /** 备用字段 */
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: TemplateEnum;
    /** 描述 */
    description: string | undefined;
    args: string | undefined;
}

export class CreatePaperInput implements ICreatePaperInput {
    /** 试卷名称,必须唯一 */
    name!: string | undefined;
    displayName!: string | undefined;
    /** 试卷的Logo图 */
    logoUrl!: string | undefined;
    /** 试卷的图片 */
    imageUrl!: string | undefined;
    /** 试卷的描述 */
    description!: string | undefined;
    /** 试卷的组织者 */
    owner!: string | undefined;
    /** 试卷时怎么生产的 */
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number;
    compositionType!: PaperCompositionEnum;
    paperUsageType!: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount!: number;
    tagIds!: number[] | undefined;

    constructor(data?: ICreatePaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.description = _data["description"];
            this.owner = _data["owner"];
            this.fromType = _data["fromType"];
            this.extensionData = _data["extensionData"];
            this.outerId = _data["outerId"];
            this.questionsCount = _data["questionsCount"];
            this.compositionType = _data["compositionType"];
            this.paperUsageType = _data["paperUsageType"];
            this.randomCount = _data["randomCount"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreatePaperInput {
    /** 试卷名称,必须唯一 */
    name: string | undefined;
    displayName: string | undefined;
    /** 试卷的Logo图 */
    logoUrl: string | undefined;
    /** 试卷的图片 */
    imageUrl: string | undefined;
    /** 试卷的描述 */
    description: string | undefined;
    /** 试卷的组织者 */
    owner: string | undefined;
    /** 试卷时怎么生产的 */
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number;
    compositionType: PaperCompositionEnum;
    paperUsageType: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount: number;
    tagIds: number[] | undefined;
}

export class CreateQuestionInput implements ICreateQuestionInput {
    /** Question的名称 */
    prefix!: string | undefined;
    /** 问题标题 */
    title!: string | undefined;
    type!: QuestionTypeEnum;
    /** 此道题的得分 */
    score!: number;
    /** 题目的顺序 */
    orderNo!: number;
    /** 内容 */
    content!: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    enabled!: boolean;
    outerId!: string | undefined;
    questionScoreType!: QuestionScoreTypeEnum;
    questionItems!: QuestionItemDto[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: ICreateQuestionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prefix = _data["prefix"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.score = _data["score"];
            this.orderNo = _data["orderNo"];
            this.content = _data["content"];
            this.answer = _data["answer"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.enabled = _data["enabled"];
            this.outerId = _data["outerId"];
            this.questionScoreType = _data["questionScoreType"];
            if (Array.isArray(_data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of _data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateQuestionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateQuestionInput {
    /** Question的名称 */
    prefix: string | undefined;
    /** 问题标题 */
    title: string | undefined;
    type: QuestionTypeEnum;
    /** 此道题的得分 */
    score: number;
    /** 题目的顺序 */
    orderNo: number;
    /** 内容 */
    content: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    enabled: boolean;
    outerId: string | undefined;
    questionScoreType: QuestionScoreTypeEnum;
    questionItems: QuestionItemDto[] | undefined;
    tagIds: number[] | undefined;
}

export class CreateSnsMsgGameInput implements ICreateSnsMsgGameInput {
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: EnumWeChatType;
    htmlTemplateID!: number | undefined;

    constructor(data?: ICreateSnsMsgGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
            this.weChatType = _data["weChatType"];
            this.htmlTemplateID = _data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): CreateSnsMsgGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSnsMsgGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ICreateSnsMsgGameInput {
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: EnumWeChatType;
    htmlTemplateID: number | undefined;
}

export class CreateSpecialUserInput implements ICreateSpecialUserInput {
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    type!: SpecialType;

    constructor(data?: ICreateSpecialUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.awardSeqs = _data["awardSeqs"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.description = _data["description"];
            this.forAward = _data["forAward"];
            this.forLottery = _data["forLottery"];
            this.forUseTicket = _data["forUseTicket"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateSpecialUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSpecialUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICreateSpecialUserInput {
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    type: SpecialType;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    orderNumber: number;
    description: string | undefined;
}

export class CreateTrainingInput implements ICreateTrainingInput {
    title!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingCategoryEnum;
    auditStatus!: AuditStatus;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingWayEnum;
    /** 主讲人用户Id */
    userId!: number | undefined;
    courseId!: number | undefined;
    groupIds!: number[] | undefined;
    paperId!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICreateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.category = _data["category"];
            this.auditStatus = _data["auditStatus"];
            this.totalLength = _data["totalLength"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.trainingWay = _data["trainingWay"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.paperId = _data["paperId"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): CreateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["paperId"] = this.paperId;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateTrainingInput {
    title: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingCategoryEnum;
    auditStatus: AuditStatus;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingWayEnum;
    /** 主讲人用户Id */
    userId: number | undefined;
    courseId: number | undefined;
    groupIds: number[] | undefined;
    paperId: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class CreateUserActionInput implements ICreateUserActionInput {
    /** 基本微信用户数据 */
    snsUserInfoId!: number;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    /** 分享后浏览的次数 */
    viewCount!: number;
    /** 分享后点赞的次数 */
    likeCount!: number;
    score!: number | undefined;
    /** 游戏图片 */
    gameImage!: string | undefined;

    constructor(data?: ICreateUserActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.score = _data["score"];
            this.gameImage = _data["gameImage"];
        }
    }

    static fromJS(data: any): CreateUserActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["score"] = this.score;
        data["gameImage"] = this.gameImage;
        return data; 
    }
}

export interface ICreateUserActionInput {
    /** 基本微信用户数据 */
    snsUserInfoId: number;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    /** 分享后浏览的次数 */
    viewCount: number;
    /** 分享后点赞的次数 */
    likeCount: number;
    score: number | undefined;
    /** 游戏图片 */
    gameImage: string | undefined;
}

export class DeviceActivity implements IDeviceActivity {
    deviceId!: number;
    activityId!: number;
    activity!: Activity;
    dispatchedActivityId!: number | undefined;
    dispatchedActivity!: DispatchedActivity;
    games!: DeviceActivityGame[] | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.dispatchedActivity = _data["dispatchedActivity"] ? DispatchedActivity.fromJS(_data["dispatchedActivity"]) : <any>undefined;
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(DeviceActivityGame.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["dispatchedActivity"] = this.dispatchedActivity ? this.dispatchedActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivity {
    deviceId: number;
    activityId: number;
    activity: Activity;
    dispatchedActivityId: number | undefined;
    dispatchedActivity: DispatchedActivity;
    games: DeviceActivityGame[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DeviceActivityDto implements IDeviceActivityDto {
    /** 设备 Id */
    deviceId!: number;
    activityId!: number;
    activity!: ActivityBasicDto;
    dispatchedActivityId!: number | undefined;
    games!: DeviceActivityGameDto[] | undefined;

    constructor(data?: IDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? ActivityBasicDto.fromJS(_data["activity"]) : <any>undefined;
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(DeviceActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceActivityDto {
    /** 设备 Id */
    deviceId: number;
    activityId: number;
    activity: ActivityBasicDto;
    dispatchedActivityId: number | undefined;
    games: DeviceActivityGameDto[] | undefined;
}

export class DeviceActivityGame implements IDeviceActivityGame {
    dispatchedActivityId!: number | undefined;
    deviceId!: number | undefined;
    deviceActivityId!: number | undefined;
    deviceActivity!: DeviceActivity;
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    activityId!: number;
    activity!: Activity;
    isShareAction!: boolean;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare;
    supportedPlayersCount!: number;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage;
    isSendSnsMsgAfterGame!: boolean;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    extensionData!: string | undefined;
    points!: number;
    isAllowBlack!: boolean;
    isAllowWhite!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.deviceId = _data["deviceId"];
            this.deviceActivityId = _data["deviceActivityId"];
            this.deviceActivity = _data["deviceActivity"] ? DeviceActivity.fromJS(_data["deviceActivity"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActivityShare.fromJS(_data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMessage.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMessage.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.extensionData = _data["extensionData"];
            this.points = _data["points"];
            this.isAllowBlack = _data["isAllowBlack"];
            this.isAllowWhite = _data["isAllowWhite"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["deviceId"] = this.deviceId;
        data["deviceActivityId"] = this.deviceActivityId;
        data["deviceActivity"] = this.deviceActivity ? this.deviceActivity.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["isAllowBlack"] = this.isAllowBlack;
        data["isAllowWhite"] = this.isAllowWhite;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGame {
    dispatchedActivityId: number | undefined;
    deviceId: number | undefined;
    deviceActivityId: number | undefined;
    deviceActivity: DeviceActivity;
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    activityId: number;
    activity: Activity;
    isShareAction: boolean;
    actionShareId: number | undefined;
    actionShare: ActivityShare;
    supportedPlayersCount: number;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage;
    isSendSnsMsgAfterGame: boolean;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    extensionData: string | undefined;
    points: number;
    isAllowBlack: boolean;
    isAllowWhite: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DeviceActivityGameDto implements IDeviceActivityGameDto {
    creationTime!: moment.Moment;
    name!: string | undefined;
    supportedPlayersCount!: number;
    isSendSnsMsgBeforeGame!: boolean;

    constructor(data?: IDeviceActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
        }
    }

    static fromJS(data: any): DeviceActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        return data; 
    }
}

export interface IDeviceActivityGameDto {
    creationTime: moment.Moment;
    name: string | undefined;
    supportedPlayersCount: number;
    isSendSnsMsgBeforeGame: boolean;
}

export class DeviceActivityGameOutput implements IDeviceActivityGameOutput {
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    software!: SoftwareOutput;
    dispatchedSoftwareId!: number;
    deviceId!: number | undefined;
    subKey!: string | undefined;
    activityId!: number;
    activity!: ActivityOutput;
    isShareAction!: boolean;
    dispatchedActivityId!: number | undefined;
    supportedPlayersCount!: number;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    actionShareId!: number | undefined;
    actionShare!: ActivityShareOutput;
    extensionData!: string | undefined;
    points!: number;
    id!: number;

    constructor(data?: IDeviceActivityGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.software = _data["software"] ? SoftwareOutput.fromJS(_data["software"]) : <any>undefined;
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.deviceId = _data["deviceId"];
            this.subKey = _data["subKey"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? ActivityOutput.fromJS(_data["activity"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActivityShareOutput.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.points = _data["points"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["deviceId"] = this.deviceId;
        data["subKey"] = this.subKey;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGameOutput {
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    software: SoftwareOutput;
    dispatchedSoftwareId: number;
    deviceId: number | undefined;
    subKey: string | undefined;
    activityId: number;
    activity: ActivityOutput;
    isShareAction: boolean;
    dispatchedActivityId: number | undefined;
    supportedPlayersCount: number;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    actionShareId: number | undefined;
    actionShare: ActivityShareOutput;
    extensionData: string | undefined;
    points: number;
    id: number;
}

export class DeviceActivityGameSimpleOutput implements IDeviceActivityGameSimpleOutput {
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    software!: SoftwareOutput;
    dispatchedSoftwareId!: number;
    deviceId!: number | undefined;
    activityId!: number;
    isShareAction!: boolean;
    dispatchedActivityId!: number | undefined;
    supportedPlayersCount!: number;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    actionShareId!: number | undefined;
    extensionData!: string | undefined;
    points!: number;
    imageLink!: string | undefined;
    id!: number;

    constructor(data?: IDeviceActivityGameSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.software = _data["software"] ? SoftwareOutput.fromJS(_data["software"]) : <any>undefined;
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.deviceId = _data["deviceId"];
            this.activityId = _data["activityId"];
            this.isShareAction = _data["isShareAction"];
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.actionShareId = _data["actionShareId"];
            this.extensionData = _data["extensionData"];
            this.points = _data["points"];
            this.imageLink = _data["imageLink"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceActivityGameSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActivityGameSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["deviceId"] = this.deviceId;
        data["activityId"] = this.activityId;
        data["isShareAction"] = this.isShareAction;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["actionShareId"] = this.actionShareId;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["imageLink"] = this.imageLink;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceActivityGameSimpleOutput {
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    software: SoftwareOutput;
    dispatchedSoftwareId: number;
    deviceId: number | undefined;
    activityId: number;
    isShareAction: boolean;
    dispatchedActivityId: number | undefined;
    supportedPlayersCount: number;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    actionShareId: number | undefined;
    extensionData: string | undefined;
    points: number;
    imageLink: string | undefined;
    id: number;
}

/** 设备镜像发布 */
export class DeviceMirrorPublishInput implements IDeviceMirrorPublishInput {
    sourceId!: number;
    targetIds!: number[];
    features!: string[];

    constructor(data?: IDeviceMirrorPublishInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.targetIds = [];
            this.features = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
            if (Array.isArray(_data["targetIds"])) {
                this.targetIds = [] as any;
                for (let item of _data["targetIds"])
                    this.targetIds!.push(item);
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceMirrorPublishInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceMirrorPublishInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        if (Array.isArray(this.targetIds)) {
            data["targetIds"] = [];
            for (let item of this.targetIds)
                data["targetIds"].push(item);
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

/** 设备镜像发布 */
export interface IDeviceMirrorPublishInput {
    sourceId: number;
    targetIds: number[];
    features: string[];
}

export class DeviceSimpleDto implements IDeviceSimpleDto {
    id!: number;
    name!: string | undefined;
    mac!: string | undefined;
    os!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    outType!: string | undefined;
    taobaoDeviceId!: string | undefined;
    subKey!: string | undefined;

    constructor(data?: IDeviceSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.os = _data["os"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.outerId = _data["outerId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.outType = _data["outType"];
            this.taobaoDeviceId = _data["taobaoDeviceId"];
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): DeviceSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["os"] = this.os;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["outType"] = this.outType;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface IDeviceSimpleDto {
    id: number;
    name: string | undefined;
    mac: string | undefined;
    os: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    outType: string | undefined;
    taobaoDeviceId: string | undefined;
    subKey: string | undefined;
}

export class DispatchedActivity implements IDispatchedActivity {
    organizationUnitId!: number;
    activityId!: number;
    activity!: Activity;
    games!: DispatchedActivityGame[] | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDispatchedActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(DispatchedActivityGame.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispatchedActivity {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedActivity {
    organizationUnitId: number;
    activityId: number;
    activity: Activity;
    games: DispatchedActivityGame[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DispatchedActivityGame implements IDispatchedActivityGame {
    organizationUnitId!: number;
    dispatchedActivityId!: number;
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    activityId!: number;
    activity!: Activity;
    isShareAction!: boolean;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare;
    supportedPlayersCount!: number;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage;
    isSendSnsMsgAfterGame!: boolean;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDispatchedActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActivityShare.fromJS(_data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMessage.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMessage.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispatchedActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedActivityGame {
    organizationUnitId: number;
    dispatchedActivityId: number;
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    activityId: number;
    activity: Activity;
    isShareAction: boolean;
    actionShareId: number | undefined;
    actionShare: ActivityShare;
    supportedPlayersCount: number;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage;
    isSendSnsMsgAfterGame: boolean;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DispatchedSoftwarePaper implements IDispatchedSoftwarePaper {
    dispatchedSoftwareId!: number;
    paperId!: number;
    paper!: Paper;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDispatchedSoftwarePaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.paperId = _data["paperId"];
            this.paper = _data["paper"] ? Paper.fromJS(_data["paper"]) : <any>undefined;
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispatchedSoftwarePaper {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftwarePaper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDispatchedSoftwarePaper {
    dispatchedSoftwareId: number;
    paperId: number;
    paper: Paper;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DoClearActivityDataInput implements IDoClearActivityDataInput {
    activityId!: number;
    isClearAction!: boolean;
    isClearUserData!: boolean;
    isClearAward!: boolean;

    constructor(data?: IDoClearActivityDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.isClearAction = _data["isClearAction"];
            this.isClearUserData = _data["isClearUserData"];
            this.isClearAward = _data["isClearAward"];
        }
    }

    static fromJS(data: any): DoClearActivityDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoClearActivityDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["isClearAction"] = this.isClearAction;
        data["isClearUserData"] = this.isClearUserData;
        data["isClearAward"] = this.isClearAward;
        return data; 
    }
}

export interface IDoClearActivityDataInput {
    activityId: number;
    isClearAction: boolean;
    isClearUserData: boolean;
    isClearAward: boolean;
}

export class DoLotteryAwardForCargoByActionInput implements IDoLotteryAwardForCargoByActionInput {
    subKey!: string | undefined;
    productId!: number | undefined;
    skuId!: number | undefined;
    awardId!: number | undefined;
    isNeedSendNotify!: boolean;
    score!: number | undefined;
    actionId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IDoLotteryAwardForCargoByActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.productId = _data["productId"];
            this.skuId = _data["skuId"];
            this.awardId = _data["awardId"];
            this.isNeedSendNotify = _data["isNeedSendNotify"];
            this.score = _data["score"];
            this.actionId = _data["actionId"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): DoLotteryAwardForCargoByActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoLotteryAwardForCargoByActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["awardId"] = this.awardId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IDoLotteryAwardForCargoByActionInput {
    subKey: string | undefined;
    productId: number | undefined;
    skuId: number | undefined;
    awardId: number | undefined;
    isNeedSendNotify: boolean;
    score: number | undefined;
    actionId: number;
    securityKey: string;
    params: string | undefined;
}

export class DoLotteryAwardForCargoBySnsInput implements IDoLotteryAwardForCargoBySnsInput {
    subKey!: string | undefined;
    snsUserInfoId!: number;
    isNeedSendNotify!: boolean;
    score!: number | undefined;
    securityKey!: string | undefined;
    params!: string | undefined;
    awardId!: number | undefined;

    constructor(data?: IDoLotteryAwardForCargoBySnsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.isNeedSendNotify = _data["isNeedSendNotify"];
            this.score = _data["score"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
            this.awardId = _data["awardId"];
        }
    }

    static fromJS(data: any): DoLotteryAwardForCargoBySnsInput {
        data = typeof data === 'object' ? data : {};
        let result = new DoLotteryAwardForCargoBySnsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        data["awardId"] = this.awardId;
        return data; 
    }
}

export interface IDoLotteryAwardForCargoBySnsInput {
    subKey: string | undefined;
    snsUserInfoId: number;
    isNeedSendNotify: boolean;
    score: number | undefined;
    securityKey: string | undefined;
    params: string | undefined;
    awardId: number | undefined;
}

export class DouyinMedia implements IDouyinMedia {
    tenantId!: number;
    app_Key!: string | undefined;
    openId!: string | undefined;
    item_id!: string | undefined;
    title!: string | undefined;
    cover!: string | undefined;
    is_top!: boolean;
    create_time!: number;
    is_reviewed!: boolean;
    share_url!: string | undefined;
    videourl!: string | undefined;
    statistics!: string | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDouyinMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.app_Key = _data["app_Key"];
            this.openId = _data["openId"];
            this.item_id = _data["item_id"];
            this.title = _data["title"];
            this.cover = _data["cover"];
            this.is_top = _data["is_top"];
            this.create_time = _data["create_time"];
            this.is_reviewed = _data["is_reviewed"];
            this.share_url = _data["share_url"];
            this.videourl = _data["videourl"];
            this.statistics = _data["statistics"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DouyinMedia {
        data = typeof data === 'object' ? data : {};
        let result = new DouyinMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["app_Key"] = this.app_Key;
        data["openId"] = this.openId;
        data["item_id"] = this.item_id;
        data["title"] = this.title;
        data["cover"] = this.cover;
        data["is_top"] = this.is_top;
        data["create_time"] = this.create_time;
        data["is_reviewed"] = this.is_reviewed;
        data["share_url"] = this.share_url;
        data["videourl"] = this.videourl;
        data["statistics"] = this.statistics;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDouyinMedia {
    tenantId: number;
    app_Key: string | undefined;
    openId: string | undefined;
    item_id: string | undefined;
    title: string | undefined;
    cover: string | undefined;
    is_top: boolean;
    create_time: number;
    is_reviewed: boolean;
    share_url: string | undefined;
    videourl: string | undefined;
    statistics: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DropCargoInput implements IDropCargoInput {
    subkey!: string | undefined;
    cargoRoadId!: number;
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: IDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.extensionData = _data["extensionData"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): DropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new DropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface IDropCargoInput {
    subkey: string | undefined;
    cargoRoadId: number;
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    actionId: number | undefined;
}

export enum EnumActivityShareType {
    Award = "Award",
    ActivityShare = "ActivityShare",
}

export enum EnumMpType {
    Private = "Private",
    Public = "Public",
}

export enum EnumQRStatus {
    BeforeGame = "BeforeGame",
    AfterGame = "AfterGame",
    ActivityIntroduction = "ActivityIntroduction",
    ActivityRegister = "ActivityRegister",
    OnlineGame = "OnlineGame",
    GameResult = "GameResult",
    Award = "Award",
    Game = "Game",
}

export enum EnumWeChatType {
    Text = "Text",
    News = "News",
}

export enum EnumWeixinShareType {
    ShareAppMessage = "ShareAppMessage",
    ShareTimeline = "ShareTimeline",
    ShareQQ = "ShareQQ",
    ShareWeibo = "ShareWeibo",
    ShareQZone = "ShareQZone",
    Like = "Like",
}

export enum ExamEnum {
    NoneOk = "NoneOk",
    PartOk = "PartOk",
    AllOk = "AllOk",
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export enum FlowType {
    Introduction = "Introduction",
    Register = "Register",
    Sign = "Sign",
    GameResult = "GameResult",
    Reward = "Reward",
}

export enum FrequencyType {
    None = "None",
    Day = "Day",
    Week = "Week",
    Month = "Month",
    Year = "Year",
}

export class GetActivityActionsForNextGameDto implements IGetActivityActionsForNextGameDto {
    activityGames!: ActivityGameActionsDto[] | undefined;

    constructor(data?: IGetActivityActionsForNextGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activityGames"])) {
                this.activityGames = [] as any;
                for (let item of _data["activityGames"])
                    this.activityGames!.push(ActivityGameActionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetActivityActionsForNextGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityActionsForNextGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityGames)) {
            data["activityGames"] = [];
            for (let item of this.activityGames)
                data["activityGames"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetActivityActionsForNextGameDto {
    activityGames: ActivityGameActionsDto[] | undefined;
}

export class GetActivityChatInput implements IGetActivityChatInput {
    activityIds!: ActivityAndSoftwareDto[] | undefined;
    startTime!: moment.Moment;
    endTime!: moment.Moment;
    tenantId!: number;

    constructor(data?: IGetActivityChatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activityIds"])) {
                this.activityIds = [] as any;
                for (let item of _data["activityIds"])
                    this.activityIds!.push(ActivityAndSoftwareDto.fromJS(item));
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): GetActivityChatInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityChatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activityIds)) {
            data["activityIds"] = [];
            for (let item of this.activityIds)
                data["activityIds"].push(item.toJSON());
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IGetActivityChatInput {
    activityIds: ActivityAndSoftwareDto[] | undefined;
    startTime: moment.Moment;
    endTime: moment.Moment;
    tenantId: number;
}

export class GetGameImageBase64Input implements IGetGameImageBase64Input {
    imageUrl!: string | undefined;

    constructor(data?: IGetGameImageBase64Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): GetGameImageBase64Input {
        data = typeof data === 'object' ? data : {};
        let result = new GetGameImageBase64Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IGetGameImageBase64Input {
    imageUrl: string | undefined;
}

export class GetLastPlayedUserInfosDto implements IGetLastPlayedUserInfosDto {
    securityKey!: string | undefined;
    deviceGameName!: string | undefined;
    userActions!: UserActionDto[] | undefined;

    constructor(data?: IGetLastPlayedUserInfosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityKey = _data["securityKey"];
            this.deviceGameName = _data["deviceGameName"];
            if (Array.isArray(_data["userActions"])) {
                this.userActions = [] as any;
                for (let item of _data["userActions"])
                    this.userActions!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLastPlayedUserInfosDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLastPlayedUserInfosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        data["deviceGameName"] = this.deviceGameName;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLastPlayedUserInfosDto {
    securityKey: string | undefined;
    deviceGameName: string | undefined;
    userActions: UserActionDto[] | undefined;
}

export class GetLimitQrcodeByWechatInput implements IGetLimitQrcodeByWechatInput {
    action_name!: string | undefined;
    action_info!: ActionInfo;

    constructor(data?: IGetLimitQrcodeByWechatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action_name = _data["action_name"];
            this.action_info = _data["action_info"] ? ActionInfo.fromJS(_data["action_info"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLimitQrcodeByWechatInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLimitQrcodeByWechatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action_name"] = this.action_name;
        data["action_info"] = this.action_info ? this.action_info.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLimitQrcodeByWechatInput {
    action_name: string | undefined;
    action_info: ActionInfo;
}

export class GetMessageSeedDto implements IGetMessageSeedDto {
    id!: number;
    creationTime!: moment.Moment;
    title!: string | undefined;
    messageCode!: string | undefined;
    description!: string | undefined;
    usage!: string | undefined;

    constructor(data?: IGetMessageSeedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.messageCode = _data["messageCode"];
            this.description = _data["description"];
            this.usage = _data["usage"];
        }
    }

    static fromJS(data: any): GetMessageSeedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMessageSeedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["messageCode"] = this.messageCode;
        data["description"] = this.description;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface IGetMessageSeedDto {
    id: number;
    creationTime: moment.Moment;
    title: string | undefined;
    messageCode: string | undefined;
    description: string | undefined;
    usage: string | undefined;
}

export class GetPaperAnswerCompetitionDto implements IGetPaperAnswerCompetitionDto {
    nickName!: string | undefined;
    openId!: string | undefined;
    headImage!: string | undefined;
    rank!: number;
    totalScore!: number;
    partakeTimes!: number;

    constructor(data?: IGetPaperAnswerCompetitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nickName = _data["nickName"];
            this.openId = _data["openId"];
            this.headImage = _data["headImage"];
            this.rank = _data["rank"];
            this.totalScore = _data["totalScore"];
            this.partakeTimes = _data["partakeTimes"];
        }
    }

    static fromJS(data: any): GetPaperAnswerCompetitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerCompetitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickName"] = this.nickName;
        data["openId"] = this.openId;
        data["headImage"] = this.headImage;
        data["rank"] = this.rank;
        data["totalScore"] = this.totalScore;
        data["partakeTimes"] = this.partakeTimes;
        return data; 
    }
}

export interface IGetPaperAnswerCompetitionDto {
    nickName: string | undefined;
    openId: string | undefined;
    headImage: string | undefined;
    rank: number;
    totalScore: number;
    partakeTimes: number;
}

export class GetPaperAnswerInvestigateDto implements IGetPaperAnswerInvestigateDto {
    questionId!: number;
    questionName!: string | undefined;
    getPaperAnswerReportDtos!: GetPaperAnswerReportDto[] | undefined;

    constructor(data?: IGetPaperAnswerInvestigateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.questionName = _data["questionName"];
            if (Array.isArray(_data["getPaperAnswerReportDtos"])) {
                this.getPaperAnswerReportDtos = [] as any;
                for (let item of _data["getPaperAnswerReportDtos"])
                    this.getPaperAnswerReportDtos!.push(GetPaperAnswerReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPaperAnswerInvestigateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerInvestigateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionName"] = this.questionName;
        if (Array.isArray(this.getPaperAnswerReportDtos)) {
            data["getPaperAnswerReportDtos"] = [];
            for (let item of this.getPaperAnswerReportDtos)
                data["getPaperAnswerReportDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPaperAnswerInvestigateDto {
    questionId: number;
    questionName: string | undefined;
    getPaperAnswerReportDtos: GetPaperAnswerReportDto[] | undefined;
}

export class GetPaperAnswerReportDto implements IGetPaperAnswerReportDto {
    questionId!: number;
    questionContent!: string | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    questionItemId!: number;
    questionItemName!: string | undefined;
    prefix!: string | undefined;
    count!: number;
    percentage!: number;

    constructor(data?: IGetPaperAnswerReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.questionContent = _data["questionContent"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.questionItemId = _data["questionItemId"];
            this.questionItemName = _data["questionItemName"];
            this.prefix = _data["prefix"];
            this.count = _data["count"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): GetPaperAnswerReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperAnswerReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionContent"] = this.questionContent;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["questionItemId"] = this.questionItemId;
        data["questionItemName"] = this.questionItemName;
        data["prefix"] = this.prefix;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        return data; 
    }
}

export interface IGetPaperAnswerReportDto {
    questionId: number;
    questionContent: string | undefined;
    userId: number | undefined;
    userName: string | undefined;
    questionItemId: number;
    questionItemName: string | undefined;
    prefix: string | undefined;
    count: number;
    percentage: number;
}

export class GetPaperOpinionReportDto implements IGetPaperOpinionReportDto {
    opinion!: string | undefined;
    nickName!: string | undefined;
    userName!: string | undefined;
    trainingTitle!: string | undefined;

    constructor(data?: IGetPaperOpinionReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.opinion = _data["opinion"];
            this.nickName = _data["nickName"];
            this.userName = _data["userName"];
            this.trainingTitle = _data["trainingTitle"];
        }
    }

    static fromJS(data: any): GetPaperOpinionReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaperOpinionReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opinion"] = this.opinion;
        data["nickName"] = this.nickName;
        data["userName"] = this.userName;
        data["trainingTitle"] = this.trainingTitle;
        return data; 
    }
}

export interface IGetPaperOpinionReportDto {
    opinion: string | undefined;
    nickName: string | undefined;
    userName: string | undefined;
    trainingTitle: string | undefined;
}

export class GetUserPaperDto implements IGetUserPaperDto {
    id!: number;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number;
    correctCount!: number;
    totalScore!: number;
    examResult!: ExamEnum;
    snsUserInfo!: SnsUserInfoOutput;
    paper!: PaperDto;
    userAction!: UserActionDto;
    opinion!: string | undefined;

    constructor(data?: IGetUserPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.examStartTime = _data["examStartTime"] ? moment(_data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = _data["examEndTime"] ? moment(_data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = _data["answeredQuestionCount"];
            this.correctCount = _data["correctCount"];
            this.totalScore = _data["totalScore"];
            this.examResult = _data["examResult"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.paper = _data["paper"] ? PaperDto.fromJS(_data["paper"]) : <any>undefined;
            this.userAction = _data["userAction"] ? UserActionDto.fromJS(_data["userAction"]) : <any>undefined;
            this.opinion = _data["opinion"];
        }
    }

    static fromJS(data: any): GetUserPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["examResult"] = this.examResult;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["opinion"] = this.opinion;
        return data; 
    }
}

export interface IGetUserPaperDto {
    id: number;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number;
    correctCount: number;
    totalScore: number;
    examResult: ExamEnum;
    snsUserInfo: SnsUserInfoOutput;
    paper: PaperDto;
    userAction: UserActionDto;
    opinion: string | undefined;
}

export class GetUserPapers4WechatDto implements IGetUserPapers4WechatDto {
    opinion!: string | undefined;
    userQuestionItems!: UserPaperQuestionId[] | undefined;

    constructor(data?: IGetUserPapers4WechatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.opinion = _data["opinion"];
            if (Array.isArray(_data["userQuestionItems"])) {
                this.userQuestionItems = [] as any;
                for (let item of _data["userQuestionItems"])
                    this.userQuestionItems!.push(UserPaperQuestionId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserPapers4WechatDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPapers4WechatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opinion"] = this.opinion;
        if (Array.isArray(this.userQuestionItems)) {
            data["userQuestionItems"] = [];
            for (let item of this.userQuestionItems)
                data["userQuestionItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserPapers4WechatDto {
    opinion: string | undefined;
    userQuestionItems: UserPaperQuestionId[] | undefined;
}

export class GetWechatMediaDto implements IGetWechatMediaDto {
    id!: number;
    creationTime!: moment.Moment;
    media_id!: string | undefined;
    mediaType!: MediaType;
    title!: string | undefined;
    name!: string | undefined;
    author!: string | undefined;
    digest!: string | undefined;
    thumb_media_id!: string | undefined;
    show_cover_pic!: boolean;
    content_source_url!: string | undefined;
    url!: string | undefined;
    thumb_url!: string | undefined;
    need_open_comment!: string | undefined;
    only_fans_can_comment!: string | undefined;
    tags!: Tag[] | undefined;

    constructor(data?: IGetWechatMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.media_id = _data["media_id"];
            this.mediaType = _data["mediaType"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.author = _data["author"];
            this.digest = _data["digest"];
            this.thumb_media_id = _data["thumb_media_id"];
            this.show_cover_pic = _data["show_cover_pic"];
            this.content_source_url = _data["content_source_url"];
            this.url = _data["url"];
            this.thumb_url = _data["thumb_url"];
            this.need_open_comment = _data["need_open_comment"];
            this.only_fans_can_comment = _data["only_fans_can_comment"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(Tag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["media_id"] = this.media_id;
        data["mediaType"] = this.mediaType;
        data["title"] = this.title;
        data["name"] = this.name;
        data["author"] = this.author;
        data["digest"] = this.digest;
        data["thumb_media_id"] = this.thumb_media_id;
        data["show_cover_pic"] = this.show_cover_pic;
        data["content_source_url"] = this.content_source_url;
        data["url"] = this.url;
        data["thumb_url"] = this.thumb_url;
        data["need_open_comment"] = this.need_open_comment;
        data["only_fans_can_comment"] = this.only_fans_can_comment;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetWechatMediaDto {
    id: number;
    creationTime: moment.Moment;
    media_id: string | undefined;
    mediaType: MediaType;
    title: string | undefined;
    name: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    thumb_media_id: string | undefined;
    show_cover_pic: boolean;
    content_source_url: string | undefined;
    url: string | undefined;
    thumb_url: string | undefined;
    need_open_comment: string | undefined;
    only_fans_can_comment: string | undefined;
    tags: Tag[] | undefined;
}

export class GetWechatMenuDto implements IGetWechatMenuDto {
    id!: number;
    creationTime!: moment.Moment;
    lastModificationTime!: moment.Moment;
    displayName!: string | undefined;
    menuType!: MenuType;
    status!: boolean;
    menuContent!: any | undefined;

    constructor(data?: IGetWechatMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.displayName = _data["displayName"];
            this.menuType = _data["menuType"];
            this.status = _data["status"];
            this.menuContent = _data["menuContent"];
        }
    }

    static fromJS(data: any): GetWechatMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["displayName"] = this.displayName;
        data["menuType"] = this.menuType;
        data["status"] = this.status;
        data["menuContent"] = this.menuContent;
        return data; 
    }
}

export interface IGetWechatMenuDto {
    id: number;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment;
    displayName: string | undefined;
    menuType: MenuType;
    status: boolean;
    menuContent: any | undefined;
}

export class GetWechatTemplateMessageDto implements IGetWechatTemplateMessageDto {
    id!: number;
    templateId!: string | undefined;
    templateMessageType!: TemplateMessageType;
    weixinAppID!: string | undefined;
    title!: string | undefined;
    primaryIndustry!: string | undefined;
    deputyIndustry!: string | undefined;
    content!: string | undefined;
    example!: string | undefined;

    constructor(data?: IGetWechatTemplateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateId = _data["templateId"];
            this.templateMessageType = _data["templateMessageType"];
            this.weixinAppID = _data["weixinAppID"];
            this.title = _data["title"];
            this.primaryIndustry = _data["primaryIndustry"];
            this.deputyIndustry = _data["deputyIndustry"];
            this.content = _data["content"];
            this.example = _data["example"];
        }
    }

    static fromJS(data: any): GetWechatTemplateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatTemplateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateId"] = this.templateId;
        data["templateMessageType"] = this.templateMessageType;
        data["weixinAppID"] = this.weixinAppID;
        data["title"] = this.title;
        data["primaryIndustry"] = this.primaryIndustry;
        data["deputyIndustry"] = this.deputyIndustry;
        data["content"] = this.content;
        data["example"] = this.example;
        return data; 
    }
}

export interface IGetWechatTemplateMessageDto {
    id: number;
    templateId: string | undefined;
    templateMessageType: TemplateMessageType;
    weixinAppID: string | undefined;
    title: string | undefined;
    primaryIndustry: string | undefined;
    deputyIndustry: string | undefined;
    content: string | undefined;
    example: string | undefined;
}

export class HtmlTemplate implements IHtmlTemplate {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    args!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: TemplateEnum;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IHtmlTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.thumbnail = _data["thumbnail"];
            this.bigImage = _data["bigImage"];
            this.actionUrl = _data["actionUrl"];
            this.args = _data["args"];
            this.title = _data["title"];
            this.logo = _data["logo"];
            this.backgroundImage = _data["backgroundImage"];
            this.templateType = _data["templateType"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["args"] = this.args;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplate {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    args: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: TemplateEnum;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class HtmlTemplateDto implements IHtmlTemplateDto {
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 缩略图 */
    thumbnail!: string | undefined;
    /** 大图 */
    bigImage!: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl!: string | undefined;
    /** 备用字段 */
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: TemplateEnum;
    /** 描述 */
    description!: string | undefined;
    args!: string | undefined;
    id!: number;

    constructor(data?: IHtmlTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.thumbnail = _data["thumbnail"];
            this.bigImage = _data["bigImage"];
            this.actionUrl = _data["actionUrl"];
            this.title = _data["title"];
            this.logo = _data["logo"];
            this.backgroundImage = _data["backgroundImage"];
            this.templateType = _data["templateType"];
            this.description = _data["description"];
            this.args = _data["args"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplateDto {
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 缩略图 */
    thumbnail: string | undefined;
    /** 大图 */
    bigImage: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl: string | undefined;
    /** 备用字段 */
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: TemplateEnum;
    /** 描述 */
    description: string | undefined;
    args: string | undefined;
    id: number;
}

export class HtmlTemplateOutput implements IHtmlTemplateOutput {
    thumbnail!: string | undefined;
    bigImage!: string | undefined;
    actionUrl!: string | undefined;
    args!: string | undefined;
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: TemplateEnum;
    description!: string | undefined;
    id!: number;

    constructor(data?: IHtmlTemplateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thumbnail = _data["thumbnail"];
            this.bigImage = _data["bigImage"];
            this.actionUrl = _data["actionUrl"];
            this.args = _data["args"];
            this.title = _data["title"];
            this.logo = _data["logo"];
            this.backgroundImage = _data["backgroundImage"];
            this.templateType = _data["templateType"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HtmlTemplateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlTemplateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["args"] = this.args;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IHtmlTemplateOutput {
    thumbnail: string | undefined;
    bigImage: string | undefined;
    actionUrl: string | undefined;
    args: string | undefined;
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: TemplateEnum;
    description: string | undefined;
    id: number;
}

export class IdNameDto implements IIdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class ImportStoreResultDto implements IImportStoreResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportStoreResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportStoreResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportStoreResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportStoreResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class KeyValueDtoOfInt64 implements IKeyValueDtoOfInt64 {
    key!: number;
    value!: string | undefined;

    constructor(data?: IKeyValueDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValueDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValueDtoOfInt64 {
    key: number;
    value: string | undefined;
}

export class KeyValueDtoOfString implements IKeyValueDtoOfString {
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IKeyValueDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValueDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValueDtoOfString {
    key: string | undefined;
    value: string | undefined;
}

export class LotteryActionDataInput implements ILotteryActionDataInput {
    isNeedSendNotify!: boolean;
    score!: number | undefined;
    actionId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: ILotteryActionDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNeedSendNotify = _data["isNeedSendNotify"];
            this.score = _data["score"];
            this.actionId = _data["actionId"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): LotteryActionDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new LotteryActionDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        data["score"] = this.score;
        data["actionId"] = this.actionId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface ILotteryActionDataInput {
    isNeedSendNotify: boolean;
    score: number | undefined;
    actionId: number;
    securityKey: string;
    params: string | undefined;
}

export class LotteryCargoResultDto implements ILotteryCargoResultDto {
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    userAwardId!: number;

    constructor(data?: ILotteryCargoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.userAwardId = _data["userAwardId"];
        }
    }

    static fromJS(data: any): LotteryCargoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LotteryCargoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["userAwardId"] = this.userAwardId;
        return data; 
    }
}

export interface ILotteryCargoResultDto {
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    userAwardId: number;
}

export class MakeUserToSpecialInput implements IMakeUserToSpecialInput {
    userId!: number;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    type!: SpecialType;

    constructor(data?: IMakeUserToSpecialInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.forAward = _data["forAward"];
            this.forLottery = _data["forLottery"];
            this.forUseTicket = _data["forUseTicket"];
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.awardSeqs = _data["awardSeqs"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.description = _data["description"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): MakeUserToSpecialInput {
        data = typeof data === 'object' ? data : {};
        let result = new MakeUserToSpecialInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["type"] = this.type;
        return data; 
    }
}

export interface IMakeUserToSpecialInput {
    userId: number;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    type: SpecialType;
}

export enum MediaType {
    News = "News",
    Image = "Image",
    Video = "Video",
    Voice = "Voice",
}

export class MenuMatchRule implements IMenuMatchRule {
    tag_id!: string | undefined;
    group_id!: string | undefined;
    sex!: string | undefined;
    country!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    client_platform_type!: string | undefined;
    language!: string | undefined;

    constructor(data?: IMenuMatchRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tag_id = _data["tag_id"];
            this.group_id = _data["group_id"];
            this.sex = _data["sex"];
            this.country = _data["country"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.client_platform_type = _data["client_platform_type"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): MenuMatchRule {
        data = typeof data === 'object' ? data : {};
        let result = new MenuMatchRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag_id"] = this.tag_id;
        data["group_id"] = this.group_id;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["client_platform_type"] = this.client_platform_type;
        data["language"] = this.language;
        return data; 
    }
}

export interface IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;
}

export enum MenuType {
    Normal = "Normal",
    Individualization = "Individualization",
}

export class MergeSnsUsersInput implements IMergeSnsUsersInput {
    openIds!: string[] | undefined;
    memberId!: number;

    constructor(data?: IMergeSnsUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["openIds"])) {
                this.openIds = [] as any;
                for (let item of _data["openIds"])
                    this.openIds!.push(item);
            }
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): MergeSnsUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeSnsUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.openIds)) {
            data["openIds"] = [];
            for (let item of this.openIds)
                data["openIds"].push(item);
        }
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface IMergeSnsUsersInput {
    openIds: string[] | undefined;
    memberId: number;
}

export class MirrorPublishActivityToDevicesInput implements IMirrorPublishActivityToDevicesInput {
    sourceId!: number;
    targetIds!: number[] | undefined;
    tenantId!: number;

    constructor(data?: IMirrorPublishActivityToDevicesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
            if (Array.isArray(_data["targetIds"])) {
                this.targetIds = [] as any;
                for (let item of _data["targetIds"])
                    this.targetIds!.push(item);
            }
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): MirrorPublishActivityToDevicesInput {
        data = typeof data === 'object' ? data : {};
        let result = new MirrorPublishActivityToDevicesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        if (Array.isArray(this.targetIds)) {
            data["targetIds"] = [];
            for (let item of this.targetIds)
                data["targetIds"].push(item);
        }
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IMirrorPublishActivityToDevicesInput {
    sourceId: number;
    targetIds: number[] | undefined;
    tenantId: number;
}

export class MpAuthorzieUrlDto implements IMpAuthorzieUrlDto {
    url!: string | undefined;

    constructor(data?: IMpAuthorzieUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): MpAuthorzieUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new MpAuthorzieUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IMpAuthorzieUrlDto {
    url: string | undefined;
}

export enum MsgTypeEnum {
    Text = "Text",
    Emoji = "Emoji",
    Audio = "Audio",
    RedPacket = "RedPacket",
    File = "File",
    Location = "Location",
    Image = "Image",
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueTimeDto implements INameValueTimeDto {
    seconds!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seconds = _data["seconds"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seconds"] = this.seconds;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueTimeDto {
    seconds: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class OAuthUserInfo implements IOAuthUserInfo {
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number;
    province!: string | undefined;
    city!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    privilege!: string[] | undefined;
    unionid!: string | undefined;

    constructor(data?: IOAuthUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            if (Array.isArray(_data["privilege"])) {
                this.privilege = [] as any;
                for (let item of _data["privilege"])
                    this.privilege!.push(item);
            }
            this.unionid = _data["unionid"];
        }
    }

    static fromJS(data: any): OAuthUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["province"] = this.province;
        data["city"] = this.city;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        if (Array.isArray(this.privilege)) {
            data["privilege"] = [];
            for (let item of this.privilege)
                data["privilege"].push(item);
        }
        data["unionid"] = this.unionid;
        return data; 
    }
}

export interface IOAuthUserInfo {
    openid: string | undefined;
    nickname: string | undefined;
    sex: number;
    province: string | undefined;
    city: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    privilege: string[] | undefined;
    unionid: string | undefined;
}

export class PagedResultDtoOfActivityAwardDto implements IPagedResultDtoOfActivityAwardDto {
    totalCount!: number;
    items!: ActivityAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityAwardDto {
    totalCount: number;
    items: ActivityAwardDto[] | undefined;
}

export class PagedResultDtoOfActivityBasicDto implements IPagedResultDtoOfActivityBasicDto {
    totalCount!: number;
    items!: ActivityBasicDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityBasicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityBasicDto {
    totalCount: number;
    items: ActivityBasicDto[] | undefined;
}

export class PagedResultDtoOfActivityDataUserOutput implements IPagedResultDtoOfActivityDataUserOutput {
    totalCount!: number;
    items!: ActivityDataUserOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityDataUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityDataUserOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityDataUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityDataUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityDataUserOutput {
    totalCount: number;
    items: ActivityDataUserOutput[] | undefined;
}

export class PagedResultDtoOfActivityGameDto implements IPagedResultDtoOfActivityGameDto {
    totalCount!: number;
    items!: ActivityGameDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityGameDto {
    totalCount: number;
    items: ActivityGameDto[] | undefined;
}

export class PagedResultDtoOfActivityUserDataDto implements IPagedResultDtoOfActivityUserDataDto {
    totalCount!: number;
    items!: ActivityUserDataDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityUserDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityUserDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityUserDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityUserDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfActivityUserDataDto {
    totalCount: number;
    items: ActivityUserDataDto[] | undefined;
}

export class PagedResultDtoOfApplyFormDto implements IPagedResultDtoOfApplyFormDto {
    totalCount!: number;
    items!: ApplyFormDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplyFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApplyFormDto {
    totalCount: number;
    items: ApplyFormDto[] | undefined;
}

export class PagedResultDtoOfAwardDto implements IPagedResultDtoOfAwardDto {
    totalCount!: number;
    items!: AwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAwardDto {
    totalCount: number;
    items: AwardDto[] | undefined;
}

export class PagedResultDtoOfAwardOutput implements IPagedResultDtoOfAwardOutput {
    totalCount!: number;
    items!: AwardOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfAwardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AwardOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAwardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAwardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAwardOutput {
    totalCount: number;
    items: AwardOutput[] | undefined;
}

export class PagedResultDtoOfCourseDto implements IPagedResultDtoOfCourseDto {
    totalCount!: number;
    items!: CourseDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCourseDto {
    totalCount: number;
    items: CourseDto[] | undefined;
}

export class PagedResultDtoOfDeviceActivityDto implements IPagedResultDtoOfDeviceActivityDto {
    totalCount!: number;
    items!: DeviceActivityDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceActivityDto {
    totalCount: number;
    items: DeviceActivityDto[] | undefined;
}

export class PagedResultDtoOfDouyinMedia implements IPagedResultDtoOfDouyinMedia {
    totalCount!: number;
    items!: DouyinMedia[] | undefined;

    constructor(data?: IPagedResultDtoOfDouyinMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DouyinMedia.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDouyinMedia {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDouyinMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDouyinMedia {
    totalCount: number;
    items: DouyinMedia[] | undefined;
}

export class PagedResultDtoOfGetMessageSeedDto implements IPagedResultDtoOfGetMessageSeedDto {
    totalCount!: number;
    items!: GetMessageSeedDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMessageSeedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMessageSeedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMessageSeedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMessageSeedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMessageSeedDto {
    totalCount: number;
    items: GetMessageSeedDto[] | undefined;
}

export class PagedResultDtoOfGetPaperAnswerCompetitionDto implements IPagedResultDtoOfGetPaperAnswerCompetitionDto {
    totalCount!: number;
    items!: GetPaperAnswerCompetitionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerCompetitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPaperAnswerCompetitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerCompetitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerCompetitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerCompetitionDto {
    totalCount: number;
    items: GetPaperAnswerCompetitionDto[] | undefined;
}

export class PagedResultDtoOfGetPaperAnswerInvestigateDto implements IPagedResultDtoOfGetPaperAnswerInvestigateDto {
    totalCount!: number;
    items!: GetPaperAnswerInvestigateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerInvestigateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPaperAnswerInvestigateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerInvestigateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerInvestigateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerInvestigateDto {
    totalCount: number;
    items: GetPaperAnswerInvestigateDto[] | undefined;
}

export class PagedResultDtoOfGetPaperAnswerReportDto implements IPagedResultDtoOfGetPaperAnswerReportDto {
    totalCount!: number;
    items!: GetPaperAnswerReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperAnswerReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPaperAnswerReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperAnswerReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperAnswerReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperAnswerReportDto {
    totalCount: number;
    items: GetPaperAnswerReportDto[] | undefined;
}

export class PagedResultDtoOfGetPaperOpinionReportDto implements IPagedResultDtoOfGetPaperOpinionReportDto {
    totalCount!: number;
    items!: GetPaperOpinionReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPaperOpinionReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPaperOpinionReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPaperOpinionReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPaperOpinionReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPaperOpinionReportDto {
    totalCount: number;
    items: GetPaperOpinionReportDto[] | undefined;
}

export class PagedResultDtoOfGetUserPaperDto implements IPagedResultDtoOfGetUserPaperDto {
    totalCount!: number;
    items!: GetUserPaperDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUserPaperDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserPaperDto {
    totalCount: number;
    items: GetUserPaperDto[] | undefined;
}

export class PagedResultDtoOfGetWechatMediaDto implements IPagedResultDtoOfGetWechatMediaDto {
    totalCount!: number;
    items!: GetWechatMediaDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetWechatMediaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatMediaDto {
    totalCount: number;
    items: GetWechatMediaDto[] | undefined;
}

export class PagedResultDtoOfGetWechatMenuDto implements IPagedResultDtoOfGetWechatMenuDto {
    totalCount!: number;
    items!: GetWechatMenuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetWechatMenuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatMenuDto {
    totalCount: number;
    items: GetWechatMenuDto[] | undefined;
}

export class PagedResultDtoOfGetWechatTemplateMessageDto implements IPagedResultDtoOfGetWechatTemplateMessageDto {
    totalCount!: number;
    items!: GetWechatTemplateMessageDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWechatTemplateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetWechatTemplateMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWechatTemplateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWechatTemplateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWechatTemplateMessageDto {
    totalCount: number;
    items: GetWechatTemplateMessageDto[] | undefined;
}

export class PagedResultDtoOfHtmlTemplateDto implements IPagedResultDtoOfHtmlTemplateDto {
    totalCount!: number;
    items!: HtmlTemplateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfHtmlTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HtmlTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHtmlTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHtmlTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfHtmlTemplateDto {
    totalCount: number;
    items: HtmlTemplateDto[] | undefined;
}

export class PagedResultDtoOfPaperDto implements IPagedResultDtoOfPaperDto {
    totalCount!: number;
    items!: PaperDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaperDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPaperDto {
    totalCount: number;
    items: PaperDto[] | undefined;
}

export class PagedResultDtoOfPlayGameOutput implements IPagedResultDtoOfPlayGameOutput {
    totalCount!: number;
    items!: PlayGameOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfPlayGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlayGameOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPlayGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPlayGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPlayGameOutput {
    totalCount: number;
    items: PlayGameOutput[] | undefined;
}

export class PagedResultDtoOfQuestionDto implements IPagedResultDtoOfQuestionDto {
    totalCount!: number;
    items!: QuestionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuestionDto {
    totalCount: number;
    items: QuestionDto[] | undefined;
}

export class PagedResultDtoOfSensingDeviceActivityDto implements IPagedResultDtoOfSensingDeviceActivityDto {
    totalCount!: number;
    items!: SensingDeviceActivityDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDeviceActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDeviceActivityDto {
    totalCount: number;
    items: SensingDeviceActivityDto[] | undefined;
}

export class PagedResultDtoOfSensingDeviceAwardDto implements IPagedResultDtoOfSensingDeviceAwardDto {
    totalCount!: number;
    items!: SensingDeviceAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDeviceAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDeviceAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDeviceAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDeviceAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDeviceAwardDto {
    totalCount: number;
    items: SensingDeviceAwardDto[] | undefined;
}

export class PagedResultDtoOfSnsUserActionSumDto implements IPagedResultDtoOfSnsUserActionSumDto {
    totalCount!: number;
    items!: SnsUserActionSumDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserActionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SnsUserActionSumDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserActionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserActionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserActionSumDto {
    totalCount: number;
    items: SnsUserActionSumDto[] | undefined;
}

export class PagedResultDtoOfSnsUserAwardOuput implements IPagedResultDtoOfSnsUserAwardOuput {
    totalCount!: number;
    items!: SnsUserAwardOuput[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserAwardOuput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SnsUserAwardOuput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserAwardOuput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserAwardOuput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserAwardOuput {
    totalCount: number;
    items: SnsUserAwardOuput[] | undefined;
}

export class PagedResultDtoOfSnsUserInfoOutput implements IPagedResultDtoOfSnsUserInfoOutput {
    totalCount!: number;
    items!: SnsUserInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SnsUserInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserInfoOutput {
    totalCount: number;
    items: SnsUserInfoOutput[] | undefined;
}

export class PagedResultDtoOfSnsUserQrcode implements IPagedResultDtoOfSnsUserQrcode {
    totalCount!: number;
    items!: SnsUserQrcode[] | undefined;

    constructor(data?: IPagedResultDtoOfSnsUserQrcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SnsUserQrcode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSnsUserQrcode {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSnsUserQrcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSnsUserQrcode {
    totalCount: number;
    items: SnsUserQrcode[] | undefined;
}

export class PagedResultDtoOfSpecailUserDto implements IPagedResultDtoOfSpecailUserDto {
    totalCount!: number;
    items!: SpecailUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSpecailUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SpecailUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSpecailUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSpecailUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSpecailUserDto {
    totalCount: number;
    items: SpecailUserDto[] | undefined;
}

export class PagedResultDtoOfTagDto implements IPagedResultDtoOfTagDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTagDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export class PagedResultDtoOfTrainingBasicDto implements IPagedResultDtoOfTrainingBasicDto {
    totalCount!: number;
    items!: TrainingBasicDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTrainingBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainingBasicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTrainingBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTrainingBasicDto {
    totalCount: number;
    items: TrainingBasicDto[] | undefined;
}

export class PagedResultDtoOfUserActionDto implements IPagedResultDtoOfUserActionDto {
    totalCount!: number;
    items!: UserActionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionDto {
    totalCount: number;
    items: UserActionDto[] | undefined;
}

export class PagedResultDtoOfUserActionInfoOutput implements IPagedResultDtoOfUserActionInfoOutput {
    totalCount!: number;
    items!: UserActionInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserActionInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionInfoOutput {
    totalCount: number;
    items: UserActionInfoOutput[] | undefined;
}

export class PagedResultDtoOfUserActionPlayInfoOutput implements IPagedResultDtoOfUserActionPlayInfoOutput {
    totalCount!: number;
    items!: UserActionPlayInfoOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserActionPlayInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserActionPlayInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserActionPlayInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserActionPlayInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserActionPlayInfoOutput {
    totalCount: number;
    items: UserActionPlayInfoOutput[] | undefined;
}

export class PagedResultDtoOfUserAwardDto implements IPagedResultDtoOfUserAwardDto {
    totalCount!: number;
    items!: UserAwardDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserAwardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserAwardDto {
    totalCount: number;
    items: UserAwardDto[] | undefined;
}

export class PagedResultDtoOfUserRoomMessageOutput implements IPagedResultDtoOfUserRoomMessageOutput {
    totalCount!: number;
    items!: UserRoomMessageOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfUserRoomMessageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRoomMessageOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserRoomMessageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserRoomMessageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserRoomMessageOutput {
    totalCount: number;
    items: UserRoomMessageOutput[] | undefined;
}

export class PagedResultDtoOfWeixinMpDto implements IPagedResultDtoOfWeixinMpDto {
    totalCount!: number;
    items!: WeixinMpDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWeixinMpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WeixinMpDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWeixinMpDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWeixinMpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWeixinMpDto {
    totalCount: number;
    items: WeixinMpDto[] | undefined;
}

export class Paper implements IPaper {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    description!: string | undefined;
    owner!: string | undefined;
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number;
    compositionType!: PaperCompositionEnum;
    paperUsageType!: PaperUsageType;
    randomCount!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.description = _data["description"];
            this.owner = _data["owner"];
            this.fromType = _data["fromType"];
            this.extensionData = _data["extensionData"];
            this.outerId = _data["outerId"];
            this.questionsCount = _data["questionsCount"];
            this.compositionType = _data["compositionType"];
            this.paperUsageType = _data["paperUsageType"];
            this.randomCount = _data["randomCount"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Paper {
        data = typeof data === 'object' ? data : {};
        let result = new Paper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaper {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    owner: string | undefined;
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number;
    compositionType: PaperCompositionEnum;
    paperUsageType: PaperUsageType;
    randomCount: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum PaperCompositionEnum {
    Fixed = "Fixed",
    Random = "Random",
    FixedPlusRandom = "FixedPlusRandom",
}

export class PaperDto implements IPaperDto {
    id!: number;
    /** 试卷名称,必须唯一 */
    name!: string | undefined;
    displayName!: string | undefined;
    /** 试卷的Logo图 */
    logoUrl!: string | undefined;
    /** 试卷的图片 */
    imageUrl!: string | undefined;
    /** 试卷的描述 */
    description!: string | undefined;
    /** 试卷的组织者 */
    owner!: string | undefined;
    /** 试卷时怎么生产的 */
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number;
    actualQuestionsCount!: number;
    compositionType!: PaperCompositionEnum;
    paperUsageType!: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount!: number;
    tags!: IdNameDto[] | undefined;
    questions!: QuestionDto[] | undefined;

    constructor(data?: IPaperDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.description = _data["description"];
            this.owner = _data["owner"];
            this.fromType = _data["fromType"];
            this.extensionData = _data["extensionData"];
            this.outerId = _data["outerId"];
            this.questionsCount = _data["questionsCount"];
            this.actualQuestionsCount = _data["actualQuestionsCount"];
            this.compositionType = _data["compositionType"];
            this.paperUsageType = _data["paperUsageType"];
            this.randomCount = _data["randomCount"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaperDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaperDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["actualQuestionsCount"] = this.actualQuestionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaperDto {
    id: number;
    /** 试卷名称,必须唯一 */
    name: string | undefined;
    displayName: string | undefined;
    /** 试卷的Logo图 */
    logoUrl: string | undefined;
    /** 试卷的图片 */
    imageUrl: string | undefined;
    /** 试卷的描述 */
    description: string | undefined;
    /** 试卷的组织者 */
    owner: string | undefined;
    /** 试卷时怎么生产的 */
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number;
    actualQuestionsCount: number;
    compositionType: PaperCompositionEnum;
    paperUsageType: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount: number;
    tags: IdNameDto[] | undefined;
    questions: QuestionDto[] | undefined;
}

export class PaperQuestion implements IPaperQuestion {
    questionId!: number;
    answer!: string | undefined;
    comments!: string | undefined;
    questionItemIds!: number[] | undefined;
    imgUrl!: string | undefined;

    constructor(data?: IPaperQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.answer = _data["answer"];
            this.comments = _data["comments"];
            if (Array.isArray(_data["questionItemIds"])) {
                this.questionItemIds = [] as any;
                for (let item of _data["questionItemIds"])
                    this.questionItemIds!.push(item);
            }
            this.imgUrl = _data["imgUrl"];
        }
    }

    static fromJS(data: any): PaperQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new PaperQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["answer"] = this.answer;
        data["comments"] = this.comments;
        if (Array.isArray(this.questionItemIds)) {
            data["questionItemIds"] = [];
            for (let item of this.questionItemIds)
                data["questionItemIds"].push(item);
        }
        data["imgUrl"] = this.imgUrl;
        return data; 
    }
}

export interface IPaperQuestion {
    questionId: number;
    answer: string | undefined;
    comments: string | undefined;
    questionItemIds: number[] | undefined;
    imgUrl: string | undefined;
}

export enum PaperUsageType {
    Competition = "Competition",
    GamePK = "GamePK",
    Vote = "Vote",
    Investigate = "Investigate",
}

export class PlayGameOutput implements IPlayGameOutput {
    gameName!: string | undefined;
    count!: number;
    gameId!: number | undefined;
    maxScore!: number | undefined;
    actionUrl!: string | undefined;

    constructor(data?: IPlayGameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameName = _data["gameName"];
            this.count = _data["count"];
            this.gameId = _data["gameId"];
            this.maxScore = _data["maxScore"];
            this.actionUrl = _data["actionUrl"];
        }
    }

    static fromJS(data: any): PlayGameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PlayGameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["count"] = this.count;
        data["gameId"] = this.gameId;
        data["maxScore"] = this.maxScore;
        data["actionUrl"] = this.actionUrl;
        return data; 
    }
}

export interface IPlayGameOutput {
    gameName: string | undefined;
    count: number;
    gameId: number | undefined;
    maxScore: number | undefined;
    actionUrl: string | undefined;
}

export class PublishedQuestionDto implements IPublishedQuestionDto {
    id!: number;
    /** 此道题的得分 */
    score!: number;
    /** 题目的顺序 */
    orderNo!: number;

    constructor(data?: IPublishedQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.score = _data["score"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): PublishedQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        return data; 
    }
}

export interface IPublishedQuestionDto {
    id: number;
    /** 此道题的得分 */
    score: number;
    /** 题目的顺序 */
    orderNo: number;
}

export class PublishEntitiesInput implements IPublishEntitiesInput {
    entityIds!: number[] | undefined;
    ouOrStoreOrDeviceList!: IdTypeDto[] | undefined;
    /** add,addonly,delete */
    action!: string | undefined;

    constructor(data?: IPublishEntitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(_data["ouOrStoreOrDeviceList"])) {
                this.ouOrStoreOrDeviceList = [] as any;
                for (let item of _data["ouOrStoreOrDeviceList"])
                    this.ouOrStoreOrDeviceList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishEntitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishEntitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouOrStoreOrDeviceList)) {
            data["ouOrStoreOrDeviceList"] = [];
            for (let item of this.ouOrStoreOrDeviceList)
                data["ouOrStoreOrDeviceList"].push(item.toJSON());
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishEntitiesInput {
    entityIds: number[] | undefined;
    ouOrStoreOrDeviceList: IdTypeDto[] | undefined;
    /** add,addonly,delete */
    action: string | undefined;
}

export class PublishPapersToSoftwares implements IPublishPapersToSoftwares {
    dispathcedSoftwareIds!: number[] | undefined;
    paperIds!: number[] | undefined;
    /** add,addonly,delete */
    action!: string | undefined;

    constructor(data?: IPublishPapersToSoftwares) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dispathcedSoftwareIds"])) {
                this.dispathcedSoftwareIds = [] as any;
                for (let item of _data["dispathcedSoftwareIds"])
                    this.dispathcedSoftwareIds!.push(item);
            }
            if (Array.isArray(_data["paperIds"])) {
                this.paperIds = [] as any;
                for (let item of _data["paperIds"])
                    this.paperIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishPapersToSoftwares {
        data = typeof data === 'object' ? data : {};
        let result = new PublishPapersToSoftwares();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dispathcedSoftwareIds)) {
            data["dispathcedSoftwareIds"] = [];
            for (let item of this.dispathcedSoftwareIds)
                data["dispathcedSoftwareIds"].push(item);
        }
        if (Array.isArray(this.paperIds)) {
            data["paperIds"] = [];
            for (let item of this.paperIds)
                data["paperIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishPapersToSoftwares {
    dispathcedSoftwareIds: number[] | undefined;
    paperIds: number[] | undefined;
    /** add,addonly,delete */
    action: string | undefined;
}

export class PublishQuestionsToPapersInput implements IPublishQuestionsToPapersInput {
    questions!: PublishedQuestionDto[] | undefined;
    paperIds!: number[] | undefined;
    /** add,addonly,delete */
    action!: string | undefined;

    constructor(data?: IPublishQuestionsToPapersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(PublishedQuestionDto.fromJS(item));
            }
            if (Array.isArray(_data["paperIds"])) {
                this.paperIds = [] as any;
                for (let item of _data["paperIds"])
                    this.paperIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishQuestionsToPapersInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishQuestionsToPapersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.paperIds)) {
            data["paperIds"] = [];
            for (let item of this.paperIds)
                data["paperIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishQuestionsToPapersInput {
    questions: PublishedQuestionDto[] | undefined;
    paperIds: number[] | undefined;
    /** add,addonly,delete */
    action: string | undefined;
}

export class Qrcode4LoginInput implements IQrcode4LoginInput {
    isSendWeChatMsg!: boolean | undefined;
    qrType!: EnumQRStatus;
    snsType!: _definitions_EnumSnsType;
    targetUrl!: string | undefined;
    isTransferred!: boolean;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IQrcode4LoginInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSendWeChatMsg = _data["isSendWeChatMsg"];
            this.qrType = _data["qrType"];
            this.snsType = _data["snsType"];
            this.targetUrl = _data["targetUrl"];
            this.isTransferred = _data["isTransferred"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): Qrcode4LoginInput {
        data = typeof data === 'object' ? data : {};
        let result = new Qrcode4LoginInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSendWeChatMsg"] = this.isSendWeChatMsg;
        data["qrType"] = this.qrType;
        data["snsType"] = this.snsType;
        data["targetUrl"] = this.targetUrl;
        data["isTransferred"] = this.isTransferred;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IQrcode4LoginInput {
    isSendWeChatMsg: boolean | undefined;
    qrType: EnumQRStatus;
    snsType: _definitions_EnumSnsType;
    targetUrl: string | undefined;
    isTransferred: boolean;
    securityKey: string;
    params: string | undefined;
}

export class QrcodeActionOutput implements IQrcodeActionOutput {
    actionId!: number;
    qrCodeUrl!: string | undefined;
    qrCodeImage!: string | undefined;
    qrCodeId!: string | undefined;

    constructor(data?: IQrcodeActionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionId = _data["actionId"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.qrCodeImage = _data["qrCodeImage"];
            this.qrCodeId = _data["qrCodeId"];
        }
    }

    static fromJS(data: any): QrcodeActionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new QrcodeActionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["qrCodeImage"] = this.qrCodeImage;
        data["qrCodeId"] = this.qrCodeId;
        return data; 
    }
}

export interface IQrcodeActionOutput {
    actionId: number;
    qrCodeUrl: string | undefined;
    qrCodeImage: string | undefined;
    qrCodeId: string | undefined;
}

export class QrcodeOutput implements IQrcodeOutput {
    qrCodeUrl!: string | undefined;
    qrCodeImage!: string | undefined;
    qrCodeId!: string | undefined;

    constructor(data?: IQrcodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.qrCodeImage = _data["qrCodeImage"];
            this.qrCodeId = _data["qrCodeId"];
        }
    }

    static fromJS(data: any): QrcodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new QrcodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["qrCodeImage"] = this.qrCodeImage;
        data["qrCodeId"] = this.qrCodeId;
        return data; 
    }
}

export interface IQrcodeOutput {
    qrCodeUrl: string | undefined;
    qrCodeImage: string | undefined;
    qrCodeId: string | undefined;
}

export class QuestionDto implements IQuestionDto {
    id!: number;
    /** Question的名称 */
    prefix!: string | undefined;
    /** 问题标题 */
    title!: string | undefined;
    type!: QuestionTypeEnum;
    /** 此道题的得分 */
    score!: number;
    /** 题目的顺序 */
    orderNo!: number;
    /** 内容 */
    content!: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    answerImgUrl!: string | undefined;
    enabled!: boolean;
    outerId!: string | undefined;
    questionScoreType!: QuestionScoreTypeEnum;
    questionItems!: QuestionItemDto[] | undefined;
    tags!: IdNameDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prefix = _data["prefix"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.score = _data["score"];
            this.orderNo = _data["orderNo"];
            this.content = _data["content"];
            this.answer = _data["answer"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.answerImgUrl = _data["answerImgUrl"];
            this.enabled = _data["enabled"];
            this.outerId = _data["outerId"];
            this.questionScoreType = _data["questionScoreType"];
            if (Array.isArray(_data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of _data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["answerImgUrl"] = this.answerImgUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionDto {
    id: number;
    /** Question的名称 */
    prefix: string | undefined;
    /** 问题标题 */
    title: string | undefined;
    type: QuestionTypeEnum;
    /** 此道题的得分 */
    score: number;
    /** 题目的顺序 */
    orderNo: number;
    /** 内容 */
    content: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    answerImgUrl: string | undefined;
    enabled: boolean;
    outerId: string | undefined;
    questionScoreType: QuestionScoreTypeEnum;
    questionItems: QuestionItemDto[] | undefined;
    tags: IdNameDto[] | undefined;
}

export class QuestionItemDto implements IQuestionItemDto {
    id!: number;
    orderNo!: number;
    /** 选项的名称，如 A,B,C  1,2,3... */
    prefix!: string | undefined;
    content!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    extensionData!: string | undefined;
    isAnswer!: boolean;
    /** 最好是分数的比例 */
    score!: number;
    /** 此项的说明 */
    description!: string | undefined;
    outerId!: string | undefined;

    constructor(data?: IQuestionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNo = _data["orderNo"];
            this.prefix = _data["prefix"];
            this.content = _data["content"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.extensionData = _data["extensionData"];
            this.isAnswer = _data["isAnswer"];
            this.score = _data["score"];
            this.description = _data["description"];
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): QuestionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNo"] = this.orderNo;
        data["prefix"] = this.prefix;
        data["content"] = this.content;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["extensionData"] = this.extensionData;
        data["isAnswer"] = this.isAnswer;
        data["score"] = this.score;
        data["description"] = this.description;
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface IQuestionItemDto {
    id: number;
    orderNo: number;
    /** 选项的名称，如 A,B,C  1,2,3... */
    prefix: string | undefined;
    content: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    extensionData: string | undefined;
    isAnswer: boolean;
    /** 最好是分数的比例 */
    score: number;
    /** 此项的说明 */
    description: string | undefined;
    outerId: string | undefined;
}

export enum QuestionScoreTypeEnum {
    Partial = "Partial",
    Full = "Full",
}

export enum QuestionTypeEnum {
    Single = "Single",
    Multiple = "Multiple",
    Text = "Text",
}

export class RankUserActionInfoOutput implements IRankUserActionInfoOutput {
    rank!: number;
    rankRate!: number;
    userType!: string | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number;
    shareCount!: number;
    viewCount!: number;
    likeCount!: number;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean;
    failReason!: string | undefined;
    id!: number;

    constructor(data?: IRankUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.rankRate = _data["rankRate"];
            this.userType = _data["userType"];
            this.qrCodeId = _data["qrCodeId"];
            this.score = _data["score"];
            this.postUrl = _data["postUrl"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.scanQrCodeTime = _data["scanQrCodeTime"];
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.failReason = _data["failReason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RankUserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RankUserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["rankRate"] = this.rankRate;
        data["userType"] = this.userType;
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRankUserActionInfoOutput {
    rank: number;
    rankRate: number;
    userType: string | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number;
    shareCount: number;
    viewCount: number;
    likeCount: number;
    scanQrCodeTime: string | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean;
    failReason: string | undefined;
    id: number;
}

export class ReplenishCargoThingInput implements IReplenishCargoThingInput {
    thingId!: number;
    stock!: number;

    constructor(data?: IReplenishCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): ReplenishCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["stock"] = this.stock;
        return data; 
    }
}

export interface IReplenishCargoThingInput {
    thingId: number;
    stock: number;
}

export class Scene implements IScene {
    scene_str!: string | undefined;

    constructor(data?: IScene) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scene_str = _data["scene_str"];
        }
    }

    static fromJS(data: any): Scene {
        data = typeof data === 'object' ? data : {};
        let result = new Scene();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scene_str"] = this.scene_str;
        return data; 
    }
}

export interface IScene {
    scene_str: string | undefined;
}

export class SendCustomMessageInput implements ISendCustomMessageInput {
    securityKey!: string | undefined;
    openId!: string | undefined;
    type!: string | undefined;
    content!: string | undefined;
    title!: string | undefined;
    imageUrl!: string | undefined;
    url!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: ISendCustomMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityKey = _data["securityKey"];
            this.openId = _data["openId"];
            this.type = _data["type"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.imageUrl = _data["imageUrl"];
            this.url = _data["url"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): SendCustomMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendCustomMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        data["openId"] = this.openId;
        data["type"] = this.type;
        data["content"] = this.content;
        data["title"] = this.title;
        data["imageUrl"] = this.imageUrl;
        data["url"] = this.url;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface ISendCustomMessageInput {
    securityKey: string | undefined;
    openId: string | undefined;
    type: string | undefined;
    content: string | undefined;
    title: string | undefined;
    imageUrl: string | undefined;
    url: string | undefined;
    picUrl: string | undefined;
}

export class SensingDeviceActivityDto implements ISensingDeviceActivityDto {
    /** 活动Id */
    id!: number;
    /** 活动名称 */
    name!: string | undefined;
    /** 活动图片 */
    imagePath!: string | undefined;
    /** 活动线下地址 */
    address!: string | undefined;
    /** 活动的首页url */
    activityUrl!: string | undefined;
    /** 活动Logo的url */
    activityLogoPath!: string | undefined;
    /** 活动开始时间 */
    openDate!: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate!: moment.Moment | undefined;
    /** 公众号appid */
    weChatAppID!: string | undefined;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID!: string | undefined;
    /** 活动主办方 */
    organizer!: string | undefined;
    /** 活动规则 */
    rules!: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate!: moment.Moment | undefined;
    /** 该活动是否是模板 */
    isTemplate!: boolean;
    /** 图标路径 更多用处是在创建活动选模板的时候 */
    iconPath!: string | undefined;
    /** 活动的所有者 */
    ownerName!: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic!: boolean;
    /** 活动联系人 */
    contactor!: string | undefined;
    /** 活动联系人电话 */
    contactorPhone!: string | undefined;
    auditStatus!: AuditStatus;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    description!: string | undefined;
    isNeedRegister!: boolean;
    games!: DeviceActivityGameDto[] | undefined;

    constructor(data?: ISensingDeviceActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imagePath = _data["imagePath"];
            this.address = _data["address"];
            this.activityUrl = _data["activityUrl"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.weChatAppID = _data["weChatAppID"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.organizer = _data["organizer"];
            this.rules = _data["rules"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.isTemplate = _data["isTemplate"];
            this.iconPath = _data["iconPath"];
            this.ownerName = _data["ownerName"];
            this.isPublic = _data["isPublic"];
            this.contactor = _data["contactor"];
            this.contactorPhone = _data["contactorPhone"];
            this.auditStatus = _data["auditStatus"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.description = _data["description"];
            this.isNeedRegister = _data["isNeedRegister"];
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(DeviceActivityGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingDeviceActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagePath"] = this.imagePath;
        data["address"] = this.address;
        data["activityUrl"] = this.activityUrl;
        data["activityLogoPath"] = this.activityLogoPath;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["weChatAppID"] = this.weChatAppID;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["organizer"] = this.organizer;
        data["rules"] = this.rules;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["isTemplate"] = this.isTemplate;
        data["iconPath"] = this.iconPath;
        data["ownerName"] = this.ownerName;
        data["isPublic"] = this.isPublic;
        data["contactor"] = this.contactor;
        data["contactorPhone"] = this.contactorPhone;
        data["auditStatus"] = this.auditStatus;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingDeviceActivityDto {
    /** 活动Id */
    id: number;
    /** 活动名称 */
    name: string | undefined;
    /** 活动图片 */
    imagePath: string | undefined;
    /** 活动线下地址 */
    address: string | undefined;
    /** 活动的首页url */
    activityUrl: string | undefined;
    /** 活动Logo的url */
    activityLogoPath: string | undefined;
    /** 活动开始时间 */
    openDate: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate: moment.Moment | undefined;
    /** 公众号appid */
    weChatAppID: string | undefined;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID: string | undefined;
    /** 活动主办方 */
    organizer: string | undefined;
    /** 活动规则 */
    rules: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate: moment.Moment | undefined;
    /** 该活动是否是模板 */
    isTemplate: boolean;
    /** 图标路径 更多用处是在创建活动选模板的时候 */
    iconPath: string | undefined;
    /** 活动的所有者 */
    ownerName: string | undefined;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic: boolean;
    /** 活动联系人 */
    contactor: string | undefined;
    /** 活动联系人电话 */
    contactorPhone: string | undefined;
    auditStatus: AuditStatus;
    isMine: boolean;
    organizationUnitId: number | undefined;
    description: string | undefined;
    isNeedRegister: boolean;
    games: DeviceActivityGameDto[] | undefined;
}

export class SensingDeviceAwardDto implements ISensingDeviceAwardDto {
    /** 所属的租户 Id */
    tenantId!: number;
    /** 活动id */
    activityId!: number;
    /** 计划奖品数 */
    planQty!: number;
    /** 已发奖品数 */
    actualQty!: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name!: string | undefined;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq!: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct!: string | undefined;
    /** 奖品图片 */
    awardImagePath!: string | undefined;
    /** 中奖概率 */
    rate!: number;
    /** 最低中奖分数 */
    minScore!: number;
    /** 最高中奖分数 */
    maxScore!: number;
    /** Random Award Switch. Not used now. */
    isRandomAward!: boolean;
    /** 描述 */
    description!: string | undefined;
    type!: AwardType;
    couponUrl!: string | undefined;
    id!: number;

    constructor(data?: ISensingDeviceAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.name = _data["name"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.rate = _data["rate"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.isRandomAward = _data["isRandomAward"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SensingDeviceAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["name"] = this.name;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["rate"] = this.rate;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["isRandomAward"] = this.isRandomAward;
        data["description"] = this.description;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISensingDeviceAwardDto {
    /** 所属的租户 Id */
    tenantId: number;
    /** 活动id */
    activityId: number;
    /** 计划奖品数 */
    planQty: number;
    /** 已发奖品数 */
    actualQty: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name: string | undefined;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct: string | undefined;
    /** 奖品图片 */
    awardImagePath: string | undefined;
    /** 中奖概率 */
    rate: number;
    /** 最低中奖分数 */
    minScore: number;
    /** 最高中奖分数 */
    maxScore: number;
    /** Random Award Switch. Not used now. */
    isRandomAward: boolean;
    /** 描述 */
    description: string | undefined;
    type: AwardType;
    couponUrl: string | undefined;
    id: number;
}

export class SensingDeviceStoreInfoDto implements ISensingDeviceStoreInfoDto {
    deviceId!: number;
    deviceName!: string | undefined;
    storeId!: number;
    outerId!: string | undefined;
    storeName!: string | undefined;
    activityId!: number;
    activityName!: string | undefined;
    acitivityNote!: string | undefined;

    constructor(data?: ISensingDeviceStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.storeId = _data["storeId"];
            this.outerId = _data["outerId"];
            this.storeName = _data["storeName"];
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.acitivityNote = _data["acitivityNote"];
        }
    }

    static fromJS(data: any): SensingDeviceStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["storeId"] = this.storeId;
        data["outerId"] = this.outerId;
        data["storeName"] = this.storeName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["acitivityNote"] = this.acitivityNote;
        return data; 
    }
}

export interface ISensingDeviceStoreInfoDto {
    deviceId: number;
    deviceName: string | undefined;
    storeId: number;
    outerId: string | undefined;
    storeName: string | undefined;
    activityId: number;
    activityName: string | undefined;
    acitivityNote: string | undefined;
}

export class SensingDeviceUserInfoInput implements ISensingDeviceUserInfoInput {
    subKey!: string;
    memberIds!: number[] | undefined;

    constructor(data?: ISensingDeviceUserInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            if (Array.isArray(_data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of _data["memberIds"])
                    this.memberIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SensingDeviceUserInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceUserInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        return data; 
    }
}

export interface ISensingDeviceUserInfoInput {
    subKey: string;
    memberIds: number[] | undefined;
}

export enum ServiceType {
    Subscribe = "Subscribe",
    HistoryToSubscribe = "HistoryToSubscribe",
    Service = "Service",
}

export class SetMediaTagsInput implements ISetMediaTagsInput {
    wechatMediaIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetMediaTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["wechatMediaIds"])) {
                this.wechatMediaIds = [] as any;
                for (let item of _data["wechatMediaIds"])
                    this.wechatMediaIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetMediaTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetMediaTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.wechatMediaIds)) {
            data["wechatMediaIds"] = [];
            for (let item of this.wechatMediaIds)
                data["wechatMediaIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetMediaTagsInput {
    wechatMediaIds: number[] | undefined;
    tagIds: number[] | undefined;
    action: string | undefined;
}

export class SimpleMemberInfoDto implements ISimpleMemberInfoDto {
    memberId!: number | undefined;
    tenantId!: number;
    regPhone!: string | undefined;
    name!: string | undefined;

    constructor(data?: ISimpleMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.tenantId = _data["tenantId"];
            this.regPhone = _data["regPhone"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SimpleMemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleMemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["tenantId"] = this.tenantId;
        data["regPhone"] = this.regPhone;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISimpleMemberInfoDto {
    memberId: number | undefined;
    tenantId: number;
    regPhone: string | undefined;
    name: string | undefined;
}

export class SingleTrainingInfo implements ISingleTrainingInfo {
    id!: number;
    ownerName!: string | undefined;
    address!: string | undefined;
    name!: string | undefined;
    isCompleted!: boolean;
    paperId!: number;
    departmentDisplayNames!: string[] | undefined;
    startTime!: moment.Moment | undefined;
    questionDtos!: QuestionDto[] | undefined;

    constructor(data?: ISingleTrainingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ownerName = _data["ownerName"];
            this.address = _data["address"];
            this.name = _data["name"];
            this.isCompleted = _data["isCompleted"];
            this.paperId = _data["paperId"];
            if (Array.isArray(_data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of _data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["questionDtos"])) {
                this.questionDtos = [] as any;
                for (let item of _data["questionDtos"])
                    this.questionDtos!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleTrainingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SingleTrainingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["name"] = this.name;
        data["isCompleted"] = this.isCompleted;
        data["paperId"] = this.paperId;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        if (Array.isArray(this.questionDtos)) {
            data["questionDtos"] = [];
            for (let item of this.questionDtos)
                data["questionDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISingleTrainingInfo {
    id: number;
    ownerName: string | undefined;
    address: string | undefined;
    name: string | undefined;
    isCompleted: boolean;
    paperId: number;
    departmentDisplayNames: string[] | undefined;
    startTime: moment.Moment | undefined;
    questionDtos: QuestionDto[] | undefined;
}

export class SingleUserPaperDetailDto implements ISingleUserPaperDetailDto {
    snsUserInfo!: SnsUserInfoDto;
    userPaper!: UserPaper;
    questions!: QuestionDto[] | undefined;
    questionItems!: QuestionItemDto[] | undefined;

    constructor(data?: ISingleUserPaperDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoDto.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.userPaper = _data["userPaper"] ? UserPaper.fromJS(_data["userPaper"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
            if (Array.isArray(_data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of _data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleUserPaperDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleUserPaperDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["userPaper"] = this.userPaper ? this.userPaper.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISingleUserPaperDetailDto {
    snsUserInfo: SnsUserInfoDto;
    userPaper: UserPaper;
    questions: QuestionDto[] | undefined;
    questionItems: QuestionItemDto[] | undefined;
}

export enum SnsActivityAuthorizationType {
    Follow = "Follow",
    Web = "Web",
    None = "None",
    FollowAutoRegister = "FollowAutoRegister",
    WebAutoRegister = "WebAutoRegister",
}

export class SnsDataInput implements ISnsDataInput {
    snsUserInfoId!: number;
    securityKey!: string | undefined;
    isNeedSendNotify!: boolean | undefined;

    constructor(data?: ISnsDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.securityKey = _data["securityKey"];
            this.isNeedSendNotify = _data["isNeedSendNotify"];
        }
    }

    static fromJS(data: any): SnsDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["securityKey"] = this.securityKey;
        data["isNeedSendNotify"] = this.isNeedSendNotify;
        return data; 
    }
}

export interface ISnsDataInput {
    snsUserInfoId: number;
    securityKey: string | undefined;
    isNeedSendNotify: boolean | undefined;
}

export class SnsMessage implements ISnsMessage {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: EnumWeChatType;
    htmlTemplateID!: number | undefined;
    htmlTemplate!: HtmlTemplate;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
            this.weChatType = _data["weChatType"];
            this.htmlTemplateID = _data["htmlTemplateID"];
            this.htmlTemplate = _data["htmlTemplate"] ? HtmlTemplate.fromJS(_data["htmlTemplate"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        data["htmlTemplate"] = this.htmlTemplate ? this.htmlTemplate.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsMessage {
    tenantId: number;
    organizationUnitId: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: EnumWeChatType;
    htmlTemplateID: number | undefined;
    htmlTemplate: HtmlTemplate;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsMsgAfterGameDto implements ISnsMsgAfterGameDto {
    id!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: EnumWeChatType;
    htmlTemplateID!: number | undefined;

    constructor(data?: ISnsMsgAfterGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
            this.weChatType = _data["weChatType"];
            this.htmlTemplateID = _data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): SnsMsgAfterGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMsgAfterGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ISnsMsgAfterGameDto {
    id: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: EnumWeChatType;
    htmlTemplateID: number | undefined;
}

export class SnsMsgBeforeGameDto implements ISnsMsgBeforeGameDto {
    id!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    url!: string | undefined;
    textMessage!: string | undefined;
    weChatType!: EnumWeChatType;
    htmlTemplateID!: number | undefined;

    constructor(data?: ISnsMsgBeforeGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.url = _data["url"];
            this.textMessage = _data["textMessage"];
            this.weChatType = _data["weChatType"];
            this.htmlTemplateID = _data["htmlTemplateID"];
        }
    }

    static fromJS(data: any): SnsMsgBeforeGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsMsgBeforeGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["url"] = this.url;
        data["textMessage"] = this.textMessage;
        data["weChatType"] = this.weChatType;
        data["htmlTemplateID"] = this.htmlTemplateID;
        return data; 
    }
}

export interface ISnsMsgBeforeGameDto {
    id: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    url: string | undefined;
    textMessage: string | undefined;
    weChatType: EnumWeChatType;
    htmlTemplateID: number | undefined;
}

export class SnsShare implements ISnsShare {
    tenantId!: number;
    weixinShareType!: EnumWeixinShareType;
    shareAppMessageType!: string | undefined;
    shareAppMessageDataUrl!: string | undefined;
    userActionId!: number | undefined;
    userAction!: UserAction;
    activityId!: number | undefined;
    activity!: Activity;
    snsUserAwardId!: number | undefined;
    snsUserAward!: SnsUserAward;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.weixinShareType = _data["weixinShareType"];
            this.shareAppMessageType = _data["shareAppMessageType"];
            this.shareAppMessageDataUrl = _data["shareAppMessageDataUrl"];
            this.userActionId = _data["userActionId"];
            this.userAction = _data["userAction"] ? UserAction.fromJS(_data["userAction"]) : <any>undefined;
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.snsUserAwardId = _data["snsUserAwardId"];
            this.snsUserAward = _data["snsUserAward"] ? SnsUserAward.fromJS(_data["snsUserAward"]) : <any>undefined;
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfo.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsShare {
        data = typeof data === 'object' ? data : {};
        let result = new SnsShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["weixinShareType"] = this.weixinShareType;
        data["shareAppMessageType"] = this.shareAppMessageType;
        data["shareAppMessageDataUrl"] = this.shareAppMessageDataUrl;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["snsUserAwardId"] = this.snsUserAwardId;
        data["snsUserAward"] = this.snsUserAward ? this.snsUserAward.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsShare {
    tenantId: number;
    weixinShareType: EnumWeixinShareType;
    shareAppMessageType: string | undefined;
    shareAppMessageDataUrl: string | undefined;
    userActionId: number | undefined;
    userAction: UserAction;
    activityId: number | undefined;
    activity: Activity;
    snsUserAwardId: number | undefined;
    snsUserAward: SnsUserAward;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsUserActionSumDto implements ISnsUserActionSumDto {
    actionCount!: number;
    tenantId!: number;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID!: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe!: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    /** 关注时间 */
    subscribeTime!: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime!: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid!: string | undefined;
    remark!: string | undefined;
    /** 是否成为粉丝 */
    isBecomeFans!: boolean;
    /** 用户真是姓名 */
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    snsType!: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserActionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionCount = _data["actionCount"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.isBecomeFans = _data["isBecomeFans"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
            this.memberId = _data["memberId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserActionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserActionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionCount"] = this.actionCount;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserActionSumDto {
    actionCount: number;
    tenantId: number;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    /** 关注时间 */
    subscribeTime: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid: string | undefined;
    remark: string | undefined;
    /** 是否成为粉丝 */
    isBecomeFans: boolean;
    /** 用户真是姓名 */
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    snsType: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number;
}

export class SnsUserAward implements ISnsUserAward {
    tenantId!: number;
    activityId!: number;
    userActionId!: number | undefined;
    userAction!: UserAction;
    snsUserInfoId!: number;
    snsUserInfo!: SnsUserInfo;
    awardId!: number;
    award!: Award;
    deviceActivityGameId!: number | undefined;
    isNotified!: boolean;
    isReceived!: boolean;
    phone!: string | undefined;
    address!: string | undefined;
    receiverName!: string | undefined;
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    expressImageUrl!: string | undefined;
    msgid!: number;
    isNeedAwardInfo!: boolean;
    isInvalidated!: boolean;
    securityCode!: string | undefined;
    verifySecurityCode!: string | undefined;
    viewCount!: number;
    likeCount!: number;
    description!: string | undefined;
    isConfirmed!: boolean;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.userActionId = _data["userActionId"];
            this.userAction = _data["userAction"] ? UserAction.fromJS(_data["userAction"]) : <any>undefined;
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfo.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.awardId = _data["awardId"];
            this.award = _data["award"] ? Award.fromJS(_data["award"]) : <any>undefined;
            this.deviceActivityGameId = _data["deviceActivityGameId"];
            this.isNotified = _data["isNotified"];
            this.isReceived = _data["isReceived"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.receiverName = _data["receiverName"];
            this.expressNO = _data["expressNO"];
            this.expressCompany = _data["expressCompany"];
            this.expressImageUrl = _data["expressImageUrl"];
            this.msgid = _data["msgid"];
            this.isNeedAwardInfo = _data["isNeedAwardInfo"];
            this.isInvalidated = _data["isInvalidated"];
            this.securityCode = _data["securityCode"];
            this.verifySecurityCode = _data["verifySecurityCode"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isConfirmed = _data["isConfirmed"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserAward {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["receiverName"] = this.receiverName;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["expressImageUrl"] = this.expressImageUrl;
        data["msgid"] = this.msgid;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isInvalidated"] = this.isInvalidated;
        data["securityCode"] = this.securityCode;
        data["verifySecurityCode"] = this.verifySecurityCode;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isConfirmed"] = this.isConfirmed;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserAward {
    tenantId: number;
    activityId: number;
    userActionId: number | undefined;
    userAction: UserAction;
    snsUserInfoId: number;
    snsUserInfo: SnsUserInfo;
    awardId: number;
    award: Award;
    deviceActivityGameId: number | undefined;
    isNotified: boolean;
    isReceived: boolean;
    phone: string | undefined;
    address: string | undefined;
    receiverName: string | undefined;
    expressNO: string | undefined;
    expressCompany: string | undefined;
    expressImageUrl: string | undefined;
    msgid: number;
    isNeedAwardInfo: boolean;
    isInvalidated: boolean;
    securityCode: string | undefined;
    verifySecurityCode: string | undefined;
    viewCount: number;
    likeCount: number;
    description: string | undefined;
    isConfirmed: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsUserAwardOuput implements ISnsUserAwardOuput {
    tenantId!: number;
    activityId!: number;
    userActionId!: number | undefined;
    userAction!: UserActionSimpleOutput;
    snsUserInfoId!: number;
    snsUserInfo!: SnsUserInfoOutput;
    awardId!: number;
    award!: AwardOutput;
    isNotified!: boolean;
    isReceived!: boolean;
    phone!: string | undefined;
    address!: string | undefined;
    receiverName!: string | undefined;
    expressNO!: string | undefined;
    expressCompany!: string | undefined;
    expressImageUrl!: string | undefined;
    msgid!: number;
    isNeedAwardInfo!: boolean;
    isInvalidated!: boolean;
    securityCode!: string | undefined;
    viewCount!: number;
    likeCount!: number;
    description!: string | undefined;
    isConfirmed!: boolean;
    id!: number;

    constructor(data?: ISnsUserAwardOuput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.activityId = _data["activityId"];
            this.userActionId = _data["userActionId"];
            this.userAction = _data["userAction"] ? UserActionSimpleOutput.fromJS(_data["userAction"]) : <any>undefined;
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.awardId = _data["awardId"];
            this.award = _data["award"] ? AwardOutput.fromJS(_data["award"]) : <any>undefined;
            this.isNotified = _data["isNotified"];
            this.isReceived = _data["isReceived"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.receiverName = _data["receiverName"];
            this.expressNO = _data["expressNO"];
            this.expressCompany = _data["expressCompany"];
            this.expressImageUrl = _data["expressImageUrl"];
            this.msgid = _data["msgid"];
            this.isNeedAwardInfo = _data["isNeedAwardInfo"];
            this.isInvalidated = _data["isInvalidated"];
            this.securityCode = _data["securityCode"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isConfirmed = _data["isConfirmed"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserAwardOuput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAwardOuput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["activityId"] = this.activityId;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["receiverName"] = this.receiverName;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["expressImageUrl"] = this.expressImageUrl;
        data["msgid"] = this.msgid;
        data["isNeedAwardInfo"] = this.isNeedAwardInfo;
        data["isInvalidated"] = this.isInvalidated;
        data["securityCode"] = this.securityCode;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isConfirmed"] = this.isConfirmed;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserAwardOuput {
    tenantId: number;
    activityId: number;
    userActionId: number | undefined;
    userAction: UserActionSimpleOutput;
    snsUserInfoId: number;
    snsUserInfo: SnsUserInfoOutput;
    awardId: number;
    award: AwardOutput;
    isNotified: boolean;
    isReceived: boolean;
    phone: string | undefined;
    address: string | undefined;
    receiverName: string | undefined;
    expressNO: string | undefined;
    expressCompany: string | undefined;
    expressImageUrl: string | undefined;
    msgid: number;
    isNeedAwardInfo: boolean;
    isInvalidated: boolean;
    securityCode: string | undefined;
    viewCount: number;
    likeCount: number;
    description: string | undefined;
    isConfirmed: boolean;
    id: number;
}

export class SnsUserAwardsSimpleOutput implements ISnsUserAwardsSimpleOutput {
    canNextAward!: boolean;
    canFreeLottery!: boolean | undefined;
    canShareGetFreeLottery!: boolean | undefined;
    currentLotteryTimes!: number | undefined;
    awards!: SnsUserAwardOuput[] | undefined;

    constructor(data?: ISnsUserAwardsSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canNextAward = _data["canNextAward"];
            this.canFreeLottery = _data["canFreeLottery"];
            this.canShareGetFreeLottery = _data["canShareGetFreeLottery"];
            this.currentLotteryTimes = _data["currentLotteryTimes"];
            if (Array.isArray(_data["awards"])) {
                this.awards = [] as any;
                for (let item of _data["awards"])
                    this.awards!.push(SnsUserAwardOuput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SnsUserAwardsSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserAwardsSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canNextAward"] = this.canNextAward;
        data["canFreeLottery"] = this.canFreeLottery;
        data["canShareGetFreeLottery"] = this.canShareGetFreeLottery;
        data["currentLotteryTimes"] = this.currentLotteryTimes;
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISnsUserAwardsSimpleOutput {
    canNextAward: boolean;
    canFreeLottery: boolean | undefined;
    canShareGetFreeLottery: boolean | undefined;
    currentLotteryTimes: number | undefined;
    awards: SnsUserAwardOuput[] | undefined;
}

export class SnsUserInfo implements ISnsUserInfo {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    userActions!: UserAction[] | undefined;
    isBecomeFans!: boolean;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: _definitions_EnumSnsType;
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.weixinGroupid = _data["weixinGroupid"];
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["userActions"])) {
                this.userActions = [] as any;
                for (let item of _data["userActions"])
                    this.userActions!.push(UserAction.fromJS(item));
            }
            this.isBecomeFans = _data["isBecomeFans"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfo {
    tenantId: number;
    organizationUnitId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    userActions: UserAction[] | undefined;
    isBecomeFans: boolean;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: _definitions_EnumSnsType;
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsUserInfoDto implements ISnsUserInfoDto {
    tenantId!: number;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID!: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe!: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    /** 关注时间 */
    subscribeTime!: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime!: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid!: string | undefined;
    remark!: string | undefined;
    /** 是否成为粉丝 */
    isBecomeFans!: boolean;
    /** 用户真是姓名 */
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    snsType!: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    memberId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.isBecomeFans = _data["isBecomeFans"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
            this.memberId = _data["memberId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["memberId"] = this.memberId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoDto {
    tenantId: number;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    /** 关注时间 */
    subscribeTime: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid: string | undefined;
    remark: string | undefined;
    /** 是否成为粉丝 */
    isBecomeFans: boolean;
    /** 用户真是姓名 */
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    snsType: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    memberId: number | undefined;
    id: number;
}

export class SnsUserInfoForOrder implements ISnsUserInfoForOrder {
    id!: number | undefined;
    openid!: string | undefined;
    memberId!: number | undefined;

    constructor(data?: ISnsUserInfoForOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.openid = _data["openid"];
            this.memberId = _data["memberId"];
        }
    }

    static fromJS(data: any): SnsUserInfoForOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoForOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openid"] = this.openid;
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface ISnsUserInfoForOrder {
    id: number | undefined;
    openid: string | undefined;
    memberId: number | undefined;
}

export class SnsUserInfoOutput implements ISnsUserInfoOutput {
    id!: number;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number;
    language!: string | undefined;
    city!: string | undefined;
    country!: string | undefined;
    province!: string | undefined;
    headimgurl!: string | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number;
    snsType!: _definitions_EnumSnsType;

    constructor(data?: ISnsUserInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.province = _data["province"];
            this.headimgurl = _data["headimgurl"];
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.weixinGroupid = _data["weixinGroupid"];
            this.snsType = _data["snsType"];
        }
    }

    static fromJS(data: any): SnsUserInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["country"] = this.country;
        data["province"] = this.province;
        data["headimgurl"] = this.headimgurl;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["snsType"] = this.snsType;
        return data; 
    }
}

export interface ISnsUserInfoOutput {
    id: number;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number;
    language: string | undefined;
    city: string | undefined;
    country: string | undefined;
    province: string | undefined;
    headimgurl: string | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number;
    snsType: _definitions_EnumSnsType;
}

export class SnsUserInfoWithMemberDto implements ISnsUserInfoWithMemberDto {
    /** 所属的租户 Id */
    tenantId!: number;
    /** 所属的组织 Id */
    organizationUnitId!: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID!: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe!: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    /** 关注时间 */
    subscribeTime!: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime!: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    userActions!: UserAction[] | undefined;
    /** 是否成为粉丝 */
    isBecomeFans!: boolean;
    /** 用户真是姓名 */
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    snsType!: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember!: boolean;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;
    point!: string | undefined;
    memberLevel!: string | undefined;
    regPhone!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserInfoWithMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? moment(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? moment(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.remark = _data["remark"];
            this.weixinGroupid = _data["weixinGroupid"];
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["userActions"])) {
                this.userActions = [] as any;
                for (let item of _data["userActions"])
                    this.userActions!.push(UserAction.fromJS(item));
            }
            this.isBecomeFans = _data["isBecomeFans"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.snsType = _data["snsType"];
            this.isFaceMember = _data["isFaceMember"];
            this.faceMemberId = _data["faceMemberId"];
            this.faceUrl = _data["faceUrl"];
            this.point = _data["point"];
            this.memberLevel = _data["memberLevel"];
            this.regPhone = _data["regPhone"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserInfoWithMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfoWithMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        if (Array.isArray(this.userActions)) {
            data["userActions"] = [];
            for (let item of this.userActions)
                data["userActions"].push(item.toJSON());
        }
        data["isBecomeFans"] = this.isBecomeFans;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        data["point"] = this.point;
        data["memberLevel"] = this.memberLevel;
        data["regPhone"] = this.regPhone;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserInfoWithMemberDto {
    /** 所属的租户 Id */
    tenantId: number;
    /** 所属的组织 Id */
    organizationUnitId: number | undefined;
    /** 公众号的AppID/或者淘宝的TaobaoSellerId. */
    snsAppID: string | undefined;
    /** 是否关注
0:不再关注
1：关注 */
    subscribe: number | undefined;
    /** 当前公众号下面的openID,如果是淘宝,就存混淆nick */
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    /** 关注时间 */
    subscribeTime: moment.Moment | undefined;
    /** 取消关注时间 */
    unSubScribeTime: moment.Moment | undefined;
    /** 每个平台下用户的唯一Id. */
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    userActions: UserAction[] | undefined;
    /** 是否成为粉丝 */
    isBecomeFans: boolean;
    /** 用户真是姓名 */
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    snsType: _definitions_EnumSnsType;
    /** 是否是人脸会员 */
    isFaceMember: boolean;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
    point: string | undefined;
    memberLevel: string | undefined;
    regPhone: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsUserQrcode implements ISnsUserQrcode {
    tenantId!: number;
    qrCodeID!: string | undefined;
    openId!: string | undefined;
    gameId!: number;
    nickname!: string | undefined;
    headimgurl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISnsUserQrcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.qrCodeID = _data["qrCodeID"];
            this.openId = _data["openId"];
            this.gameId = _data["gameId"];
            this.nickname = _data["nickname"];
            this.headimgurl = _data["headimgurl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SnsUserQrcode {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserQrcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["qrCodeID"] = this.qrCodeID;
        data["openId"] = this.openId;
        data["gameId"] = this.gameId;
        data["nickname"] = this.nickname;
        data["headimgurl"] = this.headimgurl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISnsUserQrcode {
    tenantId: number;
    qrCodeID: string | undefined;
    openId: string | undefined;
    gameId: number;
    nickname: string | undefined;
    headimgurl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SnsUserSimpleDataInput implements ISnsUserSimpleDataInput {
    openId!: string;
    snsType!: _definitions_EnumSnsType;
    securityKey!: string;
    params!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: ISnsUserSimpleDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openId = _data["openId"];
            this.snsType = _data["snsType"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): SnsUserSimpleDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserSimpleDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface ISnsUserSimpleDataInput {
    openId: string;
    snsType: _definitions_EnumSnsType;
    securityKey: string;
    params: string | undefined;
    actionId: number | undefined;
}

export class SnsUserTextDataInput implements ISnsUserTextDataInput {
    text!: string;
    openId!: string;
    snsType!: _definitions_EnumSnsType;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: ISnsUserTextDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.openId = _data["openId"];
            this.snsType = _data["snsType"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): SnsUserTextDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserTextDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["openId"] = this.openId;
        data["snsType"] = this.snsType;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface ISnsUserTextDataInput {
    text: string;
    openId: string;
    snsType: _definitions_EnumSnsType;
    securityKey: string;
    params: string | undefined;
}

export class SoftwareOutput implements ISoftwareOutput {
    name!: string | undefined;
    code!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: number;
    versionNumber!: string | undefined;
    type!: number;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    language!: string | undefined;
    gameType!: number;
    description!: string | undefined;
    extensionData!: string | undefined;
    setting!: string | undefined;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean;
    isSendWechatBeforeGame!: boolean;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean;
    shareActionTabName!: string | undefined;
    id!: number;

    constructor(data?: ISoftwareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.language = _data["language"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.setting = _data["setting"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SoftwareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["language"] = this.language;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["setting"] = this.setting;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISoftwareOutput {
    name: string | undefined;
    code: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: number;
    versionNumber: string | undefined;
    type: number;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    language: string | undefined;
    gameType: number;
    description: string | undefined;
    extensionData: string | undefined;
    setting: string | undefined;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean;
    isSendWechatBeforeGame: boolean;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean;
    shareActionTabName: string | undefined;
    id: number;
}

export class SpecailUserDto implements ISpecailUserDto {
    tenantId!: number;
    openID!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoDto;
    awardSeqs!: string | undefined;
    activityId!: number;
    name!: string | undefined;
    /** 用户电话 */
    phone!: string | undefined;
    /** 联系地址 */
    address!: string | undefined;
    /** 用户身份证号码 */
    identityID!: string | undefined;
    /** 用户公司名 */
    companyName!: string | undefined;
    description!: string | undefined;
    type!: SpecialType;
    id!: number;

    constructor(data?: ISpecailUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.openID = _data["openID"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoDto.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.awardSeqs = _data["awardSeqs"];
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SpecailUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecailUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["openID"] = this.openID;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["awardSeqs"] = this.awardSeqs;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISpecailUserDto {
    tenantId: number;
    openID: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoDto;
    awardSeqs: string | undefined;
    activityId: number;
    name: string | undefined;
    /** 用户电话 */
    phone: string | undefined;
    /** 联系地址 */
    address: string | undefined;
    /** 用户身份证号码 */
    identityID: string | undefined;
    /** 用户公司名 */
    companyName: string | undefined;
    description: string | undefined;
    type: SpecialType;
    id: number;
}

export enum SpecialType {
    White = "White",
    Black = "Black",
}

export class StoreActivity implements IStoreActivity {
    storeId!: number;
    activityId!: number;
    activity!: Activity;
    dispatchedActivityId!: number | undefined;
    dispatchedActivity!: DispatchedActivity;
    games!: StoreActivityGame[] | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IStoreActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.dispatchedActivity = _data["dispatchedActivity"] ? DispatchedActivity.fromJS(_data["dispatchedActivity"]) : <any>undefined;
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(StoreActivityGame.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreActivity {
        data = typeof data === 'object' ? data : {};
        let result = new StoreActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["dispatchedActivity"] = this.dispatchedActivity ? this.dispatchedActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreActivity {
    storeId: number;
    activityId: number;
    activity: Activity;
    dispatchedActivityId: number | undefined;
    dispatchedActivity: DispatchedActivity;
    games: StoreActivityGame[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class StoreActivityGame implements IStoreActivityGame {
    dispatchedActivityId!: number | undefined;
    storeId!: number;
    storeActivityId!: number | undefined;
    storeActivity!: StoreActivity;
    tenantId!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    activityId!: number;
    activity!: Activity;
    isShareAction!: boolean;
    actionShareId!: number | undefined;
    actionShare!: ActivityShare;
    supportedPlayersCount!: number;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessageId!: number | undefined;
    beforeGameMessage!: SnsMessage;
    afterGameMessageId!: number | undefined;
    afterGameMessage!: SnsMessage;
    isSendSnsMsgAfterGame!: boolean;
    onlineBackground!: string | undefined;
    onlineForeground!: string | undefined;
    offlineBackground!: string | undefined;
    offlineForeground!: string | undefined;
    materialPacketUrl!: string | undefined;
    maxPlayCountPerUser!: number;
    minPlayTimeDiff!: number;
    isGameStarted!: boolean;
    lastGameOverTime!: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode!: boolean;
    securityKey!: string | undefined;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    extensionData!: string | undefined;
    points!: number;
    isAllowBlack!: boolean;
    isAllowWhite!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IStoreActivityGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.storeId = _data["storeId"];
            this.storeActivityId = _data["storeActivityId"];
            this.storeActivity = _data["storeActivity"] ? StoreActivity.fromJS(_data["storeActivity"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShareId = _data["actionShareId"];
            this.actionShare = _data["actionShare"] ? ActivityShare.fromJS(_data["actionShare"]) : <any>undefined;
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessageId = _data["beforeGameMessageId"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? SnsMessage.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.afterGameMessageId = _data["afterGameMessageId"];
            this.afterGameMessage = _data["afterGameMessage"] ? SnsMessage.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.onlineBackground = _data["onlineBackground"];
            this.onlineForeground = _data["onlineForeground"];
            this.offlineBackground = _data["offlineBackground"];
            this.offlineForeground = _data["offlineForeground"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.maxPlayCountPerUser = _data["maxPlayCountPerUser"];
            this.minPlayTimeDiff = _data["minPlayTimeDiff"];
            this.isGameStarted = _data["isGameStarted"];
            this.lastGameOverTime = _data["lastGameOverTime"] ? moment(_data["lastGameOverTime"].toString()) : <any>undefined;
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.securityKey = _data["securityKey"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.extensionData = _data["extensionData"];
            this.points = _data["points"];
            this.isAllowBlack = _data["isAllowBlack"];
            this.isAllowWhite = _data["isAllowWhite"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreActivityGame {
        data = typeof data === 'object' ? data : {};
        let result = new StoreActivityGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["storeId"] = this.storeId;
        data["storeActivityId"] = this.storeActivityId;
        data["storeActivity"] = this.storeActivity ? this.storeActivity.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShareId"] = this.actionShareId;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessageId"] = this.beforeGameMessageId;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["afterGameMessageId"] = this.afterGameMessageId;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["onlineBackground"] = this.onlineBackground;
        data["onlineForeground"] = this.onlineForeground;
        data["offlineBackground"] = this.offlineBackground;
        data["offlineForeground"] = this.offlineForeground;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["maxPlayCountPerUser"] = this.maxPlayCountPerUser;
        data["minPlayTimeDiff"] = this.minPlayTimeDiff;
        data["isGameStarted"] = this.isGameStarted;
        data["lastGameOverTime"] = this.lastGameOverTime ? this.lastGameOverTime.toISOString() : <any>undefined;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["securityKey"] = this.securityKey;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["extensionData"] = this.extensionData;
        data["points"] = this.points;
        data["isAllowBlack"] = this.isAllowBlack;
        data["isAllowWhite"] = this.isAllowWhite;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreActivityGame {
    dispatchedActivityId: number | undefined;
    storeId: number;
    storeActivityId: number | undefined;
    storeActivity: StoreActivity;
    tenantId: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    activityId: number;
    activity: Activity;
    isShareAction: boolean;
    actionShareId: number | undefined;
    actionShare: ActivityShare;
    supportedPlayersCount: number;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessageId: number | undefined;
    beforeGameMessage: SnsMessage;
    afterGameMessageId: number | undefined;
    afterGameMessage: SnsMessage;
    isSendSnsMsgAfterGame: boolean;
    onlineBackground: string | undefined;
    onlineForeground: string | undefined;
    offlineBackground: string | undefined;
    offlineForeground: string | undefined;
    materialPacketUrl: string | undefined;
    maxPlayCountPerUser: number;
    minPlayTimeDiff: number;
    isGameStarted: boolean;
    lastGameOverTime: moment.Moment | undefined;
    isNeedCheckBeforScanQRCode: boolean;
    securityKey: string | undefined;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    extensionData: string | undefined;
    points: number;
    isAllowBlack: boolean;
    isAllowWhite: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SummaryReportDto implements ISummaryReportDto {
    /** 互动人次 */
    interactiveCount!: number;
    /** 粉丝人数 */
    fansCount!: number;
    /** 线上分享人数 */
    shareCount!: number;
    /** 线上浏览人数 */
    viewCount!: number;
    /** 线上点赞人数 */
    likeCount!: number;
    /** 总传播人数 */
    spreadCount!: number;
    /** 男性人数 */
    maleCount!: number;
    /** 女性人数 */
    femaleCount!: number;
    /** 中奖人数 */
    awardCount!: number;
    /** 设备下游戏数 */
    gameCount!: number;
    /** 线下到达人数 */
    offlineCount!: number;
    /** 线下驻足人数 */
    offlineStopCount!: number;

    constructor(data?: ISummaryReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interactiveCount = _data["interactiveCount"];
            this.fansCount = _data["fansCount"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.spreadCount = _data["spreadCount"];
            this.maleCount = _data["maleCount"];
            this.femaleCount = _data["femaleCount"];
            this.awardCount = _data["awardCount"];
            this.gameCount = _data["gameCount"];
            this.offlineCount = _data["offlineCount"];
            this.offlineStopCount = _data["offlineStopCount"];
        }
    }

    static fromJS(data: any): SummaryReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interactiveCount"] = this.interactiveCount;
        data["fansCount"] = this.fansCount;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["spreadCount"] = this.spreadCount;
        data["maleCount"] = this.maleCount;
        data["femaleCount"] = this.femaleCount;
        data["awardCount"] = this.awardCount;
        data["gameCount"] = this.gameCount;
        data["offlineCount"] = this.offlineCount;
        data["offlineStopCount"] = this.offlineStopCount;
        return data; 
    }
}

export interface ISummaryReportDto {
    /** 互动人次 */
    interactiveCount: number;
    /** 粉丝人数 */
    fansCount: number;
    /** 线上分享人数 */
    shareCount: number;
    /** 线上浏览人数 */
    viewCount: number;
    /** 线上点赞人数 */
    likeCount: number;
    /** 总传播人数 */
    spreadCount: number;
    /** 男性人数 */
    maleCount: number;
    /** 女性人数 */
    femaleCount: number;
    /** 中奖人数 */
    awardCount: number;
    /** 设备下游戏数 */
    gameCount: number;
    /** 线下到达人数 */
    offlineCount: number;
    /** 线下驻足人数 */
    offlineStopCount: number;
}

export class Tag implements ITag {
    value!: string;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum TagType {
    Resource = "Resource",
    Device = "Device",
    Product = "Product",
    Ads = "Ads",
    Other = "Other",
    Brand = "Brand",
    Question = "Question",
    Counter = "Counter",
    WechatPublicMessage = "WechatPublicMessage",
    UxPage = "UxPage",
    Training = "Training",
}

export enum TemplateEnum {
    ActivityIntroduction = "ActivityIntroduction",
    Action = "Action",
    Award = "Award",
    Register = "Register",
    GameOnLine = "GameOnLine",
    GameResult = "GameResult",
}

export enum TemplateMessageType {
    付款成功通知 = "付款成功通知",
    订单支付通知 = "订单支付通知",
    订单发货通知 = "订单发货通知",
    退款申请通知 = "退款申请通知",
    退款审核通知 = "退款审核通知",
    退款成功通知 = "退款成功通知",
    取货通知 = "取货通知",
    防盗器报警通知 = "防盗器报警通知",
    商机认领提醒 = "商机认领提醒",
    新预约订单通知 = "新预约订单通知",
}

export enum ThingType {
    Spu = "Spu",
    Sku = "Sku",
}

export class Training implements ITraining {
    tenantId!: number | undefined;
    title!: string | undefined;
    no!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingCategoryEnum;
    auditStatus!: AuditStatus;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingWayEnum;
    trainingStatus!: TrainingStatusEnum;
    userId!: number;
    lecturer!: string | undefined;
    paperId!: number | undefined;
    paper!: Paper;
    description!: string | undefined;
    extensionData!: string | undefined;
    isCompleted!: boolean;
    courseId!: number | undefined;
    course!: Course;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.title = _data["title"];
            this.no = _data["no"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.category = _data["category"];
            this.auditStatus = _data["auditStatus"];
            this.totalLength = _data["totalLength"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.trainingWay = _data["trainingWay"];
            this.trainingStatus = _data["trainingStatus"];
            this.userId = _data["userId"];
            this.lecturer = _data["lecturer"];
            this.paperId = _data["paperId"];
            this.paper = _data["paper"] ? Paper.fromJS(_data["paper"]) : <any>undefined;
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.isCompleted = _data["isCompleted"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["no"] = this.no;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["trainingStatus"] = this.trainingStatus;
        data["userId"] = this.userId;
        data["lecturer"] = this.lecturer;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["isCompleted"] = this.isCompleted;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITraining {
    tenantId: number | undefined;
    title: string | undefined;
    no: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingCategoryEnum;
    auditStatus: AuditStatus;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingWayEnum;
    trainingStatus: TrainingStatusEnum;
    userId: number;
    lecturer: string | undefined;
    paperId: number | undefined;
    paper: Paper;
    description: string | undefined;
    extensionData: string | undefined;
    isCompleted: boolean;
    courseId: number | undefined;
    course: Course;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TrainingAuditInput implements ITrainingAuditInput {
    trainingIds!: number[] | undefined;
    currentAuditStatus!: AuditStatus;
    targetAuditStatus!: AuditStatus;

    constructor(data?: ITrainingAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["trainingIds"])) {
                this.trainingIds = [] as any;
                for (let item of _data["trainingIds"])
                    this.trainingIds!.push(item);
            }
            this.currentAuditStatus = _data["currentAuditStatus"];
            this.targetAuditStatus = _data["targetAuditStatus"];
        }
    }

    static fromJS(data: any): TrainingAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.trainingIds)) {
            data["trainingIds"] = [];
            for (let item of this.trainingIds)
                data["trainingIds"].push(item);
        }
        data["currentAuditStatus"] = this.currentAuditStatus;
        data["targetAuditStatus"] = this.targetAuditStatus;
        return data; 
    }
}

export interface ITrainingAuditInput {
    trainingIds: number[] | undefined;
    currentAuditStatus: AuditStatus;
    targetAuditStatus: AuditStatus;
}

export class TrainingBasicDto implements ITrainingBasicDto {
    id!: number;
    tenantId!: number | undefined;
    title!: string | undefined;
    no!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingCategoryEnum;
    auditStatus!: AuditStatus;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingWayEnum;
    trainingStatus!: TrainingStatusEnum;
    /** 主讲人用户Id */
    userId!: number;
    courseId!: number;
    /** 主讲人姓名 */
    lecturer!: string | undefined;
    /** 部门名称 */
    departmentDisplayNames!: string[] | undefined;
    score!: number | undefined;
    participaterCount!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    questionNaireId!: number | undefined;
    isMine!: boolean;
    isCompleted!: boolean;
    paperId!: number | undefined;

    constructor(data?: ITrainingBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.title = _data["title"];
            this.no = _data["no"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.category = _data["category"];
            this.auditStatus = _data["auditStatus"];
            this.totalLength = _data["totalLength"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.trainingWay = _data["trainingWay"];
            this.trainingStatus = _data["trainingStatus"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.lecturer = _data["lecturer"];
            if (Array.isArray(_data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of _data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.score = _data["score"];
            this.participaterCount = _data["participaterCount"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.questionNaireId = _data["questionNaireId"];
            this.isMine = _data["isMine"];
            this.isCompleted = _data["isCompleted"];
            this.paperId = _data["paperId"];
        }
    }

    static fromJS(data: any): TrainingBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["title"] = this.title;
        data["no"] = this.no;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["trainingStatus"] = this.trainingStatus;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["lecturer"] = this.lecturer;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["score"] = this.score;
        data["participaterCount"] = this.participaterCount;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["questionNaireId"] = this.questionNaireId;
        data["isMine"] = this.isMine;
        data["isCompleted"] = this.isCompleted;
        data["paperId"] = this.paperId;
        return data; 
    }
}

export interface ITrainingBasicDto {
    id: number;
    tenantId: number | undefined;
    title: string | undefined;
    no: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingCategoryEnum;
    auditStatus: AuditStatus;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingWayEnum;
    trainingStatus: TrainingStatusEnum;
    /** 主讲人用户Id */
    userId: number;
    courseId: number;
    /** 主讲人姓名 */
    lecturer: string | undefined;
    /** 部门名称 */
    departmentDisplayNames: string[] | undefined;
    score: number | undefined;
    participaterCount: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    questionNaireId: number | undefined;
    isMine: boolean;
    isCompleted: boolean;
    paperId: number | undefined;
}

export enum TrainingCategoryEnum {
    Basic = "Basic",
    Skill = "Skill",
    Manage = "Manage",
    Other = "Other",
}

export class TrainingSimpleDto implements ITrainingSimpleDto {
    ownerTrainings!: TrainingSimpleInfo[] | undefined;
    allTrainings!: TrainingSimpleInfo[] | undefined;

    constructor(data?: ITrainingSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ownerTrainings"])) {
                this.ownerTrainings = [] as any;
                for (let item of _data["ownerTrainings"])
                    this.ownerTrainings!.push(TrainingSimpleInfo.fromJS(item));
            }
            if (Array.isArray(_data["allTrainings"])) {
                this.allTrainings = [] as any;
                for (let item of _data["allTrainings"])
                    this.allTrainings!.push(TrainingSimpleInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ownerTrainings)) {
            data["ownerTrainings"] = [];
            for (let item of this.ownerTrainings)
                data["ownerTrainings"].push(item.toJSON());
        }
        if (Array.isArray(this.allTrainings)) {
            data["allTrainings"] = [];
            for (let item of this.allTrainings)
                data["allTrainings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingSimpleDto {
    ownerTrainings: TrainingSimpleInfo[] | undefined;
    allTrainings: TrainingSimpleInfo[] | undefined;
}

export class TrainingSimpleInfo implements ITrainingSimpleInfo {
    id!: number;
    ownerName!: string | undefined;
    name!: string | undefined;
    startTime!: moment.Moment | undefined;
    address!: string | undefined;
    isCompleted!: boolean;
    departmentDisplayNames!: string[] | undefined;
    score!: number | undefined;
    participaterCount!: number | undefined;

    constructor(data?: ITrainingSimpleInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ownerName = _data["ownerName"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["departmentDisplayNames"])) {
                this.departmentDisplayNames = [] as any;
                for (let item of _data["departmentDisplayNames"])
                    this.departmentDisplayNames!.push(item);
            }
            this.score = _data["score"];
            this.participaterCount = _data["participaterCount"];
        }
    }

    static fromJS(data: any): TrainingSimpleInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSimpleInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerName"] = this.ownerName;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.departmentDisplayNames)) {
            data["departmentDisplayNames"] = [];
            for (let item of this.departmentDisplayNames)
                data["departmentDisplayNames"].push(item);
        }
        data["score"] = this.score;
        data["participaterCount"] = this.participaterCount;
        return data; 
    }
}

export interface ITrainingSimpleInfo {
    id: number;
    ownerName: string | undefined;
    name: string | undefined;
    startTime: moment.Moment | undefined;
    address: string | undefined;
    isCompleted: boolean;
    departmentDisplayNames: string[] | undefined;
    score: number | undefined;
    participaterCount: number | undefined;
}

export enum TrainingStatusEnum {
    None = "None",
    NotStarted = "NotStarted",
    Overdue = "Overdue",
    Completed = "Completed",
}

export enum TrainingWayEnum {
    LecturerAndInsideShare = "LecturerAndInsideShare",
    LecturerAndOutersideShare = "LecturerAndOutersideShare",
    VideoAndInsideShare = "VideoAndInsideShare",
    VideoAndOutersideShare = "VideoAndOutersideShare",
}

export class UpdateActivityAwardsInput implements IUpdateActivityAwardsInput {
    securityKey!: string | undefined;
    cargoStocks!: CargoStock[] | undefined;

    constructor(data?: IUpdateActivityAwardsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityKey = _data["securityKey"];
            if (Array.isArray(_data["cargoStocks"])) {
                this.cargoStocks = [] as any;
                for (let item of _data["cargoStocks"])
                    this.cargoStocks!.push(CargoStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateActivityAwardsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityAwardsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityKey"] = this.securityKey;
        if (Array.isArray(this.cargoStocks)) {
            data["cargoStocks"] = [];
            for (let item of this.cargoStocks)
                data["cargoStocks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateActivityAwardsInput {
    securityKey: string | undefined;
    cargoStocks: CargoStock[] | undefined;
}

export class UpdateAwardInput implements IUpdateAwardInput {
    id!: number;
    /** 活动id */
    activityId!: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name!: string | undefined;
    /** 计划奖品数 */
    planQty!: number;
    /** 已发奖品数 */
    actualQty!: number;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq!: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct!: string | undefined;
    /** 奖品图片 */
    awardImagePath!: string | undefined;
    /** 最低中奖分数 */
    minScore!: number;
    /** 最高中奖分数 */
    maxScore!: number;
    /** 中奖概率 */
    rate!: number;
    /** 描述 */
    description!: string | undefined;
    /** Random Award Switch. Not used now. */
    isRandomAward!: boolean;
    type!: AwardType;
    couponUrl!: string | undefined;
    thingType!: ThingType;
    thingId!: number;

    constructor(data?: IUpdateAwardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.planQty = _data["planQty"];
            this.actualQty = _data["actualQty"];
            this.awardSeq = _data["awardSeq"];
            this.awardProduct = _data["awardProduct"];
            this.awardImagePath = _data["awardImagePath"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.isRandomAward = _data["isRandomAward"];
            this.type = _data["type"];
            this.couponUrl = _data["couponUrl"];
            this.thingType = _data["thingType"];
            this.thingId = _data["thingId"];
        }
    }

    static fromJS(data: any): UpdateAwardInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAwardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["planQty"] = this.planQty;
        data["actualQty"] = this.actualQty;
        data["awardSeq"] = this.awardSeq;
        data["awardProduct"] = this.awardProduct;
        data["awardImagePath"] = this.awardImagePath;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["isRandomAward"] = this.isRandomAward;
        data["type"] = this.type;
        data["couponUrl"] = this.couponUrl;
        data["thingType"] = this.thingType;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IUpdateAwardInput {
    id: number;
    /** 活动id */
    activityId: number;
    /** 奖项名称 如 1等奖，2等奖 */
    name: string | undefined;
    /** 计划奖品数 */
    planQty: number;
    /** 已发奖品数 */
    actualQty: number;
    /** 奖品等级 如 1，2，对应上面的 1等奖，2等奖，以后排序用 */
    awardSeq: number;
    /** 奖品名称，如 ipad，索尼照相机 */
    awardProduct: string | undefined;
    /** 奖品图片 */
    awardImagePath: string | undefined;
    /** 最低中奖分数 */
    minScore: number;
    /** 最高中奖分数 */
    maxScore: number;
    /** 中奖概率 */
    rate: number;
    /** 描述 */
    description: string | undefined;
    /** Random Award Switch. Not used now. */
    isRandomAward: boolean;
    type: AwardType;
    couponUrl: string | undefined;
    thingType: ThingType;
    thingId: number;
}

export class UpdateBasicActivityInput implements IUpdateBasicActivityInput {
    id!: number;
    /** 活动名称 */
    name!: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate!: moment.Moment | undefined;
    /** 活动主办方 */
    organizer!: string | undefined;
    /** 活动的所有者 */
    ownerName!: string | undefined;
    /** 活动线下地址 */
    address!: string | undefined;
    /** 活动开始时间 */
    openDate!: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate!: moment.Moment | undefined;
    /** 活动描述 */
    description!: string | undefined;
    /** 次活动需要注册， */
    isNeedRegister!: boolean;
    /** 活动注册的人是否需要人工验证 */
    isNeedValidate!: boolean;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic!: boolean;
    /** 公众号AppId/Taobao卖家的Id */
    weChatAppID!: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId!: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId!: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID!: string | undefined;
    /** 活动规则 */
    rules!: string | undefined;
    /** 活动Logo的url */
    activityLogoPath!: string | undefined;
    /** 活动图片 */
    imagePath!: string | undefined;
    /** 该活动是否是模板 */
    isTemplate!: boolean;
    auditStatus!: AuditStatus;
    organizationUnitId!: number | undefined;

    constructor(data?: IUpdateBasicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.activityExcutedDate = _data["activityExcutedDate"] ? moment(_data["activityExcutedDate"].toString()) : <any>undefined;
            this.organizer = _data["organizer"];
            this.ownerName = _data["ownerName"];
            this.address = _data["address"];
            this.openDate = _data["openDate"] ? moment(_data["openDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isNeedRegister = _data["isNeedRegister"];
            this.isNeedValidate = _data["isNeedValidate"];
            this.isPublic = _data["isPublic"];
            this.weChatAppID = _data["weChatAppID"];
            this.weixinPublicAccountInfoId = _data["weixinPublicAccountInfoId"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
            this.taobaoSellerID = _data["taobaoSellerID"];
            this.rules = _data["rules"];
            this.activityLogoPath = _data["activityLogoPath"];
            this.imagePath = _data["imagePath"];
            this.isTemplate = _data["isTemplate"];
            this.auditStatus = _data["auditStatus"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateBasicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBasicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["activityExcutedDate"] = this.activityExcutedDate ? this.activityExcutedDate.toISOString() : <any>undefined;
        data["organizer"] = this.organizer;
        data["ownerName"] = this.ownerName;
        data["address"] = this.address;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isNeedRegister"] = this.isNeedRegister;
        data["isNeedValidate"] = this.isNeedValidate;
        data["isPublic"] = this.isPublic;
        data["weChatAppID"] = this.weChatAppID;
        data["weixinPublicAccountInfoId"] = this.weixinPublicAccountInfoId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        data["taobaoSellerID"] = this.taobaoSellerID;
        data["rules"] = this.rules;
        data["activityLogoPath"] = this.activityLogoPath;
        data["imagePath"] = this.imagePath;
        data["isTemplate"] = this.isTemplate;
        data["auditStatus"] = this.auditStatus;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateBasicActivityInput {
    id: number;
    /** 活动名称 */
    name: string | undefined;
    /** 活动执行时间 */
    activityExcutedDate: moment.Moment | undefined;
    /** 活动主办方 */
    organizer: string | undefined;
    /** 活动的所有者 */
    ownerName: string | undefined;
    /** 活动线下地址 */
    address: string | undefined;
    /** 活动开始时间 */
    openDate: moment.Moment | undefined;
    /** 活动结束时间 */
    endDate: moment.Moment | undefined;
    /** 活动描述 */
    description: string | undefined;
    /** 次活动需要注册， */
    isNeedRegister: boolean;
    /** 活动注册的人是否需要人工验证 */
    isNeedValidate: boolean;
    /** 表明此活动是否是正式使用，或者是试用. */
    isPublic: boolean;
    /** 公众号AppId/Taobao卖家的Id */
    weChatAppID: string | undefined;
    /** 公众号信息的Id */
    weixinPublicAccountInfoId: number;
    /** 淘宝或外部接口的信息的Id. */
    externalAccessTokenInfoId: number;
    /** 公众号AppId/Taobao卖家的Id */
    taobaoSellerID: string | undefined;
    /** 活动规则 */
    rules: string | undefined;
    /** 活动Logo的url */
    activityLogoPath: string | undefined;
    /** 活动图片 */
    imagePath: string | undefined;
    /** 该活动是否是模板 */
    isTemplate: boolean;
    auditStatus: AuditStatus;
    organizationUnitId: number | undefined;
}

export class UpdateCourseInput implements IUpdateCourseInput {
    id!: number;
    name!: string | undefined;
    courseNo!: string | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdateCourseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.courseNo = _data["courseNo"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateCourseInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["courseNo"] = this.courseNo;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateCourseInput {
    id: number;
    name: string | undefined;
    courseNo: string | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    tagIds: number[] | undefined;
}

export class UpdateDeviceActivityGameInput implements IUpdateDeviceActivityGameInput {
    id!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode!: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount!: number;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessage!: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame!: boolean;
    afterGameMessage!: CreateSnsMsgGameInput;
    isShareAction!: boolean;
    actionShare!: CreateActionShareInput;
    extensionData!: string | undefined;

    constructor(data?: IUpdateDeviceActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = _data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShare = _data["actionShare"] ? CreateActionShareInput.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateDeviceActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateDeviceActivityGameInput {
    id: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount: number;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessage: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame: boolean;
    afterGameMessage: CreateSnsMsgGameInput;
    isShareAction: boolean;
    actionShare: CreateActionShareInput;
    extensionData: string | undefined;
}

export class UpdateHtmlTemplateInput implements IUpdateHtmlTemplateInput {
    id!: number;
    /** 缩略图 */
    thumbnail!: string | undefined;
    /** 大图 */
    bigImage!: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl!: string | undefined;
    /** 备用字段 */
    title!: string | undefined;
    logo!: string | undefined;
    backgroundImage!: string | undefined;
    templateType!: TemplateEnum;
    /** 描述 */
    description!: string | undefined;
    args!: string | undefined;

    constructor(data?: IUpdateHtmlTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thumbnail = _data["thumbnail"];
            this.bigImage = _data["bigImage"];
            this.actionUrl = _data["actionUrl"];
            this.title = _data["title"];
            this.logo = _data["logo"];
            this.backgroundImage = _data["backgroundImage"];
            this.templateType = _data["templateType"];
            this.description = _data["description"];
            this.args = _data["args"];
        }
    }

    static fromJS(data: any): UpdateHtmlTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHtmlTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thumbnail"] = this.thumbnail;
        data["bigImage"] = this.bigImage;
        data["actionUrl"] = this.actionUrl;
        data["title"] = this.title;
        data["logo"] = this.logo;
        data["backgroundImage"] = this.backgroundImage;
        data["templateType"] = this.templateType;
        data["description"] = this.description;
        data["args"] = this.args;
        return data; 
    }
}

export interface IUpdateHtmlTemplateInput {
    id: number;
    /** 缩略图 */
    thumbnail: string | undefined;
    /** 大图 */
    bigImage: string | undefined;
    /** 模板的full url
如 http://game.troncell.com/weixin/wechatpage */
    actionUrl: string | undefined;
    /** 备用字段 */
    title: string | undefined;
    logo: string | undefined;
    backgroundImage: string | undefined;
    templateType: TemplateEnum;
    /** 描述 */
    description: string | undefined;
    args: string | undefined;
}

export class UpdatePaperInput implements IUpdatePaperInput {
    id!: number;
    /** 试卷名称,必须唯一 */
    name!: string | undefined;
    displayName!: string | undefined;
    /** 试卷的Logo图 */
    logoUrl!: string | undefined;
    /** 试卷的图片 */
    imageUrl!: string | undefined;
    /** 试卷的描述 */
    description!: string | undefined;
    /** 试卷的组织者 */
    owner!: string | undefined;
    /** 试卷时怎么生产的 */
    fromType!: string | undefined;
    extensionData!: string | undefined;
    outerId!: string | undefined;
    questionsCount!: number;
    compositionType!: PaperCompositionEnum;
    paperUsageType!: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount!: number;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdatePaperInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.description = _data["description"];
            this.owner = _data["owner"];
            this.fromType = _data["fromType"];
            this.extensionData = _data["extensionData"];
            this.outerId = _data["outerId"];
            this.questionsCount = _data["questionsCount"];
            this.compositionType = _data["compositionType"];
            this.paperUsageType = _data["paperUsageType"];
            this.randomCount = _data["randomCount"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePaperInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaperInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        data["owner"] = this.owner;
        data["fromType"] = this.fromType;
        data["extensionData"] = this.extensionData;
        data["outerId"] = this.outerId;
        data["questionsCount"] = this.questionsCount;
        data["compositionType"] = this.compositionType;
        data["paperUsageType"] = this.paperUsageType;
        data["randomCount"] = this.randomCount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdatePaperInput {
    id: number;
    /** 试卷名称,必须唯一 */
    name: string | undefined;
    displayName: string | undefined;
    /** 试卷的Logo图 */
    logoUrl: string | undefined;
    /** 试卷的图片 */
    imageUrl: string | undefined;
    /** 试卷的描述 */
    description: string | undefined;
    /** 试卷的组织者 */
    owner: string | undefined;
    /** 试卷时怎么生产的 */
    fromType: string | undefined;
    extensionData: string | undefined;
    outerId: string | undefined;
    questionsCount: number;
    compositionType: PaperCompositionEnum;
    paperUsageType: PaperUsageType;
    /** 随机的场合，随机题目的数量，最大不能超过题目的总量 QuestionsCount */
    randomCount: number;
    tagIds: number[] | undefined;
}

export class UpdateQuestionInput implements IUpdateQuestionInput {
    id!: number;
    /** Question的名称 */
    prefix!: string | undefined;
    /** 问题标题 */
    title!: string | undefined;
    type!: QuestionTypeEnum;
    /** 此道题的得分 */
    score!: number;
    /** 题目的顺序 */
    orderNo!: number;
    /** 内容 */
    content!: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer!: string | undefined;
    description!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    enabled!: boolean;
    outerId!: string | undefined;
    questionScoreType!: QuestionScoreTypeEnum;
    questionItems!: QuestionItemDto[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdateQuestionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prefix = _data["prefix"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.score = _data["score"];
            this.orderNo = _data["orderNo"];
            this.content = _data["content"];
            this.answer = _data["answer"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.enabled = _data["enabled"];
            this.outerId = _data["outerId"];
            this.questionScoreType = _data["questionScoreType"];
            if (Array.isArray(_data["questionItems"])) {
                this.questionItems = [] as any;
                for (let item of _data["questionItems"])
                    this.questionItems!.push(QuestionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateQuestionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["type"] = this.type;
        data["score"] = this.score;
        data["orderNo"] = this.orderNo;
        data["content"] = this.content;
        data["answer"] = this.answer;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["enabled"] = this.enabled;
        data["outerId"] = this.outerId;
        data["questionScoreType"] = this.questionScoreType;
        if (Array.isArray(this.questionItems)) {
            data["questionItems"] = [];
            for (let item of this.questionItems)
                data["questionItems"].push(item.toJSON());
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateQuestionInput {
    id: number;
    /** Question的名称 */
    prefix: string | undefined;
    /** 问题标题 */
    title: string | undefined;
    type: QuestionTypeEnum;
    /** 此道题的得分 */
    score: number;
    /** 题目的顺序 */
    orderNo: number;
    /** 内容 */
    content: string | undefined;
    /** Text问题的答案，选择题的答案在Item里面 */
    answer: string | undefined;
    description: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    enabled: boolean;
    outerId: string | undefined;
    questionScoreType: QuestionScoreTypeEnum;
    questionItems: QuestionItemDto[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateQuestionScoreAndOrderInput implements IUpdateQuestionScoreAndOrderInput {
    paperId!: number;
    questions!: PublishedQuestionDto[] | undefined;

    constructor(data?: IUpdateQuestionScoreAndOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paperId = _data["paperId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(PublishedQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateQuestionScoreAndOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionScoreAndOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paperId"] = this.paperId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateQuestionScoreAndOrderInput {
    paperId: number;
    questions: PublishedQuestionDto[] | undefined;
}

export class UpdateQuestionStatusInput implements IUpdateQuestionStatusInput {
    ids!: number[] | undefined;
    isEnabled!: boolean;

    constructor(data?: IUpdateQuestionStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateQuestionStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IUpdateQuestionStatusInput {
    ids: number[] | undefined;
    isEnabled: boolean;
}

export class UpdateSnsUserAwardExpressInput implements IUpdateSnsUserAwardExpressInput {
    /** 快递单号 */
    expressNO!: string | undefined;
    /** 快递公司名称 */
    expressCompany!: string | undefined;
    id!: number;

    constructor(data?: IUpdateSnsUserAwardExpressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expressNO = _data["expressNO"];
            this.expressCompany = _data["expressCompany"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSnsUserAwardExpressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSnsUserAwardExpressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateSnsUserAwardExpressInput {
    /** 快递单号 */
    expressNO: string | undefined;
    /** 快递公司名称 */
    expressCompany: string | undefined;
    id: number;
}

export class UpdateSpecialUserInput implements IUpdateSpecialUserInput {
    id!: number;
    activityId!: number;
    name!: string | undefined;
    awardSeqs!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    identityID!: string | undefined;
    companyName!: string | undefined;
    description!: string | undefined;
    forAward!: boolean | undefined;
    forLottery!: boolean | undefined;
    forUseTicket!: boolean | undefined;
    type!: SpecialType;

    constructor(data?: IUpdateSpecialUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityId = _data["activityId"];
            this.name = _data["name"];
            this.awardSeqs = _data["awardSeqs"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.identityID = _data["identityID"];
            this.companyName = _data["companyName"];
            this.description = _data["description"];
            this.forAward = _data["forAward"];
            this.forLottery = _data["forLottery"];
            this.forUseTicket = _data["forUseTicket"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UpdateSpecialUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSpecialUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["name"] = this.name;
        data["awardSeqs"] = this.awardSeqs;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["identityID"] = this.identityID;
        data["companyName"] = this.companyName;
        data["description"] = this.description;
        data["forAward"] = this.forAward;
        data["forLottery"] = this.forLottery;
        data["forUseTicket"] = this.forUseTicket;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUpdateSpecialUserInput {
    id: number;
    activityId: number;
    name: string | undefined;
    awardSeqs: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    identityID: string | undefined;
    companyName: string | undefined;
    description: string | undefined;
    forAward: boolean | undefined;
    forLottery: boolean | undefined;
    forUseTicket: boolean | undefined;
    type: SpecialType;
}

export class UpdateStoreActivityGameInput implements IUpdateStoreActivityGameInput {
    id!: number;
    name!: string | undefined;
    softwareId!: number;
    dispatchedSoftwareId!: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode!: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount!: number;
    weChatAuthorizationType!: SnsActivityAuthorizationType;
    taobaoAuthorizationType!: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl!: string | undefined;
    isSendSnsMsgBeforeGame!: boolean;
    beforeGameMessage!: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame!: boolean;
    afterGameMessage!: CreateSnsMsgGameInput;
    isShareAction!: boolean;
    actionShare!: CreateActionShareInput;
    extensionData!: string | undefined;

    constructor(data?: IUpdateStoreActivityGameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.softwareId = _data["softwareId"];
            this.dispatchedSoftwareId = _data["dispatchedSoftwareId"];
            this.isNeedCheckBeforScanQRCode = _data["isNeedCheckBeforScanQRCode"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.weChatAuthorizationType = _data["weChatAuthorizationType"];
            this.taobaoAuthorizationType = _data["taobaoAuthorizationType"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isSendSnsMsgBeforeGame = _data["isSendSnsMsgBeforeGame"];
            this.beforeGameMessage = _data["beforeGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["beforeGameMessage"]) : <any>undefined;
            this.isSendSnsMsgAfterGame = _data["isSendSnsMsgAfterGame"];
            this.afterGameMessage = _data["afterGameMessage"] ? CreateSnsMsgGameInput.fromJS(_data["afterGameMessage"]) : <any>undefined;
            this.isShareAction = _data["isShareAction"];
            this.actionShare = _data["actionShare"] ? CreateActionShareInput.fromJS(_data["actionShare"]) : <any>undefined;
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateStoreActivityGameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreActivityGameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["softwareId"] = this.softwareId;
        data["dispatchedSoftwareId"] = this.dispatchedSoftwareId;
        data["isNeedCheckBeforScanQRCode"] = this.isNeedCheckBeforScanQRCode;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["weChatAuthorizationType"] = this.weChatAuthorizationType;
        data["taobaoAuthorizationType"] = this.taobaoAuthorizationType;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isSendSnsMsgBeforeGame"] = this.isSendSnsMsgBeforeGame;
        data["beforeGameMessage"] = this.beforeGameMessage ? this.beforeGameMessage.toJSON() : <any>undefined;
        data["isSendSnsMsgAfterGame"] = this.isSendSnsMsgAfterGame;
        data["afterGameMessage"] = this.afterGameMessage ? this.afterGameMessage.toJSON() : <any>undefined;
        data["isShareAction"] = this.isShareAction;
        data["actionShare"] = this.actionShare ? this.actionShare.toJSON() : <any>undefined;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateStoreActivityGameInput {
    id: number;
    name: string | undefined;
    softwareId: number;
    dispatchedSoftwareId: number;
    /** 某些特定活动扫码前需要做一些check */
    isNeedCheckBeforScanQRCode: boolean;
    /** 该活动中游戏最大支持人数 */
    supportedPlayersCount: number;
    weChatAuthorizationType: SnsActivityAuthorizationType;
    taobaoAuthorizationType: SnsActivityAuthorizationType;
    /** 用户自定义游戏素材zip路径 */
    materialPacketUrl: string | undefined;
    isSendSnsMsgBeforeGame: boolean;
    beforeGameMessage: CreateSnsMsgGameInput;
    isSendSnsMsgAfterGame: boolean;
    afterGameMessage: CreateSnsMsgGameInput;
    isShareAction: boolean;
    actionShare: CreateActionShareInput;
    extensionData: string | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    orderNumber: number;
    description: string | undefined;
}

export class UpdateTrainingInput implements IUpdateTrainingInput {
    id!: number;
    title!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    address!: string | undefined;
    category!: TrainingCategoryEnum;
    auditStatus!: AuditStatus;
    totalLength!: number | undefined;
    fileUrl!: string | undefined;
    picUrl!: string | undefined;
    trainingWay!: TrainingWayEnum;
    /** 主讲人用户Id */
    userId!: number | undefined;
    courseId!: number | undefined;
    groupIds!: number[] | undefined;
    paperId!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateTrainingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.category = _data["category"];
            this.auditStatus = _data["auditStatus"];
            this.totalLength = _data["totalLength"];
            this.fileUrl = _data["fileUrl"];
            this.picUrl = _data["picUrl"];
            this.trainingWay = _data["trainingWay"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.paperId = _data["paperId"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateTrainingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["category"] = this.category;
        data["auditStatus"] = this.auditStatus;
        data["totalLength"] = this.totalLength;
        data["fileUrl"] = this.fileUrl;
        data["picUrl"] = this.picUrl;
        data["trainingWay"] = this.trainingWay;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["paperId"] = this.paperId;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateTrainingInput {
    id: number;
    title: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    address: string | undefined;
    category: TrainingCategoryEnum;
    auditStatus: AuditStatus;
    totalLength: number | undefined;
    fileUrl: string | undefined;
    picUrl: string | undefined;
    trainingWay: TrainingWayEnum;
    /** 主讲人用户Id */
    userId: number | undefined;
    courseId: number | undefined;
    groupIds: number[] | undefined;
    paperId: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class UpdateUserActionInput implements IUpdateUserActionInput {
    id!: number;
    /** 基本微信用户数据 */
    snsUserInfoId!: number;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    /** 分享后浏览的次数 */
    viewCount!: number;
    /** 分享后点赞的次数 */
    likeCount!: number;
    score!: number | undefined;
    /** 游戏图片 */
    gameImage!: string | undefined;

    constructor(data?: IUpdateUserActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.score = _data["score"];
            this.gameImage = _data["gameImage"];
        }
    }

    static fromJS(data: any): UpdateUserActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["score"] = this.score;
        data["gameImage"] = this.gameImage;
        return data; 
    }
}

export interface IUpdateUserActionInput {
    id: number;
    /** 基本微信用户数据 */
    snsUserInfoId: number;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    /** 分享后浏览的次数 */
    viewCount: number;
    /** 分享后点赞的次数 */
    likeCount: number;
    score: number | undefined;
    /** 游戏图片 */
    gameImage: string | undefined;
}

export class UserAction implements IUserAction {
    tenantId!: number;
    deviceActivityId!: number | undefined;
    dispatchedActivityId!: number | undefined;
    deviceActivityGameId!: number | undefined;
    deviceActivityGame!: DeviceActivityGame;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfo;
    imagePath!: string | undefined;
    softwareId!: number | undefined;
    softwareName!: string | undefined;
    activityId!: number;
    activity!: Activity;
    status!: ActionStatus;
    gameImage!: string | undefined;
    postUrl!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    score!: number | undefined;
    scene_id!: string | undefined;
    qrCodesImg!: string | undefined;
    media_id!: string | undefined;
    describeInfo!: string | undefined;
    clientName!: string | undefined;
    actionName!: string | undefined;
    queueNum!: string | undefined;
    securityCode!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerImage!: string | undefined;
    playerAge!: number | undefined;
    viewCount!: number;
    likeCount!: number;
    snsShares!: SnsShare[] | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    award!: Award;
    organizationUnitId!: number | undefined;
    organizationUnitName!: string | undefined;
    deviceId!: number | undefined;
    deviceName!: string | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    points!: number;
    type!: string | undefined;
    extensionData!: string | undefined;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.deviceActivityId = _data["deviceActivityId"];
            this.dispatchedActivityId = _data["dispatchedActivityId"];
            this.deviceActivityGameId = _data["deviceActivityGameId"];
            this.deviceActivityGame = _data["deviceActivityGame"] ? DeviceActivityGame.fromJS(_data["deviceActivityGame"]) : <any>undefined;
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfo.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.imagePath = _data["imagePath"];
            this.softwareId = _data["softwareId"];
            this.softwareName = _data["softwareName"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.status = _data["status"];
            this.gameImage = _data["gameImage"];
            this.postUrl = _data["postUrl"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.score = _data["score"];
            this.scene_id = _data["scene_id"];
            this.qrCodesImg = _data["qrCodesImg"];
            this.media_id = _data["media_id"];
            this.describeInfo = _data["describeInfo"];
            this.clientName = _data["clientName"];
            this.actionName = _data["actionName"];
            this.queueNum = _data["queueNum"];
            this.securityCode = _data["securityCode"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerImage = _data["playerImage"];
            this.playerAge = _data["playerAge"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            if (Array.isArray(_data["snsShares"])) {
                this.snsShares = [] as any;
                for (let item of _data["snsShares"])
                    this.snsShares!.push(SnsShare.fromJS(item));
            }
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.award = _data["award"] ? Award.fromJS(_data["award"]) : <any>undefined;
            this.organizationUnitId = _data["organizationUnitId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.points = _data["points"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserAction {
        data = typeof data === 'object' ? data : {};
        let result = new UserAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["deviceActivityId"] = this.deviceActivityId;
        data["dispatchedActivityId"] = this.dispatchedActivityId;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["softwareId"] = this.softwareId;
        data["softwareName"] = this.softwareName;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["gameImage"] = this.gameImage;
        data["postUrl"] = this.postUrl;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["score"] = this.score;
        data["scene_id"] = this.scene_id;
        data["qrCodesImg"] = this.qrCodesImg;
        data["media_id"] = this.media_id;
        data["describeInfo"] = this.describeInfo;
        data["clientName"] = this.clientName;
        data["actionName"] = this.actionName;
        data["queueNum"] = this.queueNum;
        data["securityCode"] = this.securityCode;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerImage"] = this.playerImage;
        data["playerAge"] = this.playerAge;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        if (Array.isArray(this.snsShares)) {
            data["snsShares"] = [];
            for (let item of this.snsShares)
                data["snsShares"].push(item.toJSON());
        }
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["award"] = this.award ? this.award.toJSON() : <any>undefined;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["points"] = this.points;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserAction {
    tenantId: number;
    deviceActivityId: number | undefined;
    dispatchedActivityId: number | undefined;
    deviceActivityGameId: number | undefined;
    deviceActivityGame: DeviceActivityGame;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfo;
    imagePath: string | undefined;
    softwareId: number | undefined;
    softwareName: string | undefined;
    activityId: number;
    activity: Activity;
    status: ActionStatus;
    gameImage: string | undefined;
    postUrl: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    score: number | undefined;
    scene_id: string | undefined;
    qrCodesImg: string | undefined;
    media_id: string | undefined;
    describeInfo: string | undefined;
    clientName: string | undefined;
    actionName: string | undefined;
    queueNum: string | undefined;
    securityCode: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerImage: string | undefined;
    playerAge: number | undefined;
    viewCount: number;
    likeCount: number;
    snsShares: SnsShare[] | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    award: Award;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    deviceId: number | undefined;
    deviceName: string | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    points: number;
    type: string | undefined;
    extensionData: string | undefined;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserActionDataOutput implements IUserActionDataOutput {
    deviceActivityGame!: DeviceActivityGameOutput;
    device!: DeviceSimpleDto;
    externalAccessSession!: string | undefined;
    transferActionUrl!: string | undefined;
    activityFlows!: ActivityFlowOutput[] | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number;
    shareCount!: number;
    viewCount!: number;
    likeCount!: number;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean;
    failReason!: string | undefined;
    id!: number;

    constructor(data?: IUserActionDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceActivityGame = _data["deviceActivityGame"] ? DeviceActivityGameOutput.fromJS(_data["deviceActivityGame"]) : <any>undefined;
            this.device = _data["device"] ? DeviceSimpleDto.fromJS(_data["device"]) : <any>undefined;
            this.externalAccessSession = _data["externalAccessSession"];
            this.transferActionUrl = _data["transferActionUrl"];
            if (Array.isArray(_data["activityFlows"])) {
                this.activityFlows = [] as any;
                for (let item of _data["activityFlows"])
                    this.activityFlows!.push(ActivityFlowOutput.fromJS(item));
            }
            this.qrCodeId = _data["qrCodeId"];
            this.score = _data["score"];
            this.postUrl = _data["postUrl"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.scanQrCodeTime = _data["scanQrCodeTime"];
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.failReason = _data["failReason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserActionDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceActivityGame"] = this.deviceActivityGame ? this.deviceActivityGame.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["externalAccessSession"] = this.externalAccessSession;
        data["transferActionUrl"] = this.transferActionUrl;
        if (Array.isArray(this.activityFlows)) {
            data["activityFlows"] = [];
            for (let item of this.activityFlows)
                data["activityFlows"].push(item.toJSON());
        }
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionDataOutput {
    deviceActivityGame: DeviceActivityGameOutput;
    device: DeviceSimpleDto;
    externalAccessSession: string | undefined;
    transferActionUrl: string | undefined;
    activityFlows: ActivityFlowOutput[] | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number;
    shareCount: number;
    viewCount: number;
    likeCount: number;
    scanQrCodeTime: string | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean;
    failReason: string | undefined;
    id: number;
}

export class UserActionDto implements IUserActionDto {
    id!: number;
    snsUserId!: number;
    headimgurl!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    province!: string | undefined;
    city!: string | undefined;
    snsType!: _definitions_EnumSnsType;
    activityId!: number;
    activityName!: string | undefined;
    snsAppID!: string | undefined;
    /** 游戏名称 */
    softwareName!: string | undefined;
    softwareId!: number;
    /** 游戏时间 */
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    /** 游戏分数 */
    score!: number | undefined;
    /** 分享后浏览的次数 */
    viewCount!: number;
    /** 分享后点赞的次数 */
    likeCount!: number;
    /** 游戏图片 */
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerAge!: number | undefined;
    shareCount!: number;
    type!: string | undefined;
    extensionData!: string | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    awardId!: number | undefined;
    awardName!: string | undefined;

    constructor(data?: IUserActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.snsUserId = _data["snsUserId"];
            this.headimgurl = _data["headimgurl"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.snsType = _data["snsType"];
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.snsAppID = _data["snsAppID"];
            this.softwareName = _data["softwareName"];
            this.softwareId = _data["softwareId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.score = _data["score"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.awardId = _data["awardId"];
            this.awardName = _data["awardName"];
        }
    }

    static fromJS(data: any): UserActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["snsUserId"] = this.snsUserId;
        data["headimgurl"] = this.headimgurl;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["province"] = this.province;
        data["city"] = this.city;
        data["snsType"] = this.snsType;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["snsAppID"] = this.snsAppID;
        data["softwareName"] = this.softwareName;
        data["softwareId"] = this.softwareId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["score"] = this.score;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["awardId"] = this.awardId;
        data["awardName"] = this.awardName;
        return data; 
    }
}

export interface IUserActionDto {
    id: number;
    snsUserId: number;
    headimgurl: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    province: string | undefined;
    city: string | undefined;
    snsType: _definitions_EnumSnsType;
    activityId: number;
    activityName: string | undefined;
    snsAppID: string | undefined;
    /** 游戏名称 */
    softwareName: string | undefined;
    softwareId: number;
    /** 游戏时间 */
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    /** 游戏分数 */
    score: number | undefined;
    /** 分享后浏览的次数 */
    viewCount: number;
    /** 分享后点赞的次数 */
    likeCount: number;
    /** 游戏图片 */
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerAge: number | undefined;
    shareCount: number;
    type: string | undefined;
    extensionData: string | undefined;
    deviceId: number;
    deviceName: string | undefined;
    awardId: number | undefined;
    awardName: string | undefined;
}

export class UserActionInfoOutput implements IUserActionInfoOutput {
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number;
    shareCount!: number;
    viewCount!: number;
    likeCount!: number;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean;
    failReason!: string | undefined;
    id!: number;

    constructor(data?: IUserActionInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeId = _data["qrCodeId"];
            this.score = _data["score"];
            this.postUrl = _data["postUrl"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.scanQrCodeTime = _data["scanQrCodeTime"];
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.failReason = _data["failReason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserActionInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionInfoOutput {
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number;
    shareCount: number;
    viewCount: number;
    likeCount: number;
    scanQrCodeTime: string | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean;
    failReason: string | undefined;
    id: number;
}

export class UserActionPlayInfoOutput implements IUserActionPlayInfoOutput {
    gameName!: string | undefined;
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number;
    shareCount!: number;
    viewCount!: number;
    likeCount!: number;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput;
    creationTime!: moment.Moment | undefined;
    isSuccess!: boolean;
    failReason!: string | undefined;
    id!: number;

    constructor(data?: IUserActionPlayInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameName = _data["gameName"];
            this.qrCodeId = _data["qrCodeId"];
            this.score = _data["score"];
            this.postUrl = _data["postUrl"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.scanQrCodeTime = _data["scanQrCodeTime"];
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.failReason = _data["failReason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserActionPlayInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionPlayInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameName"] = this.gameName;
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["failReason"] = this.failReason;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionPlayInfoOutput {
    gameName: string | undefined;
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number;
    shareCount: number;
    viewCount: number;
    likeCount: number;
    scanQrCodeTime: string | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput;
    creationTime: moment.Moment | undefined;
    isSuccess: boolean;
    failReason: string | undefined;
    id: number;
}

export class UserActionSimpleOutput implements IUserActionSimpleOutput {
    qrCodeId!: string | undefined;
    score!: number | undefined;
    postUrl!: string | undefined;
    gameImage!: string | undefined;
    playerImage!: string | undefined;
    playerPhone!: string | undefined;
    playerEmail!: string | undefined;
    playerAge!: number;
    shareCount!: number;
    viewCount!: number;
    likeCount!: number;
    scanQrCodeTime!: string | undefined;
    isSigned!: boolean;
    awardId!: number | undefined;
    isForged!: boolean | undefined;
    forgedReason!: string | undefined;
    type!: string | undefined;
    extensionData!: string | undefined;
    snsUserInfoId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number;

    constructor(data?: IUserActionSimpleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeId = _data["qrCodeId"];
            this.score = _data["score"];
            this.postUrl = _data["postUrl"];
            this.gameImage = _data["gameImage"];
            this.playerImage = _data["playerImage"];
            this.playerPhone = _data["playerPhone"];
            this.playerEmail = _data["playerEmail"];
            this.playerAge = _data["playerAge"];
            this.shareCount = _data["shareCount"];
            this.viewCount = _data["viewCount"];
            this.likeCount = _data["likeCount"];
            this.scanQrCodeTime = _data["scanQrCodeTime"];
            this.isSigned = _data["isSigned"];
            this.awardId = _data["awardId"];
            this.isForged = _data["isForged"];
            this.forgedReason = _data["forgedReason"];
            this.type = _data["type"];
            this.extensionData = _data["extensionData"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserActionSimpleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserActionSimpleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeId"] = this.qrCodeId;
        data["score"] = this.score;
        data["postUrl"] = this.postUrl;
        data["gameImage"] = this.gameImage;
        data["playerImage"] = this.playerImage;
        data["playerPhone"] = this.playerPhone;
        data["playerEmail"] = this.playerEmail;
        data["playerAge"] = this.playerAge;
        data["shareCount"] = this.shareCount;
        data["viewCount"] = this.viewCount;
        data["likeCount"] = this.likeCount;
        data["scanQrCodeTime"] = this.scanQrCodeTime;
        data["isSigned"] = this.isSigned;
        data["awardId"] = this.awardId;
        data["isForged"] = this.isForged;
        data["forgedReason"] = this.forgedReason;
        data["type"] = this.type;
        data["extensionData"] = this.extensionData;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserActionSimpleOutput {
    qrCodeId: string | undefined;
    score: number | undefined;
    postUrl: string | undefined;
    gameImage: string | undefined;
    playerImage: string | undefined;
    playerPhone: string | undefined;
    playerEmail: string | undefined;
    playerAge: number;
    shareCount: number;
    viewCount: number;
    likeCount: number;
    scanQrCodeTime: string | undefined;
    isSigned: boolean;
    awardId: number | undefined;
    isForged: boolean | undefined;
    forgedReason: string | undefined;
    type: string | undefined;
    extensionData: string | undefined;
    snsUserInfoId: number | undefined;
    creationTime: moment.Moment | undefined;
    id: number;
}

export class UserAwardByActivityDto implements IUserAwardByActivityDto {
    awardCount!: number;
    verificatedCount!: number;

    constructor(data?: IUserAwardByActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.awardCount = _data["awardCount"];
            this.verificatedCount = _data["verificatedCount"];
        }
    }

    static fromJS(data: any): UserAwardByActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardByActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardCount"] = this.awardCount;
        data["verificatedCount"] = this.verificatedCount;
        return data; 
    }
}

export interface IUserAwardByActivityDto {
    awardCount: number;
    verificatedCount: number;
}

export class UserAwardDataInput implements IUserAwardDataInput {
    userAwardId!: number;
    securityKey!: string;
    params!: string | undefined;

    constructor(data?: IUserAwardDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userAwardId = _data["userAwardId"];
            this.securityKey = _data["securityKey"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): UserAwardDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userAwardId"] = this.userAwardId;
        data["securityKey"] = this.securityKey;
        data["params"] = this.params;
        return data; 
    }
}

export interface IUserAwardDataInput {
    userAwardId: number;
    securityKey: string;
    params: string | undefined;
}

export class UserAwardDto implements IUserAwardDto {
    id!: number;
    creationTime!: moment.Moment;
    headimgurl!: string | undefined;
    nickname!: string | undefined;
    snsAppName!: string | undefined;
    securityCode!: string | undefined;
    awardSeq!: number;
    name!: string | undefined;
    isConfirmed!: boolean;
    isNotified!: boolean;
    /** 用户是否收到奖品 */
    isReceived!: boolean;
    /** 快递单号 */
    expressNO!: string | undefined;
    /** 快递公司名称 */
    expressCompany!: string | undefined;
    gameName!: string | undefined;

    constructor(data?: IUserAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.headimgurl = _data["headimgurl"];
            this.nickname = _data["nickname"];
            this.snsAppName = _data["snsAppName"];
            this.securityCode = _data["securityCode"];
            this.awardSeq = _data["awardSeq"];
            this.name = _data["name"];
            this.isConfirmed = _data["isConfirmed"];
            this.isNotified = _data["isNotified"];
            this.isReceived = _data["isReceived"];
            this.expressNO = _data["expressNO"];
            this.expressCompany = _data["expressCompany"];
            this.gameName = _data["gameName"];
        }
    }

    static fromJS(data: any): UserAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["headimgurl"] = this.headimgurl;
        data["nickname"] = this.nickname;
        data["snsAppName"] = this.snsAppName;
        data["securityCode"] = this.securityCode;
        data["awardSeq"] = this.awardSeq;
        data["name"] = this.name;
        data["isConfirmed"] = this.isConfirmed;
        data["isNotified"] = this.isNotified;
        data["isReceived"] = this.isReceived;
        data["expressNO"] = this.expressNO;
        data["expressCompany"] = this.expressCompany;
        data["gameName"] = this.gameName;
        return data; 
    }
}

export interface IUserAwardDto {
    id: number;
    creationTime: moment.Moment;
    headimgurl: string | undefined;
    nickname: string | undefined;
    snsAppName: string | undefined;
    securityCode: string | undefined;
    awardSeq: number;
    name: string | undefined;
    isConfirmed: boolean;
    isNotified: boolean;
    /** 用户是否收到奖品 */
    isReceived: boolean;
    /** 快递单号 */
    expressNO: string | undefined;
    /** 快递公司名称 */
    expressCompany: string | undefined;
    gameName: string | undefined;
}

export class UserGameRank implements IUserGameRank {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    score!: number;

    constructor(data?: IUserGameRank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headImgUrl = _data["headImgUrl"];
            this.nickName = _data["nickName"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): UserGameRank {
        data = typeof data === 'object' ? data : {};
        let result = new UserGameRank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IUserGameRank {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    score: number;
}

export class UserInteractiveDto implements IUserInteractiveDto {
    headImgUrl!: string | undefined;
    nickName!: string | undefined;
    interactiveCount!: number;

    constructor(data?: IUserInteractiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headImgUrl = _data["headImgUrl"];
            this.nickName = _data["nickName"];
            this.interactiveCount = _data["interactiveCount"];
        }
    }

    static fromJS(data: any): UserInteractiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInteractiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headImgUrl"] = this.headImgUrl;
        data["nickName"] = this.nickName;
        data["interactiveCount"] = this.interactiveCount;
        return data; 
    }
}

export interface IUserInteractiveDto {
    headImgUrl: string | undefined;
    nickName: string | undefined;
    interactiveCount: number;
}

export class UserPaper implements IUserPaper {
    tenantId!: number | undefined;
    snsUserInfoId!: number;
    snsUserInfo!: SnsUserInfo;
    paperId!: number;
    paper!: Paper;
    userActionId!: number | undefined;
    userAction!: UserAction;
    trainingId!: number | undefined;
    training!: Training;
    dispatchedSoftwarePaperId!: number | undefined;
    dispatchedSoftwarePaper!: DispatchedSoftwarePaper;
    examStartTime!: moment.Moment | undefined;
    examEndTime!: moment.Moment | undefined;
    answeredQuestionCount!: number;
    correctCount!: number;
    totalScore!: number;
    examResult!: ExamEnum;
    opinion!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserPaper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfo.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.paperId = _data["paperId"];
            this.paper = _data["paper"] ? Paper.fromJS(_data["paper"]) : <any>undefined;
            this.userActionId = _data["userActionId"];
            this.userAction = _data["userAction"] ? UserAction.fromJS(_data["userAction"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.dispatchedSoftwarePaperId = _data["dispatchedSoftwarePaperId"];
            this.dispatchedSoftwarePaper = _data["dispatchedSoftwarePaper"] ? DispatchedSoftwarePaper.fromJS(_data["dispatchedSoftwarePaper"]) : <any>undefined;
            this.examStartTime = _data["examStartTime"] ? moment(_data["examStartTime"].toString()) : <any>undefined;
            this.examEndTime = _data["examEndTime"] ? moment(_data["examEndTime"].toString()) : <any>undefined;
            this.answeredQuestionCount = _data["answeredQuestionCount"];
            this.correctCount = _data["correctCount"];
            this.totalScore = _data["totalScore"];
            this.examResult = _data["examResult"];
            this.opinion = _data["opinion"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPaper {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["paperId"] = this.paperId;
        data["paper"] = this.paper ? this.paper.toJSON() : <any>undefined;
        data["userActionId"] = this.userActionId;
        data["userAction"] = this.userAction ? this.userAction.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["dispatchedSoftwarePaperId"] = this.dispatchedSoftwarePaperId;
        data["dispatchedSoftwarePaper"] = this.dispatchedSoftwarePaper ? this.dispatchedSoftwarePaper.toJSON() : <any>undefined;
        data["examStartTime"] = this.examStartTime ? this.examStartTime.toISOString() : <any>undefined;
        data["examEndTime"] = this.examEndTime ? this.examEndTime.toISOString() : <any>undefined;
        data["answeredQuestionCount"] = this.answeredQuestionCount;
        data["correctCount"] = this.correctCount;
        data["totalScore"] = this.totalScore;
        data["examResult"] = this.examResult;
        data["opinion"] = this.opinion;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserPaper {
    tenantId: number | undefined;
    snsUserInfoId: number;
    snsUserInfo: SnsUserInfo;
    paperId: number;
    paper: Paper;
    userActionId: number | undefined;
    userAction: UserAction;
    trainingId: number | undefined;
    training: Training;
    dispatchedSoftwarePaperId: number | undefined;
    dispatchedSoftwarePaper: DispatchedSoftwarePaper;
    examStartTime: moment.Moment | undefined;
    examEndTime: moment.Moment | undefined;
    answeredQuestionCount: number;
    correctCount: number;
    totalScore: number;
    examResult: ExamEnum;
    opinion: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPaperQuestionId implements IUserPaperQuestionId {
    questionId!: number;
    questionItemId!: number;

    constructor(data?: IUserPaperQuestionId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.questionItemId = _data["questionItemId"];
        }
    }

    static fromJS(data: any): UserPaperQuestionId {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaperQuestionId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["questionItemId"] = this.questionItemId;
        return data; 
    }
}

export interface IUserPaperQuestionId {
    questionId: number;
    questionItemId: number;
}

export class UserPaperRep implements IUserPaperRep {
    name!: string | undefined;
    regPhone!: string | undefined;
    sex!: string | undefined;
    snsUserInfoId!: number;
    createDate!: moment.Moment;
    extensionData!: string | undefined;
    nickName!: string | undefined;
    answer1!: string | undefined;
    answer2!: string | undefined;
    answer3!: string | undefined;
    answer4!: string | undefined;
    answer5!: string | undefined;
    answer6!: string | undefined;
    acne_score!: string | undefined;
    speckle_score!: string | undefined;
    mole_score!: string | undefined;
    wrinkle_score!: string | undefined;
    eye_bags_score!: string | undefined;
    dark_circle_score!: string | undefined;
    blackhead_score!: string | undefined;
    pore_score!: string | undefined;
    smooth_score!: string | undefined;

    constructor(data?: IUserPaperRep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.regPhone = _data["regPhone"];
            this.sex = _data["sex"];
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.createDate = _data["createDate"] ? moment(_data["createDate"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.nickName = _data["nickName"];
            this.answer1 = _data["answer1"];
            this.answer2 = _data["answer2"];
            this.answer3 = _data["answer3"];
            this.answer4 = _data["answer4"];
            this.answer5 = _data["answer5"];
            this.answer6 = _data["answer6"];
            this.acne_score = _data["acne_score"];
            this.speckle_score = _data["speckle_score"];
            this.mole_score = _data["mole_score"];
            this.wrinkle_score = _data["wrinkle_score"];
            this.eye_bags_score = _data["eye_bags_score"];
            this.dark_circle_score = _data["dark_circle_score"];
            this.blackhead_score = _data["blackhead_score"];
            this.pore_score = _data["pore_score"];
            this.smooth_score = _data["smooth_score"];
        }
    }

    static fromJS(data: any): UserPaperRep {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaperRep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["regPhone"] = this.regPhone;
        data["sex"] = this.sex;
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["nickName"] = this.nickName;
        data["answer1"] = this.answer1;
        data["answer2"] = this.answer2;
        data["answer3"] = this.answer3;
        data["answer4"] = this.answer4;
        data["answer5"] = this.answer5;
        data["answer6"] = this.answer6;
        data["acne_score"] = this.acne_score;
        data["speckle_score"] = this.speckle_score;
        data["mole_score"] = this.mole_score;
        data["wrinkle_score"] = this.wrinkle_score;
        data["eye_bags_score"] = this.eye_bags_score;
        data["dark_circle_score"] = this.dark_circle_score;
        data["blackhead_score"] = this.blackhead_score;
        data["pore_score"] = this.pore_score;
        data["smooth_score"] = this.smooth_score;
        return data; 
    }
}

export interface IUserPaperRep {
    name: string | undefined;
    regPhone: string | undefined;
    sex: string | undefined;
    snsUserInfoId: number;
    createDate: moment.Moment;
    extensionData: string | undefined;
    nickName: string | undefined;
    answer1: string | undefined;
    answer2: string | undefined;
    answer3: string | undefined;
    answer4: string | undefined;
    answer5: string | undefined;
    answer6: string | undefined;
    acne_score: string | undefined;
    speckle_score: string | undefined;
    mole_score: string | undefined;
    wrinkle_score: string | undefined;
    eye_bags_score: string | undefined;
    dark_circle_score: string | undefined;
    blackhead_score: string | undefined;
    pore_score: string | undefined;
    smooth_score: string | undefined;
}

export class UserRoomMessageOutput implements IUserRoomMessageOutput {
    /** 用户id 特定公众号下面的user/说到Taobao的用户Id */
    snsUserInfoId!: number | undefined;
    snsUserInfo!: SnsUserInfoOutput;
    type!: MsgTypeEnum;
    content!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserRoomMessageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfoId = _data["snsUserInfoId"];
            this.snsUserInfo = _data["snsUserInfo"] ? SnsUserInfoOutput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.type = _data["type"];
            this.content = _data["content"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRoomMessageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoomMessageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfoId"] = this.snsUserInfoId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["content"] = this.content;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserRoomMessageOutput {
    /** 用户id 特定公众号下面的user/说到Taobao的用户Id */
    snsUserInfoId: number | undefined;
    snsUserInfo: SnsUserInfoOutput;
    type: MsgTypeEnum;
    content: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum VerifyType {
    WechatAuthentication = "WechatAuthentication",
    SinaWeiboAuthentication = "SinaWeiboAuthentication",
    QQweiboAuthentication = "QQweiboAuthentication",
    NoNameAuthentication = "NoNameAuthentication",
    NoNameBySinaWeiboAuthentication = "NoNameBySinaWeiboAuthentication",
    NoNameByQqWeiboAuthentication = "NoNameByQqWeiboAuthentication",
    UnAuthentication = "UnAuthentication",
}

export class WeChatJSViewModel implements IWeChatJSViewModel {
    signature!: string | undefined;
    appId!: string | undefined;
    timestamp!: string | undefined;
    nonceStr!: string | undefined;
    currentOpenId!: string | undefined;
    componentAppID!: string | undefined;
    scope!: string | undefined;

    constructor(data?: IWeChatJSViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signature = _data["signature"];
            this.appId = _data["appId"];
            this.timestamp = _data["timestamp"];
            this.nonceStr = _data["nonceStr"];
            this.currentOpenId = _data["currentOpenId"];
            this.componentAppID = _data["componentAppID"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): WeChatJSViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatJSViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signature"] = this.signature;
        data["appId"] = this.appId;
        data["timestamp"] = this.timestamp;
        data["nonceStr"] = this.nonceStr;
        data["currentOpenId"] = this.currentOpenId;
        data["componentAppID"] = this.componentAppID;
        data["scope"] = this.scope;
        return data; 
    }
}

export interface IWeChatJSViewModel {
    signature: string | undefined;
    appId: string | undefined;
    timestamp: string | undefined;
    nonceStr: string | undefined;
    currentOpenId: string | undefined;
    componentAppID: string | undefined;
    scope: string | undefined;
}

export class WechatLoginResultDto implements IWechatLoginResultDto {
    isBind!: boolean;
    unionid!: string | undefined;
    tenantId!: number | undefined;
    authenticateResultModel!: AuthenticateResultModel;

    constructor(data?: IWechatLoginResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isBind = _data["isBind"];
            this.unionid = _data["unionid"];
            this.tenantId = _data["tenantId"];
            this.authenticateResultModel = _data["authenticateResultModel"] ? AuthenticateResultModel.fromJS(_data["authenticateResultModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WechatLoginResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatLoginResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isBind"] = this.isBind;
        data["unionid"] = this.unionid;
        data["tenantId"] = this.tenantId;
        data["authenticateResultModel"] = this.authenticateResultModel ? this.authenticateResultModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWechatLoginResultDto {
    isBind: boolean;
    unionid: string | undefined;
    tenantId: number | undefined;
    authenticateResultModel: AuthenticateResultModel;
}

export enum WeixinAuthStatus {
    Authrozied = "Authrozied",
    UnAuthrozied = "UnAuthrozied",
    Locked = "Locked",
    UnLocked = "UnLocked",
}

export class WeixinMpDto implements IWeixinMpDto {
    weixinAppID!: string | undefined;
    /** 有效期（在授权的公众号具备API权限时，才有此返回值） */
    expires_in!: number;
    name!: string | undefined;
    iconPath!: string | undefined;
    /** 公众号名称 */
    nickName!: string | undefined;
    /** 公众号头像 */
    head_img!: string | undefined;
    service_type_info!: ServiceType;
    verify_type_info!: VerifyType;
    /** 授权方公众号的原始ID */
    user_name!: string | undefined;
    /** 授权方公众号所设置的微信号，可能为空 */
    alias!: string | undefined;
    /** 二维码图片的URL，开发者最好自行也进行保存 */
    qrcode_url!: string | undefined;
    status!: WeixinAuthStatus;
    func_infos!: string | undefined;
    authorizationTime!: moment.Moment | undefined;
    unAuthorizationTime!: moment.Moment | undefined;
    expiredTime!: moment.Moment | undefined;
    /** 中奖模板id
类似 4MVFGFHDQtNexQgT9U9mIko2_zcMnxCLTbKDlwYowTs */
    awardTemplateId!: string | undefined;
    mpType!: EnumMpType;
    organizationUnitId!: number | undefined;
    isMine!: boolean;
    from!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IWeixinMpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weixinAppID = _data["weixinAppID"];
            this.expires_in = _data["expires_in"];
            this.name = _data["name"];
            this.iconPath = _data["iconPath"];
            this.nickName = _data["nickName"];
            this.head_img = _data["head_img"];
            this.service_type_info = _data["service_type_info"];
            this.verify_type_info = _data["verify_type_info"];
            this.user_name = _data["user_name"];
            this.alias = _data["alias"];
            this.qrcode_url = _data["qrcode_url"];
            this.status = _data["status"];
            this.func_infos = _data["func_infos"];
            this.authorizationTime = _data["authorizationTime"] ? moment(_data["authorizationTime"].toString()) : <any>undefined;
            this.unAuthorizationTime = _data["unAuthorizationTime"] ? moment(_data["unAuthorizationTime"].toString()) : <any>undefined;
            this.expiredTime = _data["expiredTime"] ? moment(_data["expiredTime"].toString()) : <any>undefined;
            this.awardTemplateId = _data["awardTemplateId"];
            this.mpType = _data["mpType"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isMine = _data["isMine"];
            this.from = _data["from"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeixinMpDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeixinMpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weixinAppID"] = this.weixinAppID;
        data["expires_in"] = this.expires_in;
        data["name"] = this.name;
        data["iconPath"] = this.iconPath;
        data["nickName"] = this.nickName;
        data["head_img"] = this.head_img;
        data["service_type_info"] = this.service_type_info;
        data["verify_type_info"] = this.verify_type_info;
        data["user_name"] = this.user_name;
        data["alias"] = this.alias;
        data["qrcode_url"] = this.qrcode_url;
        data["status"] = this.status;
        data["func_infos"] = this.func_infos;
        data["authorizationTime"] = this.authorizationTime ? this.authorizationTime.toISOString() : <any>undefined;
        data["unAuthorizationTime"] = this.unAuthorizationTime ? this.unAuthorizationTime.toISOString() : <any>undefined;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        data["awardTemplateId"] = this.awardTemplateId;
        data["mpType"] = this.mpType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isMine"] = this.isMine;
        data["from"] = this.from;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWeixinMpDto {
    weixinAppID: string | undefined;
    /** 有效期（在授权的公众号具备API权限时，才有此返回值） */
    expires_in: number;
    name: string | undefined;
    iconPath: string | undefined;
    /** 公众号名称 */
    nickName: string | undefined;
    /** 公众号头像 */
    head_img: string | undefined;
    service_type_info: ServiceType;
    verify_type_info: VerifyType;
    /** 授权方公众号的原始ID */
    user_name: string | undefined;
    /** 授权方公众号所设置的微信号，可能为空 */
    alias: string | undefined;
    /** 二维码图片的URL，开发者最好自行也进行保存 */
    qrcode_url: string | undefined;
    status: WeixinAuthStatus;
    func_infos: string | undefined;
    authorizationTime: moment.Moment | undefined;
    unAuthorizationTime: moment.Moment | undefined;
    expiredTime: moment.Moment | undefined;
    /** 中奖模板id
类似 4MVFGFHDQtNexQgT9U9mIko2_zcMnxCLTbKDlwYowTs */
    awardTemplateId: string | undefined;
    mpType: EnumMpType;
    organizationUnitId: number | undefined;
    isMine: boolean;
    from: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class WeixinOpenPlatformDto implements IWeixinOpenPlatformDto {
    name!: string | undefined;
    componentAppID!: string | undefined;
    icon!: string | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IWeixinOpenPlatformDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.componentAppID = _data["componentAppID"];
            this.icon = _data["icon"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeixinOpenPlatformDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeixinOpenPlatformDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["componentAppID"] = this.componentAppID;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWeixinOpenPlatformDto {
    name: string | undefined;
    componentAppID: string | undefined;
    icon: string | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}